{"_id": "6367672d1a6d9265ec017c73", "generate_results": ["public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages == null) return true;\n\tfor(int i=0; i<messages.length; i++){\n\t\tif(messages[i].getTime() > timestamp){\n\t\t\tmessages[i].setTime(timestamp);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n    boolean shouldPrintMessage = false;\n    if(messages.containsKey(message)){\n        long currentTime = System.currentTimeMillis();\n        long diff = (currentTime - messages.get(message));\n        if(diff < 10){\n            shouldPrintMessage = true;\n        }\n    }\n    return shouldPrintMessage;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(timestamp > 10)\n\t\treturn false;\n\telse{\n\t\tif(messages == null)\n\t\t\tmessages = new HashMap<String,String>();\n\t\tif(messages.containsKey(message))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif (messages.containsKey(message)){\n\t\tif (messages.get(message).getTimestamp() < timestamp){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages.containsKey(message)){\n\t\tlong difference = (System.currentTimeMillis() - messages.get(message));\n\t\tif(difference > 10){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tmessages[timestamp] = message;\n\treturn messages[timestamp].equals(\"1\");\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages.containsKey(message)){\n\t\tlong time = System.currentTimeMillis();\n\t\tif(messages.get(message) > time){\n\t\t\tmessages.put(message,time);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages.containsKey(message) && messages.get(message).length()>0){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\t\n\tif(messages.containsKey(timestamp)){\n\t\tif(messages.get(timestamp).toString().compareTo(message) > 0){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\treturn false;\n\t}\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n    synchronized (messages){\n        if (messages.get(timestamp)!= null && messages.get(timestamp).length() > 0 && messages.get(timestamp).length() > 5)\n            return true;\n    }\n    return false;\n}"]}
{"_id": "6367672d1a6d9265ec017c74", "generate_results": ["public boolean remove(int val){\n\tif(values.containsKey(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\t\n\tif(map.containsKey(val)){\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\tif (map.containsKey(val)){\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\tfor(int i=0;i<this.size();i++){\n\t\tif(this.get(i).equals(val)){\n\t\t\tthis.remove(i);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean remove(int val){\nif(map.containsKey(val)){\nmap.remove(val);\nreturn true;}\nreturn false;}", "public boolean remove(int val){\n\tif(map.contains(val)){\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "public boolean remove(int val){\nif(map.containsKey(val)){\nint val2=map.get(val);\nmap.remove(val);\nreturn true;\n}else{\nreturn false;\n}\n}", "public boolean remove(int val){\n\t//System.out.println(\"Removing \"+val);\n\tif(values.containsKey(val)){\n\t\tvalues.remove(val);\n\t}\n\treturn true;\n}", "public boolean remove(int val){\n\tif(this.map.containsKey(val)){\n\t\tthis.map.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\tif(map.containsKey(val)){\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}"]}
{"_id": "6367672d1a6d9265ec017c78", "generate_results": ["public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\tmap.put(val, val);\n\treturn true;\n}", "public boolean insert(int val){\nint hash = val;\nString key = keyOf(hash);\nString value = valueOf(hash);\nif(map.contains(key)){\nreturn false;\n}if(map.containsKey(key)){\nmap.put(key, value);\nreturn true;\n}else if(map.containsValue(value)){\nmap.put(key, value);\nreturn true;\n}else{\nmap.put(key, value);\nreturn true;\n}\n}", "public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\tmap.put(val, val);\n\treturn true;\n}", "public boolean insert(int val){\n\tif(!map.containsKey(val)){\n\t\tmap.put(val, val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\telse{\n\t\tmap.put(val, val);\n\t\treturn true;\n\t}\n}", "public boolean insert(int val){\n    if(map.containsKey(val)){\n        return false;\n    }else{\n        map.put(val, val);\n        return true;\n    }\n}", "public boolean insert(int val){\n    if(map.containsKey(val)){\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n    for(int i=0; i<map.size();i++){\n        if(map.get(i).getVal() == val){\n            return false;\n        }\n    }\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\tmap.put(val, val);\n\treturn true;\n}", "public boolean insert(int val){\n    if(map.containsKey(val)){\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}"]}
{"_id": "6367670b1a6d9265ec017a00", "generate_results": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1.length!= array2.length)\n\t\treturn false;\n\tfor(int i=0; i<array1.length; i++){\n\t\tif(array1[i]!= array2[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif (array1.length!=array2.length) return false;\n\t\n\tfor (int i=0;i<array1.length;i++)\n\t\tif (array1[i]!=array2[i]) return false;\n\t\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\treturn (array1.length == array2.length)? true : false;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n    if(array1 == null || array2 == null) return false;\n    final int length1 = array1.length;\n    final int length2 = array2.length;\n    if(length1!= length2) return false;\n    for(int i=0;i<length1;i++){\n        if(array1[i]!= array2[i]) return false;\n    }\n    return true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1 == null) {\n\t\treturn false;\n\t}\n\tif(array2 == null) {\n\t\treturn false;\n\t}\n\t\n\treturn array1.length == array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1 == null || array2 == null){\n\t\treturn false;\n\t}\n\tif(array1.length == array2.length){\n\t\treturn true;\n\t}\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\t\n\tif(array1.length!=array2.length)\n\t\treturn false;\n\t\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n    if (array1.length!= array2.length) {\n        return false;\n    }\n\n    int i1 = 0;\n    int i2 = 0;\n\n    while (i1 < array1.length) {\n        if (array1[i1] == array2[i2]) {\n            i1++;\n            i2++;\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1==null || array2==null){\n\t\treturn false;\n\t}\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"]}
{"_id": "636767081a6d9265ec017989", "generate_results": ["public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0) {\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] primitives = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) {\n\t\tprimitives[i] = array[i];\n\t}\n\treturn primitives;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tfinal boolean[] primitiveArray = new boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tprimitiveArray[i] = array[i];\n\t}\n\treturn primitiveArray;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array==null) return null;\n\tif(array.length==0) return EMPTY_BOOLEAN_ARRAY;\n\tboolean[] primitiveArray = new boolean[array.length];\n\tfor(int i=0;i<array.length;i++) primitiveArray[i] = array[i];\n\treturn primitiveArray;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if(array == null) return null;\n    final int length = array.length;\n    if(length == 0) return EMPTY_BOOLEAN_ARRAY;\n    if(length == 1) return new boolean[]{array[0]};\n    return ArrayUtils.toPrimitive(array);\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0) {\n\t\treturn ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] primitiveArray=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tprimitiveArray[i]=array[i];\n\t}\n\treturn primitiveArray;\n}", "public static byte[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_BYTE_ARRAY;\n    final byte[] primitiveArray = new byte[array.length];\n    for (int i = 0; i < array.length; i++) primitiveArray[i] = array[i].booleanValue()? 1 : 0;\n    return primitiveArray;\n}", "public static Boolean[] toPrimitive(final Boolean[] array){\n\tif(array==null||array.length==0)return null;\n\tfinal Boolean[] primitives=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)primitives[i]=array[i];\n\treturn primitives;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if(array == null)\n        return null;\n    final int length = array.length;\n    if(length == 0)\n        return EMPTY_BOOLEAN_ARRAY;\n    if(length == 1)\n        return new boolean[]{array[0]};\n    if(length == 2)\n        return new boolean[]{array[0], array[1]};\n    if(length == 3)\n        return new boolean[]{array[0], array[1], array[2]};\n    return null;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n  if(array==null) return null;\n  if(array.length==0) return EMPTY_BOOLEAN_ARRAY;\n  return array;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array == null) {\n\t\treturn null;\n\t}\n\tfinal boolean[] primitiveArray = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) {\n\t\tprimitiveArray[i] = array[i];\n\t}\n\treturn primitiveArray;\n}"]}
{"_id": "636766f81a6d9265ec01775c", "generate_results": ["public static String toString(Object obj){\n    if(obj == null)\n        return \"\";\n    String s = obj.toString();\n    return s.replaceAll(\"\\\\s+\", \"\").replaceAll(\"\\\\r|\\\\n|\\\\t|\\\\v\", \"\");\n}", "public static String toString(Object obj){\n\tif(obj == null) return \"null\";\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n\tif(obj == null) return \"null\";\n\tif(obj instanceof String) return (String)obj;\n\tif(obj instanceof Character) return \"Character\";\n\tif(obj instanceof Boolean) return \"Boolean\";\n\tif(obj instanceof Byte) return \"Byte\";\n\tif(obj instanceof Double) return \"Double\";\n\tif(obj instanceof Float) return \"Float\";\n\tif(obj instanceof Integer) return \"Integer\";\n\tif(obj instanceof Long) return \"Long\";\n\tif(obj instanceof Short) return \"Short\";\n\tif(obj instanceof Object[]) return \"Object[]\";\n\tif(obj instanceof Object[][]) return \"Object[][]\";\n\tif(obj instanceof Object[][][]) return \"Object[][][]\";\n\tif(obj instanceof Object[][][][]) return \"Object[][][][]\";\n\tif(obj instanceof", "public static String toString(Object obj){\n  if (obj == null) return \"\";\n  if (obj instanceof String) return (String)obj;\n  if (obj instanceof Integer) return \"0x\"+Integer.toHexString(((Integer)obj).intValue());\n  if (obj instanceof Long) return \"0x\"+Long.toHexString(((Long)obj).longValue());\n  if (obj instanceof Boolean) return \"true\";\n  if (obj instanceof Byte) return \"0b\"+obj.toString();\n  if (obj instanceof Short) return \"0x\"+obj.toString();\n  if (obj instanceof Character) return \"0x\"+obj.toString();\n  if (obj instanceof Float) return \"0f\"+obj.toString();\n  if (obj instanceof Double) return \"0d\"+obj.toString();\n  if (obj instanceof BigDecimal) return \"0b\"+obj.toString();\n  if (obj instanceof BigInteger) return \"0b\"+obj.toString();\n  if (obj instanceof BigDecimal) return \"0b\"+obj.toString();\n  if (obj instanceof BigInteger) return \"0b\"+obj.toString();\n  return obj.toString();\n}", "public static String toString(Object obj){\n\tif(obj == null) {\n\t\treturn \"\";\n\t}\n\t\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(\"{\");\n\t\n\tif(obj instanceof String){\n\t\tsb.append(\"\\\"\").append(obj).append(\"\\\",\");\n\t} else if(obj instanceof Number){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Boolean){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Character){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Date){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Double){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Float){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Long){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Integer){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Short){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof Byte){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof BigDecimal){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof BigInteger){\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t} else if(obj instanceof String[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof Object[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof char[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof byte[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof short[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof int[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof long[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof double[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof float[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else if(obj instanceof boolean[]){\n\t\tsb.append(\"\\\"\" + StringUtil.join(obj, \",\") + \"\\\"\");\n\t} else {\n\t\tsb.append(\"\\\"\" + obj.toString() + \"\\\"\");\n\t}\n\t\n\tsb.append(\"}\");\n\t\n\treturn sb.toString();\n}", "public static String toString(Object obj){\nif(obj == null){\nreturn \"\";\n}\nString s=obj.toString();\nreturn s.replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\r\\\\n]\", \"\")\n.replaceAll(\"[\\\\r\\\\n]\", \"\").replaceAll(\"\\\\n\", \"\")\n.replaceAll(\"[\\\\r\\\\n]\", \"\");\n}", "public static String toString(Object obj){\n\tif(obj == null){\n\t\treturn \"\";\n\t}\n\telse if(obj instanceof String){\n\t\treturn (String)obj;\n\t}\n\telse if(obj instanceof Integer){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Short){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Long){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Float){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Double){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Boolean){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Date){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Time){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof byte[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigDecimal){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigInteger){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigDecimal){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigInteger){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Character){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Character[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof byte[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Boolean[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof String[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Object[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof byte[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigDecimal[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigInteger[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigDecimal[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof BigInteger[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof String[]){\n\t\treturn \"\"+obj;\n\t}\n\telse if(obj instanceof Object[]){\n\t\treturn \"\"+obj;\n\t}\n\treturn \"\"+obj;\n}", "public static String toString(Object obj){\n\tif(obj == null){\n\t\treturn \"\";\n\t}\n\t\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n\tif(obj == null){\n\t\treturn \"\";\n\t}\n\tif(obj instanceof String){\n\t\treturn (String)obj;\n\t}else if(obj instanceof Integer){\n\t\treturn String.valueOf(obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString(obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn obj.toString();\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Long){\n\t\treturn Long.toString((long)obj);\n\t}else if(obj instanceof Float){\n\t\treturn Float.toString((float)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Integer){\n\t\treturn Integer.toString((int)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Integer){\n\t\treturn Integer.toString((int)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Integer){\n\t\treturn Integer.toString((int)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Integer){\n\t\treturn Integer.toString((int)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.toString((short)obj);\n\t}else if(obj instanceof Integer){\n\t\treturn Integer.toString((int)obj);\n\t}else if(obj instanceof Double){\n\t\treturn Double.toString((double)obj);\n\t}else if(obj instanceof Boolean){\n\t\treturn Boolean.toString(obj);\n\t}else if(obj instanceof Character){\n\t\treturn Character.toString((char)obj);\n\t}else if(obj instanceof Byte){\n\t\treturn Byte.toString((byte)obj);\n\t}else if(obj instanceof Short){\n\t\treturn Short.", "public static String toString(Object obj){\n\tif(obj == null) return \"\";\n\treturn obj.toString();\n}"]}
{"_id": "636766f91a6d9265ec01777f", "generate_results": ["public static boolean toBoolean(Boolean bool){\n\tif (bool == null) return false;\n\treturn bool;\n}", "public static boolean toBoolean(Boolean bool){\n\treturn bool == null? false : bool;\n}", "public static boolean toBoolean(Boolean bool){\n\tif(bool == null){\n\t\treturn false;\n\t}\n\treturn bool;\n}", "public static boolean toBoolean(Boolean bool){\n\tif(bool == null){\n\t\treturn false;\n\t}\n\treturn bool;\n}", "public static boolean toBoolean(Boolean bool){\n\treturn bool;\n}", "public static Boolean toBoolean(Boolean bool){\n\tif(bool == null){\n\t\treturn null;\n\t}else{\n\t\treturn bool;\n\t}\n}", "public static boolean toBoolean(Boolean bool){\n\tif(bool == null){\n\t\treturn false;\n\t}\n\treturn bool;\n}", "public static Boolean toBoolean(Boolean bool){\n    if(bool == null)return false;\n    return bool;\n}", "public static boolean toBoolean(Boolean bool){\n\tif(bool == null) return false;\n\treturn bool;\n}", "public static boolean toBoolean(Boolean bool){\n    if (bool == null) return false;\n    return bool;\n}"]}
{"_id": "6367670b1a6d9265ec0179ff", "generate_results": ["public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null || array.length == 0) return EMPTY_BYTE_OBJECT_ARRAY;\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null) return EMPTY_BYTE_OBJECT_ARRAY;\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n    if (array == null || array.length == 0) return EMPTY_BYTE_ARRAY;\n    return array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n  return array == null? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n    return array==null?new Byte[0]:array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n    return nullToEmpty(array, 0);\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null || array.length == 0) return EMPTY_BYTE_OBJECT_ARRAY;\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null) return EMPTY_BYTE_OBJECT_ARRAY;\n\tif(array.length == 0) return new Byte[0];\n\tfinal Byte[] result = new Byte[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i];\n\treturn result;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n    if(array == null) return EMPTY_BYTE_OBJECT_ARRAY;\n    return array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) return new Byte[0];\n\n\tfinal Byte[] empty = new Byte[0];\n\treturn array;\n}"]}
{"_id": "6367670a1a6d9265ec0179e8", "generate_results": ["public static Boolean[] nullToEmpty(final Boolean[] array){\n    if(array == null || array.length == 0)\n        return EMPTY_BOOLEAN_OBJECT_ARRAY;\n    return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if (array == null || array.length == 0)\n        return EMPTY_BOOLEAN_OBJECT_ARRAY;\n    \n    return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null || array.length == 0){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null || array.length == 0) return null;\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if(array == null || array.length == 0){\n        return EMPTY_BOOLEAN_OBJECT_ARRAY;\n    }else{\n        return array;\n    }\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null || array.length == 0){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n//\tif(array == null || array.length == 0){\n//\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n//\t}\n//\treturn array;\n//}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\treturn array == null? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if(array == null) return null;\n    final Boolean[] result = new Boolean[array.length];\n    for(int i = 0; i < array.length; i++) {\n        final Boolean element = array[i];\n        if(element == null) result[i] = null;\n        else result[i] = Boolean.valueOf(element.booleanValue());\n    }\n    return result;\n}"]}
{"_id": "636767031a6d9265ec0178e6", "generate_results": ["public static byte[] toPrimitive(final Byte[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn null;\n\t}\n\tfinal int primitiveCount = array.length;\n\tswitch(primitiveCount){\n\t\tcase 1:\n\t\t\treturn array[0];\n\t\tcase 2:\n\t\t\treturn array[0] << 16 | array[1] << 8 | array[2];\n\t\tcase 3:\n\t\t\treturn array[0] << 24 | array[1] << 16 | array[2] << 8 | array[3];\n\t\tcase 4:\n\t\t\treturn array[0] << 32 | array[1] << 24 | array[2] << 16 | array[3] << 8 | array[4];\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}", "public static Object toPrimitive(final Byte[] array){\n\treturn toPrimitive(array);\n}", "public static byte[] toPrimitive(final Byte[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]==null){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn array.length>0?array:null;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return EMPTY;\n\t\n\tfinal byte[] primitiveArray = new byte[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tprimitiveArray[i] = array[i];\n\t}\n\treturn primitiveArray;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\t\n\tif(array==null){\n\t\treturn null;\n\t}\n\t\n\tif(array.length==0){\n\t\treturn null;\n\t}\n\t\n\tbyte[] b = new byte[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tb[i] = array[i];\n\t}\n\t\n\treturn b;\n}", "public static Byte[] toPrimitive(final Byte[] array){\n    if(array==null){\n        return null;\n    }else if(array.length==0){\n        return EMPTY_BYTE_ARRAY;\n    }\n    \n    final Byte[] result = new Byte[array.length];\n    for(int i=0;i<array.length;i++){\n        result[i] = array[i];\n    }\n    return result;\n}", "public static Byte[] toPrimitive(final Byte[] array){\n\tif (array == null) return null;\n\tfinal int len = array.length;\n\tif (len == 0) return EMPTY_BYTE_ARRAY;\n\tfinal Byte[] result = new Byte[len];\n\tfor (int i = 0; i < len; i++) result[i] = array[i];\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n    if (array.length == 0) return emptyArray();\n    \n    final int len = array.length;\n    if (len == 1) {\n      final byte ret = array[0];\n      return isPrimitive(ret)? (byte[])ret : null;\n    } else {\n      final byte[] ret = new byte[len];\n      for (int i = 0; i < len; i++) {\n        ret[i] = array[i];\n      }\n      return ret;\n    }\n  }", "public static byte[] toPrimitive(final Byte[] array){\n    if(array == null){\n        return null;\n    }\n    \n    for(final byte b: array){\n        if(b == null){\n            return null;\n        }\n    }\n    \n    return array;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null){\n        return null;\n    }\n    switch (array.length){\n    case 0:\n        return null;\n    case 1:\n        return array[0];\n    default:\n        int length = array.length;\n        byte[] result = new byte[length];\n        for (int i = 0; i < length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n}"]}
{"_id": "636767001a6d9265ec017873", "generate_results": ["public static String reverse(final String str){\n\tchar[] chs = str.toCharArray();\n\tint i = 0;\n\tint j = chs.length - 1;\n\twhile (i < j) {\n\t\tif (chs[i] == chs[j]) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tj--;\n\t\t}\n\t}\n\treturn new String(chs);\n}", "public static String reverse(final String str){\n    final char[] ch = str.toCharArray();\n    for(int i=0; i<ch.length; i++){\n        ch[i] = ch[i+ch.length-1];\n        ch[i+ch.length-1] = ch[i];\n    }\n    return new String(ch);\n}", "public static String reverse(final String str){\n    final char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    int i = 0;\n    while (i < chars.length) {\n      char ch = chars[i];\n      if (ch =='') {\n        i++;\n        continue;\n      }\n      if (ch == '\\n') {\n        sb.append(\"\\\\n\");\n        i++;\n        continue;\n      }\n      if (ch == '\\r') {\n        sb.append(\"\\\\r\");\n        i++;\n        continue;\n      }\n      if (ch == '\\t') {\n        sb.append(\"\\\\t\");\n        i++;\n        continue;\n      }\n      sb.append(ch);\n      i++;\n    }\n    return sb.toString();\n  }", "public static String reverse(final String str){\n        return str.substring(0, str.length()-1);\n    }", "public static String reverse(final String str){\n\treturn str.substring(0, str.length()-1);\n}", "public static String reverse(final String str){\n\tStringBuilder sb = new StringBuilder(str.length());\n\tfor(int i=str.length()-1;i>=0;i--){\n\t\tchar c = str.charAt(i);\n\t\tsb.append(c);\n\t}\n\treturn sb.toString();\n}", "public static String reverse(final String str){\n    return new StringBuilder(str).reverse().toString();\n}", "public static String reverse(final String str){\n\treturn str.substring(0, str.length()-1);\n}", "public static String reverse(final String str){\n    int len = str.length();\n    StringBuilder sb = new StringBuilder( len );\n    for( int i=0; i<len; i++ ){\n        char c = str.charAt(i);\n        sb.append( c );\n    }\n    return sb.reverse().toString();\n}", "public static String reverse(final String str){\n\tfinal char[] arr = str.toCharArray();\n\t\n\tfor(int i=0;i<arr.length;i++){\n\t\tarr[i] = arr[i+1];\n\t\tarr[i+1] = arr[i];\n\t}\n\treturn new String(arr);\n}"]}
{"_id": "636766ff1a6d9265ec01784b", "generate_results": ["public static boolean isDigits(String str){\n    if(str==null) return false;\n    char[] chars=str.toCharArray();\n    for(char c:chars){\n        if(!Character.isDigit(c)) return false;\n    }\n    return true;\n}", "public static boolean isDigits(String str){\n\tif(str == null) return false;\n\tString[] parts = str.split(\"\\\\.\");\n\tif(parts.length == 0) return false;\n\telse if(parts.length == 1) return true;\n\telse{\n\t\tint len = parts.length;\n\t\tfor(int i=0;i<len-1;i++){\n\t\t\tif(!isDigits(parts[i]) && parts[i].charAt(0)=='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(parts[len-1]!= null && parts[len-1].charAt(0)=='0'){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}", "public static boolean isDigits(String str){\n\t\n\tchar[] chs = str.toCharArray();\n\t\n\tfor (int i = 0; i < chs.length; i++) {\n\t\tif(Character.isDig", "public static boolean isDigits(String str){\n\t\n\tint len = str.length();\n\t\n\tif(len == 0){\n\t\treturn true;\n\t}\n\t\n\tchar c = str.charAt(0);\n\t\n\tif(c == '0'){\n\t\treturn true;\n\t}\n\t\n\tfor(int i=1;i<len;i++){\n\t\tc = str.charAt(i);\n\t\tif(c=='0'){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}", "public static boolean isDigits(String str){\n\tint len = str.length();\n\tint lastChar = 0;\n\tfor(int i=0;i<len;i++){\n\t\tchar ch = str.charAt(i);\n\t\tif(ch=='0' || ch=='1'){\n\t\t\tif(lastChar=='0'){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}else{\n\t\t\tlastChar = ch;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean isDigits(String str){\n\tif (str == null)\n\t\treturn false;\n\tfor (int i = 0; i < str.length(); i++)\n\t\tif (!Character.isDigit(str.charAt(i)))\n\t\t\treturn false;\n\treturn true;\n}", "public static boolean isDigits(String str){\n    boolean isDigit = false;\n    if(str!= null){\n        for(int i = 0; i< str.length(); i++){\n            char c = str.charAt(i);\n            if(Character.isDigit(c)){\n                isDigit = true;\n            }\n        }\n    }\n    return isDigit;\n}", "public static boolean isDigits(String str){\n\t\n\tif(str == null || str.isEmpty()){\n\t\treturn false;\n\t}\n\t\n\tfor(char c : str.toCharArray()){\n\t\tif(Character.isDigit(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean isDigits(String str){\n\tint len = str.length();\n\tfor(int i = 0; i < len; i++){\n\t\tif(Character.isDigit(str.charAt(i)) == false){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n    if(str.length()==0) return false;\n    \n    int i=0;\n    while(i<str.length() && str.charAt(i)!='.'){\n        i++;\n    }\n    \n    if(i==str.length()){\n        return true;\n    }else{\n        return false;\n    }\n    \n}"]}
{"_id": "6367670c1a6d9265ec017a35", "generate_results": ["Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(ignoreCase){\n\t\treturn str.endsWith(suffix);\n\t}\n\telse{\n\t\treturn str.endsWith(suffix.toUpperCase());\n\t}\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    int len = str.length();\n    int suffixLen = suffix.length();\n    if(len==0 || suffixLen==0){\n        return ignoreCase;\n    }\n    if(ignoreCase){\n        return str.startsWith(suffix)\n                || str.endsWith(suffix);\n    }\n    return str.endsWith(suffix);\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str.endsWith(suffix)){\n\t\treturn true;\n\t}\n\tif(ignoreCase){\n\t\tint i = str.length()-1;\n\t\twhile(i >= 0 &&!Character.isWhitespace(str.charAt(i))) i--;\n\t\treturn i >= 0 && str.charAt(i) == suffix.charAt(0);\n\t}\n\treturn str.endsWith(suffix);\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str==null) return false;\n\tint len = str.length();\n\tif(str.length()<suffix.length()){\n\t\treturn false;\n\t}\n\tfor(int i=len-suffix.length();i>=0;i--){\n\t\tif(ignoreCase){\n\t\t\tif(str.charAt(i)==suffix.charAt(0)){\n\t\t\t\t// If the character is a prefix character, we are done\n\t\t\t\tif(i>=suffix.length()){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// If the character is not a prefix character, we are done\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(str.charAt(i)==suffix.charAt(suffix.length()-1)){\n\t\t\t\t// If the character is a suffix character, we are done\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// If the character is not a suffix character, we are done\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str.length() < suffix.length()){\n\t\treturn false;\n\t}\n\tfinal int start = str.length() - suffix.length();\n\tfinal int end = str.length();\n\tfor(int i = start;i<end;i++){\n\t\tfinal char ch = str.charAt(i);\n\t\tif(ignoreCase){\n\t\t\tif(Character.toLowerCase(ch)!= Character.toLowerCase(suffix.charAt(i-start))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if(ch!= suffix.charAt(i-start)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif (ignoreCase){\n\t\treturn str.endsWith(suffix);\n\t}\n\treturn str.endsWith(suffix.toLowerCase());\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tfinal int len = str.length();\n\tif(len == 0){\n\t\treturn ignoreCase;\n\t}\n\tfor(int i=0;i<suffix.length();i++){\n\t\tchar c = str.charAt(len-1-i);\n\t\tif(!ignoreCase){\n\t\t\tif(c == suffix.charAt(i)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(Character.toLowerCase(c) == Character.toLowerCase(suffix.charAt(i))){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(suffix==null) return false;\n\tif(ignoreCase) {\n\t\treturn str.endsWith(suffix);\n\t}\n\telse {\n\t\treturn str.endsWith(suffix.toLowerCase());\n\t}\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tfinal int strLen = str.length();\n\tfinal int suffixLen = suffix.length();\n\t\n\tif(ignoreCase){\n\t\tif(strLen > suffixLen) return false;\n\t}\n\telse{\n\t\tif(strLen < suffixLen) return false;\n\t}\n\t\n\tif(ignoreCase){\n\t\tif(str.charAt(strLen-suffixLen)!= suffix.charAt(suffixLen)) return false;\n\t}\n\telse{\n\t\tif(!str.regionMatches(true,strLen-suffixLen,suffix,0,suffixLen)) return false;\n\t}\n\t\n\treturn true;\n}", "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(endsWith(str,suffix)) return true;\n\tif(ignoreCase){\n\t\treturn endsWithIgnoreCase(str,suffix);\n\t}\n\treturn endsWithIgnoreCase(str,suffix);\n}"]}
{"_id": "636766f11a6d9265ec017651", "generate_results": ["public static Character[] nullToEmpty(final Character[] array){\n        if(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n        final Character[] result = new Character[array.length];\n        for(int i = 0; i < array.length; i++) result[i] = array[i];\n        return result;\n    }", "public static Character[] nullToEmpty(final Character[] array){\n    if(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n    else return array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\tif(array.length == 0){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n    if (array == null || array.length == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n    return array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\tif (array.length == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n    if(array==null){\n        return EMPTY_CHARACTER_OBJECT_ARRAY;\n    }else{\n        return array;\n    }\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n  if(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n  if(array.length == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n  return array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n    if(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n    final int size = array.length;\n    if(size == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n    final Character[] newArray = new Character[size];\n    System.arraycopy(array, 0, newArray, 0, size);\n    return newArray;\n}"]}
{"_id": "636767021a6d9265ec0178bb", "generate_results": ["public static Double[] nullToEmpty(final Double[] array){\nif(array==null || array.length==0 || array.length==1){\nreturn EMPTY_DOUBLE_ARRAY;\n}else{\nreturn array;\n}\n}", "public static Double[] nullToEmpty(final Double[] array){\n    if (array == null) {\n        return EMPTY_CHARACTER_OBJECT_ARRAY;\n    }\n    return array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n    if(array == null) return new Double[0];\n    final Double[] result = new Double[array.length];\n    for(int i = 0; i < array.length; i++) \n      result[i] = array[i];\n    return result;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif(array == null){\n\t\treturn EMPTY_DOUBLE_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tdouble[] result = new double[array.length];\n\tif(array == null) result = EMPTY_CHARACTER_OBJECT_ARRAY;\n\telse for(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif(array==null || array.length==0){return EMPTY_DOUBLE_OBJECT_ARRAY;}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n    if (array == null || array.length == 0) return EMPTY_DOUBLE_ARRAY;\n    final Double[] arrayCopy = array.clone();\n    for (int i = 0; i < array.length; i++) {\n        arrayCopy[i] = null;\n    }\n    return arrayCopy;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\t if(array == null || array.length == 0)\n\t\treturn null;\n\t return array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n   if(array == null) return EMPTY_DOUBLE_OBJECT_ARRAY;\n   final Double[] retval = new Double[array.length];\n   for(int i=0; i<array.length; i++){\n    retval[i] = array[i];\n   }\n   return retval;\n}"]}
{"_id": "636766f01a6d9265ec01762e", "generate_results": ["public static boolean isEmpty(final double[] array){\n\treturn (array == null) || (array.length == 0);\n}", "public static boolean isEmpty(final double[] array){\n  return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    if(array.length == 0)\n        return true;\n    return false;\n}", "public static boolean isEmpty(final double[] array){\n\treturn array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n\treturn array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    return (array.length == 0);\n}", "public static boolean isEmpty(final double[] array){\n    if(array == null || array.length == 0){\n        return true;\n    }else{\n        return false;\n    }\n}", "public static boolean isEmpty(final double[] array){\n\tboolean isEmpty = false;\n\tif(array == null || array.length == 0){\n\t\tisEmpty = true;\n\t}\n\treturn isEmpty;\n}", "public static boolean isEmpty(final double[] array){\n\treturn array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n\tif(array == null){\n\t\treturn true;\n\t}\n\treturn array.length == 0;\n}"]}
{"_id": "636766f21a6d9265ec017677", "generate_results": ["public static boolean isNotTrue(Boolean bool){\n    return!bool;\n}", "public static boolean isNotTrue(Boolean bool){\n\treturn bool == null ||!bool;\n}", "public static boolean isNotTrue(Boolean bool){\n\treturn!bool;\n}", "public static Boolean isNotTrue(Boolean bool){\n//      return bool? Boolean.FALSE : Boolean.TRUE;\n//  }", "public static boolean isNotTrue(Boolean bool){\n    return!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n    return!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n\tif(bool == null)\n\t\treturn false;\n\tif(bool.equals(Boolean.FALSE))\n\t\treturn false;\n\treturn true;\n}", "public static boolean isNotTrue(Boolean bool){\n\treturn!bool;\n}", "public static boolean isNotTrue(Boolean bool){\n    if(bool == null){\n        return false;\n    }\n    else if(bool.booleanValue() == false){\n        return true;\n    }\n    else{\n        return false;\n    }\n}", "public static boolean isNotTrue(Boolean bool){\n    if(bool == null) return false;\n    return!bool;\n}"]}
{"_id": "636766ff1a6d9265ec017842", "generate_results": ["public static double[] toPrimitive(final Double[] array){\n\tif(array.length == 0)\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = array[i];\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\nif(array == null){\nreturn null;}\nif(array.length == 0) {\nreturn EMPTY_DOUBLE_ARRAY;}\nif(array.length == 1) {\nreturn new double[]{array[0]};\n}\nfinal double[] result = new double[array.length];\nfor(int i=0;i<array.length;i++){\nresult[i] = array[i];\n}\nreturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\tif(array == null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n    \n    if(array == null) return null;\n    final double[] result = new double[array.length];\n    for(int i = 0; i < array.length; i++) result[i] = array[i];\n    return result;\n}", "public static double[] toPrimitive(final Double[] array){\n    if(array == null){\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    final int length = array.length;\n    if(length == 0){\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    final double[] result = new double[length];\n    for(int i = 0; i < length; i++){\n        result[i] = array[i];\n    }\n    return result;\n}", "public Double[] toPrimitive(final Double[] array){\n\tif(array==null){\n\t\treturn array==null? array: array.clone();\n\t}\n", "public static Double[] toPrimitive(final Double[] array){\n    if(array == null){\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    return array;\n}", "public static double[] toPrimitive(final Double[] array){\n    if(array.length == 0) return EMPTY_DOUBLE_ARRAY;\n    final double[] result = new double[array.length];\n    for(int i = 0; i < array.length; i++){\n      result[i] = array[i];\n    }\n    return result;\n  }", "public static double[] toPrimitive(final Double[] array){\n    if (array.length == 0) return EMPTY_DOUBLE_ARRAY;\n    final double[] result = new double[array.length];\n    for(int i = 0; i < array.length; i++){\n      result[i] = array[i];\n    }\n    return result;\n  }", "public static double[] toPrimitive(final Double[] array){\n\tif(array == null || array.length == 0) return EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}"]}
{"_id": "6367670a1a6d9265ec0179cf", "generate_results": ["public static char toChar(final Character ch,final char defaultValue){\n\tif (ch == null) return defaultValue;\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif (ch == null) {\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch==null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch!=null){\n\t\treturn ch.charValue();\n\t}else{\n\t\treturn defaultValue;\n\t}\n}", "public static char toChar(final Character ch,final char defaultValue){\n\treturn ch == null? defaultValue : ch;\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch==null)\n\t\treturn defaultValue;\n\tif(ch.toString().startsWith(\"0x\")){\n\t\tint intValue = Integer.parseInt(ch.toString().substring(2),16);\n\t\treturn (char)(intValue);\n\t}\n\treturn (char)(ch.toString().charAt(0));\n}", "public static char toChar(final Character ch,final char defaultValue){\n\treturn toChar(ch,defaultValue);\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tfinal char value = ch==null? defaultValue : ch.charValue();\n\treturn value;\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch==null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch == null){\n\t\treturn defaultValue;\n\t}\n\treturn toChar(ch.toString(), defaultValue);\n}"]}
{"_id": "636767081a6d9265ec0179a2", "generate_results": ["Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\treturn s.isEmpty() || s.charAt(0) == '0';\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tboolean allZeros = true;\n\tint index = 0;\n\twhile(index < s.length()){\n\t\tif(s.charAt(index)!= '0'){\n\t\t\tallZeros = false;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\treturn allZeros;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n    if (s == null) return true;\n    for (int i = 0; i < s.length(); i++){\n        if (s.charAt(i) == '0'){\n            return false;\n        }\n    }\n    return true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tint len = s.length();\n\tfor(int i = 0; i < len; ++i){\n\t\tif(s.charAt(i)!= '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '0') {\n            return false;\n        }\n    }\n    return true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)!='0'){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i) == '0'){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i)==0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tif(s.length() < 1){\n\t\treturn false;\n\t}\n\tboolean flag = true;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(s.charAt(i) == '0'){\n\t\t\tflag = false;\n\t\t}\n\t}\n\treturn flag;\n}", "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n    for(int i = 0; i < s.length(); i++){\n        if(s.charAt(i)!= '0'){\n            return false;\n        }\n    }\n    return true;\n}"]}
{"_id": "636766f21a6d9265ec01767d", "generate_results": ["public static String toString(Object object){\n    if(object == null)\n        return null;\n    \n    if(object instanceof String)\n        return (String)object;\n    \n    if(object instanceof JSONObject)\n        return toString((JSONObject)object);\n    \n    if(object instanceof JSONArray)\n        return toString((JSONArray)object);\n    \n    String string;\n    try{\n        string = object.toString();\n    }catch(Exception e){\n        return null;\n    }\n    \n    if(string!= null)\n        return string;\n    \n    string = null;\n    return string;\n}", "public static String toString(Object object){\n    if (object == null) {\n        return null;\n    } else {\n        return object.toString();\n    }\n}", "public static String toString(Object object){\nif(object == null){\nreturn null;\n}\nreturn object.toString();\n}", "public static String toString(Object object){\n    if(object == null){\n        return null;\n    }\n    if(object instanceof String){\n        return (String)object;\n    }\n    return object.toString();\n}", "public static String toString(Object object){\n    if(object instanceof String){\n        return (String) object;\n    }\n    if(object instanceof Boolean){\n        return (Boolean) object? \"1\" : \"0\";\n    }\n    if(object instanceof Integer){\n        return String.valueOf((Integer) object);\n    }\n    if(object instanceof Long){\n        return String.valueOf((Long) object);\n    }\n    if(object instanceof Float){\n        return String.valueOf((Float) object);\n    }\n    if(object instanceof Double){\n        return String.valueOf((Double) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((Short) object);\n    }\n    if(object instanceof Byte){\n        return String.valueOf((Byte) object);\n    }\n    if(object instanceof BigDecimal){\n        return String.valueOf((BigDecimal) object);\n    }\n    if(object instanceof BigInteger){\n        return String.valueOf((BigInteger) object);\n    }\n    if(object instanceof Character){\n        return String.valueOf((Character) object);\n    }\n    if(object instanceof Short){\n        return String.valueOf((", "public static String toString(Object object){\n    if (object == null)\n        return null;\n    if (object instanceof String)\n        return (String) object;\n    if (object instanceof byte[])\n        return new String((byte[]) object);\n    if (object instanceof Character)\n        return new String((Character) object);\n    if (object instanceof Integer)\n        return new String((Integer) object);\n    if (object instanceof Long)\n        return new String((Long) object);\n    if (object instanceof Boolean)\n        return new String((Boolean) object);\n    if (object instanceof Double)\n        return new String((Double) object);\n    if (object instanceof Float)\n        return new String((Float) object);\n    if (object instanceof Short)\n        return new String((Short) object);\n    if (object instanceof Byte)\n        return new String((Byte) object);\n    if (object instanceof Date)\n        return new String((Date) object);\n    if (object instanceof LocalDate)\n        return new String((LocalDate) object);\n    if (object instanceof LocalDateTime)\n        return new String((LocalDateTime) object);\n    if (object instanceof LocalTime)\n        return new String((LocalTime) object);\n    if (object instanceof CharSequence)\n        return new String((CharSequence) object);\n    if (object instanceof CharacterSequence)\n        return new String((CharacterSequence) object);\n    if (object instanceof List)\n        return new String((List) object);\n    if (object instanceof Map)\n        return new String((Map) object);\n    if (object instanceof Object[])\n        return new String((Object[]) object);\n    if (object instanceof Object)\n        return new String((Object) object);\n    if (object instanceof ObjectArray)\n        return new String((ObjectArray) object);\n    if (object instanceof ObjectHashMap)\n        return new String((ObjectHashMap) object);\n    if (object instanceof Serializable)\n        return new String((Serializable) object);\n    if (object instanceof StringBuilder)\n        return new StringBuilder((StringBuilder) object);\n    if (object instanceof StringBuilderArray)\n        return new StringBuilderArray((StringBuilderArray) object);\n    throw new IllegalArgumentException(\"don't know how to convert object of type \" + object.getClass().getCanonicalName());\n}", "public static String toString(Object object){\n\tif(object == null) return null;\n\treturn object.toString();\n}", "public static String toString(Object object){\nif (object == null)\nreturn null;\n\nif (object instanceof String)\nreturn (String) object;\n\nif (object instanceof String[])\nreturn toString((String[]) object);\n\nif (object instanceof StringBuilder)\nreturn toString((StringBuilder) object);\n\nif (object instanceof StringBuffer)\nreturn toString((StringBuffer) object);\n\nif (object instanceof HashMap)\nreturn toString((HashMap) object);\n\nif (object instanceof HashSet)\nreturn toString((HashSet) object);\n\nif (object instanceof Map)\nreturn toString((Map) object);\n\nif (object instanceof Set)\nreturn toString((Set) object);\n\nif (object instanceof Date)\nreturn toString((Date) object);\n\nif (object instanceof Locale)\nreturn toString((Locale) object);\n\nif (object instanceof Locale.Category)\nreturn toString((Locale.Category) object);\n\nif (object instanceof Locale.Language)\nreturn toString((Locale.Language) object);\n\nif (object instanceof Locale.Country)\nreturn toString((Locale.Country) object);\n\nif (object instanceof Locale.Variant)\nreturn toString((Locale.Variant) object);\n\nif (object instanceof Locale.Pattern)\nreturn toString((Locale.Pattern) object);\n\nif (object instanceof Locale.Script)\nreturn toString((Locale.Script) object);\n\nif (object instanceof Locale.Script.Variant)\nreturn toString((Locale.Script.Variant) object);\n\nif (object instanceof Thread)\nreturn toString((Thread) object);\n\nif (object instanceof Throwable)\nreturn toString((Throwable) object);\n\nif (object instanceof Throwable[])\nreturn toString((Throwable[]) object);\n\nif (object instanceof Class)\nreturn toString((Class) object);\n\nif (object instanceof Class.Name)\nreturn toString((Class.Name) object);\n\nif (object instanceof Class.Name.String)\nreturn toString((Class.Name.String) object);\n\nif (object instanceof Class.Name.StringBuffer)\nreturn toString((Class.Name.StringBuffer) object);\n\nif (object instanceof Class.Name.StringBuffer.String)\nreturn toString((Class.Name.StringBuffer.String) object);\n\nif (object instanceof Class.Name.StringBuffer.StringBuffer)\nreturn toString((Class.Name.StringBuffer.StringBuffer) object);\n\nif (object instanceof Class.Name.StringBuilder)\nreturn toString((Class.Name.StringBuilder) object);\n\nif (object instanceof Class.Name.StringBuilder.String)\nreturn toString((Class.Name.StringBuilder.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuffer)\nreturn toString((Class.Name.StringBuilder.StringBuffer) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder)\nreturn toString((Class.Name.StringBuilder.StringBuilder) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuffer.String)\nreturn toString((Class.Name.StringBuilder.StringBuilder.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.String)\nreturn toString((Class.Name.StringBuilder.StringBuilder.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.StringBuffer)\nreturn toString((Class.Name.StringBuilder.StringBuilder.StringBuffer) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.StringBuffer.String)\nreturn toString((Class.Name.StringBuilder.StringBuilder.StringBuilder.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.StringBuffer.String)\nreturn toString((Class.Name.StringBuilder.StringBuilder.StringBuffer.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.StringBuilder.String.String)\nreturn toString((Class.Name.StringBuilder.StringBuilder.StringBuilder.String.String) object);\n\nif (object instanceof Class.Name.StringBuilder.StringBuilder.String", "public static String toString(Object object){\n    if(object==null)\n        return null;\n    String result = object.toString();\n    return result;\n}", "public static String toString(Object object){\n\tif(object == null) return null;\n\tif(object instanceof Number){\n\t\treturn object.toString();\n\t}\n\tString s = object.toString();\n\tif(s.length() < 1) s = \"\";\n\treturn s;\n}"]}
{"_id": "6367670c1a6d9265ec017a2a", "generate_results": ["public static int[] toPrimitive(final Integer[] array){\n    final int[] primitiveArray= new int[array.length];\n    for(int i= 0; i < array.length; i++){\n        primitiveArray[i] = array[i];\n    }\n    return primitiveArray;\n}", "public static int[] toPrimitive(final Integer[] array){\n        if(array==null) return null;\n        final int[] ret = new int[array.length];\n        for(int i=0;i<array.length;i++){\n            ret[", "public static int[] toPrimitive(final Integer[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\tfinal int[] primitive = new int[array.length];\n\tfor(int a = 0; a < array.length; a++) {\n\t\tprimitive[a] = array[a];\n\t}\n\treturn primitive;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if(array == null) return null;\n    if(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n    final Integer[] primArray = new Integer[array.length];\n    for(int i = 0; i < array.length; i++)\n      primArray[i] = array[i];\n    return primArray;\n}", "public static int[] toPrimitive(final Integer[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\treturn array.length == 0?ArrayUtils.EMPTY_INT_ARRAY:array;\n}", "public static long[] toPrimitive(final Integer[] array){\n\tif(array == null || array.length == 0)\n\t\treturn (long[])null;\n\tfinal long[] result = new long[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = array[i];\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if(array == null){\n        return null;\n    }\n    final int[] res = new int[array.length];\n    for(int i = 0; i < array.length; i++){\n        res[i] = array[i];\n    }\n    return res;\n}", "public static int[] toPrimitive(final Integer[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tint[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n if(array == null) return null;\n if(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n int[] primitiveArray = new int[array.length];\n for(int i = 0; i < array.length; i++){\n if(array[i]!= null){\n primitiveArray[i] = array[i].intValue();\n }\n }\n return primitiveArray;\n}", "public static int[] toPrimitive(final Integer[] array){\n\tif (array==null) return null;\n\tif (array.length==0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal int[] result = new int[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}"]}
{"_id": "636766fa1a6d9265ec01779d", "generate_results": ["public static boolean isAsciiControl(final char ch){\n\treturn ch=='\\u007F' || ch=='\\u0085' || ch=='\\u00A0' || ch=='\\u1680' || ch=='\\u180E' || ch=='\\u2000' || ch=='\\u2001' || ch=='\\u2002' || ch=='\\u2003' || ch=='\\u2004' || ch=='\\u2005' || ch=='\\u2006' || ch=='\\u2007' || ch=='\\u2008' || ch=='\\u2009' || ch=='\\u200A' || ch=='\\u202F' || ch=='\\u205F' || ch=='\\u3000';\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch>='a' && ch<='z' || ch>='A' && ch<='Z') || ch=='\\t' || ch=='\\n';\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch >= '!' && ch <= '~');\n}", "public static boolean isAsciiControl(final char ch){\n\tif (ch >='' && ch <= '~'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch >= '\\u0080' && ch <= '\\u00BF');\n}", "public static boolean isAsciiControl(final char ch){\n\treturn ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'));\n}", "public static boolean isAsciiControl(final char ch){\n    return (ch >= '!' && ch <= '@');\n}", "public static boolean isAsciiControl(final char ch){\n\tif(ch >='' && ch <= '~')\n\t\treturn true;\n\treturn false;\n}", "public static boolean isAsciiControl(final char ch){\n    return (ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '\\b' || ch == '\\f');\n}", "public static boolean isAsciiControl(final char ch){\n    return ch >= 0x20 && ch <= 0x7F;\n}"]}
{"_id": "636766fa1a6d9265ec017796", "generate_results": ["public static boolean[] toObject(final boolean[] array){\n\tif (array == null) return null;\n\treturn array.clone();\n}", "public static Boolean[] toObject(final boolean[] array){\n\tfinal Object[] objects = new Object[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tobjects[i] = new Object();\n\t\tobjects[i].toString();\n\t}\n\treturn objects;\n}", "public static Boolean[] toObject(final boolean[] array){\n\treturn toObject(array, new Array() {\n\t\t@Override\n\t\tpublic Object get(int index) {\n\t\t\treturn array[index];\n\t\t}\n\t});\n}", "public static Boolean[] toObject(final boolean[] array){\n\tBoolean[] objects = new Boolean[array.length];\n\tfor( int i = 0; i < array.length; i++ ){\n\t\tobjects[i] = new Boolean(array[i]);\n\t}\n\treturn objects;\n}", "public static Boolean[] toObject(final boolean[] array){\n\tObject[] objectArray = new Object[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tobjectArray[i] = new Boolean(array[i]);\n\t}\n\treturn (Boolean[]) objectArray;\n}", "public static Boolean[] toObject(final boolean[] array){\n\tfinal Boolean[] result = new Boolean[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tresult[i] = Boolean.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) {\n        return null;\n    }\n    final Boolean[] result = new Boolean[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = Boolean.valueOf(array[i]);\n    }\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\treturn toObject(array, (Class) Boolean.class);\n}", "public static Boolean[] toObject(final boolean[] array){\n    final Object[] objects = new Object[array.length];\n    for(int i=0; i < array.length; i++){\n      objects[i] = new Boolean(array[i]);\n    }\n    return objects;\n  }", "public static Boolean[] toObject(final boolean[] array){\n\treturn toObject(array, new Object[array.length]);\n}"]}
{"_id": "6367670a1a6d9265ec0179f1", "generate_results": ["public static Short[] toObject(final short[] array){\n\tObject[] result = null;\n\tif(array!= null){\n\t\tresult = new Object[array.length];\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tresult[i] = array[i];\n\t\t}\n\t}\n\treturn (Short[]) result;\n}", "public static Short[] toObject(final short[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\t\n\tfinal Short[] result = new Short[array.length];\n\t\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = (short)array[i];\n\t}\n\t\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\tif(array == null) return null;\n\t\n\tShort[] arr = new Short[array.length];\n\t\n\tfor(int i = 0; i < array.length; i++){\n\t\tarr[i] = (Short)array[i];\n\t}\n\t\n\treturn arr;\n}", "public static Short[] toObject(final short[] array){\n    final Short[] result = new Short[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = (Short)array[i];\n    }\n    return result;\n}", "public static Short[] toObject(final short[] array){\n    // TODO: implement\n    return array;\n}", "public static Short[] toObject(final short[] array){\n    final Short[] result = new Short[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = (Short)array[i];\n    }\n    return result;\n}", "public static short[] toObject(final short[] array){\n\tif (array == null) return null;\n\t\n\tfinal short[] result = new short[array.length];\n\tfor(int i=0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n    Short[] result = new Short[array.length];\n    for (int i = 0; i < array.length; i++){\n        result[i] = Short.valueOf(array[i]);\n    }\n    return result;\n}", "public static Short[] toObject(final short[] array){\n\tfinal Object[] array2 = new Object[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tarray2[i] = array[i];\n\t}\n\treturn array2;\n}", "public static int[] toObject(final short[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return null;\n\t\n\tfinal Object[] result = new Object[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}"]}
{"_id": "636766fe1a6d9265ec017838", "generate_results": ["public static char[] toPrimitive(final Character[] array){\n if(array == null){\n   return null;\n }\n if(array.length == 0){\n   return ArrayUtils.EMPTY_CHAR_ARRAY;\n }\n char[] a = new char[array.length];\n for(int i = 0; i < array.length; i++){\n   a[i] = array[i];\n }\n return a;\n}", "public static char[] toPrimitive(final Character[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\tfinal char[] array2 = new char[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tarray2[i] = array[i];\n\t}\n\treturn array2;\n}", "public static char[] toPrimitive(final Character[] array){\n    if(array == null || array.length == 0){\n        return ArrayUtils.EMPTY_CHAR_ARRAY;\n    }\n    return array.clone();\n}", "public static char[] toPrimitive(final Character[] array){\n\tif (array == null) return ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal int arraySize = array.length;\n\tif (arraySize == 0) return ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result = new char[arraySize];\n\tfor (int i = 0; i < arraySize; i++) {\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n     if(array == null)\n        return null;\n     if(array.length == 0)\n        return ArrayUtils.EMPTY_CHAR_ARRAY;\n     if(array.length == 1)\n        return array[0]==null?ArrayUtils.EMPTY_CHAR_ARRAY:new char[]{array[0]};\n     return array.length==1?new char[]{array[0]}:ArrayUtils.toStringArray(array);\n }", "public static char[] toPrimitive(final Character[] array){\n  if(array == null)return null;\n  final char[] result = new char[array.length];\n  for(int i = 0; i < array.length; i++)result[i] = array[i];\n  return result;\n}", "public static char[] toPrimitive(final Character[] array){\n\tif(array!=null){\n\t\treturn array.clone();\n\t}\n\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n}", "public static char[] toPrimitive(final Character[] array){\nif(array == null){\nreturn null;\n}else{\nreturn array.length == 0? ArrayUtils.EMPTY_CHAR_ARRAY : array.clone();\n}\n}", "public static char[] toPrimitive(final Character[] array){\n\tif(array == null)return null;\n\tfinal int len = array.length;\n\tif(len == 0)return ArrayUtils.EMPTY_CHAR_ARRAY;\n\tif(len == 1)return new char[]{array[0]};\n\tfinal char[] result = new char[len];\n\tfor(int i = 0;i < len;i++)result[i] = array[i];\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\nif(array==null){\nreturn null;}\nif(array.length==0){\nreturn ArrayUtils.EMPTY_CHAR_ARRAY;\n}\nfinal char[] result = new char[array.length];\nfor(int i=0;i<array.length;i++){{\nresult[i]=array[i];}}\nreturn result;\n}"]}
{"_id": "636767041a6d9265ec01790f", "generate_results": ["public static Integer[] toObject(final int[] array){\n\treturn toObjectArray(array, new Integer[array.length]);\n}", "public static Integer[] toObject(final int[] array){\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = Integer.valueOf(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array==null) return null;\n\tint n=array.length;\n\tInteger[] o=new Integer[n];\n\tfor (int i=0;i<n;i++){\n\t\to[i]=new Integer(array[i]);\n\t}\n\treturn o;\n}", "public static Integer[] toObject(final int[] array){\n\tif(array == null || array.length == 0) return null;\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i ++){\n\t\tresult[i] = Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; ++i){\n\t\tresult[i] = Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tInteger[] intArray = new Integer[array.length];\n\tfor(int i = 0;i < array.length;i++){\n\t\tintArray[i] = array[i];\n\t}\n\treturn intArray;\n}", "public static Integer[] toObject(final int[] array){\n\treturn toObject(array, 0);\n}", "public static Integer[] toObject(final int[] array){\n\treturn new Integer[]{array[0],array[1],array[2],array[3],array[4]};\n}", "public static Integer[] toObject(final int[] array){\n\tfinal Integer[] object = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tobject[i] = new Integer(array[i]);\n\t}\n\treturn object;\n}"]}
{"_id": "636766fa1a6d9265ec0177a4", "generate_results": ["public static Object toObject(final double[] array){\n\treturn Arrays.toObject(array);\n}", "public static Double[] toObject(final double[] array){\n\tif(array == null) return null;\n\treturn new Double[]{array[0], array[1], array[2], array[3], array[4], array[5]};\n}", "public static Object[] toObject(final double[] array){\n\tObject[] objectArray = new Object[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tobjectArray[i] = new Double(array[i]);\n\t}\n\treturn objectArray;\n}", "public static Double[] toObject(final double[] array){\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n    final Double[] result = new Double[array.length];\n    for (int i = 0; i < result.length; i++)\n        result[i] = new Double(array[i]);\n    return result;\n}", "public static Double[] toObject(final double[] array){\n\tfinal Double[] result = new Double[array.length];\n    \tfor(int i=0; i<array.length; i++){\n    \t\tresult[i] = new Double(array[i]);\n    \t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\tif (array == null) return null;\n\tfinal Double[] result = new Double[array.length];\n\tfor (int i=0; i<array.length; i++) {\n\t\tresult[i] = Double.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n    return toObject(array, new Double[]{});\n}", "public static Double[] toObject(final double[] array){\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}"]}
{"_id": "636767151a6d9265ec017b6b", "generate_results": ["Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(ignoreCase){\n\t\treturn str.startsWith(prefix);\n\t}else{\n\t\treturn str.startsWith(prefix);\n\t}\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(ignoreCase){\n\t\treturn str.startsWith(prefix);\n\t}else{\n\t\treturn str.startsWith(prefix);\n\t}\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str==null || prefix==null){\n\t\treturn ignoreCase;\n\t}else if(ignoreCase){\n\t\treturn str.toLowerCase().startsWith(prefix.toLowerCase());\n\t}else{\n\t\treturn str.toLowerCase().startsWith(prefix);\n\t}\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif (str == null){\n\t\treturn false;\n\t}\n\tif (prefix == null){\n\t\treturn str.startsWith(ignoreCase);\n\t}\n\treturn str.startsWith(prefix) || (str.length() >= prefix.length() && str.substring(0, prefix.length()).startsWith(prefix));\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str == null){\n\t\treturn false;\n\t}\n\tif(prefix == null){\n\t\treturn true;\n\t}\n\tif(ignoreCase){\n\t\treturn str.toLowerCase().startsWith(prefix.toLowerCase());\n\t}\n\treturn str.startsWith(prefix);\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str == null){\n\t\treturn false;\n\t}\n\tfinal int len = str.length();\n\tif(ignoreCase){\n\t\tfinal char[] chars = str.toCharArray();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(chars[i]!= prefix.charAt(i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfinal char[] chars = str.toCharArray();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(chars[i]!= prefix.charAt(i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n//\tif (str == null) return false;\n//\tif (prefix == null) return true;\n//\tif (ignoreCase)\n//\t\treturn str.startsWith(prefix);\n//\telse\n//\t\treturn str.toLowerCase().startsWith(prefix);\n//}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif (str == null || prefix == null) return false;\n\tif (ignoreCase) {\n\t\treturn str.startsWith(prefix);\n\t} else {\n\t\treturn str.startsWith(prefix.toLowerCase());\n\t}\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif (str == null) return false;\n\tif (prefix == null) return str.startsWith(ignoreCase);\n\tfinal String p = str.substring(ignoreCase? 0 : str.length()-ignoreCase.length(),ignoreCase? str.length() : str.length()-ignoreCase.length());\n\tif (p.startsWith(prefix)) return true;\n\tif (p.startsWith(prefix+\"-\")) return true;\n\treturn false;\n}", "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str == null){\n\t\treturn false;\n\t}\n\telse if(prefix == null){\n\t\treturn str.length() >= prefix.length();\n\t}\n\telse {\n\t\treturn str.toLowerCase().startsWith(prefix.toLowerCase()));\n\t}\n}"]}
{"_id": "636766fe1a6d9265ec01781c", "generate_results": ["public static Character toCharacterObject(final char ch){\n    Character c = Character.valueOf(ch);\n    return c;\n}", "public static Character toCharacterObject(final char ch){\n  switch (ch) {\n  case '\\'':\n    return new Character('\\'');\n  case '\\\"':\n    return new Character('\\\"');\n  case '\\n':\n    return new Character('\\n');\n  case '\\r':\n    return new Character('\\r');\n  case '\\b':\n    return new Character('\\b');\n  case '\\t':\n    return new Character('\\t');\n  default:\n    return new Character(ch);\n  }\n}", "public static Character toCharacterObject(final char ch){\n  switch (ch){\n  case '\\'':\n    return CHAR_SINGLEQUOTE;\n  case '\"':\n    return CHAR_DOUBLEQUOTE;\n  case '\\\\':\n    return CHAR_BACKQUOTE;\n  default:\n    return CHAR_UNKNOWN;\n  }\n}", "public static Character toCharacterObject(final char ch){\n    if (ch < 256)\n        return Character.valueOf((char) ch);\n    else if (ch < 65536)\n        return Character.valueOf((char) ((ch >> 8) & 0xFF));\n    else if (ch < 131072)\n        return Character.valueOf((char) ((ch >> 16) & 0xFF));\n    else if (ch < 268435456)\n        return Character.valueOf((char) ((ch >> 24) & 0xFF));\n\n    return null;\n}", "public static Character toCharacterObject(final char ch){\n\tCharacter ret;\n\tif(ch>=0 && ch<=255){\n\t\tret = Character.valueOf((char)ch);\n\t}else if(ch>=256 && ch<=65535){\n\t\tret = Character.valueOf((char)(ch>>8));\n\t\tret = Character.valueOf((char)(ch&0xff));\n\t}else if(ch>=65536 && ch<=1023){\n\t\tret = Character.valueOf((char)(ch>>16));\n\t\tret = Character.valueOf((char)(ch&0xff00));\n\t}else{\n\t\tret = Character.valueOf(ch);\n\t}\n\treturn ret;\n}", "public static Character toCharacterObject(final char ch){\n\treturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\treturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\treturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\tif(ch >='' && ch < 127) {\n\t\treturn new Character(ch);\n\t} else {\n\t\tthrow new IllegalArgumentException(\"Invalid character: \"+ch+\" (0x\"+Integer.toHexString(ch)+\")\");\n\t}\n}", "public static Character toCharacterObject(final char ch){\n\treturn new Character(ch);\n}"]}
{"_id": "636766fb1a6d9265ec0177c1", "generate_results": ["public static boolean isAsciiAlphaUpper(final char ch){\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn ch>='A' && ch<='Z';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n    if(ch >= 'a' && ch <= 'z'){\n        return true;\n    }\n    return false;\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n//\treturn Character.isUpperCase(ch);\n//}", "public static boolean isAsciiAlphaUpper(final char ch){\n    return (Character.isUpperCase(ch) || Character.isUpperCase(ch));\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\tif(ch >= 'a' && ch <= 'z'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\tif(ch >= 'A' && ch <= 'Z'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 'A' && ch <= 'Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n    return (ch >= 'A' && ch <= 'Z');\n}"]}
{"_id": "6367670a1a6d9265ec0179d9", "generate_results": ["public static int length(final String str){\n  int length=0;\n  if(str!=null){\n    for(int i=0;i<str.length();i++){\n      if(str.charAt(i)=='\\r'||str.charAt(i)=='\\n'){\n        length++;\n      }\n    }\n  }\n  return length;\n}", "public static int length(final String str){\nif(str == null){\nreturn 0;\n}else{\nreturn str.length();\n}\n}", "public static int length(final String str){\n\tif (str == null) return 0;\n\treturn str.length();\n}", "public static int length(final String str){\n\treturn str==null?0:str.length();\n}", "public static int length(final String str){\n\tif(str == null || str.isEmpty())\n\t\treturn 0;\n\tint len = str.length();\n\tif(len == 0)\n\t\treturn 0;\n\treturn 1;\n}", "public static int length(final String str){\n\treturn str == null? 0 : str.length();\n}", "public static int length(final String str){\n    if(str == null){\n        return 0;\n    }\n    int len = str.length();\n    if(len == 0){\n        return 0;\n    }\n    return len;\n}", "public static int length(final String str){\n\tif(str == null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "public static int length(final String str){\n  return str == null? 0 : str.length();\n}", "public static int length(final String str){\n\tif(str == null)return 0;\n\treturn str.length();\n}"]}
{"_id": "636766f81a6d9265ec017748", "generate_results": ["public static String base64Decode(final String s){\n\ttry{\n\t\treturn new String(Base64.decodeBase64(s.getBytes(\"UTF-8\")));\n\t}catch(final Exception e){\n\t\treturn \"\";\n\t}\n}", "public static String base64Decode(final String s){\n\tStringBuffer sb = new StringBuffer();\n\tint len = s.length();\n\tfor (int i = 0; i < len; i++){\n\t\tchar c = s.charAt(i);\n\t\tif (c == '='){\n\t\t\tsb.append(c);\n\t\t}else{\n\t\t\tsb.append('=');\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String base64Decode(final String s){\n\t// TODO: Implement me!\n\treturn null;\n}", "public static int base64Decode(final String s){\n    int len = s.length();\n    if(len < 1) return -1;\n    if(len % 4!= 0) return -1;\n    int next = (s.charAt(0) >= 'A')? s.charAt(0) - 'A' : s.charAt(0) - 'a';\n    int i = 1;\n    while(i < len){\n        char c = s.charAt(i);\n        if(c == '='){\n            i++;\n            if(i < len)\n                return next;\n            break;\n        }\n        next = (c >= 'A')? c - 'A' : c - 'a';\n        i++;\n    }\n    return -1;\n}", "public static String base64Decode(final String s){\n    return base64Decode(s);\n}", "public static String base64Decode(final String s){\n    StringBuilder sb = new StringBuilder();\n    try{\n        //Base64\n        Base64.Decoder decoder = Base64.getDecoder();\n        byte[] decoded = decoder.decode(s.getBytes());\n        //Log.i(\"TAG\", \"base64Decode:\" + decoded.length);\n        for(int i=0; i < decoded.length; i++){\n            sb.append(String.format(\"%02X\", decoded[i]));\n        }\n        return sb.toString();\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n\n    return null;\n}", "public static String base64Decode(final String s){\n     \n    byte[] bytes = s.getBytes(Charset.forName(\"UTF-8\"));\n    String encoded = new String(bytes);\n    return encoded;\n  }", "public static String base64Decode(final String s){\n\tif(s==null){\n\t\treturn null;\n\t}\n\tbyte[] bytes = s.getBytes(StandardCharsets.UTF_8.name());\n\treturn new String(bytes, StandardCharsets.UTF_8.name());\n}", "public static byte[] base64Decode(final String s) {\n//\tint len = s.length();\n//\tint i = 0;\n//\tbyte[] b = new byte[len];\n//\twhile (i < len) {\n//\t\tif (s.charAt(i) == '=') {\n//\t\t\ti++;\n//\t\t\tcontinue;\n//\t\t}\n//\t\tb[i] = (byte)s.charAt(i);\n//\t\ti++;\n//\t}\n//\treturn b;\n//}", "public static String base64Decode(final String s){\n    if(s==null) return null;\n    final byte[] result = Base64.decode(s);\n    return new String(result, \"UTF-8\");\n}"]}
{"_id": "636766f11a6d9265ec017663", "generate_results": ["public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null){\n\t\treturn array2 == null;\n\t}\n\tif(array2 == null){\n\t\treturn false;\n\t}\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null || array2 == null)\n\t\treturn false;\n\tif(array1.length!= array2.length)\n\t\treturn false;\n\tfor(int i = 0;i < array1.length;i++){\n\t\tif(array1[i]!= array2[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null || array2 == null) return false;\n\treturn (array1.length == array2.length);\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null)return array2==null;\n\tif(array2==null)return false;\n\tif(array1.length!=array2.length)return false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i])return false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null || array2 == null)\n\t\treturn false;\n\t\n\tif(array1.length!= array2.length)\n\t\treturn false;\n\t\n\tint length = array1.length;\n\tfor(int i=0;i<length;i++){\n\t\tif(array1[i]!= array2[i])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    int length1 = array1.length;\n    int length2 = array2.length;\n    if(length1 == 0){\n        return length2 == 0;\n    }\n    if(length2 == 0){\n        return true;\n    }\n    if(length1!= length2){\n        return false;\n    }\n    for(int i=0;i<length1;i++){\n        if(array1[i]!= array2[i]){\n            return false;\n        }\n    }\n    return true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    if(array1 == null || array2 == null){\n        return false;\n    }\n    return array1.length == array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null)\n\t\treturn array2 == null;\n\tif(array2 == null)\n\t\treturn array1 == null;\n\tif(array1.length!= array2.length)\n\t\treturn false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null&&array2==null)return true;\n\tif(array1==null||array2==null)return false;\n\tif(array1.length!=array2.length)return false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    if(array1==null||array2==null) return false;\n    if(array1.length!= array2.length) return false;\n    \n    int len = 0;\n    for(int i=0;i<array1.length;i++)\n        len += array1[i] == array2[i]?1:0;\n    return len == array1.length;\n}"]}
{"_id": "636766f31a6d9265ec01768f", "generate_results": ["public static char[] clone(final char[] array){\n\treturn copyOf(array, array.length);\n}", "public static char[] clone(final char[] array){\n    final char[] clone = new char[array.length];\n    System.arraycopy(array, 0, clone, 0, array.length);\n    return clone;\n}", "public static char[] clone(final char[] array){\n    final char[] clone = new char[array.length];\n    System.arraycopy(array, 0, clone, 0, array.length);\n    return clone;\n}", "public static char[] clone(final char[] array){\n\tif (array!= null) {\n\t\treturn Arrays.copyOf(array, array.length);\n\t}\n\treturn null;\n}", "public static char[] clone(final char[] array){\n  char[] cloned = new char[array.length];\n  System.arraycopy(array, 0, cloned, 0, array.length);\n  return cloned;\n}", "public static char[] clone(final char[] array){\n\treturn (char[])Array.clone(array);\n}", "public static char[] clone(final char[] array){\n\tif(array==null)\n\t\treturn null;\n\tfinal char[] clone = new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tclone[i]=array[i];\n\t}\n\treturn clone;\n}", "public static char[] clone(final char[] array){\n    final char[] result = new char[array.length];\n    System.arraycopy(array, 0, result, 0, array.length);\n    return result;\n}", "public static char[] clone(final char[] array){\n\tfinal char[] result = new char[array.length];\n\tfor(int i = 0; i < result.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\t\n\treturn result;\n}", "public static char[] clone(final char[] array){\n    char[] newArray = new char[array.length];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    return newArray;\n}"]}
{"_id": "636766fb1a6d9265ec0177c3", "generate_results": ["public static boolean isAscii(final char ch){\n\treturn (ch >= '0' && ch <= '9');\n}", "public static boolean isAscii(final char ch){\n\treturn ch>='a' && ch<='z' || ch>='A' && ch<='Z';\n}", "public static boolean isAscii(final char ch){\n\treturn (ch>= '!' && ch<='~' && ch<='?');\n}", "public static boolean isAscii(final char ch){\n    return ch >= '0' && ch <= '7';\n}", "public static boolean isAscii(final char ch){\n\tif(ch<''|| ch>='~'){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}", "public static boolean isAscii(final char ch){\n\treturn ch >= '\\u0000' && ch <= '\\u007f';\n}", "public static boolean isAscii(final char ch){\n\tif (ch <= 0x7F) return true;\n\treturn false;\n}", "public static boolean isAscii(final char ch){\n\treturn  (ch >= '!' && ch <= '~');\n}", "public static boolean isAscii(final char ch){\n\treturn (ch >= '!' && ch <= '~');\n}", "public static boolean isAscii(final char ch){\n    if(ch<=0x20 || ch>0x7f) return false;\n    return true;\n}"]}
{"_id": "6367670b1a6d9265ec017a05", "generate_results": ["public static String toString(final char ch){\n    return new String(new char[] {ch});\n}", "public static String toString(final char ch){\n\treturn new String(new char[]{(char)ch});\n}", "public static String toString(final char ch){\n\tif(ch == '\\n'){\n\t\treturn \"\\\\n\";\n\t}\n\tif(ch == '\\r'){\n\t\treturn \"\\\\r\";\n\t}\n\tif(ch == '\\t'){\n\t\treturn \"\\\\t\";\n\t}\n\tif(ch == '\\\\'){\n\t\treturn \"\\\\\\\\\";\n\t}\n\tif(ch == '\\\"'){\n\t\treturn \"\\\\\\\"\";\n\t}\n\tif(ch == '\\''){\n\t\treturn \"\\\\\\'\";\n\t}\n\tif(ch == '\\b'){\n\t\treturn \"\\\\b\";\n\t}\n\tif(ch == '\\f'){\n\t\treturn \"\\\\f\";\n\t}\n\tif(ch == '\\n'){\n\t\treturn \"\\\\n\";\n\t}\n\tif(ch == '\\r'){\n\t\treturn \"\\\\r\";\n\t}\n\tif(ch == '\\t'){\n\t\treturn \"\\\\t\";\n\t}\n\tif(ch == '\\\\'){\n\t\treturn \"\\\\\\\\\";\n\t}\n\tif(ch == '\\''){\n\t\treturn \"\\\\'\";\n\t}\n\tif(ch == '\\\"'){\n\t\treturn \"\\\\\\\"\";\n\t}\n\tif(ch == '\\b'){\n\t\treturn \"\\\\b\";\n\t}\n\tif(ch == '\\f'){\n\t\treturn \"\\\\f\";\n\t}\n\tif(ch == '\\n'){\n\t\treturn \"\\\\n\";\n\t}\n\treturn \"\"+ch;\n}", "public static String toString(final char ch){\n\tif (ch == 0)\n\t\treturn \"\";\n\telse\n\t\treturn Character.toString(ch);\n}", "public static String toString(final char ch){\n    return new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\tif (ch < 0)\n\t\tthrow new IllegalArgumentException(\"cannot convert negative character\");\n\t\n\tString ret = \"\";\n\tif (ch < 127)\n\t\tret += String.valueOf(ch);\n\telse if (ch < 256)\n\t\tret += \"\\\\\" + String.valueOf(ch);\n\telse\n\t\tret += \"\\\\\" + String.valueOf(ch) + \"\\\\\";\n\t\n\treturn ret;\n}", "public static String toString(final char ch){\n    return new String(new char[] {ch});\n}", "public static String toString(final char ch){\n\tchar[] a = new char[1];\n\ta[0] = ch;\n\treturn new String(a);\n}", "public static String toString(final char ch){\n\treturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n  return String.valueOf(ch);\n}"]}
{"_id": "636767191a6d9265ec017c0f", "generate_results": ["Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n\tbyte[] data = new byte[size];\n\tSystem.arraycopy(this.data, 0, data, 0, this.data.length);\n\tthis.data = data;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    byteVector.ensureCapacity(byteVector.capacity() + size);\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    byte[] newData = new byte[size];\n    System.arraycopy(data, 0, newData, 0, size);\n    data = newData;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    byte[] newArray = new byte[size];\n    for(int i = 0; i < size; i++){\n        newArray[i] = data[i];\n    }\n    data = newArray;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n\tfinal int newSize = (getSize() + size) > MAX_SIZE? MAX_SIZE : getSize() + size;\n\tfinal byte[] newData = new byte[newSize];\n\tSystem.arraycopy(data, 0, newData, 0, getSize());\n\tthis.data = newData;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n\n    byte[] newData = new byte[size];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    if(size >= max_size){\n        max_size = size;\n    }else{\n        max_size = (max_size * 2) + 1;\n    }\n    byte[] new_data = new byte[max_size];\n    System.arraycopy(data, 0, new_data, 0, data.length);\n    data = new_data;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    if(size <= 0){\n        return;\n    }\n    byte[][] newData = new byte[size][];\n    byte[] oldData = data;\n    data = newData;\n    for(int i=0; i < size; i++){\n        newData[i] = oldData;\n        oldData = oldData[i];\n    }\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n    byte[] data = new byte[size];\n    System.arraycopy(array, 0, data, 0, array.length);\n    array = data;\n}", "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n  byteVector.ensureCapacity(byteVector.capacity());\n  byteVector.resize(byteVector.capacity() + size);\n}"]}
{"_id": "636766ef1a6d9265ec01761a", "generate_results": ["Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tif(value == null)\n\t\treturn -1;\n\t\n\tint index = find(value);\n\tif(index!= -1)\n\t\treturn index;\n\t\n\tindex = addType(value);\n\treturn index;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tint index = 0;\n\tif(typeTable[index] == null){\n\t\ttypeTable[index] = new TypeEntry(value);\n\t\treturn index;\n\t}\n\treturn -1;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tint index = getTypeIndex(value);\n\tif(index < 0){\n\t\tif(index == -1){\n\t\t\tindex = getOrCreateTypeIndex(value);\n\t\t}else{\n\t\t\tindex = -1;\n\t\t}\n\t}\n\t\n\treturn index;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tfinal int index = get(value);\n\tif(index == -1){\n\t\tfinal int len = getSize();\n\t\tfinal int[] array = new int[len];\n\t\tSystem.arraycopy(getBytes(), 0, array, 0, len);\n\t\tSystem.arraycopy(getBytes(), len, array, 0, index);\n\t\tfinal int[] array1 = new int[len];\n\t\tSystem.arraycopy(getBytes(), 0, array1, 0, len);\n\t\tSystem.arraycopy(getBytes(), index, array1, 0, index);\n\t\tset(value, array);\n\t\tset(value, array1);\n\t\treturn index;\n\t}\n\treturn index;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tint index = checkTypeTableFor(value);\n\tif(index < 0){\n\t\tindex = addType(value);\n\t\tfinal int index2 = checkTypeTableFor(value);\n\t\tif(index2 >= 0){\n\t\t\treturn index2;\n\t\t}\n\t}\n\treturn index;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tif(!isSymbolTableEmpty()){\n\t\treturn getTypeIndex(value);\n\t}\n\telse{\n\t\treturn addType(value, value);\n\t}\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n    if(typeTable==null){\n        typeTable=new HashMap<String, Integer>();\n    }\n    return typeTable.get(value);\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tif(value.length() > 0){\n\t\tfinal int type = addType(value.charAt(0));\n\t\tif(type!= -1){\n\t\t\tfinal String entry = value.substring(1);\n\t\t\tfor(int i = 1; i < value.length(); i++){\n\t\t\t\tfinal char c = value.charAt(i);\n\t\t\t\tif(c == '&'){\n\t\t\t\t\tfinal int id = addType(c);\n\t\t\t\t\tif(id!= -1){\n\t\t\t\t\t\tvalue = value.substring(0, i) + \";\" + value.substring(i);\n\t\t\t\t\t\treturn type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(id!= -1){\n\t\t\t\t\tvalue = value.substring(0, i) + \";\" + value.substring(i);\n\t\t\t\t\treturn type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tif(value == null) return -1;\n\tif(!typeTable.containsKey(value)){\n\t\ttypeTable.put(value, new int[1]);\n\t\treturn 0;\n\t}\n\treturn typeTable.get(value)[0];\n}", "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tif(value.length() == 0) return -1;\n\tif(value.equals(\"void\")) return 0;\n\tint index = 0;\n\twhile(index < symbolTable.size() && symbolTable.get(index)!= value) index++;\n\tif(index == symbolTable.size()) symbolTable.add(value);\n\telse symbolTable.set(index, value);\n\treturn index;\n}"]}
{"_id": "636766f81a6d9265ec01775b", "generate_results": ["public long readLong(final int offset){\n\treturn readInt(offset) | (readInt(offset+4) << 32);\n}", "public long readLong(final int offset){\n\treturn readByte(offset) | (readByte(offset + 1) << 8) |\n\t\t(readByte(offset + 2) << 16) |\n\t\t(readByte(offset + 3) << 24);\n}", "public long readLong(final int offset){\n    return readSignedLong(offset);\n}", "public long readLong(final int offset){\n    return _readLong(offset);\n}", "public long readLong(final int offset) {\n        return read(offset, 8);\n    }", "public long readLong(final int offset){\n\treturn readInt(offset);\n}", "public long readLong(final int offset){\n\treturn readLong(offset, false);\n}", "public long readLong(final int offset){\n  return readVarint64(offset);\n}", "public long readLong(final int offset){\n\treturn readLong(offset, 4);\n}", "public long readLong(final int offset){\n    return (long)readUnsignedByte(offset)<<8 | (long)readUnsignedByte(offset+1);\n}"]}
{"_id": "6367671a1a6d9265ec017c15", "generate_results": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\nbyteVector.put(byteArrayValue,byteOffset,byteLength);\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tbyteArrayValue = byteArrayValue.clone();\n\t}\n\tif(byteArrayValue.length > byteOffset + byteLength){\n\t\tbyteArrayValue = byteArrayValue.subarray(byteOffset, byteLength);\n\t}\n\tthis.byteArrayValue = byteArrayValue;\n\tthis.byteArrayOff = 0;\n\tthis.byteArrayLen = byteArrayValue.length;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength)\n\t\tbyteArrayValue = Arrays.copyOf(byteArrayValue, byteOffset + byteLength);\n\t\n\tcount += byteLength;\n\t\n\tfinal int newByteOffset = byteOffset + byteLength;\n\t\n\tbyte[] newByteArray = new byte[byteArrayValue.length + byteLength];\n\tSystem.arraycopy(byteArrayValue, byteOffset, newByteArray, 0, byteLength);\n\t\n\treturn new ByteVector(newByteArray, newByteOffset, byteLength);\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tbyte[] newArray = new byte[byteOffset + byteLength];\n\t\tSystem.arraycopy(byteArrayValue, 0, newArray, 0, byteOffset);\n\t\tbyteArrayValue = newArray;\n\t}\n\tif(byteArrayValue.length > byteOffset + byteLength){\n\t\tbyte[] newArray = new byte[byteOffset + byteLength];\n\t\tSystem.arraycopy(byteArrayValue, byteOffset, newArray, 0, byteOffset);\n\t\tbyteArrayValue = newArray;\n\t}\n\t\n\tbyteArrayValue[byteOffset] = (byte)byteArrayValue.length;\n\t\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset+byteLength)\n\t\tbyteArrayValue = Arrays.copyOfRange(byteArrayValue,byteOffset,byteOffset+byteLength);\n\tthis.bytes = Arrays.copyOfRange(this.bytes,byteOffset,byteOffset+byteLength);\n\tthis.length = byteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tbyteVector.ensureCapacity(byteOffset + byteLength);\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteVector, byteOffset, byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset+byteLength)\n\t\texpand(byteArrayValue.length);\n\tSystem.arraycopy(byteArrayValue, byteOffset, _buffer, _position, byteLength);\n\t_position += byteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tbyteArrayValue = new byte[byteOffset + byteLength];\n\t}\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteArrayValue,0,byteLength);\n\treturn this;\n}", "public final ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tputByteArray(byteArrayValue, byteOffset, byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length - byteOffset < byteLength){\n\t\tbyteArrayValue = new byte[byteLength];\n\t}\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteArrayValue, byteOffset, byteLength);\n\t\n\treturn this;\n}"]}
{"_id": "636767021a6d9265ec0178b2", "generate_results": ["Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n    final int index = descriptor.indexOf(':');\n    if(index!= -1) {\n        final String value = descriptor.substring(index + 1);\n        final String[] values = value.split(\",\");\n        if(values.length > 1) {\n            set(values[0], values[1]);\n        }\n    }\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tchar character = descriptor.charAt(0);\n\tif(character == 'a'){\n\t\tthis.char = 'a';\n\t}\n\telse if(character == 'b'){\n\t\tthis.char = 'b';\n\t}\n\telse if(character == 'c'){\n\t\tthis.char = 'c';\n\t}\n\telse if(character == 'd'){\n\t\tthis.char = 'd';\n\t}\n\telse if(character == 'e'){\n\t\tthis.char = 'e';\n\t}\n\telse if(character == 'f'){\n\t\tthis.char = 'f';\n\t}\n\telse if(character == 'g'){\n\t\tthis.char = 'g';\n\t}\n\telse if(character == 'h'){\n\t\tthis.char = 'h';\n\t}\n\telse if(character == 'i'){\n\t\tthis.char = 'i';\n\t}\n\telse if(character == 'j'){\n\t\tthis.char = 'j';\n\t}\n\telse if(character == 'k'){\n\t\tthis.char = 'k';\n\t}\n\telse if(character == 'l'){\n\t\tthis.char = 'l';\n\t}\n\telse if(character =='m'){\n\t\tthis.char ='m';\n\t}\n\telse if(character == 'n'){\n\t\tthis.char = 'n';\n\t}\n\telse if(character == 'o'){\n\t\tthis.char = 'o';\n\t}\n\telse if(character == 'p'){\n\t\tthis.char = 'p';\n\t}\n\telse if(character == 'q'){\n\t\tthis.char = 'q';\n\t}\n\telse if(character == 'r'){\n\t\tthis.char = 'r';\n\t}\n\telse if(character =='s'){\n\t\tthis.char ='s';\n\t}\n\telse if(character == 't'){\n\t\tthis.char = 't';\n\t}\n\telse if(character == 'u'){\n\t\tthis.char = 'u';\n\t}\n\telse if(character == 'v'){\n\t\tthis.char = 'v';\n\t}\n\telse if(character == 'w'){\n\t\tthis.char = 'w';\n\t}\n\telse if(character == 'x'){\n\t\tthis.char = 'x';\n\t}\n\telse if(character == 'y'){\n\t\tthis.char = 'y';\n\t}\n\telse if(character == 'z'){\n\t\tthis.char = 'z';\n\t}\n\telse if(character == '0'){\n\t\tthis.char = '0';\n\t}\n\telse if(character == '1'){\n\t\tthis.char = '1';\n\t}\n\telse if(character == '2'){\n\t\tthis.char = '2';\n\t}\n\telse if(character == '3'){\n\t\tthis.char = '3';\n\t}\n\telse if(character == '4'){\n\t\tthis.char = '4';\n\t}\n\telse if(character == '5'){\n\t\tthis.char = '5';\n\t}\n\telse if(character == '6'){\n\t\tthis.char = '6';\n\t}\n\telse if(character == '7'){\n\t\tthis.char = '7';\n\t}\n\telse if(character == '8'){\n\t\tthis.char = '8';\n\t}\n\telse if(character == '9'){\n\t\tthis.char = '9';\n\t}\n\telse if(character == '.') {\n\t\tthis.char = '.';\n\t}\n\telse if(character =='') {\n\t\tthis.char ='';\n\t}\n\telse {\n\t\tthis.char = character;\n\t}\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tfinal int first = descriptor.charAt(0);\n\tswitch(first){\n\tcase 'M':\n\tcase'm':\n\t\tm = parseMilliseconds(descriptor);\n\t\tbreak;\n\tcase 'S':\n\tcase's':\n\t\ts = parseSeconds(descriptor);\n\t\tbreak;\n\tcase 'H':\n\tcase 'h':\n\t\th = parseHours(descriptor);\n\t\tbreak;\n\tcase 'D':\n\tcase 'd':\n\t\td = parseDays(descriptor);\n\t\tbreak;\n\tcase 'W':\n\tcase 'w':\n\t\tw = parseWeeks(descriptor);\n\t\tbreak;\n\tcase 'M':\n\tcase'm':\n\t\tm = parseMinutes(descriptor);\n\t\tbreak;\n\tcase 'S':\n\tcase's':\n\t\ts = parseSeconds(descriptor);\n\t\tbreak;\n\tcase 'A':\n\tcase 'a':\n\t\ta = parseAMPM(descriptor);\n\t\tbreak;\n\tcase 'H':\n\tcase 'h':\n\t\th = parseHours(descriptor);\n\t\tbreak;\n\tcase 'D':\n\tcase 'd':\n\t\td = parseDays(descriptor);\n\t\tbreak;\n\tcase 'W':\n\tcase 'w':\n\t\tw = parseWeeks(descriptor);\n\t\tbreak;\n\tcase 'M':\n\tcase'm':\n\t\tm = parseMinutes(descriptor);\n\t\tbreak;\n\tcase 'S':\n\tcase's':\n\t\ts = parseSeconds(descriptor);\n\t\tbreak;\n\tcase 'A':\n\tcase 'a':\n\t\ta = parseAMPM(descriptor);\n\t\tbreak;\n\tcase 'H':\n\tcase 'h':\n\t\th = parseHours(descriptor);\n\t\tbreak;\n\tcase 'D':\n\tcase 'd':\n\t\td = parseDays(descriptor);\n\t\tbreak;\n\tcase 'W':\n\tcase 'w':\n\t\tw = parseWeeks(descriptor);\n\t\tbreak;\n\tdefault:\n\t\tthrow new IllegalStateException(\"Unrecognized descriptor: \" + descriptor);\n\t}\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n    if(descriptor.length() == 1){\n        this.value = Character.toUpperCase(descriptor.charAt(0));\n    } else {\n        this.value = Character.toLowerCase(descriptor.charAt(0));\n    }\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n    switch(descriptor.charAt(0)){\n    case 'H':\n        push(Hex);\n        break;\n    case 'B':\n        push(Binary);\n        break;\n    case 'L':\n        push(Long);\n        break;\n    case 'F':\n        push(Float);\n        break;\n    case 'D':\n        push(Double);\n        break;\n    case 'c':\n        push(String);\n        break;\n    case 't':\n        push(String);\n        break;\n    default:\n        throw new InternalError(\"Unsupported descriptor character: \" + descriptor);\n    }\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tif(descriptor.charAt(0) == '$'){\n\t\tString firstChar = descriptor.substring(1);\n\t\tString[] values = firstChar.split(\"=\");\n\t\tString var = values[0];\n\t\tString value = values[1];\n\n\t\tif(var.equals(\"\")){\n\t\t\tvalue = \"1\";\n\t\t}else{\n\t\t\tvalue = value + \"=\" + var;\n\t\t}\n\n\t\tthis.value = value;\n\t}else{\n\t\tthis.value = descriptor;\n\t}\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n    final String desc = descriptor.substring(descriptor.length() - 1);\n    this.descriptor = desc;\n    if(descriptor.equals(\"\")){\n        this.descriptor = null;\n    }else{\n        this.descriptor = desc;\n    }\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\t\n\tif(descriptor.length() == 0){\n\t\treturn;\n\t}\n\t\n\tfinal char firstChar = descriptor.charAt(0);\n\t\n\tif(firstChar == '\\0'){\n\t\treturn;\n\t}\n\n\tint i = 0;\n\t\n\twhile(i < descriptor.length()){\n\t\t\n\t\tif(Character.isWhitespace(descriptor.charAt(i))){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ti++;\n\t}\n\t\n\tif(i == 0){\n\t\treturn;\n\t}\n\t\n\tfinal String value = descriptor.substring(i);\n\t\n\tif(value.length() == 0){\n\t\treturn;\n\t}\n\t\n\tfinal String[] valueList = {value};\n\t\n\tpop(valueList);\n}", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tswitch(descriptor){\n\t\tcase \"0\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"1\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"2\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"3\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"4\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"5\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"6\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"7\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"8\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"9\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"+\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"-\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"=\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"|\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"~\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"&\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"|^\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"^\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"^?\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"^@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"^@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@^\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@^?\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@^@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@^@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@*\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@@@@@@@@@@@*@\":\n\t\t\tpop();\n\t\t\tbreak;\n\t\tcase \"@+@@@", "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tif(descriptor.length() == 0){\n\t\t// if the descriptor is empty, pop the value\n\t\tvalues[0] = values[0].substring(1);\n\t} else {\n\t\t// otherwise, pop to the end of the descriptor\n\t\tvalues[0] = values[0].substring(0, descriptor.length());\n\t}\n}"]}
{"_id": "636766fa1a6d9265ec0177a9", "generate_results": ["Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n\tif(initializedTypeMap.containsKey(abstractType)){\n\t\treturn;\n\t}\n\tfinal int last = initializedTypeMap.size()-1;\n\tinitializedTypeMap.put(abstractType, last);\n\tfor(int j=last-1;j>=0;j--){\n\t\tif(initializedTypeMap.get(abstractType)>j){\n\t\t\tinitializedTypeMap.put(abstractType, j);\n\t\t}\n\t}\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n\tinitializedTypes.add(abstractType);\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    final int initializer = getInitializer();\n    if (initializer == 0) {\n        throw new AssertionError(abstractType + \" is not initialized\");\n    }\n    setInitializer(initializer - 1);\n    getInitializer()[0] = abstractType;\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    if(abstractType == I_TYPE)\n        initializedTypes.add(I_TYPE);\n    else if(abstractType == J_TYPE)\n        initializedTypes.add(J_TYPE);\n    else if(abstractType == K_TYPE)\n        initializedTypes.add(K_TYPE);\n    else if(abstractType == L_TYPE)\n        initializedTypes.add(L_TYPE);\n    else if(abstractType == M_TYPE)\n        initializedTypes.add(M_TYPE);\n    else if(abstractType == N_TYPE)\n        initializedTypes.add(N_TYPE);\n    else if(abstractType == O_TYPE)\n        initializedTypes.add(O_TYPE);\n    else if(abstractType == P_TYPE)\n        initializedTypes.add(P_TYPE);\n    else if(abstractType == Q_TYPE)\n        initializedTypes.add(Q_TYPE);\n    else if(abstractType == R_TYPE)\n        initializedTypes.add(R_TYPE);\n    else if(abstractType == S_TYPE)\n        initializedTypes.add(S_TYPE);\n    else if(abstractType == T_TYPE)\n        initializedTypes.add(T_TYPE);\n    else if(abstractType == U_TYPE)\n        initializedTypes.add(U_TYPE);\n    else if(abstractType == V_TYPE)\n        initializedTypes.add(V_TYPE);\n    else if(abstractType == W_TYPE)\n        initializedTypes.add(W_TYPE);\n    else if(abstractType == X_TYPE)\n        initializedTypes.add(X_TYPE);\n    else if(abstractType == Y_TYPE)\n        initializedTypes.add(Y_TYPE);\n    else if(abstractType == Z_TYPE)\n        initializedTypes.add(Z_TYPE);\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    //check if the abstract type has been initialized yet\n    if(initializedTypes.get(abstractType) == null){\n        initializedTypes.put(abstractType, true);\n        \n        //add the abstract type to the list of types to be initialized\n        typesToBeInitialized.add(abstractType);\n    }\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    type.init(abstractType);\n    this.initializedTypes.add(abstractType);\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    if(initializedTypes.size() > 0){\n        int i = 0;\n        while(i < initializedTypes.size() && initializedTypes.get(i) == abstractType){\n            i++;\n        }\n        if(i > 0){\n            initializedTypes.remove(i);\n        }\n    }\n    initializedTypes.add(abstractType);\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n        if(abstractType == 0){\n            for(int i = 0; i < super.getNumInitializations(); i++){\n                final int type = super.getInitialization(i).getAbstractType();\n                if(type == abstractType){\n                    return;\n                }\n            }\n        }else{\n            for(int i = 0; i < super.getNumInitializations(); i++){\n                final int type = super.getInitialization(i).getAbstractType();\n                if(type == abstractType){\n                    return;\n                }\n            }\n        }\n        super.addInitialization(new Initialization(abstractType));\n    }", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n\tif(initializedType == -1){\n\t\tinitializedType = abstractType;\n\t}else{\n\t\tif(initializedType == abstractType){\n\t\t\tabstractType = -1;\n\t\t}else{\n\t\t\tabstractType = -2;\n\t\t}\n\t}\n}", "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n    if (initializedTypes == null) {\n      initializedTypes = new HashSet<>();\n    }\n    initializedTypes.add(abstractType);\n  }"]}
{"_id": "6367670a1a6d9265ec0179dc", "generate_results": ["Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfor(int i=start; i<=end; i++){\n\t\tfinal AbstractType type=m_types.get(i);\n\t\tif(type!= null){\n\t\t\t//System.out.println(type.getClass().getName());\n\t\t\ttype.put(this);\n\t\t}\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\t\n\tfinal int frame = start;\n\tfinal int length = end - start;\n\t\n\t//The last element is the size of the array.\n\tint firstElement = length;\n\t\n\t//If the frame is -1, then the frame is always 0.\n\tif(frame == -1){\n\t\tfirstElement = 0;\n\t}\n\t\n\t//The first element is the size of the array.\n\tfinal int firstElementSize = firstElement;\n\t\n\t//The size of the array.\n\tfinal int size = length;\n\t\n\t//The last element is the value of the first element.\n\tfinal int lastElement = firstElementSize;\n\t\n\t//If the frame is 0, then the frame is always 0.\n\tif(frame == 0){\n\t\tlastElement = 0;\n\t}\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElement;\n\t\n\t//The size of the array.\n\tfinal int arraySize = size;\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array2 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array3 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array4 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\tint currentElement = 0;\n\t\n\t//The array.\n\tfinal int[] array5 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array6 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array7 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array8 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array9 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array10 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array11 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array12 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array13 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array14 = new int[arraySize];\n\t\n\t//The last element is the value of the last element.\n\tfinal int lastElementSize = lastElementSize;\n\t\n\t//The array.\n\tfinal int[] array15 = new int[arraySize];", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n    try{\n        for(int i=start;i<end;i++){\n            final Object type=getType(i);\n            if(type == null)\n                continue;\n            putType(i,type);\n        }\n    }catch(final NullPointerException npe){\n        // ignore\n    }\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfinal int endOfFrame = end;\n\tfinal int arrayStart = start;\n\tfinal int arrayEnd = endOfFrame;\n\tfinal int elementCount = arrayEnd - arrayStart;\n\t\n\t//If the end is beyond the end of the array, then set the end to the end of the array.\n\tif(endOfFrame > elementCount){\n\t\tendOfFrame = elementCount;\n\t}\n\t\n\t//If the end is beyond the start of the array, then set the start to the end of the array.\n\tif(start > arrayStart){\n\t\tstart = arrayEnd;\n\t}\n\t\n\t//If the start is beyond the end of the array, then set the end to the end of the array.\n\tif(start < arrayStart){\n\t\tstart = arrayEnd;\n\t}\n\t\n\t//Create an array of the size of the end of the array as well as the start of the array.\n\tint[] array = new int[2*elementCount];\n\t\n\t//Fill the array with start and end of array.\n\tfor(int i=0;i<elementCount;i++){\n\t\tarray[i*2] = arrayStart;\n\t\tarray[i*2+1] = start;\n\t}\n\t\n\t//Put the array into frame.\n\tcurrentFrame.putIntArray(array);\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfinal int size = end - start;\n\t\n\tfor(int i=0;i<size;i++){\n\t\tfinal AbstractType t = (AbstractType)this.types.get(start+i);\n\t\tif(t!= null){\n\t\t\tthis.types.put(start+i,t);\n\t\t}\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tif(start>=end){\n\t\treturn;\n\t}\n\tint i = start;\n\twhile(i<end){\n\t\tputType(i);\n\t\ti++;\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tint i=start;\n\twhile (i<end){\n\t\tAbstractType type=getAbstractType(i);\n\t\tif (type!=null &&!type.isAbstract()){\n\t\t\tputAbstractType(i,type);\n\t\t}\n\t\ti++;\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfinal int n = end - start;\n\tfinal int start2 = start + 1;\n\tfinal int end2 = end - 1;\n\t\n\t// copy content from start to end\n\tfor(int i = start; i < end; i++){\n\t\tputAbstractType(i, i+1);\n\t}\n\t\n\t// copy content from start2 to end2\n\tfor(int i = start2; i < end2; i++){\n\t\tputAbstractType(i, i+1);\n\t}\n\t\n\t// copy content from end2 to end\n\tfor(int i = end2; i >= end; i--){\n\t\tputAbstractType(i, i+1);\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tif (start == end) return;\n\tfinal AbstractType type = this.typeAt(start);\n\tfinal Iterator<AbstractType> iter = this.iteratorAt(start);\n\twhile (iter.hasNext()){\n\t\titer.next();\n\t\titer.remove();\n\t}\n\tfinal int count = end - start;\n\tfor (int i = 0; i < count; i++){\n\t\tfinal AbstractType type2 = this.typeAt(start + i);\n\t\tthis.add(type2);\n\t}\n}", "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfinal int startFrame = start / AbstractType.SIZE;\n\tfinal int endFrame = end / AbstractType.SIZE;\n\tfinal int start = startFrame * AbstractType.SIZE;\n\tfinal int end = endFrame * AbstractType.SIZE;\n\tfinal int startIndex = startFrame * AbstractType.SIZE;\n\tfinal int endIndex = endFrame * AbstractType.SIZE;\n\tfor(int i = start;i < end;i++){\n\t\tfinal AbstractType type = AbstractType.getType(i);\n\t\tputType(type.getBaseType(), i);\n\t\tputType(type.getType(), i);\n\t\tputType(type.getTypeIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t}\n\t\n\tfor(int i = startIndex;i < endIndex;i++){\n\t\tfinal AbstractType type = AbstractType.getType(i);\n\t\tputType(type.getBaseType(), i);\n\t\tputType(type.getType(), i);\n\t\tputType(type.getTypeIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t\tputType(type.getTypeIndexIndex(), i);\n\t}\n}"]}
{"_id": "636766f21a6d9265ec017667", "generate_results": ["public short readShort(final int offset){\n\treturn ((short)getShort(offset));\n}", "public short readShort(final int offset){\n\tshort value = 0;\n\t\n\tif(classFileBuffer.length - offset < 2){\n\t\treturn value;\n\t}\n\t\n\tfinal byte[] tmp = classFileBuffer;\n\tfinal byte b = tmp[offset];\n\tvalue = (short)((b & 0x00FF) << 8 | (b & 0xFF00) >>> 8);\n\t\n\treturn value;\n}", "public short readShort(final int offset){\n  final int start = offset;\n  \n  final int len = readInt(offset);\n  if(len<0){\n    throw new EOFException(\"Unexpected end of file\");\n  }\n  \n  offset += len;\n  \n  if(offset<start){\n    offset = start;\n    return 0;\n  }\n  \n  final int i = offset;\n  final int v = readInt(i);\n  \n  offset += 4;\n  return (short)v;\n}", "public short readShort(final int offset){\n\treturn (short)readInt(offset);\n}", "public short readShort(final int offset){\n    return (short) classFileBuffer.readShort(offset);\n}", "public short readShort(final int offset){\n\treturn (short) readUnsignedShort(offset);\n}", "public short readShort(final int offset){\n\tif (classFileBuffer[offset] == 0)\n\t\tthrow new IOException(\"unexpected end of file at offset \" + offset);\n\treturn (short) (classFileBuffer[offset] & 0xFF);\n}", "public short readShort(final int offset){\n\treturn (short)(getShort(offset) & 0xffff);\n}", "public short readShort(final int offset){\n\tfinal byte[] buffer = classFileBuffer;\n\treturn short(buffer, offset);\n}", "public short readShort(final int offset){\n    short retval = 0;\n    try{\n        retval = (short) (read(offset, 2) & 0xFF);\n    "]}
{"_id": "636766ff1a6d9265ec017853", "generate_results": ["Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n    if (labels[bytecodeOffset] == null) {\n        labels[bytecodeOffset] = new Label();\n    }\n    return labels[bytecodeOffset];\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n    if(labels[bytecodeOffset]!=null)\n        return labels[bytecodeOffset];\n\n    final int target = readInt(bytecodeOffset);\n    final Label start = new Label();\n    labels[bytecodeOffset] = start;\n    final Label end = new Label();\n    final int frameIndex = bytecodeOffset - start.getOffset();\n    if(frameIndex>=0)\n        readFrame(frameIndex,labels);\n    // read frame\n    switch(bytecodeOffset){\n      case ByteVector.LOOKUPSWITCH_INSN:\n      case ByteVector.LOOKUPSWITCH_LAST_INSN:\n        readElement(bytecodeOffset);\n        readElement(bytecodeOffset);\n        break;\n      case ByteVector.COND_SWITCH_INSN:\n      case ByteVector.COND_SWITCH_LAST_INSN:\n        readElement(bytecodeOffset);\n        readElement(bytecodeOffset);\n        break;\n      case ByteVector.GOTO_W:\n      case ByteVector.GOTO_W_AJ:\n        readElement(bytecodeOffset);\n        break;\n      case ByteVector.JSR_W:\n      case ByteVector.JSR_W_AJ:\n        readElement(bytecodeOffset);\n        break;\n      case ByteVector.RET_W:\n      case ByteVector.RET_W_AJ:\n        readElement(bytecodeOffset);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown opcode: \"+bytecodeOffset+\" at \"+print());\n    }\n    return start;\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n    switch(bytecodeOffset){\n      case ByteCodes.LDC:\n      case ByteCodes.ALOAD:\n      case ByteCodes.ISTORE:\n      case ByteCodes.ISTORE_0:\n      case ByteCodes.ISTORE_1:\n      case ByteCodes.ISTORE_2:\n      case ByteCodes.ISTORE_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.LDIV:\n      case ByteCodes.LDIV_0:\n      case ByteCodes.LDIV_1:\n      case ByteCodes.LDIV_2:\n      case ByteCodes.LDIV_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.LCMP:\n      case ByteCodes.LCMP_0:\n      case ByteCodes.LCMP_1:\n      case ByteCodes.LCMP_2:\n      case ByteCodes.LCMP_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.LDC_W:\n      case ByteCodes.LDC2_W:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.LLOAD:\n      case ByteCodes.LLOAD_0:\n      case ByteCodes.LLOAD_1:\n      case ByteCodes.LLOAD_2:\n      case ByteCodes.LLOAD_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.LSTORE:\n      case ByteCodes.LSTORE_0:\n      case ByteCodes.LSTORE_1:\n      case ByteCodes.LSTORE_2:\n      case ByteCodes.LSTORE_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.RET:\n        return labels[bytecodeOffset];\n      case ByteCodes.RETURN:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.RETURN_W:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.RETURN_A:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.RETURN_N:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.RETURN_P:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.SALOAD:\n      case ByteCodes.SALOAD_0:\n      case ByteCodes.SALOAD_1:\n      case ByteCodes.SALOAD_2:\n      case ByteCodes.SALOAD_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.SASTORE:\n      case ByteCodes.SASTORE_0:\n      case ByteCodes.SASTORE_1:\n      case ByteCodes.SASTORE_2:\n      case ByteCodes.SASTORE_3:\n        labels[bytecodeOffset] = labels[bytecodeOffset].getNext();\n        return labels[bytecodeOffset];\n      case ByteCodes.SALOAD_W:\n      case ByteCodes.SALOAD_0_W:\n      case ByteCodes.SALOAD_1_W:\n      case ByteCodes.SALOAD_2_W:\n      case ByteCodes.SALOAD", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n    if(labels[bytecodeOffset]==null)\n        labels[bytecodeOffset] = new Label();\n    return labels[bytecodeOffset];\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset] = new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if (bytecodeOffset < labels.length) {\n    return labels[bytecodeOffset];\n  } else {\n    return new Label();\n  }\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if (_labelNames == null) return null;\n  Label result = _labelNames[findLabel(bytecodeOffset)];\n  if (result!= null) return result;\n  labels[findLabel(bytecodeOffset)] = new Label();\n  return labels[findLabel(bytecodeOffset)];\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n    Label label = labels[bytecodeOffset];\n    if(label == null) {\n       label = labels[bytecodeOffset] = new Label();\n    }\n    return label;\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if(bytecodeOffset == 0) return labels[0];\n  byte[] bytecode = new byte[1];\n  labelReader.read(bytecode,0,1);\n  if(bytecode[0]!= METHOD_LABEL)return labels[0];\n  labels[0] = newLabel();\n  newLabel().read(bytecode,1,1);\n  return labels[0];\n}", "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tLabel label = labels[bytecodeOffset];\n\tif(label == null){\n\t\tlabel = new Label(bytecodeOffset);\n\t\tlabels[bytecodeOffset] = label;\n\t}\n\treturn label;\n}"]}
{"_id": "636766fe1a6d9265ec01782a", "generate_results": ["Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\treturn readString(constantPoolEntryIndex,charBuffer);\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\tConstantPoolEntry entry = constantPoolEntryArray[constantPoolEntryIndex];\n\tif (entry.getUtf8Length() == 0)\n\t\treturn null;\n\telse{\n\t\tcharBuffer[0] = (char)entry.getUtf8Length();\n\t\treturn new String(charBuffer);\n\t}\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\tfinal int utfLength = readUnsignedShort(constantPoolEntryIndex+1);\n\tfinal int utfOffset = constantPoolEntryIndex+3;\n\tfinal int utfLength2 = readUnsignedShort(constantPoolEntryIndex+2);\n\tfinal int utfOffset2 = constantPoolEntryIndex+5;\n\tfinal int utfLength3 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset3 = constantPoolEntryIndex+7;\n\tfinal int utfLength4 = readUnsignedShort(constantPoolEntryIndex+2);\n\tfinal int utfOffset4 = constantPoolEntryIndex+9;\n\tfinal int utfLength5 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset5 = constantPoolEntryIndex+11;\n\tfinal int utfLength6 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset6 = constantPoolEntryIndex+13;\n\tfinal int utfLength7 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset7 = constantPoolEntryIndex+15;\n\tfinal int utfLength8 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset8 = constantPoolEntryIndex+17;\n\tfinal int utfLength9 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset9 = constantPoolEntryIndex+19;\n\tfinal int utfLength10 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset10 = constantPoolEntryIndex+21;\n\tfinal int utfLength11 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset11 = constantPoolEntryIndex+23;\n\tfinal int utfLength12 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset12 = constantPoolEntryIndex+25;\n\tfinal int utfLength13 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset13 = constantPoolEntryIndex+27;\n\tfinal int utfLength14 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset14 = constantPoolEntryIndex+29;\n\tfinal int utfLength15 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset15 = constantPoolEntryIndex+31;\n\tfinal int utfLength16 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset16 = constantPoolEntryIndex+33;\n\tfinal int utfLength17 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset17 = constantPoolEntryIndex+35;\n\tfinal int utfLength18 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset18 = constantPoolEntryIndex+37;\n\tfinal int utfLength19 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset19 = constantPoolEntryIndex+39;\n\tfinal int utfLength20 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset20 = constantPoolEntryIndex+41;\n\tfinal int utfLength21 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset21 = constantPoolEntryIndex+43;\n\tfinal int utfLength22 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset22 = constantPoolEntryIndex+45;\n\tfinal int utfLength23 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset23 = constantPoolEntryIndex+47;\n\tfinal int utfLength24 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset24 = constantPoolEntryIndex+49;\n\tfinal int utfLength25 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset25 = constantPoolEntryIndex+51;\n\tfinal int utfLength26 = readUnsignedShort(constantPoolEntryIndex+3);\n\tfinal int utfOffset26 = constantPoolEntryIndex+53;", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\tfinal int utfIndex = constantPoolEntryIndex + 1;\n\tfinal int utfLength = utfIndex - charBuffer.length;\n\tfinal int utfLengthInBytes = utfLength * 4;\n\tfinal char[] utfBytes = new char[utfLengthInBytes];\n\tfinal int utfIndexInBytes = 0;\n\tfinal int utfIndexInChars = utfIndex - charBuffer.length;\n\tfinal int utfIndexInCharsInBytes = utfIndexInChars * 4;\n\tSystem.arraycopy(charBuffer, charBuffer.length, utfBytes, 0, utfLengthInBytes);\n\tfinal int utfLengthInChars = utfLengthInBytes / 4;\n\tfinal int utfLengthInBytesInChars = utfLengthInChars * 4;\n\tfinal byte[] utfBytesInBytes = new byte[utfLengthInBytesInChars];\n\tfinal int utfIndexInCharsInBytes = 0;\n\tfinal int utfIndexInCharsInBytesInBytes = utfIndexInCharsInBytes * 4;\n\tfinal int utfIndexInCharsInBytesInBytes = utfIndexInCharsInBytes - utfIndexInCharsInBytesInBytes;\n\tfinal int utfLengthInCharsInBytes = utfLengthInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utfLengthInCharsInBytesInBytes = utfLengthInCharsInBytesInBytes / 4;\n\tfinal int utf", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n    return readUtf(constantPoolEntryIndex,charBuffer, 0);\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\tfinal int index = charBuffer.length-1;\n\tif(index >= constantPoolEntryIndex){\n\t\treturn null;\n\t}\n\tfinal int constantValueIndex = constantPoolEntryIndex+index;\n\tfinal int constantValueLength = constantPool[constantValueIndex];\n\tif(index == 0){\n\t\treturn Integer.toString(constantValueIndex);\n\t}\n\treturn readUtf(constantValueIndex,charBuffer,index);\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n        if (constantPoolEntryIndex == 0) {\n            charBuffer[0] = '\\0';\n        }else{\n            charBuffer[0] = charBuffer[constantPoolEntryIndex-1];\n        }\n        return new String(charBuffer);\n    }", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n    final int constantPoolIndex = constantPoolEntryIndex;\n    final int utfIndex = constantPoolIndex + 1;\n    final int utfCount = readUnsignedShort(utfIndex);\n\n    final int utfLength = readUnsignedShort(utfIndex + 2);\n    final char[] utfChars = new char[utfLength];\n\n    read(utfIndex + 4, utfChars, 0, utfLength);\n\n    return new String(charBuffer, 0, utfCount).replace(new String(utfChars), \"\");\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\treturn readUtf(constantPoolEntryIndex, charBuffer, 0);\n}", "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\tfinal int maxLength = 10;\n\tfinal int length = readUnsignedShort(constantPoolEntryIndex);\n\tfinal int start = readUnsignedShort(constantPoolEntryIndex + 2);\n\tfinal int end = start + length;\n\tfinal byte[] bytes = new byte[end - start];\n\tfinal int count = readBytes(start, bytes, 0, end - start);\n\tif (count < 0 || length < maxLength) throw new IllegalArgumentException();\n\tString result = new String(charBuffer, 0, count);\n\tresult = result.substring(0, result.length() - 1);\n\treturn result;\n}"]}
{"_id": "636766f81a6d9265ec017758", "generate_results": ["public int hashCode(){ return hashCode; }", "public int hashCode(){\n\treturn super.hashCode();\n}", "public int hashCode(){\n\treturn hash;\n}", "public int hashCode(){ return type.hashCode(); }", "public int hashCode(){\n\treturn hash;\n}", "public boolean equals(Object other){\n    if (other == null) return false;\n    if (other instanceof HashCode) return ((HashCode)other).hash == hash;\n    return other.hashCode() == hash;\n}", "public int hashCode(){ return type.hashCode(); }", "public int hashCode(){ return hash(this); }", "public int hashCode(){\n    int h = 0;\n    switch (getType()) {\n    case DOUBLE:\n        h = Double.hashCode(Double.doubleToLongBits(*this));\n        break;\n    case FLOAT:\n        h = Float.hashCode(Float.floatToIntBits(*this));\n        break;\n    case INT:\n        h = Integer.hashCode(*this);\n        break;\n    case LONG:\n        h = Long.hashCode(*this);\n        break;\n    case SHORT:\n        h = Short.hashCode(*this);\n        break;\n    case BYTE:\n        h = Byte.hashCode(*this);\n        break;\n    }\n    return h;\n}", "public int hashCode(){ return this.type"]}
{"_id": "636766fe1a6d9265ec017823", "generate_results": ["Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = pool.addConstantUTF(name, descriptor);\n\tfinal int tag = pool.addConstantTag(index);\n\treturn index;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = constantPool.getConstant(name, Tag.REF).index;\n\tindex = constantPool.addConstant(descriptor, Tag.REF, index);\n\treturn index;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n    int index = constantPool.addConstant(name, descriptor);\n    if (name.indexOf('<') >= 0) {\n        // we have a UTF string constant\n        index = constantPool.addUtfStringConstant(name, descriptor);\n    }\n    return index;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\t//\tstatic int constantPoolIndex = 0;\n\t//\tconstantPool[constantPoolIndex] = new Constant(name, descriptor);\n\t//\tconstantPoolIndex++;\n\t//\treturn constantPoolIndex;\n\treturn 0x2A;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n   // if the name is null, we are adding a constant pool entry.\n   if(name==null){\n      return addConstant(0);\n   }\n   // if the name is not null, we are adding a constant pool entry.\n   return addConstant(name.hashCode() ^ name.length());\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\t\n\tif(debug) System.out.println(\"addConstantNameAndType:\"+name+\" \"+descriptor);\n\t\n\tint index=-1;\n\t\n\t//Check if we have already added it\n\tindex=pool.getConstant(name,descriptor);\n\tif(index==-1){\n\t\t\n\t\t//Create a new constant for this name and type\n\t\tindex=pool.addConstant(name,descriptor);\n\t\t\n\t\t//Add it to the constant pool and return the index\n\t\tpool.putByte(index);\n\t\t\n\t}\n\t\n\treturn index;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\treturn _constantPool.addConstantNameAndType(name, descriptor);\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = currentIndex;\n\tindex = writer.addConstantUtf8(name, index);\n\tindex = writer.addConstantUtf8(descriptor, index);\n\treturn index;\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\treturn this.addConstant(ConstantNameAndType.get(name, descriptor));\n}", "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tConstantPoolGen cpg = constantPool();\n\tcpg.addUtf8(name);\n\tcpg.addUtf8(descriptor);\n\tint index = cpg.addConstantClass(descriptor);\n\treturn index;\n}"]}
{"_id": "636767131a6d9265ec017b23", "generate_results": ["Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tthis.lineNumber += lineNumber;\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tthis.lines.add(lineNumber);\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tthis.lineNumber++;\n\tthis.lineCount += lineNumber;\n\tthis.lineNumber = Math.min(this.lineNumber, this.lineCount);\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tif(lineNumber > 0){\n\t\tint lineNumberInt = lineNumber;\n\t\tif(lineNumberInt < 0){\n\t\t\tlineNumberInt += lineNumber;\n\t\t\tlineNumberInt -= lineNumber;\n\t\t}\n\t\tthis.lineNumber = lineNumberInt;\n\t}\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tlines.add(lineNumber);\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tthis.lineNumber += lineNumber;\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tfor(final int i=0; i<lineNumber; i++){\n\t\tlines.add(i);\n\t}\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tlines.add(lineNumber);\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tlines[lineNumber]++;\n\tlines[lineNumber] %= lines.length;\n}", "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tthis.lineNumber++;\n\tthis.lines.add(createLine(lineNumber));\n}"]}
{"_id": "636766f11a6d9265ec017658", "generate_results": ["public static int indexOfLastSeparator(String filename){\n   int index=0;\n   int len=filename.length();\n   if(len>0 && (filename.charAt(len-1)!='\\\\' || filename.charAt(len-2)!='\\\\')){\n      index=len-2;\n   }\n   return index;\n}", "public static int indexOfLastSeparator(String filename){\n\tint start = 0;\n\tint end = filename.length();\n\twhile(start < end){\n\t\tchar c = filename.charAt(end - start);\n\t\tif(c == '/' || c == '\\\\'){\n\t\t\tend--;\n\t\t}else if(c == '\\\\'){\n\t\t\tend--;\n\t\t}else if(c == ':'){\n\t\t\tend--;\n\t\t}else if(c == '.'){\n\t\t\tend--;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t\tstart = end;\n\t}\n\treturn start;\n}", "public static int indexOfLastSeparator(String filename){\n\tint pos=0;\n\tpos=indexOfLastSeparator(filename, pos);\n\tif(pos<0) pos=0;\n\treturn pos;\n}", "public static int indexOfLastSeparator(String filename){\n\t\n\tint index = filename.lastIndexOf(separator);\n\t\n\tif(index == -1)\n\t\tindex = filename.lastIndexOf(separator);\n\t\n\treturn index;\n}", "public static int indexOfLastSeparator(String filename){\n    char lastSep = filename.charAt(filename.length() - 1);\n    if (lastSep == '/' || lastSep == '\\\\')\n        return filename.length() - 1;\n    else\n        return -1;\n}", "public static int indexOfLastSeparator(String filename){\n    int index = filename.length()-1;\n    char lastChar = filename.charAt(index);\n\n    if (lastChar == '\\\\' || lastChar == '/')\n        index--;\n\n    return index;\n}", "public static int indexOfLastSeparator(String filename){\n\tint index = filename.lastIndexOf(File.separatorChar);\n\treturn index;\n}", "public static int indexOfLastSeparator(String filename){\n\tif(filename == null){\n\t\treturn -1;\n\t}\n\tint index = 0;\n\tfor(int i = 0; i < filename.length(); i++){\n\t\tif(filename.charAt(i) == '/'){\n\t\t\t// if there is a directory separator, i is set to the last\n\t\t\t// directory separator index, otherwise i is set to the\n\t\t\t// index of the last character.\n\t\t\tif(i == 0 || filename.charAt(i - 1) == '/'){\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn index;\n}", "public static int indexOfLastSeparator(String filename){\n    int i = 0;\n    int j = filename.length();\n    while (j > 0 && filename.charAt(j-1) == '/' && filename.charAt(j-2) == '/') j--;\n    \n    if (j > 0) return i;\n    return -1;\n}", "public static int indexOfLastSeparator(String filename){\n    if(filename.length() == 0){\n        return 0;\n    }\n    \n    int i = filename.length()-1;\n    while(i >= 0){\n        if(filename.charAt(i) == '\\\\'){\n            break;\n        }\n        i--;\n    }\n    \n    return i;\n}"]}
{"_id": "636766fe1a6d9265ec017833", "generate_results": ["public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file.isDirectory()) {\n\t\tFile[] files = file.listFiles();\n\t\tif (files!= null) {\n\t\t\tfor (File f : files) {\n\t\t\t\tforceDeleteOnExit(f);\n\t\t\t}\n\t\t}\n\t}\n\tfile.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file!= null) {\n      if (file.isDirectory()) {\n        for (File childFile : file.listFiles()) {\n          forceDeleteOnExit(childFile);\n        }\n      }\n      if (!file.delete()) {\n        throw new IOException(\"Failed to delete \" + file);\n      }\n    }\n  }", "public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file.isDirectory()) {\n\t\tFile[] list = file.listFiles();\n\t\tfor (File f: list) {\n\t\t\tforceDeleteOnExit(f);\n\t\t}\n\t}\n\tfile.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.exists()) {\n      forceDeleteOnExit(file);\n    } else {\n      throw new IOException(\"Cannot delete: \" + file);\n    }\n  }", "public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file.exists()) {\n\t\tFileUtils.forceDelete(file);\n\t}\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.isDirectory()) {\n      File[] children = file.listFiles();\n      if (children!= null) {\n        for (File child : children) {\n          forceDeleteOnExit(child);\n        }\n      }\n    }\n    file.delete();\n  }", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.exists()) {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files!= null) {\n                for (File file1 : files) {\n                    forceDeleteOnExit(file1);\n                }\n            }\n        }\n        file.delete();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file.exists()) {\n\t\tif (file.isDirectory()) {\n\t\t\tFile[] files = file.listFiles();\n\t\t\tfor (File f : files) {\n\t\t\t\tf.delete();\n\t\t\t}\n\t\t}\n\t\tfile.delete();\n\t}\n\tif (file.isFile()) {\n\t\tfile.delete();\n\t}\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.exists()) {\n      forceDelete(file);\n    }\n  }", "public static void forceDeleteOnExit(File file) throws IOException {\n    forceDelete(file.getAbsolutePath());\n}"]}
{"_id": "636767061a6d9265ec01794a", "generate_results": ["public static int indexOfExtension(String filename){\n    int lastIndex = -1;\n    for(int i=0;i<filename.length();i++){\n        if(filename.charAt(i)=='.'){\n            if(i==lastIndex) return -1;\n            else lastIndex = i;\n        }\n    }\n    return lastIndex;\n}", "public static int indexOfExtension(String filename){\n    if(filename == null || filename.length() == 0 || filename.charAt(filename.length()-1)!='.'){\n        return -1;\n    }\n    int index = 0;\n    while(index < filename.length() && filename.charAt(index)!='.'){\n        index++;\n    }\n    return index;\n}", "public static int indexOfExtension(String filename){\n\tif (filename!=null){\n\t\tint indexOf = filename.lastIndexOf(\".\");\n\t\tif (indexOf!= -1) {\n\t\t\treturn indexOf;\n\t\t}\n\t}\n\treturn -1;\n}", "public static int indexOfExtension(String filename){\n    int index=0;\n    String extension=filename.substring(filename.lastIndexOf(\".\"));\n    int lastIndex=extension.lastIndexOf(\".\");\n    if(lastIndex==-1)\n        return index;\n    else\n        return lastIndex;\n}", "public static int indexOfExtension(String filename){\n\tint lastIndexOfExtension = -1;\n\tint fileLength = filename.length();\n\tfor(int i=0;i<fileLength;i++){\n\t\tif(filename.charAt(i)=='.'){\n\t\t\tif(i>=fileLength-1){\n\t\t\t\treturn lastIndexOfExtension;\n\t\t\t}\n\t\t\tint indexOfExtension = i+1;\n\t\t\twhile(indexOfExtension<fileLength){\n\t\t\t\tif(filename.charAt(indexOfExtension)!='.'){\n\t\t\t\t\treturn indexOfExtension;\n\t\t\t\t}\n\t\t\t\tindexOfExtension++;\n\t\t\t}\n\t\t\tlastIndexOfExtension = indexOfExtension;\n\t\t}\n\t}\n\treturn lastIndexOfExtension;\n}", "public static int indexOfExtension(String filename){\n\tint start = 0;\n\tint end = 0;\n\tint length = filename.length();\n\t\n\twhile(end < length){\n\t\tif(filename.charAt(end) == '.'){\n\t\t\tstart = end + 1;\n\t\t\tbreak;\n\t\t}\n\t\tend++;\n\t}\n\t\n\tif(start == 0){\n\t\treturn -1;\n\t}\n\t\n\tend = start;\n\twhile(end < length){\n\t\tif(filename.charAt(end) == '.'){\n\t\t\tstart = end + 1;\n\t\t\tbreak;\n\t\t}\n\t\tend++;\n\t}\n\t\n\tif(start == 0){\n\t\treturn -1;\n\t}\n\t\n\tint index = end;\n\t\n\tString ext = filename.substring(index);\n\t\n\twhile(ext.length() > 0){\n\t\tif(ext.charAt(0) == '.'){\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t\text = ext.substring(1);\n\t}\n\t\n\treturn index;\n}", "public static int indexOfExtension(String filename){\n\tint iIndex = filename.lastIndexOf(File.separatorChar);\n\tif (iIndex == -1) return -1;\n\tiIndex++;\n\treturn iIndex;\n}", "public static int indexOfExtension(String filename){\n\tint index = indexOfExtension(filename,0);\n\treturn index;\n}", "public static int indexOfExtension(String filename){\n\tint index = -1;\n\tint start = 0;\n\tfor(int i=0;i<filename.length();i++){\n\t\tif(filename.charAt(i)==FileManager.FILE_SEPARATOR){\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif(filename.charAt(i)==FileManager.FILE_SEPARATOR_DOT){\n\t\t\tif(i==0){\n\t\t\t\tif(start>0){\n\t\t\t\t\tindex = start;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(start>1){\n\t\t\t\t\tindex = start;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(filename.charAt(i)==FileManager.FILE_SEPARATOR_DOT_ZERO){\n\t\t\tif(i==0){\n\t\t\t\tif(start>0){\n\t\t\t\t\tindex = start;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(start>1){\n\t\t\t\t\tindex = start;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(start>i){\n\t\t\t\tindex = start;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn index;\n}", "public static int indexOfExtension(String filename){\n\tint indexOfSeparator = indexOfExtension(filename, File.separator);\n\tif (indexOfSeparator == -1){\n\t\treturn -1;\n\t}\n\treturn indexOfSeparator;\n}"]}
{"_id": "6367670b1a6d9265ec0179fe", "generate_results": ["public void write(byte b[]) throws IOException {\n    if (b.length == 0) {\n      return;\n    }\n    out.write(b);\n  }", "public void write(byte b[]) throws IOException {\n    out.write(b);\n}", "public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n    out.write(b);\n}", "public void write(byte b[]) throws IOException {\n    out.write(b);\n}", "public void write(byte b[]) throws IOException {\n\toutput.write(b);\n}", "public void write(byte b[]) throws IOException {\n    out.write(b);\n}", "public void write(byte b[]) throws IOException {\n    output.write(b);\n}", "public void write(byte b[]) throws IOException {\n        out.write(b);\n    }", "public void write(byte b[]) throws IOException {\n    out.write(b);\n}"]}
{"_id": "636766f91a6d9265ec01776e", "generate_results": ["public void write(final byte b[],final int off,final int len) throws IOException {\n\t// Write all bytes\n\tsuper.write(b,off,len);\n\n\t// Write the length\n\tout.writeInt(len);\n\tout.writeInt(len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif(len<0) throw new IllegalArgumentException(\"len cannot be less than 0\");\n\tif(off<0) throw new IllegalArgumentException(\"off cannot be less than 0\");\n\tif(off+len>b.length) throw new IndexOutOfBoundsException();\n\tif(len==0) return;\n\tif(off>=b.length) {\n\t\tthrow new IndexOutOfBoundsException();\n\t}\n\tif(len==b.length-off) {\n\t\tSystem.arraycopy(b,off,b,off+len,b.length-off);\n\t} else {\n\t\tSystem.arraycopy(b,off,b,off,len);\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tfor (int i=0;i<len;i++) {\n\t\tthis.write(b[off+i]);\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tint i = off, j = 0;\n\twhile (i < off + len) {\n\t\tif (i >= arrlen) {\n\t\t\tarrlen = (i < arrlen + arrlen)? i : arrlen;\n\t\t}\n\t\tif (i >= arrlen) {\n\t\t\tbyte[] a = new byte[arrlen - i];\n\t\t\tSystem.arraycopy(arr,i,a,0,arrlen-i);\n\t\t\tarr = a;\n\t\t}\n\t\tarr[i++] = b[j++];\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif (closed) throw new IOException(\"closed\");\n\tif (b == null) throw new NullPointerException();\n\tif ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {\n\t\tthrow new IndexOutOfBoundsException();\n\t}\n\tif (len == 0) return;\n\tint from = off;\n\tint to = off + len;\n\twhile (from < to) {\n\t\tfinal byte b1 = b[from];\n\t\tfinal int bytes_done = write(b1);\n\t\tif (bytes_done == 0) // no bytes to write\n\t\t\tbreak;\n\t\tfrom += bytes_done;\n\t}\n\tbytesWritten += bytes_done;\n\tif (from < to) {\n\t\tfinal byte b2 = b[to];\n\t\tfinal int bytes_done = write(b2);\n\t\tif (bytes_done == 0) // no bytes to write\n\t\t\tthrow new EOFException();\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif(fReadOnly) {\n\t\tthrow new IllegalStateException(\"Read only\");\n\t}\n\tfStream.write(b,off,len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tthis.out.write(b,off,len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n    write(b, off, len, this.buffer.length);\n  }", "public void write(final byte b[],final int off,final int len) throws IOException {\n    if (len==0) return;\n    if (off+len>b.length) throw new IndexOutOfBoundsException();\n    System.arraycopy(b,off,this.buffer,this.bufferPos,len);\n    this.bufferPos+=len;\n    this.written+=len;\n  }", "public void write(final byte b[],final int off,final int len) throws IOException {\n    final int endoff=off+len;\n    if (endoff>this.pos) {\n      this.pos=endoff;\n      this.posInBytes=this.pos;\n    }\n    this.write(b,off,len);\n  }"]}
{"_id": "6367670a1a6d9265ec0179d8", "generate_results": ["public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n  }", "public void write(final byte[] b) throws IOException {\n    this.write(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(final byte[] b, final int offset, final int length) throws IOException {\n    if (length > this.buffer.length - this.position) {\n      this.write(this.buffer, 0, this.position);\n    }\n    this.buffer = Arrays.copyOf(this.buffer, this.position + length);\n    this.position += length;\n    Util.write(this.buffer, offset, b, 0, length);\n  }", "public void write(final byte[] b) throws IOException {\n        write(b, 0, b.length);\n    }", "public void write(final byte[] b) throws IOException {\n    write(b, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n  }", "public void write(final byte[] b) throws IOException {\n\tassert (this.buffer!= null);\n\tif (b.length == 0) return;   // nothing to do\n\tif (b.length > this.buffer.length) {\n\t\t// this.buffer = new byte[b.length+1];\n\t\tfinal byte[] tmp = new byte[b.length + 1];\n\t\tSystem.arraycopy(b, 0, tmp, 0, b.length);\n\t\tb = tmp;\n\t}\n\tthis.buffer = b;\n\tthis.pos = 0;\n\tsuper.write(b);\n}"]}
{"_id": "636767001a6d9265ec01787e", "generate_results": ["public String toString(){\n    return(StringBuffer.toString(this));\n}", "public String toString(){\n\treturn \"\";\n}", "public String toString(){\n\tString out=null;\n\tfor(int i=0;i<this.size();i++){\n\t\tout=this.get(i).toString();\n\t}\n\treturn out;\n}", "public String toString(){\n\treturn this.toString();\n}", "public String concatenate(String[] array, String separator, int start, int end, int startIndex, int endIndex){\n\tStringBuilder concatenation = new StringBuilder();\n\tfor(int i = start; i < end; i++){\n\t\tconcatenation.append(array[i]);\n\t\tif(i < array.length - 1){\n\t\t\tconcatenation.append(separator);\n\t\t}\n\t}\n\treturn concatenation.toString();\n}", "public String toString(){\n\tString r = \"\";\n\tchar c;\n\tfor (int i = 0; i < this.length(); i++){\n\t\tc = this.charAt(i);\n\t\tif (c == '\\\\'){\n\t\t\tr += \"\\\\\\\\\";\n\t\t}\n\t\telse if (c == '\\''){\n\t\t\tr += \"\\\\'\";\n\t\t}\n\t\telse if (c == '\\\"'){\n\t\t\tr += \"\\\\\\\"\";\n\t\t}\n\t\telse if (c == '\\n'){\n\t\t\tr += \"\\\\n\";\n\t\t}\n\t\telse if (c == '\\t'){\n\t\t\tr += \"\\\\t\";\n\t\t}\n\t\telse if (c == '\\b'){\n\t\t\tr += \"\\\\b\";\n\t\t}\n\t\telse if (c == '\\r'){\n\t\t\tr += \"\\\\r\";\n\t\t}\n\t\telse{\n\t\t\tr += c;\n\t\t}\n\t}\n\treturn r;\n}", "public String toString(){\n    return this.value;\n}", "public String toString(int offset, int length){\n\tString result = \"\";\n\tStringBuilder index = new StringBuilder();\n\tStringBuilder length = new StringBuilder();\n\tfor(int i = offset; i < length; i++){\n\t\tindex.append(this.get(i));\n\t\tlength.append(this.get(i + 1));\n\t}\n\tresult = index.toString() + length.toString() + this.get(length);\n\treturn result;\n}", "public String toString(){\n\treturn _builder.toString();\n}", "public String toString(){\n    StringBuilder sb = new StringBuilder();\n    sb.append(getClass().getSimpleName());\n    sb.append(\"[\");\n    sb.append(\"id=\");\n    sb.append(id);\n    sb.append(\", \");\n    sb.append(\"name=\");\n    sb.append(name);\n    sb.append(\", \");\n    sb.append(\"description=\");\n    sb.append(description);\n    sb.append(\"]\");\n    return sb.toString();\n}"]}
{"_id": "636767001a6d9265ec01787f", "generate_results": ["Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n        if (array == null) return;\n        int arrayStart = fieldName.lastIndexOf(\"[\");\n        int arrayEnd = fieldName.lastIndexOf(\"]\");\n        if (arrayStart < 0 || arrayEnd < 0 || arrayEnd < arrayStart) return;\n        int arrayStartIndex = fieldName.lastIndexOf(arraySeparator);\n        if (arrayStartIndex < 0) return;\n        \n        int arrayEndIndex = fieldName.indexOf(arraySeparator,arrayStartIndex+1);\n        if (arrayEndIndex < 0) return;\n        \n        int endIndex = fieldName.indexOf(arraySeparator,arrayEndIndex+1);\n        if (endIndex < 0) return;\n        \n        int startIndex = fieldName.indexOf(arraySeparator,(arrayStartIndex+1)+1);\n        if (startIndex < 0) return;\n        int length = array.length;\n        if (startIndex > endIndex) return;\n        \n        buffer.append(fieldName.substring(arrayStartIndex+1,arrayEndIndex));\n        for (int i=0;i<length;i++) {\n            appendDetail(buffer,fieldName.substring(arrayStartIndex+1,arrayEndIndex+1),array[i]);\n        }\n    }", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tif(array == null || array.length == 0)\n\t\treturn;\n\t\n\tif(array.length > 1)\n\t\tbuffer.append(arraySeparator);\n\t\n\tfor(int i = 0; i < array.length; i++)\n\t\tbuffer.append(array[i]);\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n        for(int i=arrayStart;i<arrayEnd;i++){\n            buffer.append(fieldName+arraySeparator+i);\n        }\n    }", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tString arraySeparator = \"\\r\\n\";\n\t\n\tif (array == null) {\n\t\tbuffer.append(\"null\");\n\t\treturn;\n\t}\n\t\n\tString string = null;\n\tint i = 0;\n\tfor (int j = 0; j < array.length; j++) {\n\t\tif (i == array.length - 1) {\n\t\t\tstring = fieldName + array[j];\n\t\t} else {\n\t\t\tstring = fieldName + array[j] + arraySeparator;\n\t\t}\n\t\ti++;\n\t}\n\t\n\tbuffer.append(string);\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tif (array == null) return;\n\tif (fieldName == null) return;\n\tbuffer.append(arraySeparator);\n\tfor (int i = 0; i < array.length; i++){\n\t\tappendDetail(buffer,fieldName+\"[\"+i+\"]\",array[i]);\n\t}\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tString fieldNameArray = fieldName.substring(0, fieldName.length() - 1);\n\tif(array==null){\n\t\tbuffer.append(fieldNameArray);\n\t}else{\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tbuffer.append(fieldNameArray);\n\t\t\tbuffer.append(array[i]);\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t}\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tbuffer.append(arraySeparator);\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t}\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tbuffer.append(fieldName+arraySeparator);\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]+arraySeparator);\n\t}\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tif (array == null){\n\t\treturn;\n\t}\n\tbuffer.append(arraySeparator);\n\tfor (int i=0;i<array.length;i++){\n\t\tbuffer.append(arraySeparator);\n\t\tbuffer.append(fieldName);\n\t\tbuffer.append(array[i]);\n\t\tbuffer.append(arraySeparator);\n\t}\t\n}", "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(arraySeparator);\n\tfor(int i = 0; i < array.length; i++){\n\t\tbuffer.append(array[i]);\n\t\tbuffer.append(arraySeparator);\n\t}\n}"]}
{"_id": "636766f71a6d9265ec017730", "generate_results": ["If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif (collection == null)\n\t\treturn EMPTY_STRING_ARRAY;\n\telse if (collection instanceof String[])\n\t\treturn (String[]) collection;\n\telse\n\t\treturn new String[0];\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null)\n\t\treturn EMPTY_STRING_ARRAY;\n\telse\n\t\treturn collection.toArray(new String[collection.size()]);\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif (collection == null) return EMPTY_STRING_ARRAY;\n\telse return collection.toArray(EMPTY_STRING_ARRAY);\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null) return EMPTY_STRING_ARRAY;\n\tif(collection instanceof String[]) return (String[])collection;\n\t\n\tString[] result = new String[collection.size()];\n\tfor(int i = 0; i < collection.size(); i++) {\n\t\tresult[i] = collection.toString(i);\n\t}\n\treturn result;\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null){\n\t\treturn new String[0];\n\t}\n\tif(collection instanceof String[]){\n\t\treturn (String[])collection;\n\t}\n\tif(collection instanceof Object[]){\n\t\treturn (String[])toNoNullStringArray((Object[])collection);\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null) return EMPTY_STRING_ARRAY;\n\t\n\tString[] array = new String[collection.size()];\n\tfor(int i=0;i<collection.size();i++){\n\t\tarray[i] = collection.get(i).toString();\n\t}\n\t\n\treturn array;\n}", "public static String[] toNoNullStringArray(Collection<?> collection){\n    if (collection == null) {\n        return null;\n    }\n    String[] array = new String[collection.size()];\n    int i = 0;\n    for (Object o : collection) {\n        if (o!= null) {\n            array[i++] = o.toString();\n        }\n    }\n    return array;\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null) {\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\tString[] stringArray = new String[collection.size()];\n\tint i = 0;\n\tfor(Object object : collection) {\n\t\tstringArray[i] = object.toString();\n\t\ti++;\n\t}\n\treturn stringArray;\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n    if(collection == null) return EMPTY_STRING_ARRAY;\n    else return new String[collection.size()];\n}", "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n\tif(collection == null) return new String[0];\n\treturn collection.toArray(new String[collection.size()]);\n}"]}
{"_id": "636767041a6d9265ec017911", "generate_results": ["Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null){\n        REGISTRY.register(value);\n    }\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n\tif(value == null){\n\t\tREGISTRY[0] = value;\n\t}\n\telse{\n\t\tREGISTRY[0] = value;\n\t\tfor(int i = 1; i < MAX_VALUE_COUNT; i++){\n\t\t\tREGISTRY[i] = null;\n\t\t}\n\t}\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value == null){\n        REGISTRY.put(value, value);\n    }\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null){\n        REGISTRY.push(value);\n    }\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n\tif(value!= null){\n\t\tregistry.register(value);\n\t}\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null)\n        REGISTRY.register(value);\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if (value!= null)\n        REGISTRY.register(value);\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n  if (value!= null) {\n    REGISTRY.register(value);\n  }\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null){\n        REGISTRY.register(value);\n    }\n}", "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if (value.getClass()==String){\n        REGISTRY.register(value.toString());\n    } else {\n        REGISTRY.register(value);\n    }\n}"]}
{"_id": "636766fe1a6d9265ec017821", "generate_results": ["Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tif(array!=null){\n\t\tbuffer.append(fieldName);\n\t\tbuffer.append(\"=\");\n\t\tbuffer.append(array);\n\t}else{\n\t\tbuffer.append(fieldName);\n\t\tbuffer.append(\" = \");\n\t}\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n    buffer.append(fieldName);\n    buffer.append(\" \");\n    buffer.append(array);\n    buffer.append(\"\\n\");\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append('=');\n\tbuffer.append(Arrays.toString(array));\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(DETECTOR_MEMORY_USAGE);\n\tbuffer.append(array.length);\n\tbuffer.append(DETECTOR_MEMORY_USAGE);\n\tbuffer.append(array.length);\n\tbuffer.append(DETECTOR_MEMORY_USAGE);\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(\"=\");\n\tbuffer.append(ByteUtil.toHex(array[0],array[1],array[2]));\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(array);\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tString tmp=new String(array);\n\ttmp=tmp.replace(\":\", \"\");\n\ttmp=tmp.replace(\"_\", \" \");\n\ttmp=tmp.replace(\"+\", \" \");\n\n\tbuffer.append(\"\\t\\t\"+fieldName+\" = \"+tmp);\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(\":\");\n\tbuffer.append(array);\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append('=');\n\tbuffer.append(new String(array));\n}", "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(\"=\");\n\tbuffer.append(new String(array));\n}"]}
{"_id": "636766fc1a6d9265ec0177ef", "generate_results": ["Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tint size = array.length;\n\tString[] result = new String[size];\n\tfor(int i = 0; i < size; i++){\n\t\tresult[i] = String.valueOf(array[i]);\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tif(array[i]!= null){\n\t\t\tresult[i] = (String)array[i];\n\t\t}\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif (array == null) {\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tif (array[i]!= null) {\n\t\t\tresult[i] = array[i].toString();\n\t\t}\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif (array == null) return null;\n\tString[] result = new String[array.length];\n\tint i = 0;\n\tfor (Object element: array) {\n\t\tif (element!= null) result[i++] = element.toString();\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif (array.length == 0) {\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < result.length; i++) {\n\t\tif (array[i]!= null) {\n\t\t\tresult[i] = array[i].toString();\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Attempted to convert an array of size \" + array.length + \" with a null element.\");\n\t\t}\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif(array.length == 0)\n\t\treturn new String[0];\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = array[i].toString();\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n    if(array.length == 0){\n        throw new IllegalArgumentException(\"The given array is empty.\");\n    }\n    String[] result = new String[array.length];\n    for(int i = 0;i < array.length;i++){\n        if(array[i]!= null){\n            result[i] = (String) array[i];\n        }\n    }\n    return result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif(array==null){\n\t\tthrow new IllegalArgumentException(\"array must not be null\");\n\t}\n\tString[] result = new String[array.length];\n\tint index = 0;\n\tfor(Object object:array){\n\t\tif(object!=null){\n\t\t\tresult[index++] = object.toString();\n\t\t}\n\t}\n\treturn result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n    if(array.length == 0)\n        return EMPTY_STRING_ARRAY;\n\n    String[] result = new String[array.length];\n    for(int i = 0; i < array.length; i++)\n        result[i] = toString(array[i]);\n\n    return result;\n}", "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tif(array==null)\n\t\treturn new String[0];\n\tString[] result = new String[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i] = toString(array[i]);\n\treturn result;\n}"]}
{"_id": "636766f11a6d9265ec017641", "generate_results": ["public int available() throws IOException {\n    if (length == 0) {\n      return 0;\n    } else {\n      return super.available() - index;\n    }\n  }", "public int available() throws IOException {\n    return super.available();\n}", "public int available() throws IOException {\n    return available(index);\n  }", "public int available() throws IOException {\n        return in.available();\n    }", "public int available() throws IOException {\n    return stream.available();\n}", "public int available() throws IOException {\n    return _stream.available();\n}", "public int available() throws IOException {\n\treturn stream.available();\n}", "public int available() throws IOException {\n    if (_index == -1) return 0;\n    return _buffer.available() / _index;\n}", "public synchronized void readAll() throws IOException {\n  if (index < 0) {\n    return;\n  }\n  byte[] b = new byte[available()];\n  int count = super.read(b);\n  if (count > 0) {\n    index = -1;\n  }\n}", "public int available() throws IOException {\n    return _data.available();\n}"]}
{"_id": "636766f01a6d9265ec017639", "generate_results": ["public static <T>List<T> asList(T[] a){\n\tif(a == null) return new ArrayList();\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n    return a == null? Collections.<T>emptyList() : Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tif(a==null) return Collections.emptyList();\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tif (a == null) return Collections.emptyList();\n\tList<T> list = new ArrayList<T>(a.length);\n\tfor (T t : a) list.add(t);\n\treturn list;\n}", "public static <T>List<T> asList(T[] a){\n    if (a == null){\n        return Collections.emptyList();\n    }\n    List<T> list = new ArrayList<T>(a.length);\n    for (int i = 0; i < a.length; i++){\n        list.add(a[i]);\n    }\n    return list;\n}", "public static <T>List<T> asList(T[] a){\n\tList<T> list = new ArrayList<T>();\n\tif(a == null) return list;\n\tfor(T t : a) list.add(t);\n\treturn list;\n}", "public static <T>List<T> asList(T[] a){\n\tif (a == null) return Collections.emptyList();\n\tList<T> list = new ArrayList<T>(a.length);\n\tfor (int i = 0; i < a.length; i++)\n\t\tlist.add(a[i]);\n\treturn list;\n}", "public static <T>List<T> asList(T[] a){\n\tif(a==null) return new ArrayList<>();\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){ return emptyList(); }", "public static <T>List<T> asList(T[] a){\n\tif(a == null) return emptyList();\n\tList<T> list = new ArrayList<T>();\n\tif(a.length == 0) return list;\n\tfor(int i = 0; i < a.length; i++) {\n\t\tlist.add(a[i]);\n\t}\n\treturn list;\n}"]}
{"_id": "636766f91a6d9265ec01777d", "generate_results": ["public static byte convertHexDigit(byte b){\n\tbyte r = 0;\n\tif(b >= '0' && b <= '9'){\n\t\tr = (byte)((b-'0') << 4);\n\t}\n\telse if(b >= 'A' && b <= 'F'){\n\t\tr = (byte)((b-'A') << 4);\n\t}\n\telse if(b >= 'a' && b <= 'f'){\n\t\tr = (byte)((b-'a') << 4);\n\t}\n\treturn r;\n}", "public static byte convertHexDigit(byte b){\n    return (byte) (b & 0xF0);\n}", "public static byte convertHexDigit(byte b){\n\treturn convertHexDigit((byte)(b - '0'));\n}", "public static byte convertHexDigit(byte b){\n\tif(b < '0') return (byte)(b + 0x30);\n\tif(b < 'a') return (byte)(b - 0x37);\n\treturn (byte)(b - 0x36);\n}", "public static byte convertHexDigit(byte b){\n    if (b >= '0' && b <= '9') return (byte)(b - '0');\n    if (b >= 'a' && b <= 'f') return (byte)(b - 'a' + 10);\n    if (b >= 'A' && b <= 'F') return (byte)(b - 'A' + 10);\n    return 0;\n}", "public static byte convertHexDigit(byte b){\n\treturn (byte)((b & 0xf0) >> 4);\n}", "public static byte convertHexDigit(byte b){\n    int ch = b & 0xF;\n    if(ch >= '0' && ch <= '9'){\n        return (byte)(ch - '0');\n    } else if(ch >= 'a' && ch <= 'f'){\n        return (byte)(ch - 'a' + 10);\n    } else{\n        return (byte)(ch - 'A' + 10);\n    }\n}", "public static byte convertHexDigit(byte b){\n\treturn (byte) (b - 0x30);\n}", "public static byte convertHexDigit(byte b){\n\tif (b >= '0' && b <= '9') return (byte)(b - '0');\n\tif (b >= 'A' && b <= 'F') return (byte)(b - 'A' + 10);\n\tif (b >= 'a' && b <= 'f') return (byte)(b - 'a' + 10);\n\tthrow new IllegalArgumentException(\"Invalid hex character \\\"\" + b + \"\\\"\");\n}", "public static byte convertHexDigit(byte b){\n        return (byte)((b & 0xF0) >> 4);\n    }"]}
{"_id": "6367670a1a6d9265ec0179e7", "generate_results": ["public Converter lookup(final Class<?> clazz){\n\tConverter converter = lookup(clazz, false);\n\tif(converter == null){\n\t\treturn null;\n\t}\n\treturn converter;\n}", "public Converter lookup(final Class<?> clazz){\n    return lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n\tif (clazz.isInterface()) {\n\t\treturn null;\n\t}\n\tfor (final Converter c : converters) {\n\t\tif (c.isConverter(clazz)) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n\treturn lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n    return (Converter) ConverterManager.lookup(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\tfor(final Converter converter : converters){\n\t\tif(converter.matches(clazz)){\n\t\t\treturn converter;\n\t\t}\n\t}\n\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n\tif(converters.containsKey(clazz)){\n\t\tConverter converter = converters.get(clazz);\n\t\treturn converter;\n\t}\n\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n    return converters.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\t//System.out.println(\"Looking for converter using: \"+clazz);\n\tConverter converter = null;\n\tfor(Converter c : converters){\n\t\tif(c.getClass().equals(clazz)){\n\t\t\tconverter = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn converter;\n}", "public Converter lookup(final Class<?> clazz){\n\tif(converters.containsKey(clazz)){\n\t\treturn converters.get(clazz);\n\t}\n\treturn null;\n}"]}
{"_id": "6367670b1a6d9265ec0179f2", "generate_results": ["public boolean containsKey(final Object key){\n\treturn Maps.containsKey(map, key);\n}", "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n  }", "public boolean containsKey(final Object key){return map.containsKey(key);}", "public boolean containsKey(final Object key){return map.containsKey(key);}", "public boolean containsKey(final Object key){ return m.containsKey(key); }", "public boolean containsKey(final Object key){ return super.containsKey(key); }", "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n}", "public boolean containsKey(final Object key){\n\treturn map.containsKey(key);\n}", "public boolean containsKey(final Object key){ return map.containsKey(key); }", "public boolean containsKey(final Object key){\n\treturn map.containsKey(key);\n}"]}
{"_id": "636767041a6d9265ec0178f8", "generate_results": ["Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\t// make a new string array\n\tfinal String[] newStr = new String[src.length];\n\tfor(int i = 0; i < src.length; i++){\n\t\tnewStr[i] = src[i];\n\t}\n\treturn newStr;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\tdst[i] = src[i];\n\t}\n\treturn dst;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor (int i = 0; i < src.length; i++) {\n\t\tdst[i] = src[i];\n\t}\n\treturn dst;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] tgt = new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\ttgt[i] = src[i].toLowerCase();\n\t}\n\treturn tgt;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] tmp = new String[src.length];\n\t\n\tfor(int i=0; i<src.length; ++i){\n\t\ttmp[i] = src[i];\n\t}\n\t\n\treturn tmp;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor (int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i];\n\t}\n\treturn dst;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n    String[] ret = new String[src.length];\n    for(int i = 0; i < src.length; i++){\n        ret[i] = src[i].toLowerCase();\n    }\n    return ret;\n}", "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n    String[] dst = new String[src.length];\n    for (int i = 0; i < src.length; i++) {\n        dst[i] = src[i].toLowerCase();\n    }\n    return dst;\n}"]}
{"_id": "636767021a6d9265ec0178bf", "generate_results": ["If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof String) {\n\t\treturn value;\n\t}\n\tif (value instanceof List) {\n\t\treturn ((List<?>)value).get(0);\n\t}\n\treturn value;\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) return null;\n\tif (value instanceof String) {\n\t\treturn value;\n\t}\n\treturn type.cast(value);\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\treturn value;\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value==null ||!(value instanceof String)) return super.convertToType(type,value);\n\tfinal String s = (String) value;\n\treturn s.substring(0,s.indexOf(\"|\"));\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n    if(value instanceof String){\n        return value;\n    }\n    return value;\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null)\n\t\treturn null;\n\t\n\tif (value instanceof String)\n\t\treturn value;\n\t\n\tif (value instanceof Number)\n\t\treturn value;\n\t\n\tif (value instanceof Long)\n\t\treturn value;\n\t\n\tif (value instanceof Integer)\n\t\treturn value;\n\t\n\tif (value instanceof Boolean)\n\t\treturn value;\n\t\n\tif (value instanceof Double)\n\t\treturn value;\n\t\n\tthrow new Exception(\"Cannot convert type \" + value.getClass().getName() + \" to object of type \" + type);\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (type.equals(String.class)) {\n\t\treturn value.toString();\n\t}\n\treturn value;\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif(value == null) return null;\n\tif(value instanceof String) {\n\t\treturn value;\n\t} else if(value instanceof Integer) {\n\t\treturn value.toString();\n\t} else if(value instanceof Long) {\n\t\treturn value.toString();\n\t} else if(value instanceof Float) {\n\t\treturn value.toString();\n\t} else if(value instanceof Double) {\n\t\treturn value.toString();\n\t} else if(value instanceof Boolean) {\n\t\treturn value.toString();\n\t} else if(value instanceof Character) {\n\t\treturn value.toString();\n\t} else if(value instanceof Enum) {\n\t\treturn value.toString();\n\t} else if(value instanceof Date) {\n\t\treturn value.toString();\n\t} else if(value instanceof Timestamp) {\n\t\treturn value.toString();\n\t} else if(value instanceof URL) {\n\t\treturn value.toString();\n\t} else if(value instanceof Byte) {\n\t\treturn value.toString();\n\t} else if(value instanceof Short) {\n\t\treturn value.toString();\n\t} else if(value instanceof BigDecimal) {\n\t\treturn value.toString();\n\t} else if(value instanceof BigInteger) {\n\t\treturn value.toString();\n\t} else if(value instanceof Locale) {\n\t\treturn value.toString();\n\t} else if(value instanceof EnumSet) {\n\t\treturn value.toString();\n\t} else if(value instanceof Enum) {\n\t\treturn value.toString();\n\t} else if(value instanceof EnumSet) {\n\t\treturn value.toString();\n\t} else if(value instanceof EnumMap) {\n\t\treturn value.toString();\n\t} else {\n\t\treturn value.toString();\n\t}\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n  if (value instanceof String) {\n    return value;\n  } else if (value instanceof Number) {\n    return value;\n  } else {\n    return value;\n  }\n}", "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value==null) return null;\n\telse if (value instanceof String) return value;\n\telse if (value instanceof Integer) return Integer.valueOf(((Integer)value).intValue());\n\telse if (value instanceof Long) return Long.valueOf(((Long)value).longValue());\n\telse if (value instanceof Float) return Float.valueOf(((Float)value).floatValue());\n\telse if (value instanceof Double) return Double.valueOf(((Double)value).doubleValue());\n\telse if (value instanceof BigDecimal) return new BigDecimal(((BigDecimal)value).toString());\n\telse if (value instanceof BigInteger) return new BigInteger(((BigInteger)value).toString());\n\telse if (value instanceof Boolean) return Boolean.valueOf(((Boolean)value).booleanValue());\n\telse return value;\n}"]}
{"_id": "636766f11a6d9265ec01764f", "generate_results": ["public Collection<Object> values(){\n    return Collections.unmodifiableList(beanMap.values());\n}", "public Collection<Object> values(){\n\treturn this.map.values();\n}", "public Collection<Object> values(){\n\treturn this.beanMap.values();\n}", "public Collection<Object> values(){\n\treturn _values;\n}", "public Collection<Object> values(){\n\treturn new ArrayList<Object>(beanMap.values());\n}", "public Collection<Object> values(){\n\treturn new ArrayList<Object>(this.values());\n}", "public Collection<Object> values(){\n    return Collections.unmodifiableCollection(methods.values());\n}", "public Collection<Object> values(){\n    return new ArrayList(getBeanMap().values());\n}", "public Collection<Object> values(){\n  return new ArrayList<Object>(this.methods());\n}", "public Collection<Object> values(){\n\treturn new ArrayList<Object>(methods);\n}"]}
{"_id": "636767071a6d9265ec017962", "generate_results": ["public void putAllWriteable(BeanMap map){\n    for(Map.Entry<String, Class<?>> entry : map.entrySet()){\n        this.putWriteable(entry.getKey(), entry.getValue());\n    }\n}", "public void putAllWriteable(BeanMap map){\n\tfor(Iterator itr = map.iterator(); itr.hasNext();){\n\t\tBean b = (Bean)itr.next();\n\t\tthis.putWriteable(b.getName(), b);\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tmap.putAllWriteable(this);\n}", "public void putAllWriteable(BeanMap map){\n\tmap.putAll(this);\n}", "public void putAllWriteable(BeanMap map){\n\tfor(Map.Entry<String,String> entry: map.entrySet()) {\n\t\tthis.put(entry.getKey(), entry.getValue());\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tif(map==null)return;\n\tfor(String key: map.keySet()){\n\t\ttry{\n\t\t\twriteable.write(map.get(key));\n\t\t}catch(IOException e){\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}", "public void putAllWriteable(BeanMap map) {\n    map.putAllWriteable(this);\n}", "public void putAllWriteable(BeanMap map){\n\tif(map!= null){\n\t\tmap.putAll(this);\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tmap.putAll(this);\n}", "public void putAllWriteable(BeanMap map){\n\tfor (Map.Entry<String, Class<?>> entry : map.entrySet()) {\n\t\tputWriteable(entry.getKey(), entry.getValue());\n\t}\n}"]}
{"_id": "636767031a6d9265ec0178dd", "generate_results": ["public long contentLength(){\n    if (contentLength == 0){\n        return 0;\n    }\n    return contentLength;\n}", "public long contentLength(){\n    try {\n        return Integer.parseInt(this.request.getHeader(\"Content-Length\"));\n    } catch (NumberFormatException e) {\n        return this.contentLength;\n    }\n}", "public long contentLength(){\n    String contentLength = null;\n    try {\n        contentLength = request.getContentLength();\n    } catch (NumberFormatException ex) {\n        return -1;\n    }\n    return Integer.parseInt(contentLength);\n}", "public long contentLength(){\n\tif(contentLength==-1){\n\t\ttry{\n\t\t\treturn Integer.parseInt(getHeader(\"Content-Length\"));\n\t\t}catch(NumberFormatException e){\n\t\t\tcontentLength = 0;\n\t\t}\n\t}\n\treturn contentLength;\n}", "public long contentLength(){\n  return request.getContentLength();\n}", "public long contentLength(){\n\tlong length;\n\ttry{\n\t\tlength = request.getContentLength();\n\t\tif(length == 0) length = -1;\n\t}catch(NumberFormatException ex){\n\t\tlength = -1;\n\t}\n\treturn length;\n}", "public long contentLength(){\n  try {\n    // getContentLength() is not implemented in Apache Tomcat, so we need to use the same method here\n    return getContentLength(getContentType());\n  } catch (NumberFormatException e) {\n    return -1;\n  }\n}", "public long contentLength(){\n\ttry{\n\t\tif(this.contentLength!= null){\n\t\t\treturn this.contentLength;\n\t\t}\n\t\treturn this.contentLength = this.getContentLength();\n\t}\n\tcatch(NumberFormatException e){\n\t\treturn 0;\n\t}\n}", "public long getContentLength() {\n    return contentLength();\n}", "public long contentLength(){\n\tif(contentLength == -1){\n\t\ttry{\n\t\t\tif(hasContentLength()){\n\t\t\t\treturn (long)getContentLength();\n\t\t\t}\n\t\t}\n\t\tcatch(NumberFormatException e){\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn contentLength;\n}"]}
{"_id": "636767121a6d9265ec017b0a", "generate_results": ["Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\t\n\tint index = -1;\n\tint lineEnd = -1;\n\t\n\twhile(headerPart.indexOf('\\n')!= -1){\n\t\t\n\t\tlineEnd = headerPart.indexOf('\\n');\n\t\t\n\t\tif(lineEnd == -1){\n\t\t\tlineEnd = headerPart.length();\n\t\t}\n\t\t\n\t\tif(lineEnd > end){\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\theaderPart = headerPart.substring(0, lineEnd);\n\t\t\n\t\tindex++;\n\t}\n\t\n\treturn index;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index=end;\n\tint position=0;\n\twhile(index<headerPart.length()){\n\t\tif(headerPart.charAt(index)=='\\n'){\n\t\t\tbreak;\n\t\t}\n\t\tposition++;\n\t\tindex++;\n\t}\n\treturn position;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tif( end == -1){\n\t\tend = headerPart.length() - 1;\n\t}\n\twhile(end>=0 && headerPart.charAt(end)=='>'){\n\t\tend--;\n\t}\n\treturn end;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index=headerPart.indexOf(end);\n\tif(index==-1){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn index;\n\t}\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint indexOfEndOfLine = headerPart.indexOf('\\n');\n\tif (indexOfEndOfLine == -1){\n\t\tindexOfEndOfLine = headerPart.length();\n\t}\n\treturn end+1;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint start=end;\n\tint last=0;\n\twhile(start<headerPart.length()){\n\t\tif(headerPart.charAt(start)=='\\n'){\n\t\t\tlast=start;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t\tstart++;\n\t}\n\t\n\treturn last;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index = 0;\n\tint indexStart=0;\n\tint indexEnd=0;\n\t\n\tif(headerPart.length()>end){\n\t\tindexStart = headerPart.length()-end;\n\t\tindexEnd=headerPart.length();\n\t}\n\telse{\n\t\tindexStart = end;\n\t\tindexEnd=end;\n\t}\n\t\n\treturn indexStart;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint start=end;\n\twhile(start<headerPart.length() && Character.isWhitespace(headerPart.charAt(start)))\n\t\tstart++;\n\treturn start;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint start=end;\n\tint startIndex=0;\n\tint index;\n\twhile(end-start>0 && headerPart.charAt(end-1)=='\\n')\n\t\tend--;\n\t\n\tindex=end-start;\n\tif(index>0 && headerPart.charAt(index-1)=='\\n')\n\t\tindex--;\n\t\n\treturn index;\n}", "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index = end;\n\tif(headerPart.length()>end){ \n\t\tif(headerPart.charAt(end)=='\\\\'){\n\t\t\tindex++;\n\t\t\twhile(headerPart.charAt(index)!='\\\\'){\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\telse\n\t\t\tindex++;\n\t}\n\treturn index;\n}"]}
{"_id": "636766ff1a6d9265ec017851", "generate_results": ["Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tif(pos>value.length){\n\t\treturn -1;\n\t}\n\tfor(int i=0;i<pos;i++){\n\t\tif(value==buf[i]){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tint r = pos;\n\twhile (((r < 0) || ((r >= (int)size)) || ((r >= (pos+1)) && ((r+1) < (int)size))) && (r >= 0)){\n\t\tif (value == (byte)0){\n\t\t\treturn r;\n\t\t}\n\t\tr--;\n\t}\n\treturn -1;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tif (pos<0) return -1;\n\tif (pos==0) return value;\n\tint i=pos-1;\n\twhile (i>=0) {\n\t\tif (data[i]==value) return i;\n\t\ti--;\n\t}\n\treturn -1;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tint i = pos;\n\twhile (i < buffer.length) {\n\t\tif (buffer[i] == value) {\n\t\t\treturn i;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\treturn 0;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tint valuePos=pos;\n\tint valueLen=0;\n\tint valueLen2=0;\n\tif(value==null){\n\t\treturn -1;\n\t}\n\twhile(valuePos<valueLen){\n\t\tvalueLen2=valueLen-valuePos;\n\t\tif(valueLen2<0){\n\t\t\treturn -1;\n\t\t}\n\t\tvalue=value.charAt(valuePos);\n\t\tvaluePos+=valueLen2;\n\t}\n\treturn valuePos;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tint i;\n\tfor(i=pos;i>=0;i--){\n\t\tif(buffer[i]==value){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\t// The byte value to compare.\n\tint b = value;\n\n\t// The position in the buffer where the byte to compare is.\n\tint pos1 = pos;\n\n\t// The buffer position from which to start looking for the byte.\n\tint pos2 = pos1 + 1;\n\n\t// The number of bytes in the buffer.\n\tint bytes = pos2 - pos1 + 1;\n\n\t// The position in the buffer where the byte to compare is.\n\tint pos1b = pos1;\n\n\t// The position in the buffer where the byte to compare is.\n\tint pos2b = pos2;\n\n\t// The buffer position from which to start looking for the byte.\n\tint pos1bb = pos1b;\n\n\t// The buffer position from which to start looking for the byte.\n\tint pos2bb = pos2b;\n\n\t// The number of bytes in the buffer.\n\tint bytesb = bytes;\n\n\t// The position in the buffer where the byte to compare is.\n\tint pos1b = pos1bb;\n\n\t// The position in the buffer where the byte to compare is.\n\tint pos2b = pos2bb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbb = bytesb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbb = bytesbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbb = bytesbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbb = bytesbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbb = bytesbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbb = bytesbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbb = bytesbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbb = bytesbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb = bytesbbbbbbbbb;\n\n\t// The number of bytes in the buffer.\n\tint bytesbbbbbbbbbbb =", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\treturn (pos < 0)? 0 : (pos >= len)? len-1 : pos;\n}", "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\n    if(pos < 0) return 0;\n    \n    while(pos >= 0)\n    {\n        if(buffer[pos] == value) return pos;\n        pos--;\n    }\n    \n    return -1;\n}"]}
{"_id": "636766f81a6d9265ec01774b", "generate_results": ["public char readChar() throws IOException {\n\tint ch = readByte();\n\tif ((ch & 0x80) == 0) {\n\t\treturn (char) ch;\n\t} else {\n\t\treturn (char) ((ch & 0x7F) | 0x80);\n\t}\n}", "public long readLineLong() throws IOException {\n\tlong i;\n\tchar c;\n\tlong n;\n\tStringBuffer sb = new StringBuffer();\n\n\tfor (i = 0; i < max; i++) {\n\t\tc = readByte();\n\t\tif (c == '\\n')\n\t\t\tbreak;\n\t\tsb.append(c);\n\t\tif (sb.length() > 0 && delimiter.equals(sb.toString()))\n\t\t\treturn Long.parseLong(sb.toString());\n\t}\n\n\treturn -1;\n}", "public byte readByte() throws IOException {\n\treturn read(new byte[1]);\n}", "public byte readByte() throws IOException {\n    if (buffer == null)\n      throw new IOException(\"buffer is null\");\n    return buffer[pos++];\n  }", "public byte readByte() throws IOException {\n    byte b = 0;\n    \n    if (this.pos >= this.limit) {\n        return b;\n    }\n    \n    b = this.buffer[this.pos++];\n    \n    return b;\n}", "public byte readByte() throws IOException {\n\tbyte b = 0;\n\tint i;\n\tfor (i=0; i<6; i++) {\n\t\tb = in.read();\n\t\tif (i==5) {\n\t\t\tb &= 0x7f;\n\t\t}\n\t\tif (b==0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (byte)b;\n}", "public byte readByte() throws IOException {\n\tbyte b = read();\n\treturn b;\n}", "public byte readByte() throws IOException {\n    return _byteBuffer.readByte();\n}", "public byte readByte() throws IOException {\n\tif (pos >= len)\n\t\tthrow new EOFException();\n\treturn (byte) ((buffer[pos++] & 0xFF) >> (8 - pos));\n}", "public byte readByte() throws IOException {\n\tbyte b = (byte)in.read();\n\treturn b;\n}"]}
{"_id": "636766fa1a6d9265ec01779c", "generate_results": ["Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tint index = 0;\n\tString token = \"\";\n\twhile(index < terminators.length){\n\t\tfinal char terminator = terminators[index];\n\t\tif(terminator == '\\n'){\n\t\t\ttoken += \"\\n\";\n\t\t\tindex++;\n\t\t}else if(terminator == '\\r' && index < terminators.length - 1){\n\t\t\ttoken += \"\\r\";\n\t\t\tindex++;\n\t\t}else{\n\t\t\ttoken += terminator;\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn token;\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tchar ch = terminators[0];\n\t\n\tif(ch == '*'){\n\t\treturn '*';\n\t}\n\t\n\tif(ch == '?'){\n\t\treturn '?';\n\t}\n\t\n\tif(ch == '+'){\n\t\treturn '+';\n\t}\n\t\n\tif(ch == ','){\n\t\treturn ',';\n\t}\n\t\n\tif(ch == '('){\n\t\treturn '(';\n\t}\n\t\n\tif(ch == ')'){\n\t\treturn ')';\n\t}\n\t\n\tif(ch == '['){\n\t\treturn '[';\n\t}\n\t\n\tif(ch == ']'){\n\t\treturn ']';\n\t}\n\t\n\treturn ':';\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    StringBuilder sb = new StringBuilder();\n    for (char terminator : terminators) {\n        if (sb.length()!= 0) {\n            sb.append(\" \");\n        }\n        sb.append(terminator);\n    }\n    return sb.toString();\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    StringBuilder token = new StringBuilder();\n    char terminator = terminators[0];\n    while(terminator!= ')' && terminator!= '('){\n        token.append(terminator);\n        terminator = terminators[0];\n    }\n    return token.toString();\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    String token = \"\";\n    for (int i = 0; i < terminators.length; i++) {\n        char c = terminators[i];\n        if (c == '\"') {\n            token = token.substring(1);\n        } else if (c == '\\'') {\n            token = token.substring(1);\n        } else if (c == '(') {\n            token = token.substring(1);\n        } else if (c == ')') {\n            token = token.substring(1);\n        } else if (c == ',') {\n            token = token.substring(1);\n        } else if (c == ';') {\n            token = token.substring(1);\n        } else if (c == ':') {\n            token = token.substring(1);\n        } else if (c == '\\\\') {\n            token = token.substring(1);\n        } else if (c == '\\r') {\n            token = token.substring(1);\n        } else if (c == '\\n') {\n            token = token.substring(1);\n        } else if (c == '(') {\n            token = token.substring(1);\n        } else if (c == ')') {\n            token = token.substring(1);\n        } else if (c == ';') {\n            token = token.substring(1);\n        } else if (c == '/') {\n            token = token.substring(1);\n        } else if (c == '*') {\n            token = token.substring(1);\n        } else if (c == '=') {\n            token = token.substring(1);\n        } else if (c == '!') {\n            token = token.substring(1);\n        } else if (c == '+') {\n            token = token.substring(1);\n        } else {\n            token = token.substring(1);\n        }\n    }\n    return token;\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    final ArrayList<String> tokens = new ArrayList<>();\n    int tokenId = 0;\n    for(int i = 0; i < terminators.length; i++){\n        if(terminators[i] == ';'){\n            break;\n        }\n        if(terminators[i] == ','){\n            i++;\n            if(i >= terminators.length){\n                return null;\n            }\n        }\n        if(terminators[i] == '\\n'){\n            return null;\n        }\n        if(terminators[i] == '\\r'){\n            ++i;\n            if(i >= terminators.length){\n                return null;\n            }\n        }\n        tokens.add(Integer.toString(tokenId++));\n    }\n    return tokens.toArray(new String[tokens.size()]);\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tStringBuilder token = null;\n\tint lastIndex = terminators.length - 1;\n\twhile(true){\n\t\tif(terminators[lastIndex] ==''){\n\t\t\tif(token == null){\n\t\t\t\ttoken = new StringBuilder();\n\t\t\t}\n\t\t\ttoken.append(terminators[lastIndex]);\n\t\t\tlastIndex--;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn token.toString();\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    int offset = 0;\n    int size = terminators.length;\n    String out = null;\n    while(true){\n        if(size == 0){\n            return out;\n        }\n        char ch = terminators[offset];\n        if(ch == ')'){\n            return out;\n        }\n        if(ch == '('){\n            offset++;\n            size--;\n        }else if(ch == ',' && size > 0){\n            return out;\n        }else if(ch == ';'){\n            return out;\n        }else if(ch == '\"'){\n            return out;\n        }\n        out = out + ch;\n        size--;\n        offset++;\n    }\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tString token;\n\tint i = 0;\n\twhile (i < terminators.length) {\n\t\tif (terminators[i] == '\\n') {\n\t\t\ttoken = new String(terminators, i, terminators.length - i);\n\t\t\ti += terminators.length - i;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn token;\n}", "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n    final StringBuilder t = new StringBuilder();\n    boolean found = false;\n    for(int i=0; i<terminators.length; i++){\n        if(found){\n            t.append(terminators[i]);\n        }else{\n            t.append(terminators[i]);\n        }\n        if(terminators[i]==' '){\n            found = true;\n        }\n    }\n    if(!found){\n        throw new IllegalArgumentException(String.format(\"Unable to parse '%s'\", new String(terminators)));\n    }\n    return t.toString();\n}"]}
{"_id": "636766fd1a6d9265ec017814", "generate_results": ["public static boolean arrayequals(byte[] a,byte[] b,int count){\n   if(a==b) return true;\n   for(int i=0;i<count;i++)\n   if(a[i]!=b[i]) return false;\n   return true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length!= b.length)\n\t\treturn false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!= b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif (a==null) return false;\n\tif (b==null) return false;\n\tif (a.length!=b.length) return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length==b.length){\n\t\tfor(int i=0;i<count;i++){\n\t\t\tif(a[i]!=b[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a == b){\n\t\treturn true;\n\t}\n\tif(a.length!= b.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!= b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length!=b.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(count<0){count=0;}\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a==null || b==null)return false;\n\t\n\tif(a.length!=b.length)return false;\n\t\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length!=b.length)return false;\n\tfor(int i=0;i<count;i++", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length!=b.length || a.length!=count)return false;\n\tif(a.length==0)return true;\n\tfor(int i=0;i<a.length;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}"]}
{"_id": "636766f61a6d9265ec017701", "generate_results": ["public static int lastIndexOf(String str,String searchStr){\n\tif (str == null || searchStr == null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\tif (str.length() == 0 || searchStr.length() == 0) {\n\t\treturn INDEXNOTFOUND;\n\t}\n\tint index = str.lastIndexOf(searchStr);\n", "public static int lastIndexOf(String str,String searchStr){\n    int index = str.lastIndexOf(searchStr);\n    if(index == INDEXNOTFOUND){\n        return INDEXNOTFOUND;\n    }\n    return index;\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif(str.length()==0){return INDEXNOTFOUND;}\n\tint i=str.length()-1;\n\twhile(i>=0 && str.charAt(i)!=searchStr.charAt(0)){\n\t\ti--;\n\t}\n\treturn i;\n}", "public static int lastIndexOf(String str,String searchStr){\n    if (str.length() == 0) return INDEXNOTFOUND;\n    int pos = str.lastIndexOf(searchStr);\n    if (pos == INDEXNOTFOUND) return INDEXNOTFOUND;\n    return pos;\n}", "public static int lastIndexOf(String str,String searchStr){\n\tint lastIndex = str.length()-1;\n\twhile(lastIndex>=0 && lastIndex<searchStr.length()){\n\t\tif(str.charAt(lastIndex)==searchStr.charAt(0)){\n\t\t\treturn lastIndex;\n\t\t}\n\t\tlastIndex--;\n\t}\n\treturn INDEXNOTFOUND;\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif(str.length()==0){\n\t\treturn INDEXNOTFOUND;\n\t}\n\tint index = str.length()-searchStr.length();\n\tif(index<0){\n\t\treturn INDEXNOTFOUND;\n\t}\n\twhile(index>=0){\n\t\tif(str.charAt(index)==searchStr.charAt(0)){\n\t\t\treturn index;\n\t\t}\n\t\tindex--;\n\t}\n\treturn INDEXNOTFOUND;\n}", "public static int lastIndexOf(String str,String searchStr){\n\t\n\tif(searchStr==null || str==null) return INDEXNOTFOUND;\n\t\n\tint index = str.length();\n\t\n\tint lastIndex = index;\n\t\n\twhile(index>0)\n\t{\n\t\tindex--;\n\t\tif(str.charAt(index)==searchStr.charAt(0)){\n\t\t\tif(index==0){\n\t\t\t\treturn index;\n\t\t\t}else{\n\t\t\t\tif(index==index-1){\n\t\t\t\t\treturn INDEXNOTFOUND;\n\t\t\t\t}else{\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INDEXNOTFOUND;\n}", "public static int lastIndexOf(String str,String searchStr){\n    if(str == null || searchStr == null){\n        return INDEXNOTFOUND;\n    }\n    int lastIndex = str.length() - searchStr.length();\n    return lastIndex < 0? INDEXNOTFOUND : str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\tint index = -1;\n\tif(str==null || searchStr == null || str.length() == 0 || searchStr.length() == 0){\n\t\treturn -1;\n\t}\n\tint len = str.length();\n\tint searchLen = searchStr.length();\n\tif(len<searchLen){\n\t\treturn -1;\n\t}\n\tint index1 = len-searchLen;\n\tint index2 = 0;\n\twhile(index1 > 0 && index2 < index1){\n\t\tindex2++;\n\t\tindex1--;\n\t}\n\tif(index1 == 0 && index1 == index2){\n\t\tindex = index2;\n\t}else if(index1 == index2){\n\t\tindex = index2;\n\t}else{\n\t\tindex = -1;\n\t}\n\treturn index;\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif(str.equals(\"\")){\n\t\treturn INDEXNOTFOUND;\n\t}\n\tint index = str.length()-searchStr.length();\n\twhile(index>=0){\n\t\tif(str.substring(index,index+searchStr.length()).equals(searchStr)){\n\t\t\treturn index;\n\t\t}\n\t\tindex--;\n\t}\n\treturn INDEXNOTFOUND;\n}"]}
{"_id": "636766ff1a6d9265ec01783b", "generate_results": ["public static String sub(String str,int start,int end){\n\tif(start==0) return str.substring(end);\n\tif(end==-1) return str.substring(start);\n\tif(end<0) end=str.length();\n\tint i=start;\n\tint j=end;\n\twhile(i<j) {\n\t\tif(str.charAt(i)>=str.charAt(j)) {\n\t\t\tj--;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn str.substring(start,j);\n}", "public static String sub(String str,int start,int end){\n\tif(start>end){\n\t\tthrow new RuntimeException(\"start>end\");\n\t}\n\tString s=str.substring(start,end);\n\treturn s;\n}", "public static String sub(String str,int start,int end){\n\t\n\tif(start<1){\n\t\tthrow new IllegalArgumentException(\"The start parameter should be greater than zero\");\n\t}\n\t\n\tif(end<1){\n\t\tthrow new IllegalArgumentException(\"The end parameter should be greater than zero\");\n\t}\n\t\n\tif(start>end){\n\t\tthrow new IllegalArgumentException(\"The start parameter should be less than the end\");\n\t}\n\t\n\tint len = end - start;\n\t\n\tif(len<1){\n\t\tthrow new IllegalArgumentException(\"The length parameter should be greater than zero\");\n\t}\n\t\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\tint s=start;\n\tint e=end;\n\twhile(s<e){\n\t\tchar c=str.charAt(s);\n\t\tif(c==' ') s++;\n\t\telse if(c=='\\n') return str.substring(s,e);\n\t\telse if(c<'A' || c>'Z') return null;\n\t\telse s++;\n\t}\n\treturn null;\n}", "public static String sub(String str,int start,int end){\n    int i=0;\n    while(i<end){\n        if(str.charAt(i)==str.charAt(start)){\n            return str.substring(start,i+1);\n        }\n        i++;\n    }\n    return \"\";\n}", "public static String sub(String str,int start,int end){\n\t\n\tif(end <= start){\n\t\tthrow new IndexOutOfBoundsException(\"end must be greater than start\");\n\t}\n\t\n\tint startIndex = str.indexOf(start);\n\t\n\tif(startIndex == -1){\n\t\treturn str;\n\t}\n\t\n\tchar[] chars = str.toCharArray();\n\t\n\tchar prev = chars[startIndex];\n\tchar next = chars[startIndex+1];\n\t\n\treturn prev+next;\n}", "public static String sub(String str,int start,int end){\n\tStringBuffer sb=new StringBuffer(str);\n\tif(start>=0&&end>=0&&start<=str.length()&&end<=str.length()){\n\t\tif(start>0&&end>0&&start<=str.length()&&end<=str.length()){\n\t\t\tsb.delete(start,end);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String sub(String str,int start,int end){\n    if(start>end){\n        throw new IllegalArgumentException(\"Start must be less than end\");\n    }\n    if(start<0){\n        throw new IllegalArgumentException(\"Start must be greater than 0\");\n    }\n    if(end>str.length()){\n        throw new IllegalArgumentException(\"End must be less than the String length\");\n    }\n    if(start<0){\n        start=0;\n    }\n    if(end>str.length()){\n        end=str.length();\n    }\n    if(end<start){\n        return str.substring(start,end);\n    } else {\n        return str.substring(start,end);\n    }\n}", "public static String sub(String str,int start,int end){\n\tStringBuffer result=new StringBuffer();\n\tif(str.length()<start) return result.toString();\n\tif(str.length()<end", "public static String sub(String str,int start,int end){\n\tint len = str.length();\n\tif(start < 0)\n\t\tstart = 0;\n\tif(end > len)\n\t\tend = len;\n\tif(end <= start)\n\t\treturn \"\";\n\t\n\tint i = start;\n\tint j = start;\n\tint k = end;\n\tint l = end;\n\t\n\twhile(i<=l)\n\t{\n\t\tif(str.charAt(i)=='\\n')\n\t\t\ti++;\n\t\telse if(str.charAt(i)=='\\r')\n\t\t\ti++;\n\t\telse\n\t\t{\n\t\t\tif(k>=len)\n\t\t\t\treturn \"\";\n\t\t\tif(str.charAt(i)==str.charAt(k))\n\t\t\t\tk++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(k==len)\n\t\t\t\t{\n\t\t\t\t\tif(j<end)\n\t\t\t\t\t\treturn str.substring(j,end);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(j>=l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j>=end)\n\t\t\t\t\t\t\treturn str.substring(j-end,l);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn str.substring(j-l,j);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j>=l)\n\t\t\t\t\t\t\treturn str.substring(j-l,j);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn str.substring(j-l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn \"\";\n}"]}
{"_id": "6367670b1a6d9265ec017a0f", "generate_results": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif(str==null){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(str.equalsIgnoreCase(searchStrArray.get(i)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\tif(str==null || searchStrArray==null) return false;\n\t\tfor(int i=0;i<searchStrArray.size();i++){\n\t\t\t", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n    for (String element : searchStrArray){\n        if (str.matches(Pattern.compile(Pattern.quote(element)))){\n            return true;\n        }\n    }\n    return false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tif(str==null || searchStrArray==null) return false;\n\t\n\tfor(String s : searchStrArray){\n\t\tif(!containsAnyIgnoreCase(str,s)) return false;\n\t}\n\treturn true;\n\t\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tboolean result = false;\n\tfor(String s : searchStrArray){\n\t\tif(str.contains(s)){\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tif(str == null || searchStrArray == null){\n\t\treturn false;\n\t}\n\t\n\tchar[] chars = str.toCharArray();\n\tboolean result = true;\n\tfor(int i = 0;i < chars.length && result;i++){\n\t\tfor(int j = 0;j < searchStrArray.size() && result;j++){\n\t\t\tif(chars[i] == searchStrArray.get(j)){\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tif(str==null||str.isEmpty()){\n\t\treturn false; //empty string\n\t}\n\t\n\tfor(String element : searchStrArray){\n\t\tif(str.contains(element)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(str.contains(searchStrArray.get(i)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n    if (str == null) return false;\n    for (String s : searchStrArray){\n        if (str.toLowerCase().contains(s.toLowerCase())) return true;\n    }\n    return false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif(str==null || searchStrArray==null || searchStrArray.size()<1){\n\t\treturn false;\n\t}\n\tString result=null;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(searchStrArray.get(i).toLowerCase().contains(str.toLowerCase())){\n\t\t\tresult=searchStrArray.get(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result!=null;\n}"]}
{"_id": "636767021a6d9265ec0178bc", "generate_results": ["public static int indexOf(String str,String searchStr){\n\tint i=0;\n\twhile(i<str.length() && str.charAt(i)!=searchStr.charAt(i)){\n\t\ti++;\n\t}\n\treturn i;\n}", "public static int indexOf(String str,String searchStr){\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\tif(null == str || null == searchStr){\n\t\treturn -1;\n\t}\n\tint index = 0;\n\tint count = str.length();\n\twhile(index < count){\n\t\tif(str.charAt(index) == searchStr.charAt(index)){\n\t\t\treturn index;\n\t\t}\n\t\tindex++;\n\t}\n\treturn -1;\n}", "public static int indexOf(String str,String searchStr){\n    return str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\tint i=0;\n\twhile(i<str.length() &&!searchStr.equals(str.substring(i, i+1))) i++;\n\treturn i;\n}", "public static int indexOf(String str,String searchStr){\n\tif(str == null || searchStr == null)\n\t\treturn -1;\n\tint start = 0;\n\tint end = str.length();\n\twhile(start <= end){\n\t\tint mid = (start + end) / 2;\n\t\tif(str.substring(mid).equals(searchStr))\n\t\t\treturn mid;\n\t\tif(str.substring(mid).compareTo(searchStr) < 0)\n\t\t\tend = mid;\n\t\telse\n\t\t\tstart = mid + 1;\n\t}\n\treturn -1;\n}", "public static int indexOf(String str,String searchStr){\n    int len = str.length();\n    int index = 0;\n    while(index<len){\n        if(str.charAt(index)==searchStr.charAt(0)){\n            index++;\n        }else if(searchStr.charAt(index)!=0){\n            break;\n        }else{\n            index++;\n        }\n    }\n    return index;\n}", "public static int indexOf(String str,String searchStr){\n\t\n\tint searchLen=searchStr.length();\n\tint start=0;\n\tint end=str.length();\n\t\n\twhile (start<end){\n\t\t\n\t\tint index=str.indexOf(searchStr,start);\n\t\tif (index!=-1){\n\t\t\treturn index;\n\t\t}\n\t\telse{\n\t\t\tstart++;\n\t\t}\n\t}\n\t\n\treturn -1;\n}", "public static int indexOf(String str,String searchStr){\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\tint x = 0;\n\tint j = 0;\n\twhile(x < str.length() && j < searchStr.length()){\n\t\tif(str.charAt(x) == searchStr.charAt(j)){\n\t\t\tj++;\n\t\t}\n\t\telse{\n\t\t\tx++;\n\t\t}\n\t}\n\treturn x;\n}"]}
{"_id": "636766fc1a6d9265ec0177da", "generate_results": ["Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return c == ';' || c == ':';\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return (c == ':' || c == ';' || c =='' || c == '\\t' || c == '\\n');\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='(' || c==')' || c=='{' || c==')' || c=='\"' || c=='\\'' || c=='`';\n}\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// ----------------------------------------------------------------", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return c == '\"';\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n\treturn c == ',' || c == ';';\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n\tif(c=='\\'' || c=='\\\"') return true;\n\telse if(c=='(' || c==')') return true;\n\telse return false;\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    switch(c){\n        case ',':\n        case ';':\n        case '\\'':\n        case '`':\n            return true;\n        default:\n            return false;\n    }\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n\tif (c == '_' || c == ':')\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n\tif(c=='/'){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}", "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return (c == ':') || (c == ';');\n}"]}
{"_id": "636767031a6d9265ec0178ef", "generate_results": ["Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    if(array.getClass().equals(newArrayComponentType)){\n        return array;\n    }\n    Object result = Array.newInstance(newArrayComponentType,array.length());\n    // Fill with the default value\n    for(int i=0;i<array.length();i++){\n        Array.set(result,i,array[i]);\n    }\n    return result;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    String newArrayComponentTypeName=newArrayComponentType.getName();\n    if(array instanceof Object[]){\n        Object[] newArray=(Object[])array;\n        newArray[newArray.length-1]=newArray;\n        return newArray;\n    }else{\n        Object[] newArray=(Object[])new Object[array.length+1];\n        System.arraycopy(array,0,newArray,0,array.length);\n        newArray[newArray.length-1]=newArray;\n        return newArray;\n    }\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    if(array==null) return null;\n    Object arrayCopy = array.getClass().newInstance();\n    for(int i = 0; i < array.length(); i++){\n        if(array.getClass().getComponentType().isAssignableFrom(newArrayComponentType)){\n            arrayCopy = array.getClass().getComponentType().cast(arrayCopy);\n        }else{\n            arrayCopy = array.getClass().getComponentType().cast(arrayCopy);\n        }\n        arrayCopy.set(array.get(i), newArrayComponentType.cast(arrayCopy.get(i)));\n    }\n    return arrayCopy;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tObject copyArray = array;\n\tif (array instanceof Object[]){\n\t\tcopyArray = Array.newInstance(newArrayComponentType, ((Object[]) array).length + 1);\n\t}\n\treturn copyArray;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tfinal Object[] arrayCopy = (Object[])Array.newInstance(newArrayComponentType,array.length+1);\n\tSystem.arraycopy(array,0,arrayCopy,0,array.length);\n\tarrayCopy[array.length] = newArrayComponentType;\n\treturn arrayCopy;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    if(array instanceof Object[]){\n        return Arrays.copyOf((Object[])array,array.length());\n    }\n    return new Object[]{array.toString(),newArrayComponentType.getName()};\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\t\tObject[] newArray = new Object[array.getClass().getComponentType().getParameterTypes().length];\n\t\tfor(int i = 0;i < newArray.length;i++){\n\t\t\tnewArray[i] = array.getClass().getComponentType().getParameterTypes()[i];\n\t\t}\n\t\treturn newArray;\n\t}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    final int newArraySize = Array.getLength(array);\n    final Object newArray = Array.newInstance(newArrayComponentType, newArraySize);\n    Array.set(newArray, newArraySize, array);\n    return newArray;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif (array == null) return null;\n\tfinal Object newArray = Array.newInstance(newArrayComponentType,array.length+1);\n\tArray.set(newArray,array.length,array);\n\treturn newArray;\n}", "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif (array == null) return null;\n\tif (array.getClass().isArray()){\n\t\tfinal Object newArray = Array.newInstance(newArrayComponentType, 1);\n\t\tfinal Object result = Array.set(newArray, 1, array);\n\t\treturn result;\n\t}\n\treturn Array.newInstance(newArrayComponentType, array.length + 1);\n}"]}
{"_id": "636766fe1a6d9265ec017834", "generate_results": ["public static String sessionId(){\n    HttpSession session = request.getSession(false);\n    return (String) session.getAttribute(\"sessionId\");\n}", "public static String sessionId(){\n\tHttpSession session = request.getSession(false);\n\tString sId = null;\n\tif(session!=null){\n\t\tsId = session.getId();\n\t}\n\treturn sId;\n}", "public static String sessionId(){\n\tif(sessionId == null){\n\t\tsessionId = ServletUtil.getSessionId();\n\t}\n\treturn sessionId;\n}", "public static String sessionId(){\n\treturn (String)session.getAttribute(\"sessionid\");\n}", "public static String sessionId(){\n\treturn (String) session.getAttribute(\"sessid\");\n}", "public static String sessionId(){\n\tlong time=System.currentTimeMillis();\n\tString sessionId=\"\";\n\tString className=Thread.currentThread().getName();\n\tif(time<=0L)\n\t\treturn sessionId;\n\tString id=\"\";\n\ttry{\n\t\tid=Thread.currentThread().getContextClassLoader().getResource(\"\").getFile();\n\t}\n\tcatch(IOException e){\n\t\te.printStackTrace();\n\t}\n\tlong millis=System.currentTimeMillis();\n\tlong start=millis;\n\twhile(millis<=0L){\n\t\ttry{\n\t\t\tThread.sleep(20);\n\t\t}\n\t\tcatch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tmillis=System.currentTimeMillis();\n\t}\n\tlong end=millis;\n\tlong diff=end-start;\n\tlong diff1=diff*1000;\n\tif(diff1<0L)\n\t\treturn diff1;\n\telse{\n\t\tlong diff2=diff1*1000;\n\t\tlong diff3=diff2/10;\n\t\tlong diff4=diff3/10;\n\t\tlong diff5=diff4/10;\n\t\tlong diff6=diff5/10;\n\t\tlong diff7=diff6/10;\n\t\tlong diff8=diff7/10;\n\t\tlong diff9=diff8/10;\n\t\tlong diff10=diff9/10;\n\t\tlong diff11=diff10/10;\n\t\tlong diff12=diff11/10;\n\t\tlong diff13=diff12/10;\n\t\tlong diff14=diff13/10;\n\t\tlong diff15=diff14/10;\n\t\tlong diff16=diff15/10;\n\t\tlong diff17=diff16/10;\n\t\tlong diff18=diff17/10;\n\t\tlong diff19=diff18/10;\n\t\tlong diff20=diff19/10;\n\t\tlong diff21=diff20/10;\n\t\tlong diff22=diff21/10;\n\t\tlong diff23=diff22/10;\n\t\tlong diff24=diff23/10;\n\t\tlong diff25=diff24/10;\n\t\tlong diff26=diff25/10;\n\t\tlong diff27=diff26/10;\n\t\tlong diff28=diff27/10;\n\t\tlong diff29=diff28/10;\n\t\tlong diff30=diff29/10;\n\t\tlong diff31=diff30/10;\n\t\tlong diff32=diff31/10;\n\t\tlong diff33=diff32/10;\n\t\tlong diff34=diff33/10;\n\t\tlong diff35=diff34/10;\n\t\tlong diff36=diff35/10;\n\t\tlong diff37=diff36/10;\n\t\tlong diff38=diff37/10;\n\t\tlong diff39=diff38/10;\n\t\tlong diff40=diff39/10;\n\t\tlong diff41=diff40/10;\n\t\tlong diff42=diff41/10;\n\t\tlong diff43=diff42/10;\n\t\tlong diff44=diff43/10;\n\t\tlong diff45=diff44/10;\n\t\tlong diff46=diff45/10;\n\t\tlong diff47=diff46/10;\n\t\tlong diff48=diff47/10;\n\t\tlong diff49=diff48/10;\n\t\tlong diff50=diff49/10;\n\t\tlong diff51=diff50/10;\n\t\tlong diff52=diff51/10;\n\t\tlong diff53=diff52/10;\n\t\tlong diff54=diff53/10;\n\t\tlong diff55=diff54/10;\n\t\tlong diff56=diff55/10;\n\t\tlong diff57=diff56/10;\n\t\tlong diff58=diff57/10;\n\t\tlong diff59=diff58/10;\n\t\tlong diff60=diff59/10;\n\t\tlong diff61=diff60/10;\n\t\tlong diff62=diff61/10;\n\t\tlong diff63=diff62/10;\n\t\tlong diff64=diff63/10;\n\t\tlong diff65=diff64/10;\n\t\tlong diff66=diff65/10;\n\t\tlong diff67=diff66/10;\n\t\tlong diff68=diff67/10;\n\t\tlong diff69=diff68/10;\n\t\tlong diff70=diff69/10;\n\t\tlong diff71=diff70/10;\n\t\tlong diff72=diff71/10", "public static String sessionId(){\n\treturn sessionId;\n}", "public static String sessionId(){\n\treturn sessionId;\n}", "public static String sessionId(){\n\treturn sessionId;\n}", "public static String sessionId(){\n\tString id = \"\";\n\tSession session = WebContext.get().getSession();\n\tif (session!= null && session.getAttribute(\"user\")!= null) {\n\t\tid = (String) session.getAttribute(\"user\");\n\t}\n\treturn id;\n}"]}
{"_id": "636766ae1a6d9265ec0175dc", "generate_results": ["public Boolean isPartialContentResponse(){\n\treturn this.isPartialContent;\n}", "public Boolean isPartialContentResponse(){\n\treturn isPartialContent;\n}", "public Boolean isPartialContentResponse(){\n\treturn isPartialContentResponse(response);\n}", "public Boolean isPartialContentResponse(){\n    return true;\n}", "public Boolean isPartialContentResponse(){\n\treturn (false);\n}", "public Boolean isPartialContentResponse(){\n\treturn this.isPartialContentResponse;\n}", "public Boolean isPartialContentResponse(){\n\t\n\tif (request.getResponse().getStatusCode() == HttpStatus.SC_OK){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public Boolean isPartialContentResponse(){\n    return this.isPartialContentResponse;\n}", "public Boolean isPartialContentResponse(){\n    return isPartialContent;\n}", "public String getStatusCodeString(){\n\tif(isPartialContentResponse()){\n\t\treturn null;\n\t}\n\treturn getStatusCode();\n}"]}
{"_id": "636766ae1a6d9265ec0175d8", "generate_results": ["Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder sb = new StringBuilder();\n\tint start = 0;\n\tint end = 0;\n\t\n\t//get the start and end offset of the content range\n\tif(offset > 0){\n\t\tstart = offset;\n\t\tend = offset;\n\t}\n\t\n\t//go through the content range to get the end offset\n\twhile(start < offset){\n\t\tsb.append(content[start]);\n\t\tstart++;\n\t}\n\t\n\t//get the end offset\n\tend = offset - 1;\n\t\n\t//if the end offset is 0,the end offset must be one greater\n\tif(end == 0){\n\t\tend = count - 1;\n\t}\n\t\n\treturn sb.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n    StringBuilder builder = new StringBuilder();\n    StringBuilder contentRangeBuilder = new StringBuilder();\n    String contentRange = null;\n    int count = 0;\n    String offset = null;\n    \n    if(offset!= null){\n        contentRangeBuilder.append(offset);\n    }else{\n        contentRangeBuilder.append(\"bytes\");\n    }\n    \n    if(count > 0){\n        contentRangeBuilder.append(\"-\");\n        contentRangeBuilder.append(count);\n    }\n    \n    builder.append(contentRangeBuilder.toString());\n    \n    return builder.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tint offset = 0;\n\tint limit = count;\n\tif(limit == 0) limit = count-1;\n\tif(limit <= count) limit = count;\n\tStringBuilder sb = new StringBuilder();\n\twhile(offset < limit){\n\t\tsb.append(getText(offset,limit));\n\t\toffset += getTextLength(offset,limit);\n\t}\n\treturn sb.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder contentRange = new StringBuilder();\n\tcontentRange.append(offset);\n\tcontentRange.append(limit);\n\treturn contentRange.toString();\n}", "public static void main(String[] args) throws Exception {\n\tif (args.length < 2) {\n\t\tSystem.err.println(\"Usage: java -jar \" + Main.class.getName() + \" <image>\");\n\t\tSystem.exit(1);\n\t}\n\t\n\tString fileName = args[0];\n\tFile file = new File(fileName);\n\tBufferedReader br = new BufferedReader(new FileReader(file));\n\tString line = null;\n\tboolean readSuccessful = false;\n\tint count = 1;\n\twhile ((line = br.readLine())!= null) {\n\t\tString[] split = line.split(\"\\\\s+\");\n\t\tif (split.length!= 2) {\n\t\t\tSystem.err.println(line + \": line split error\");\n\t\t\tcontinue;\n\t\t}\n\t\tint offset = Integer.parseInt(split[0]);\n\t\tint count = Integer.parseInt(split[1]);\n\t\tString contentRange = buildContentRange();\n\t\tif (contentRange.length() == 0) {\n\t\t\tcontentRange = buildContentRange();\n\t\t}\n\t\tSystem.out.println(contentRange + \":\" + count);\n\t\t\n\t\tif (contentRange.startsWith(\"bytes \")) {\n\t\t\treadSuccessful = true;\n\t\t}\n\t\t\n\t\tif (contentRange.endsWith(\"-\")) {\n\t\t\tcount = Integer.parseInt(contentRange.substring(0, contentRange.length() - 1));\n\t\t}\n\t\t\n\t\tif (readSuccessful) {\n\t\t\tcount += 1;\n\t\t\tSystem.out.println(count + \":\" + contentRange);\n\t\t}\n\t}\n\tif (!readSuccessful) {\n\t\tSystem.err.println(\"Fail to read file\");\n\t}\n\tbr.close();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tsb.append(\"bytes=\");\n\tsb.append(offset);\n\tsb.append(\"-\");\n\tsb.append(limit);\n\treturn sb.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder ret = new StringBuilder();\n\tret.append(offset).append(\",\").append(limit);\n\t//ret.append(\",count=\").append(count);\n\treturn ret.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n    StringBuilder sb = new StringBuilder();\n    int start = 0;\n    int end = 0;\n    if(offset > 0){\n        start = offset;\n        end = getContentRangeEnd(start);\n    }\n    if(start > 0){\n        sb.append(getContentRangeStart(start));\n    }\n    sb.append(end - start);\n    return sb.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder contentRange = new StringBuilder();\n\tcontentRange.append(contentRangeStart);\n\tcontentRange.append(contentRangeEnd);\n\treturn contentRange.toString();\n}", "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder contentRange = new StringBuilder(1024);\n\tint start = 0;\n\tint end = 0;\n\t\n\tif(offset == 0) {\n\t\tcontentRange.append(\"0-\");\n\t\tcontentRange.append(limit);\n\t\tcontentRange.append(\"/\");\n\t\tcontentRange.append(count);\n\t} else {\n\t\tcontentRange.append(\"0-\");\n\t\tcontentRange.append(offset);\n\t\tcontentRange.append(\"-\");\n\t\tcontentRange.append(limit);\n\t\tcontentRange.append(\"/\");\n\t\tcontentRange.append(count);\n\t}\n\t\n\treturn contentRange.toString();\n}"]}
{"_id": "636766f01a6d9265ec01763e", "generate_results": ["Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\tif(charset.equals(\"UTF-8\")){\n\t\treturn \"UTF-8\";\n\t}\n\tif(charset.equals(\"ISO-8859-1\")){\n\t\treturn \"ISO-8859-1\";\n\t}\n\tif(charset.equals(\"UTF-16\")){\n\t\treturn \"UTF-16\";\n\t}\n\tif(charset.equals(\"ISO-8859-2\")){\n\t\treturn \"ISO-8859-2\";\n\t}\n\tif(charset.equals(\"ISO-8859-3\")){\n\t\treturn \"ISO-8859-3\";\n\t}\n\tif(charset.equals(\"ISO-8859-4\")){\n\t\treturn \"ISO-8859-4\";\n\t}\n\tif(charset.equals(\"ISO-8859-5\")){\n\t\treturn \"ISO-8859-5\";\n\t}\n\tif(charset.equals(\"ISO-8859-6\")){\n\t\treturn \"ISO-8859-6\";\n\t}\n\tif(charset.equals(\"ISO-8859-7\")){\n\t\treturn \"ISO-8859-7\";\n\t}\n\tif(charset.equals(\"ISO-8859-8\")){\n\t\treturn \"ISO-8859-8\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-I\")){\n\t\treturn \"ISO-8859-8-I\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-J\")){\n\t\treturn \"ISO-8859-8-J\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-K\")){\n\t\treturn \"ISO-8859-8-K\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-L\")){\n\t\treturn \"ISO-8859-8-L\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-M\")){\n\t\treturn \"ISO-8859-8-M\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-N\")){\n\t\treturn \"ISO-8859-8-N\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-O\")){\n\t\treturn \"ISO-8859-8-O\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-P\")){\n\t\treturn \"ISO-8859-8-P\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-Q\")){\n\t\treturn \"ISO-8859-8-Q\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-R\")){\n\t\treturn \"ISO-8859-8-R\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-S\")){\n\t\treturn \"ISO-8859-8-S\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-T\")){\n\t\treturn \"ISO-8859-8-T\";\n\t}\n\tif(charset.equals(\"ISO-8859-8-U\")){\n\t\treturn \"ISO-8859-8-U\";\n\t}\n\tif(charset.equals(\"ISO-8859-9\")){\n\t\treturn \"ISO-8859-9\";\n\t}\n\tif(charset.equals(\"ISO-8859-10\")){\n\t\treturn \"ISO-8859-10\";\n\t}\n\tif(charset.equals(\"ISO-8859-11\")){\n\t\treturn \"ISO-8859-11\";\n\t}\n\tif(charset.equals(\"ISO-8859-13\")){\n\t\treturn \"ISO-8859-13\";\n\t}\n\tif(charset.equals(\"ISO-8859-14\")){\n\t\treturn \"ISO-8859-14\";\n\t}\n\tif(charset.equals(\"ISO-8859-15\")){\n\t\treturn \"ISO-8859-15\";\n\t}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\tif(charset.equals(\"\")){\n\t\treturn \"ISO-8859-1\";\n\t}\n\tif(charset.equals(\"UTF-8\")){\n\t\treturn \"UTF-8\";\n\t}\n\treturn charset;\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    return charset.replace(\"_\", \"-\");\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"charset=\");\n    sb.append(charset);\n    return sb.toString();\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\tif(charset.equals(\"UTF-8\")){\n\t\treturn \"UTF8\";\n\t}\n\treturn charset;\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\tif (charset == null || charset.length() == 0) return null;\n\t\n\tString ret = null;\n\t\n\t// first try to see if it's a valid Java charset name.\n\t// if it's not, it'll just be returned as-is.\n\tret = javaCharsetFromName(charset);\n\t\n\t// if that fails, try to see if it's a valid MIME charset.\n\t// if it's not, it'll be returned as-is.\n\tret = javaCharsetFromMime(charset);\n\t\n\t// if that both fail, return the default.\n\treturn ret;\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\tif (charset.equals(\"UTF-8\")) return \"UTF8\";\n\treturn charset;\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    String s = null;\n    switch(charset){\n        case \"ISO-8859-1\":\n            s = \"US-ASCII\";\n            break;\n        case \"UTF-8\":\n            s = \"UTF-8\";\n            break;\n        case \"UTF-16\":\n            s = \"UTF-16\";\n            break;\n        case \"UTF-16BE\":\n            s = \"UTF-16BE\";\n            break;\n        case \"UTF-16LE\":\n            s = \"UTF-16LE\";\n            break;\n        case \"UTF-16\":\n            s = \"UTF-16\";\n            break;\n        case \"SHIFT_JIS\":\n            s = \"Shift_JIS\";\n            break;\n        case \"EUC-JP\":\n            s = \"EUC-JP\";\n            break;\n        case \"EUC-KR\":\n            s = \"EUC-KR\";\n            break;\n        case \"BIG5\":\n            s = \"Big5\";\n            break;\n        case \"CP1250\":\n            s = \"CP1250\";\n            break;\n        case \"CP1251\":\n            s = \"CP1251\";\n            break;\n        case \"CP1252\":\n            s = \"CP1252\";\n            break;\n        case \"CP1253\":\n            s = \"CP1253\";\n            break;\n        case \"CP1254\":\n            s = \"CP1254\";\n            break;\n        case \"CP1255\":\n            s = \"CP1255\";\n            break;\n        case \"CP1256\":\n            s = \"CP1256\";\n            break;\n        case \"CP1257\":\n            s = \"CP1257\";\n            break;\n        case \"CP1258\":\n            s = \"CP1258\";\n            break;\n        case \"CP1259\":\n            s = \"CP1259\";\n            break;\n        case \"CP1260\":\n            s = \"CP1260\";\n            break;\n        case \"CP1261\":\n            s = \"CP1261\";\n            break;\n        case \"CP1262\":\n            s = \"CP1262\";\n            break;\n        case \"CP1263\":\n            s = \"CP1263\";\n            break;\n        case \"CP1264\":\n            s = \"CP1264\";\n            break;\n        case \"CP1265\":\n            s = \"CP1265\";\n            break;\n        case \"CP1266\":\n            s = \"CP1266\";\n            break;\n        case \"CP1267\":\n            s = \"CP1267\";\n            break;\n        case \"CP1268\":\n            s = \"CP1268\";\n            break;\n        case \"CP1269\":\n            s = \"CP1269\";\n            break;\n        case \"CP1270\":\n            s = \"CP1270\";\n            break;\n        case \"CP1271\":\n            s = \"CP1271\";\n            break;\n        case \"CP1272\":\n            s = \"CP1272\";\n            break;\n        case \"CP1273\":\n            s = \"CP1273\";\n            break;\n        case \"CP1274\":\n            s = \"CP1274\";\n            break;\n        case \"CP1275\":\n            s = \"CP1275\";\n            break;\n        case \"CP1276\":\n            s = \"CP1276\";\n            break;\n        case \"CP1277\":\n            s = \"CP1277\";\n            break;\n        case \"CP1278\":\n            s = \"CP1278\";\n            break;\n        case \"CP1279\":\n            s = \"CP1279\";\n            break;\n        case \"CP1280\":\n            s = \"CP1280\";\n            break;\n        case \"CP1281\":\n            s = \"CP1281\";\n            break;\n        case \"CP1282\":\n            s = \"CP1282\";\n            break;\n        case \"CP1283\":\n            s = \"CP1283\";\n            break;\n        case \"CP1284\":\n            s = \"CP1284\";\n            break;\n        case \"CP1285\":\n            s = \"CP1285\";\n            break;\n        ", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    charset=charset.toLowerCase();\n    if(charset.equals(\"utf-8\")){\n        return \"UTF-8\";\n    } else if(charset.equals(\"utf-16\")){\n        return \"UTF-16BE\";\n    } else if(charset.equals(\"utf-16\")){\n        return \"UTF-16LE\";\n    } else if(charset.equals(\"utf-32\")){\n        return \"UTF-32BE\";\n    } else if(charset.equals(\"utf-32\")){\n        return \"UTF-32LE\";\n    }\n    return charset;\n}", "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n\t// If the charset is not in the list, return the\n\t// default charset.\n\tif(!charset.equals(\"UTF-8\")){\n\t\treturn charset;\n\t}\n\t\n\t// Otherwise, look for a Java equivalent.\n\t// Note that this code will not work for a BOM\n\t// (byte-order-mark), so we have to try all\n\t// possibilities.\n\tfor(int i=0;i<charset.length();i++){\n\t\tif(charset.charAt(i)=='\\t'){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Check if the next character is a\n\t\t// legal Java character.\n\t\tif(charset.charAt(i)>='\\u0080'){\n\t\t\t// If the character is a legal Java\n\t\t\t// character, return it.\n\t\t\treturn charset.substring(0,i);\n\t\t}\n\t}\n\t\n\t// If we got here, we have a bug, let's return the default\n\t// charset.\n\treturn \"UTF-8\";\n}"]}
{"_id": "636767441a6d9265ec017cc1", "generate_results": ["Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n\tTreeNode<T> right = node;\n\twhile (right.left!= null){\n\t\tright = right.left;\n\t}\n\n\tright.left = node.right;\n\tnode.right = right;\n\n\treturn node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n\t\n\tif (node == null){\n\t\treturn null;\n\t}\n\t\n\tTreeNode<T> rotateRight = node.right;\n\t\n\tnode.right = rotateRight.left;\n\t\n\trotateRight.left = node;\n\t\n\treturn node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    if(node.left!= null)\n        node.left = rotateRight(node.left);\n    if(node.right!= null)\n        node.right = rotateRight(node.right);\n    \n    return node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    TreeNode<T> temp = node.right;\n    node.right = node.right.left;\n    node.right.left = temp;\n    return node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    if (node == null)\n        return node;\n    \n    TreeNode<T> left = node.left;\n    TreeNode<T> right = node.right;\n    \n    // Rotate the left subtree.\n    rotateLeft(left);\n    // Rotate the right subtree.\n    rotateRight(right);\n    \n    // Swap the subtrees.\n    node.left = left;\n    node.right = right;\n    return node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n\tif(node == null){\n\t\treturn null;\n\t}\n\telse if(node.left == null){\n\t\tnode.left = rotateRight(node.right);\n\t\tnode.right = null;\n\t}\n\telse{\n\t\tnode.right = rotateRight(node.left);\n\t\tnode.left = null;\n\t}\n\treturn node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    \n    // Rotate the right the left branch of the node\n    if(node.left!= null){\n        TreeNode<T> temp = node.left;\n        node.left = rotateRight(node.left);\n        node.right = temp;\n    }\n    // Rotate the right the right branch of the node\n    if(node.right!= null){\n        TreeNode<T> temp = node.right;\n        node.right = rotateRight(node.right);\n        node.left = temp;\n    }\n    // Return the node\n    return node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n\tif (node == null)\n\t\treturn null;\n\t\n\tTreeNode<T> parent = node.getParent();\n\t\n\tif (parent == null){\n\t\t//The root node\n\t\t\n\t\t//Calculate the new parent\n\t\tparent = rotateRight(node.getLeft());\n\t\t\n\t\t//Set the new parent and return\n\t\tnode.setParent(parent);\n\t\treturn parent;\n\t}\n\t\n\t//The left node\n\t\n\t//Calculate the new parent\n\tTreeNode<T> newParent = rotateRight(parent.getRight());\n\t\n\t//Set the new parent and return\n\tnode.setParent(newParent);\n\treturn newParent;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n\tif(node.left == null){\n\t\treturn node;\n\t}\n\tTreeNode<T> temp = node.left;\n\tnode.left = rotateRight(node.left);\n\tnode.right = temp.right;\n\ttemp.right = node;\n\treturn node;\n}", "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    if (node.left == null) {\n        node.left = rotateRight(node.right);\n        return node.left;\n    } else {\n        node.right = rotateRight(node.left);\n        return rotateLeft(node);\n    }\n}"]}
{"_id": "636767551a6d9265ec017f3f", "generate_results": ["public static final <V>void swap(V[] arr,int i,int j){\n\t\n\tif(i>=0 && i<arr.length && j>=0 && j<arr.length){\n\t\t\n\t\tarr[i]=arr[j];\n\t\tarr[j]=arr[i];\n\t\t\n\t}\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV tmp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=tmp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tarr[i]=arr[j];\n\tarr[j]=arr[i];\n}", "public static final <V>void swap(V[] arr,int i,int j){\n    V temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}", "public static final <V> V[] swap(V[] arr,int i,int j){\n\tV[] res=copyOf(arr,i,j);\n\tswap(res,i,j);\n\treturn res;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n    V v=arr[i];\n    arr[i]=arr[j];\n    arr[j]=v;\n}", "public static final <V>V swap(V[] arr,int i,int j){\n    arr[i] = arr[j];\n    arr[j] = arr[i];\n    return arr[i];\n}", "public static final <V>void swap(V[] arr,int i,int j){\n  arr[i]=arr[j];\n  arr[j]=arr[i];\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tif(i<j){\n\t\tV temp = arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tarr[i]=arr[j];\n\tarr[j]=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=arr[i];\n}"]}
{"_id": "6367675c1a6d9265ec018058", "generate_results": ["Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new LongSupplier(start);\n}", "Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new Supplier<String>() {\n        public String get() { return Integer.toString(start); }\n    };\n}", "Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n  return new Supplier<String>() {\n    public String get() {\n      return Integer.toString(start);\n    }\n  };\n}", "public static Supplier<String> createStringSupplier10(int start){\n    return () -> String.format(\"%s-%d\", \n        Suppliers.range(start, start+1).get().toString(), \n        Integer.toString(start+1));\n}", "public E get() { return clazz.cast(new Object()).get(start, stop, step, start2, stop2, step2, start3, stop3);}", "Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new Supplier<String>() {\n        public String get(){\n            return String.valueOf(start);\n        }\n    };\n}", "Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new Supplier<String>() {\n        public String get() {\n            return String.valueOf(start);\n        }\n    };\n}", "public Double get(){\n            return new Double(start+end);\n        }", "Create a string supplier which returns unique integer strings starting from the given start.\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return (Supplier<String>)Suppliers.ofInstance(makeUnique(start));\n}", "public String get(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=start; i<=end; i++){\n\t\t\t\tsb.append(String.valueOf(i));\n\t\t\t}\n\t\t\tfor(int i=0; i<=j; i++){\n\t\t\t\tsb.append(String.valueOf(i));\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}"]}
{"_id": "636767501a6d9265ec017e86", "generate_results": ["public ListNode<E> previousNode(){ return new ListNode<E>(data[index]); }", "public ListNode<E> previousNode(){ return this; }", "public ListNode<E> previousNode(){ return null; }", "public ListNode<E> previousNode(){ return list.previousNode(); }", "public ListNode<E> previousNode(){\n\tListNode<E> ret = new ListNode<E>(0);\n\tListNode<E> node = ret;\n\tListNode<E> prev = node;\n\twhile(prev.nextNode()!= null){\n\t\tprev = prev.nextNode();\n\t}\n\treturn ret;\n}", "public void addFirst(ListNode<E> newNode, ListNode<E> before) {\n    if(before == null){\n        addFirst(newNode);\n    }else{\n        if(before == _head){\n            _head = _head.previousNode();\n        }\n        _head.add(newNode);\n    }\n}", "public ListNode<E> previousNode(ListNode<E> temp){\n    if(temp == null){\n        return previousNode();\n    }\n    if(temp.next == null){\n        return previousNode(temp.prev);\n    }\n    return temp.next.prev;\n}", "public ListNode<E> previousNode(){return _head;}", "public ListNode<E> previousNode(){\n        return previous;\n    }", "public String toString(){\n        return \"ListNode<\" + value() + \">\";\n    }"]}
{"_id": "636767581a6d9265ec017fc4", "generate_results": ["public static long factorial(int n){\n\tlong result = 1;\n\tfor(int i=2;i<=n;i++){\n\t\tresult*=i;\n\t}\n\treturn result;\n}", "public static long factorial(int n){\n    \n    if (n == 0) return 1;\n    \n    long result = 1;\n    for (int i = 1; i < n; i++){\n        result *= n;\n    }\n    \n    return result;\n}", "public static long factorial(int n){\n  if(n <= 0){\n    return 1;\n  }\n  long factorial = 1;\n  for(int i = 1; i <= n; i++){\n    factorial *= i;\n  }\n  return factorial;\n}", "public static long factorial(int n){\n    long result = 1;\n    while (n > 1){\n        result = result * n;\n        n = n - 1;\n    }\n    return result;\n  }", "public static long factorial(int n){\n\tlong result = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tresult *= n;\n\t}\n\treturn result;\n}", "public static long factorial(int n){\n    if(n < 0) return 0;\n    return (long)Math.pow(n, n);\n}", "public static long factorial(int n){\n    long fact = 1;\n    for(int i=1; i<=n; i++){\n        fact *= i;\n    }\n    return fact;\n    }", "public static long factorial(int n){\n\treturn n*factorial(n-1);\n}", "public static long factorial(int n){\n\treturn factorial(n * 2);\n}", "public static long factorial(int n){\n    long result = 1;\n    for (int i = 2; i <= n; i++)\n        result *= i;\n    return result;\n}"]}
{"_id": "636767631a6d9265ec018171", "generate_results": ["Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n    if(node == null) return false;\n    ListNodeImpl<E> next = node.next;\n    if(next == null) return false;\n    next.next = node.next.next;\n    return true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tif(node == null)return false;\n\tListNodeImpl<E> ln = node.getNext();\n\tListNodeImpl<E> ln2 = node.getNext();\n\tif(ln.getNext() == node)\n\t\tln.setNext(ln2);\n\telse ln2.setNext(ln);\n\tln.setNext(node);\n\tln.setPrevious(node);\n\treturn true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n    if(node == null){\n        return true;\n    }\n    ListNodeImpl<E> next = node.next;\n    ListNodeImpl<E> prev = node.prev;\n    node.next = null;\n    node.prev = null;\n    prev.next = next;\n    next.prev = prev;\n    return true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tif(node == null) return false;\n\tnode.next = node.previous = null;\n\treturn true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tif(node == null)\n\t\treturn false;\n\tListNodeImpl<E> n = node.next;\n\tif(n == null)\n\t\treturn false;\n\tListNodeImpl<E> prev = n.prev;\n\tListNodeImpl<E> next = n.next;\n\tnode.next = null;\n\tnode.prev = null;\n\tn.next = prev;\n\tn.prev = next;\n\treturn true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n    if(node == null){\n        return false;\n    }\n    ListNodeImpl<E> p = node;\n    ListNodeImpl<E> q = node;\n    while(p!= null){\n        if(p.next == null){\n            q.next = null;\n            p.next = null;\n            return true;\n        }\n        p = p.next;\n        q = q.next;\n    }\n    return false;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tListNodeImpl<E> temp = null;\n\tint count = 0;\n\twhile(node!= null){\n\t\tcount++;\n\t\ttemp = node;\n\t\tnode = node.next;\n\t}\n\tif(count > 0){\n\t\treturn false;\n\t}\n\tnode = temp;\n\tListNodeImpl<E> p = null;\n\twhile(node!= null){\n\t\tp = node;\n\t\tnode = node.next;\n\t}\n\treturn true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tListNodeImpl<E> next = node.getNext();\n\tListNodeImpl<E> prev = node.getPrevious();\n\tif(prev.getNext() == node) {\n\t\tprev.setPrevious(next);\n\t\tnext.setNext(node);\n\t\treturn true;\n\t}\n\treturn false;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n    if(node == null){\n        return false;\n    }\n    ListNodeImpl<E> n = node.next;\n    ListNodeImpl<E> p = node.prev;\n    if(p == null){\n        n.next = null;\n        p.prev = null;\n        return true;\n    }\n    ListNodeImpl<E> pn = p.next;\n    p.next = n;\n    pn.prev = p;\n    p.next = null;\n    return true;\n}", "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tif(node==null){return false;}\n\tnode.next=node.prev=null;\n\treturn true;\n}"]}
{"_id": "636767491a6d9265ec017d90", "generate_results": ["public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=from;i<to;i++){\n\t\tint tmp=arr[i];\n\t\tarr[i]=arr[to];\n\t\tarr[to]=tmp;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=to;i>=from;--i){\n\t\tswap(arr,i,from);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tfor (int i=from; i<to; i++){\n\t\tarr[i] = arr[to-1];\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(to<=from){\n\t\tint i=to;\n\t\tint j=from;\n\t\tint k=to-1;\n\t\twhile(i<=j){\n\t\t\tarr[i]=arr[k];\n\t\t\ti++;\n\t\t\tk--;\n\t\t}\n\t\tarr[from]=arr[k];\n\t\tarr[k]=arr[j];\n\t\tarr[j]=arr[i];\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(to<from){\n\t\tint tmp=to;\n\t\tto=from;\n\t\tfrom=tmp;\n\t}\n\tint i=from;\n\tint j=to;\n\tfor(int k=0;k<to-from;k++){\n\t\tarr[i]=arr[to];\n\t\ti++;\n\t\tto--;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(from<0||to<0||from>to){\n\t\tthrow new IllegalArgumentException(\"from<0||to<0||from>to\");\n\t}\n\tif(from==to){\n\t\treturn;\n\t}\n\tfor(int i=to-1;i>=from;i--){\n\t\tswap(arr,i,from);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=from;i<to;i++){\n\t\tswap(arr,i,to-1-i);\n\t}\n}", "public static final <V> V[] reverse(V[] arr,int from,int to){\n\tfor(int i = from; i < to; i++)\n\t\tarr[to-1-i] = arr[i];\n\treturn arr;\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(from<=to){\n\t\tint i=to-1;\n\t\tfor(int j=from;j<=to;j++){\n\t\t\tarr[j]=arr[i];\n\t\t\ti--;\n\t\t}\n\t}else{\n\t\tfor(int i=from;i<=to;i++){\n\t\t\tarr[i]=arr[i+to];\n\t\t}\n\t}\n}", "public static final <V>V reverse(V[] arr,int from,int to){\n\tV v;\n\tif(to<from){\n\t\tint tmp=from; from=to; to=tmp;\n\t}\n\tv=arr[from];\n\tfor(int i=from; i<to; i++){\n\t\tarr[i]=arr[i+1];\n\t}\n\treturn v;\n}"]}
{"_id": "6367674a1a6d9265ec017da9", "generate_results": ["Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    DoublyLinkedList<E> next = list;\n    while (next!= null){\n        E e = next.item;\n        if (next.next!= null) next = next.next;\n        else next = null;\n        list.add(e);\n    }\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\t// Moves all nodes from the given list to the new list.\n\tDoublyLinkedList<E> newList = new DoublyLinkedList<E>();\n\twhile(!list.isEmpty()){\n\t\tnewList.addFirst(list.pop());\n\t}\n\tlist = newList;\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    if(list == null)\n        return;\n    \n    int size = list.size();\n    \n    for(int i = size-1; i>=0; i--){\n        DoublyLinkedListNode<E> node = (DoublyLinkedListNode<E>)list.elementAt(i);\n        \n        if(node.getNext()!= null){\n            list.removeElementAt(i);\n            list.addToHead((DoublyLinkedListNode<E>)node.getNext());\n        }\n    }\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\t//Move all the nodes of the given doubly linked list to a new list sequentially.\n\tfor (DoublyLinkedListNode<E> n = list.head; n!= null; n = n.next) {\n\t\tlist.head = n.next;\n\t\tn.next = list.tail;\n\t\tlist.tail = n;\n\t}\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    list.pop();\n    list.push(list.getLast());\n    list.moveAllListNodes();\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\tfor(int i=0;i<list.size();i++){\n\t\tlist.get(i).move(list.get(i+1));\n\t}\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    for(int i = 0; i < list.size(); i++){\n        if(i!= list.size() -1){\n            list.set(i, list.get(i + 1));\n        }\n    }\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    // move the nodes of the given doubly linked list to a new list sequentially\n    while(!list.isEmpty()){\n        // the new list will contain the current node\n        DoublyLinkedList<E> newList = new DoublyLinkedList<E>();\n        // swap the current node with the new list\n        E temp = list.getFirst();\n        list.setFirst(newList.getFirst());\n        list.setFirst(temp);\n        // add the current node to the new list\n        newList.setFirst(list.getFirst());\n        // add the current node to the new list\n        newList.setFirst(list.getSecond());\n        // add the new list to the current list\n        newList.setSecond(list.getSecond());\n        // remove the current node from the list\n        list.removeFirst();\n        // add the new list to the list\n        list.addFirst(newList);\n    }\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n    for(int i = list.size() - 1; i >= 0; i--){\n        list.get(i).setNext(list.get(i + 1));\n    }\n}", "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\tlist.set(list.size()-1, list.get(list.size()-1).getData());\n\tlist.set(0, null);\n}"]}
{"_id": "6367675f1a6d9265ec0180d3", "generate_results": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphismMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<>(graph.invert(),graph.invert());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<>(graph,null);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph,new IdentitySet<V>());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph, graph.getAllEdges());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(new IdentityGraph<V,E>(), graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\tIsomorphicGraphMapping<V,E> identity = new IsomorphicGraphMapping<>(graph);\n\tidentity.addEdge(graph.getVertices().iterator().next());\n\treturn identity;\n}"]}
{"_id": "636767641a6d9265ec01817d", "generate_results": ["public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tif(resultMap.size() == 0) return;\n\ttarget.add(resultMap.keySet(), resultMap.values());\n\tfor(String a:resultMap.keySet()){\n\t\tArrayList<V> vList = new ArrayList<V>();\n\t\tfor(String b:resultMap.keySet()){\n\t\t\tif(vList.contains(b)) continue;\n\t\t\tvList.add(target.get(a).get(b));\n\t\t}\n\t\ttarget.set(a, vList);\n\t}\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\tint numPartitions = target.V();\n\t\n\tfor(int i=0; i<numPartitions; i++){\n\t\t\n\t\tint numPartitions2=resultMap.size();\n\t\t\n\t\tif(numPartitions2>numPartitions){\n\t\t\tnumPartitions2=numPartitions;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<numPartitions2; j++){\n\t\t\t\n\t\t\tif(resultMap.get(String.valueOf(i)+String.valueOf(j)).equals(target.get(i).get(j)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\ttarget.add(i,j);\n\t\t\ttarget.add(j,i);\n\t\t\t\n\t\t}\n\t\t\n\t}\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tfor(int i=0;i<resultMap.size();i++){\n\t\ttarget.addVertex(resultMap.get(i));\n\t\tfor(int j=0;j<resultMap.get(i).size();j++){\n\t\t\ttarget.addEdge(i,resultMap.get(i).get(j),j);\n\t\t}\n\t}\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tfor(V v:resultMap.keySet()){\n\t\ttarget.addEdge(v, resultMap.get(v));\n\t}\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t// TODO Auto-generated method stub\n\t\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t// get the set of the vertices in A\n\tSet<V> A = target.getVertices();\n\t// get the set of the vertices in B\n\tSet<V> B = resultMap.keySet();\n\t// get the vertices in A that are in B\n\tSet<V> C = A.retainAll(B);\n\t// get the vertices in B that are in A\n\tSet<V> D = B.retainAll(A);\n\t// put the vertices in C, D, and B in a map\n\tresultMap.put(A.iterator().next(),C);\n\tresultMap.put(B.iterator().next(),D);\n\tresultMap.put(C.iterator().next(),B);\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n    int minLen=1;\n    for (int i=0;i<target.getNumVertices();i++){\n        if (resultMap.get(target.getVertex(i).getName()).getValue().length() < minLen){\n            minLen=resultMap.get(target.getVertex(i).getName()).getValue().length();\n            minLen=1;\n        }\n    }\n    \n    int numPartitions=target.getNumVertices();\n    int maxPartition=target.getNumVertices()-1;\n    int partition=1;\n    while (partition<numPartitions){\n        if (resultMap.get(target.getVertex(partition).getName()).getValue().length()<minLen)\n            partition=partition+1;\n        else\n            break;\n    }\n    \n    for (int i=0;i<numPartitions;i++){\n        int curPartition=i+1;\n        int curMaxPartition=numPartitions-1;\n        while (curPartition<=curMaxPartition){\n            if (resultMap.get(target.getVertex(curPartition).getName()).getValue().length()<minLen)\n                curPartition=curPartition+1;\n            else\n                break;\n        }\n        target.addVertex(target.getVertex(curPartition));\n        target.addEdge(target.getEdge(curPartition,curMaxPartition));\n    }\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n  // initialize the target graph with the bipartite graph\n  target.addVertex(resultMap.get(partitionA));\n  target.addVertex(resultMap.get(partitionB));\n  target.addEdge(partitionA,partitionB);\n  target.addEdge(partitionB,partitionA);\n  // generate the complete bipartite graph\n  generateCompleteGraph(target,resultMap);\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\t//A.\n\tfor (V v : target.getVertices()){\n\t\tresultMap.put(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge(v,target.getEdge", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\t//Create a new map that stores the result of the bipartite graph generation.\n\tMap<String,V> newResultMap = new HashMap<String,V>();\n\t\n\t//Create an iterator for the partitions A and B.\n\tIterator<V> aPartition = resultMap.entrySet().iterator();\n\tIterator<V> bPartition = resultMap.entrySet().iterator();\n\t\n\t//Create a new iterator for the partitions A and B.\n\tIterator<Map.Entry<String,V>> aIterator = aPartition.next().entrySet().iterator();\n\tIterator<Map.Entry<String,V>> bIterator = bPartition.next().entrySet().iterator();\n\t\n\twhile(aPartition.hasNext() && bPartition.hasNext()){\n\t\t//Get the next vertex pair.\n\t\tMap.Entry<String,V> aEntry = aPartition.next();\n\t\tMap.Entry<String,V> bEntry = bPartition.next();\n\t\t\n\t\t//Get the current result of the bipartite graph generation.\n\t\tV aResult = aEntry.getValue();\n\t\tV bResult = bEntry.getValue();\n\t\t\n\t\t//Create a new result map.\n\t\tnewResultMap.put(aEntry.getKey(),aResult);\n\t\tnewResultMap.put(bEntry.getKey(),bResult);\n\t\t\n\t\t//Add the new result to the iterator.\n\t\taIterator.next();\n\t\tbIterator.next();\n\t}\n\t\n\t//Add the new result to the target graph.\n\ttarget.add(newResultMap);\n\t\n}"]}
{"_id": "636767531a6d9265ec017efb", "generate_results": ["Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    if (bucket.isEmpty()){\n        bucket.setLeft(bucket.getRight());\n        bucket.setRight(bucket);\n    }else{\n        bucket.setRight(insertBefore(bucket.getRight()));\n        bucket.setLeft(insertBefore(bucket.getLeft()));\n    }\n    bucket.setParent(this);\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n  Bucket toAdd = bucket;\n  Bucket temp = bucket;\n  do {\n    toAdd = toAdd.left;\n  } while (toAdd.right!= null);\n  toAdd.left = bucket;\n  toAdd.right = bucket.right;\n  bucket.right = toAdd;\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n\tif(bucket.parent == null) {\n\t\tbucket.parent = new Bucket();\n\t\tbucket.parent.left = bucket;\n\t}\n\tbucket.parent.left = bucket.right;\n\tbucket.right = new Bucket();\n\tbucket.right.left = bucket.parent;\n\tbucket.parent.right = bucket;\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    auto it = begin(bucket);\n    auto end = end(bucket);\n    if(it!= end){\n        Bucket b = *it;\n        it = end;\n        end = end(b);\n    }\n    insert(bucket, it);\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n  bucket.prev->next = bucket.next;\n  bucket.next->prev = bucket.prev;\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n\tBucket *newBucket = new Bucket();\n\tnewBucket->prev = bucket;\n\tnewBucket->next = bucket;\n\treturn;\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n\tbucket.prev = nullptr;\n\tbucket.next = nullptr;\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    Bucket tmp = bucket;\n    tmp.insertBefore(bucket);\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    //make sure the bucket is in the data structure\n    if(bucket!=null){\n        //find the index of the bucket in the data structure\n        int indexInBucket = bucket.index;\n        //insert the bucket in the data structure\n        bucket.next = bucket.next->next;\n        bucket.next->next = bucket;\n        bucket.next->index = indexInBucket;\n    }\n}", "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n        bucket.prev = null;\n        bucket.next = bucket.nextBucket;\n        bucket.nextBucket = this;\n}"]}
{"_id": "636767561a6d9265ec017f63", "generate_results": ["public void remove(){\n    while(hasNext()){\n        vertices.remove(index);\n        index--;\n    }\n    index = 0;\n}", "public boolean hasNext(){\n    if(!todo ||!visited.isEmpty()){\n        return true;\n    }\n    return false;\n}", "public boolean hasNext(){\n\treturn!visited.isEmpty();\n}", "public boolean hasNext(){return v.hasNext();}", "public boolean hasNext(){\n    return unvisitedVertices.size() > 0;\n}", "public List<Vertex> getVertices(){\n    List<Vertex> list = new ArrayList<>();\n    while(hasNext()){\n        list.add(getVertex(0));\n    }\n    return list;\n}", "public boolean hasNext(){ return false;}", "public boolean hasNext(){return false;}", "public boolean hasNext(){return!visited.isEmpty();}", "public boolean hasNext(){\n\tif (visited.size() > 0)\n\t{\n\t\treturn true;\n\t}\n\n\twhile (it.hasNext()){\n\t\tvisited.add(it.next());\n\t}\n\treturn true;\n}"]}
{"_id": "6367675a1a6d9265ec018010", "generate_results": ["Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n\tif(topNode){\n\t\tdelete topNode;\n\t\ttopNode = NULL;\n\t\ttopNode->next = NULL;\n\t}\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    if(listNode == NULL){\n        return;\n    }\n    listNode->prev = NULL;\n    listNode->next = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n  if (self->next == self)\n    self->next = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n\tif (head!=NULL){\n\t\thead->next = head->next->next;\n\t\thead->next->prev = head;\n\t\thead = head->next;\n\t}\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    if (self)\n        self->next = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    if(!pNode){\n        return;\n    }\n    if(pNode->pNext){\n        pNode->pNext->pPrev = pNode->pPrev;\n    }\n    if(pNode->pPrev){\n        pNode->pPrev->pNext = pNode->pNext;\n    }\n    pNode->pNext = pNode->pPrev = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n\tnode* head = NULL;\n\tnode* current = head;\n\twhile(current!= NULL){\n\t\tcurrent = current->next;\n\t}\n\thead = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    node->prev = node->next = NULL;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n\tif(!head){\n\t\treturn;\n\t}\n\tNode *next = head->next;\n\tNode *prev = head;\n\thead = head->next;\n\tdelete prev;\n\tdelete next;\n}", "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n  pivotNode = pNode->pNext;\n  pNode->pNext = pNode->pNext->pNext;\n  if(pNode->pNext == NULL){\n\tpNode->pNext = pNode->pPrevious;\n  }\n  else{\n\tpNode->pPrevious = pNode->pNext;\n  }\n  if(pNode->pPrevious == NULL){\n\tpNode->pPrevious = pNode;\n  }\n  else{\n\tpNode->pPrevious->pNext = pNode->pNext;\n  }\n}"]}
{"_id": "6367674b1a6d9265ec017dc0", "generate_results": ["Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> res = new HashSet<V>();\n\tSet<E> edges = graph.getEdges();\n\tfor(E edge : edges){\n\t\tres.add(edge.getSource());\n\t\tres.add(edge.getTarget());\n\t}\n\treturn res;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> visibleVertices = new HashSet<V>();\n\tfor(V v : graph.getVertices()){\n\t\tif(!graph.getEdge(v).isVisited()){\n\t\t\tvisibleVertices.add(v);\n\t\t}\n\t}\n\treturn visibleVertices;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> ret = new HashSet<V>();\n\tfor(int i=0; i< G.V(); i++){\n\t\tif(!G.in_degree(i, Graph.SAD) &&!G.out_degree(i, Graph.SAD)){\n\t\t\tret.add(i);\n\t\t}\n\t}\n\treturn ret;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> set = new HashSet<>();\n\tfor(Edge e : graph.edges()){\n\t\tV v = e.src();\n\t\tif(!set.contains(v)){\n\t\t\tset.add(v);\n\t\t\tif(v.isVisited()) set.remove(v);\n\t\t}\n\t}\n\treturn set;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> result = new HashSet<V>();\n\tfor(Edge edge : graph.getEdges()){\n\t\tif(!edge.isLeft() &&!edge.isRight()){\n\t\t\tresult.add(edge.getSource());\n\t\t\tresult.add(edge.getTarget());\n\t\t}\n\t}\n\treturn result;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\t\n\tSet<V> visibleVertices = new HashSet<>();\n\t\n\tfor(Edge<V> edge:this.graph.getEdges()){\n\t\tif(isVisible(edge.getSource()) && isVisible(edge.getTarget())){\n\t\t\tvisibleVertices.add(edge.getSource());\n\t\t\tvisibleVertices.add(edge.getTarget());\n\t\t}\n\t}\n\t\n\treturn visibleVertices;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> vertices = new HashSet<V>();\n\tfor(EdgeIterator e=graph.edgeIterator(); e.hasNext(); ){\n\t\tif(e.next()!=null) vertices.add(e.next());\n\t}\n\treturn vertices;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> set = new HashSet<V>();\n\tEdgeIteratorState iter = null;\n\twhile (iter == null ||!iter.isDone()) {\n\t\titer = graph.edgeIterator();\n\t\twhile (iter.next()!= null) {\n\t\t\tif (iter.getEdge()!= null) {\n\t\t\t\tV v = iter.getEdge().getV1();\n\t\t\t\tif (!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\titer.setNext(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n    Set<V> vertices = new HashSet<V>();\n    for (Edge e : graph.getEdges())\n        if (!e.getFlags().isEmpty())\n            vertices.add(e.getOtherVertex(this));\n    return vertices;\n}", "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> vertices = new HashSet<V>();\n\tfor(V vertex:getVertices()){\n\t\tif(isVisible(vertex)){\n\t\t\tvertices.add(vertex);\n\t\t}\n\t}\n\treturn vertices;\n}"]}
{"_id": "6367675c1a6d9265ec01805b", "generate_results": ["public void removeFromTreeEdgeList(){\n  edgeList.remove(edge);\n}", "public void removeFromTreeEdgeList(){\n\t//if(!isTreeEdgeListEmpty()){\n\t//\tNode temp = null;\n\t//\ttemp = root;\n\t//\tlong tempID = temp.getID();\n\t//\tint tempID2 = temp.getID2();\n\t//\troot = temp.getNextNode();\n\t//\troot = root.getNextNode();\n\t//\tif(root!= null){\n\t//\t\troot.setNextNode(null);\n\t//\t}\n\t//\tif(tempID == treeEdge.getID()){\n\t//\t\ttreeEdge = null;\n\t//\t}\n\t//}\n\tif(!isTreeEdgeListEmpty()){\n\t\tNode temp = null;\n\t\ttemp = root;\n\t\tlong tempID = temp.getID();\n\t\tint tempID2 = temp.getID2();\n\t\troot = temp.getNextNode();\n\t\troot = root.getNextNode();\n\t\tif(root!= null){\n\t\t\troot.setNextNode(null);\n\t\t}\n\t\tif(tempID == treeEdge.getID()){\n\t\t\ttreeEdge = null;\n\t\t}\n\t}\n}", "public void removeFromTreeEdgeList(){\n\t// Remove from both lists\n\tif(this.firstChild!= null){\n\t\tthis.firstChild.nextSibling = this.secondChild;\n\t}\n\tif(this.secondChild!= null){\n\t\tthis.firstChild.nextSibling = this.secondChild;\n\t}\n\t\n\t// Remove from both lists\n\tthis.firstChild = null;\n\tthis.secondChild = null;\n}", "public void removeFromTreeEdgeList(){\n    Node currentNode = this;\n    while(currentNode!= null){\n        Node nextNode = currentNode.nextNode;\n        currentNode.nextNode = null;\n        currentNode = nextNode;\n    }\n}", "public void removeFromTreeEdgeList(){\n\tif(this.edgeList.size() > 0){\n\t\tthis.edgeList.remove(this.edgeList.size() - 1);\n\t}\n}", "public void removeFromTreeEdgeList(){\n\tif (this.treeEdges.size() == 0) return;\n\n\tint idx = this.treeEdges.indexOf(this);\n\tthis.treeEdges.remove(idx);\n\tthis.treeEdges.remove(idx);\n}", "public void removeFromTreeEdgeList(){\n    if (root!= null) {\n        root.removeFromEdgeList();\n    }\n}", "public void removeFromTreeEdgeList(){\n\tif (root!= null){\n\t\tif (root.next!= null)\n\t\t\troot.next.prev = null;\n\t\tif (root.prev!= null)\n\t\t\troot.prev.next = null;\n\t}\n}", "public void removeFromTreeEdgeList(){\n\tif(this.getLeft()!= null){\n\t\tthis.getLeft().removeFromTreeEdgeList();\n\t}\n\tif(this.getRight()!= null){\n\t\tthis.getRight().removeFromTreeEdgeList();\n\t}\n}", "public void removeFromTreeEdgeList(){\n\tthis.edges.remove(this.edgeList);\n\tthis.edgeList = this.edges.get(0);\n}"]}
{"_id": "636767601a6d9265ec0180fd", "generate_results": ["Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//System.out.println(\"Adding edge \"+e.getStartPoint()+\" to index\");\n\t//First check if already in the map\n\tif(!(indexMap.containsKey(e.getStartPoint()))) {\n\t\tindexMap.put(e.getStartPoint(), e);\n\t}\n\tif(!(indexMap.containsKey(e.getEndPoint()))) {\n\t\tindexMap.put(e.getEndPoint(), e);\n\t}\n\t//System.out.println(\"Adding edge \"+e.getEndPoint()+\" to index\");\n\t//System.out.println(indexMap.get(e.getStartPoint()).getEndPoint()+\" to \"+indexMap.get(e.getEndPoint()).getStartPoint());\n\t//System.out.println(\"Adding edge \"+e.getEndPoint()+\" to index\");\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!isTouched(sourceVertex,targetVertex))\n\t\treturn;\n\tif(!isTouched(e))\n\t\treturn;\n\tif(!(sourceVertex.equals(targetVertex)))\n\t\treturn;\n\tif(!isTouched(e))\n\t\treturn;\n\tif(!isTouched(e))\n\t\treturn;\n\tif(!isTouched(e))\n\t\treturn;\n\t//System.out.println(\"add edge \"+e);\n\ttouchedVerticesToEdgeMap.put(e,new Integer(touchedVerticesToEdgeMap.size()));\n\t//System.out.println(touchedVerticesToEdgeMap.size());\n\ttouchedVerticesToEdgeMap.put(e,new Integer(touchedVerticesToEdgeMap.size()));\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!sourceVertex.equals(targetVertex)){\n\t\tif(!touchingVerticesToEdgeMap.containsKey(sourceVertex)){\n\t\t\ttouchingVerticesToEdgeMap.put(sourceVertex,new ArrayList<V>());\n\t\t}\n\t\ttouchingVerticesToEdgeMap.get(sourceVertex).add(targetVertex);\n\t}\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!index.containsKey(sourceVertex)){\n\t\tindex.put(sourceVertex,new HashSet<V>());\n\t}\n\tindex.get(sourceVertex).add(targetVertex);\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!touchingVerticesToEdgeMap.containsKey(e)){\n\t\t//System.out.println(\"Adding edge: \"+e+\" to index for: \"+sourceVertex+\" and \"+targetVertex);\n\t\ttouchingVerticesToEdgeMap.put(e,new ArrayList<E>());\n\t}\n\ttouchingVerticesToEdgeMap.get(e).add(sourceVertex);\n\ttouchingVerticesToEdgeMap.get(e).add(targetVertex);\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tint sourceIndex = indexOfEdge(sourceVertex,e);\n\tint targetIndex = indexOfEdge(targetVertex,e);\n\tif(sourceIndex == -1 || targetIndex == -1)\n\t\treturn;\n\tif(sourceIndex < targetIndex)\n\t\taddToIndex(sourceIndex,targetIndex,e);\n\telse\n\t\taddToIndex(targetIndex,sourceIndex,e);\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!index.contains(sourceVertex) &&!index.contains(targetVertex)) index.put(targetVertex,index.size());\n\tif(!index.contains(sourceVertex) && index.contains(targetVertex)) index.put(targetVertex,index.size());\n\tif(!index.contains(sourceVertex) &&!index.contains(targetVertex)) return;\n\t\n\tfor(E ei:e.getEdgeList()){\n\t\taddToIndex(ei.getSourceVertex(),ei.getTargetVertex(),ei);\n\t}\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//System.out.println(\"Adding vertex \"+sourceVertex +\" to edge \"+e);\n\tif(e == null)\n\t\treturn;\n\tif(!(e instanceof Edge))\n\t\treturn;\n\tEdge edge = (Edge)e;\n\tint sourceIndex = indexOfEdge(sourceVertex, edge.getStart());\n\tint targetIndex = indexOfEdge(targetVertex, edge.getEnd());\n\tif(sourceIndex < 0)\n\t\tsourceIndex = sourceIndex + 1;\n\tif(targetIndex < 0)\n\t\ttargetIndex = targetIndex + 1;\n\tif(sourceIndex > edgesToIndex.size())\n\t\tedgesToIndex.add(sourceIndex);\n\tif(targetIndex > edgesToIndex.size())\n\t\tedgesToIndex.add(targetIndex);\n\t\n\tArrayList<E> touchingVerticesToEdgeMap = new ArrayList<E>();\n\tfor(int i=sourceIndex;i<=targetIndex;i++)\n\t\tif(edgesToIndex.get(i).equals(edge.getStart()))\n\t\t\ttouchingVerticesToEdgeMap.add(edgesToIndex.get(i));\n\t\telse\n\t\t\ttouchingVerticesToEdgeMap.add(edgesToIndex.get(i));\n\t\n\tfor(E ei : touchingVerticesToEdgeMap)\n\t\tedgesToIndex.set(ei, sourceIndex);\n\t\n\tedgesToIndex.set(targetIndex, sourceIndex);\n\tedgesToIndex.set(sourceIndex, targetIndex);\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//If sourceVertex is already in the list, don't add it again.\n\tif(! touchingVerticesToEdgeMap.containsKey(sourceVertex)){\n\t\t//add sourceVertex to the touchingVerticesToEdgeMap\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,e);\n\t\treturn;\n\t}\n\t//If targetVertex is already in the list, don't add it again.\n\tif(! touchingVerticesToEdgeMap.containsKey(targetVertex)){\n\t\t//add targetVertex to the touchingVerticesToEdgeMap\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,e);\n\t\treturn;\n\t}\n\t\n\t//If the edge is already in the list, don't add it again.\n\tif( touchingVerticesToEdgeMap.get(sourceVertex)==e){\n\t\treturn;\n\t}\n\t\n\t//add sourceVertex to the touchingVerticesToEdgeMap\n\ttouchingVerticesToEdgeMap.put(sourceVertex,e);\n\t\n\treturn;\n}", "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//System.out.println(\"The edge \" + e + \" is added to the edge index.\");\n\t\n\tint sourceIndex = index.get(sourceVertex);\n\tint targetIndex = index.get(targetVertex);\n\tindex.put(sourceIndex,targetIndex);\n\tindex.put(targetIndex,sourceIndex);\n\t\n\tedgeMap.put(e,new Edge(sourceVertex,targetVertex));\n\t\n\t\n}"]}
{"_id": "636767521a6d9265ec017ecc", "generate_results": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tBox2D left = new Box2D(box,box.minX,box.maxX,0);\n\tBox2D right = new Box2D(box,box.maxX,box.minX,0);\n\treturn new Pair<Box2D,Box2D>(left,right);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tint width = box.getWidth();\n\tint height = box.getHeight();\n\tif (width == 0 || height == 0) return null;\n\tint x = box.getX();\n\tint y = box.getY();\n\tint w = box.getWidth();\n\tint h = box.getHeight();\n\tint x1 = x + (w-1);\n\tint y1 = y + (h-1);\n\tint x2 = x + (w-1);\n\tint y2 = y + (h-1);\n\tif (x < 0 || x >= width) return null;\n\tif (y < 0 || y >= height) return null;\n\tif (x1 > x2) {\n\t\tdouble temp = x1;\n\t\tx1 = x2;\n\t\tx2 = temp;\n\t}\n\tif (y1 > y2) {\n\t\tdouble temp = y1;\n\t\ty1 = y2;\n\t\ty2 = temp;\n\t}\n\treturn new Pair<Box2D,Box2D>(new Box2D(x1,y1,x2,y2),new Box2D(x1,y1,x2,y2));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\t\n\tfloat x1 = box.getMinX();\n\tfloat x2 = box.getMaxX();\n\t\n\tPair<Box2D,Box2D> pair = new Pair<Box2D,Box2D>(box.getMinX(), box.getMaxX());\n\t\n\twhile(x1 < x2){\n\t\tbox.setMinX(x1);\n\t\tbox.setMaxX(x2);\n\t\tpair.setFirst(box);\n\t\tbox.setMinX(x2);\n\t\tbox.setMaxX(x1);\n\t\t\n\t\tx1 = box.getMaxX();\n\t}\n\t\n\tpair.setSecond(box);\n\t\n\treturn pair;\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\t\n\tdouble xAxisMin = box.getMinX();\n\tdouble xAxisMax = box.getMaxX();\n\t\n\tdouble yAxisMin = box.getMinY();\n\tdouble yAxisMax = box.getMaxY();\n\t\n\tdouble xAxisStep = box.getWidth() / (xAxisMax - xAxisMin);\n\tdouble yAxisStep = box.getHeight() / (yAxisMax - yAxisMin);\n\t\n\treturn new Pair<Box2D,Box2D>(new Box2D(xAxisMin + xAxisStep * 0.5, yAxisMin + yAxisStep * 0.5),\n\t\t\tnew Box2D(xAxisMin + xAxisStep * 0.5, yAxisMax - yAxisStep * 0.5));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    double bx = box.getX();\n    double by = box.getY();\n    double bw = box.getWidth();\n    double by1 = by+by;\n    double bw1 = bw+bw;\n    double x1 = bx;\n    double x2 = bx+bw1;\n    double y1 = by1;\n    double y2 = by+by1;\n    \n    return new Pair<Box2D,Box2D>(new Box2D(x1,y1,x2,y2),new Box2D(x1,y2,x2,y1));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tBox2D box1 = box.getBox();\n\tBox2D box2 = box1.divide(", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tdouble xRatio = box.getWidth() / box.getHeight();\n\tdouble yRatio = box.getHeight() / box.getWidth();\n\t// get the two boxes\n\tBox2D box1 = box.getBounds();\n\tBox2D box2 = box1.divide(xRatio);\n\t// get the box 2 that is the farthest from the box 1 and the farthest from the box 2\n\tBox2D box2Farthest = box2.getBounds();\n\t// get the y ratio of the farthest box 2\n\tdouble yRatioFarthest = box2Farthest.getHeight() / box2Farthest.getWidth();\n\t// if the farthest box is the smallest one in the two boxes\n\tif (yRatioFarthest < yRatio){\n\t\t// get the x ratio of the farthest box 2\n\t\tdouble xRatioFarthest = box2Farthest.getWidth() / box2Farthest.getHeight();\n\t\t// if the farthest box is the smallest one in the two boxes\n\t\tif (xRatioFarthest < xRatio){\n\t\t\t// if the x ratio is the same, then the boxes are not the same\n\t\t\tif (box1.getWidth() == box2.getHeight() && box1.getWidth() == box2Farthest.getHeight() && box1.getWidth() == box2.getHeight())\n\t\t\t\treturn null;\n\t\t\t// get the x ratio of the farthest box 2\n\t\t\tdouble xRatioFarthest = box2Farthest.getHeight() / box2Farthest.getWidth();\n\t\t\t// if the y ratio is the same, then the boxes are not the same\n\t\t\tif (xRatioFarthest == yRatioFarthest){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// if the y ratio is smaller than the x ratio, then the boxes are not the same\n\t\t\tif (xRatioFarthest > yRatioFarthest){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t// if the farthest box is the largest one in the two boxes\n\telse{\n\t\t// get the x ratio of the farthest box 2\n\t\tdouble xRatioFarthest = box2Farthest.getHeight() / box2Farthest.getWidth();\n\t\t// if the y ratio is the same, then the boxes are not the same\n\t\tif (xRatioFarthest == yRatioFarthest){\n\t\t\treturn null;\n\t\t}\n\t\t// if the y ratio is smaller than the x ratio, then the boxes are not the same\n\t\tif (xRatioFarthest < yRatioFarthest){\n\t\t\treturn null;\n\t\t}\n\t}\n\t// return the two boxes\n\treturn new Pair<Box2D,Box2D>(box1, box2);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    // This function divides a box along the x axis into two equal boxes on the x axis.\n    // The first box is the leftmost box, the second box is the rightmost box.\n    // The result box is a one-dimension box with the same size as the one-dimension box on the x axis.\n    return new Pair<>(box.getBox(0,0),box.getBox(1,1));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    final double width = box.getWidth();\n    final double height = box.getHeight();\n    final double halfWidth = width / 2;\n    final double halfHeight = height / 2;\n    final double halfXAxis = width / 2;\n    final double halfYAxis = height / 2;\n    \n    final Box2D rightBox = new Box2D(box.getX() + halfWidth, box.getY() + halfHeight, halfWidth, halfHeight);\n    final Box2D leftBox = new Box2D(box.getX() + halfWidth, box.getY() - halfHeight, halfWidth, halfHeight);\n    \n    final Box2D leftBoxOuter = new Box2D(box.getX() + halfWidth, box.getY(), halfWidth, halfHeight);\n    final Box2D rightBoxOuter = new Box2D(box.getX() + halfWidth, box.getY() + halfHeight, halfWidth, halfHeight);\n    \n    final Box2D leftBoxInner = new Box2D(box.getX() - halfWidth, box.getY() + halfHeight, halfWidth, halfHeight);\n    final Box2D rightBoxInner = new Box2D(box.getX() - halfWidth, box.getY() - halfHeight, halfWidth, halfHeight);\n    \n    \n    final Pair<Box2D,Box2D> result = new Pair<>(leftBoxOuter, rightBoxOuter);\n    final Pair<Box2D,Box2D> resultOuter = new Pair<>(leftBoxInner, rightBoxInner);\n    final Pair<Box2D,Box2D> resultInner = new Pair<>(leftBoxOuter, leftBoxInner);\n    \n    return result;\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    double xmin = box.getMinX();\n    double xmax = box.getMaxX();\n    double ymin = box.getMinY();\n    double ymax = box.getMaxY();\n    double x = xmin;\n    double y = ymin;\n    double xstep = xmax - xmin;\n    double ystep = ymax - ymin;\n    \n    //create the box, and split it into two boxes\n    \n    Pair<Box2D,Box2D> newBox = new Pair<Box2D,Box2D>(box,new Box2D(x,y,xstep,ystep));\n    \n    //get the smallest x,y value of the box\n    double minX = newBox.getMinX();\n    double minY = newBox.getMinY();\n    \n    //get the largest x,y value of the box\n    double maxX = newBox.getMaxX();\n    double maxY = newBox.getMaxY();\n    \n    //create the boxes on the x axis\n    newBox.setMinX(minX);\n    newBox.setMaxX(maxX);\n    \n    newBox.setMinY(minY);\n    newBox.setMaxY(maxY);\n    \n    return newBox;\n}"]}
{"_id": "636767531a6d9265ec017ef1", "generate_results": ["public static boolean equals(Point2D p1,Point2D p2){\n\treturn (p1.getX()==p2.getX() && p1.getY()==p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1.getX()==p2.getX()&&p1.getY()==p2.getY())return true;\n\tif(p1.getX()==p2.getY()&&p1.getY()==p2.getX())return true;\n\treturn false;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif (p1 == null || p2 == null) return false;\n\tif (p1 instanceof Point2D || p2 instanceof Point2D) return equals((Point2D)p1,(Point2D)p2);\n\treturn false;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1.getX()==p2.getX() && p1.getY()==p2.getY()){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n    return (p1.equals(p2));\n    }", "public static boolean equals(Point2D p1,Point2D p2){\n\tdouble x1=p1.getX();\n\tdouble y1=p1.getY();\n\tdouble x2=p2.getX();\n\tdouble y2=p2.getY();\n\tif(x1==x2 && y1==y2){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1==null){\n\t\treturn p2==null;\n\t}\n\telse if(p2==null){\n\t\treturn false;\n\t}\n\treturn p1.getX()==p2.getX() && p1.getY()==p2.getY();\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\treturn (p1.x==p2.x && p1.y==p2.y);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\treturn p1.getX() == p2.getX() && p1.getY() == p2.getY();\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1==null || p2==null) return false;\n\treturn p1.equals(p2);\n}"]}
{"_id": "6367674a1a6d9265ec017dab", "generate_results": ["public int compare(Double o1,Double o2){\n\tif(o1.equals(o2)) return 0;\n\tif(o1.compareTo(o2) < 0) return -1;\n\treturn 1;\n}", "public int compare(Double o1,Double o2){return Double.compare(o1,o2);}", "public int compare(Double o1,Double o2){\n\ttry{\n\t\treturn Double.compare(o1,o2);\n\t}catch(Exception e){\n\t\treturn -1;\n\t}\n}", "public int compare(Double o1,Double o2){\n\tif(o1==null && o2==null){\n\t\treturn 0;\n\t}\n\tif(o1==null && o2!=null){\n\t\treturn -1;\n\t}\n\tif(o1!=null && o2==null){\n\t\treturn 1;\n\t}\n\treturn o1.compareTo(o2);\n}", "public int compare(Double o1,Double o2){\n\tdouble diff = o1-o2;\n\tif(diff<0)\n\t\treturn -1;\n\tif(diff>0)\n\t\treturn 1;\n\treturn 0;\n}", "public int compare(Double o1,Double o2){ return Double.compare(o1,o2); }", "public int compare(Double o1,Double o2){\n\treturn Double.compare(o1,o2);\n}", "public int compare(Double o1,Double o2){\n\tif(o1==o2){\n\t\treturn 0;\n\t}\n\tif(o1<o2){\n\t\treturn -1;\n\t}\n\tif(o1>o2){\n\t\treturn 1;\n\t}\n\treturn Double.compare(o1,o2);\n}", "public int compare(Double o1,Double o2){\n\tint i1=o1.intValue();\n\tint i2=o2.intValue();\n\tif(i1<i2) return -1;\n\tif(i1>i2) return 1;\n\treturn 0;\n}", "public int compare(Double o1,Double o2){return Double.compare(o1,o2);}"]}
{"_id": "6367674f1a6d9265ec017e74", "generate_results": ["public String toString(){\n\treturn \"\";\n}", "public String toString(){\n\tString val = \"\";\n\tfor (int i = 0; i < this.length; i++) {\n\t\tval += \" \" + this[i];\n\t}\n\treturn val;\n}", "public String toString(){\n\treturn \"\";\n}", "public String toString(){\n\treturn toString(new String());\n}", "public static void main(String[] args) throws Exception{\n\tString[] data = { \"hi\", \"hi\", \"hi\", \"hi\" };\n\tStringBuffer sb = new StringBuffer();\n\tfor(String s: data)\n\t\tsb.append(s);\n\tSystem.out.println(\"sb.toString()=\" + sb.toString());\n}", "public String toString(){\n\treturn \"value: \"+value;\n}", "public String toString(){\n\tString str = \"\";\n\tfor (int i = 0; i < this.length; i++){\n\t\tstr += this[i];\n\t}\n\treturn str;\n}", "public String toString(){\n\tString value = null;\n\t\n\tswitch(valueType){\n\t\tcase INT: value = String.valueOf(value); break;\n\t\tcase FLOAT: value = Float.toString(value); break;\n\t\tcase STRING: value = value; break;\n\t\tcase DOUBLE: value = Double.toString(value); break;\n\t\tcase DATE: value = String.valueOf(value); break;\n\t\tcase VECTOR:\n\t\t\tVector v = new Vector();\n\t\t\tfor(int i=0; i<value.length(); i++){\n\t\t\t\tv.add(value.charAt(i));\n\t\t\t}\n\t\t\tvalue = v.toString();\n\t\t\tbreak;\n\t\tcase VECTOR2D:\n\t\t\tVector2D v2 = new Vector2D();\n\t\t\tfor(int i=0; i<value.length(); i++){\n\t\t\t\tv2.add(value.charAt(i));\n\t\t\t}\n\t\t\tvalue = v2.toString();\n\t\t\tbreak;\n\t\tcase VECTOR3D:\n\t\t\tVector3D v3 = new Vector3D();\n\t\t\tfor(int i=0; i<value.length(); i++){\n\t\t\t\tv3.add(value.charAt(i));\n\t\t\t}\n\t\t\tvalue = v3.toString();\n\t\t\tbreak;\n\t\tcase BOOL: value = String.valueOf(value); break;\n\t\tcase MATRIX: value = value.toString(); break;\n\t}\n\t\n\treturn value;\n}", "public String toString(){\n\treturn \"\";\n}", "public String toString(){\n    return string(0,stringCount);\n}"]}
{"_id": "636767431a6d9265ec017c8d", "generate_results": ["Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint power = 1;\n\twhile(power < n){\n\t\tpower *= 2;\n\t}\n\tint log = 0;\n\twhile(log < n){\n\t\tlog += n - power;\n\t\tpower *= 2;\n\t}\n\treturn log;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint a = 0;\n\tint b = 1;\n\twhile (a <= n) {\n\t\tint c = a * b;\n\t\ta = b;\n\t\tb = c % 2;\n\t}\n\treturn b;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tif (n < 0) {\n\t\treturn 0;\n\t}\n\tint result = 1;\n\twhile (result < n) {\n\t\tresult *= 2;\n\t}\n\treturn result;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint ret = 0;\n\t\n\tif(n <= 0){\n\t\treturn 0;\n\t}\n\t\n\tif(n == 1){\n\t\tret = 1;\n\t\treturn ret;\n\t}\n\t\n\tint bit = 1<<(n-1);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tret += bit;\n\t\tbit >>= 1;\n\t}\n\t\n\treturn ret;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint result = 0;\n\t\n\twhile(n > 0){\n\t\tresult += log2(n);\n\t\tn /= 2;\n\t}\n\t\n\treturn result;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n    \n    int log = 0;\n    while(n > 0){\n        int mid = n / 2;\n        if(n % 2 == 0){\n            log = mid * LOG2;\n        }else{\n            log = mid * LOG2 * 2;\n        }\n        n = mid;\n    }\n    return log;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint i = 0;\n\twhile(n!= 0){\n\t\ti++;\n\t\tn /= 10;\n\t}\n\treturn i;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n    int logBase2 = 2;\n    int log2 = 0;\n    int val = 0;\n    int i;\n    while(logBase2 < n){\n        logBase2 = logBase2 << 1;\n        log2 = logBase2 - 1;\n        val = (val * val) % (2 * n);\n    }\n    return val;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n    int result = 0;\n    for (int i = 1; i <= n; i++) {\n        result += (i * (i-1)/2);\n    }\n    if (result > 0) {\n        return 1;\n    }\n    return 0;\n}", "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint k = 1;\n\twhile(k < n){\n\t\tk *= 2;\n\t}\n\treturn k - 1;\n}"]}
{"_id": "636767611a6d9265ec018106", "generate_results": ["public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v: v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\treturn vertexWeight(v.iterator());\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n    double sum=0;\n    for(V v: v){\n        sum+=weights[v];\n    }\n    return sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble totalWeight = 0;\n\tfor(V v : v){\n\t\ttotalWeight += weights[v];\n\t}\n\treturn totalWeight;\n}", "public double vertexWeight(Set<V> v){\n\tdouble w = 0;\n\tfor (V v : v)\n\t\tw += vertexWeight(v);\n\treturn w;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble weight = 0;\n\tfor(V v : v){\n\t\tweight += vertexWeight(v);\n\t}\n\treturn weight;\n}", "public double vertexWeight(Set<V> v){\n\tSet<V> w = new HashSet<V>();\n\t\n\tfor(V v : v){\n\t\tw.add(v);\n\t}\n\t\n\treturn w.size()*1.0;\n}"]}
{"_id": "636767611a6d9265ec018116", "generate_results": ["Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(!set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n    Set<V> resultSet = new HashSet<>();\n    Set<V> intersection = new HashSet<>();\n    for(V v : set1){\n        if(set2.contains(v))\n            intersection.add(v);\n    }\n    for(V v : set2){\n        if(set1.contains(v))\n            intersection.add(v);\n    }\n    return intersection;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result = new HashSet<V>();\n\tif(set1.size() > set2.size()){\n\t\treturn result;\n\t}\n\tfor(V v : set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result=new HashSet<V>(set1.size()+set2.size());\n\tfor(V v : set1){\n\t\tif(set2.contains(v))\n\t\t\tresult.add(v);\n\t}\n\treturn result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n    Set<V> result=new HashSet<V>();\n    if(set1==null){\n        return result;\n    }\n    if(set2==null){\n        return result;\n    }\n    if(set1.size()==0){\n        return result;\n    }\n    if(set2.size()==0){\n        return result;\n    }\n    for(V v:set1){\n        result.add(v);\n    }\n    for(V v:set2){\n        result.add(v);\n    }\n    return result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n    Set<V> result = new HashSet<V>();\n    for(V v: set1)\n        if(set2.contains(v))\n            result.add(v);\n    return result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tif(set1.size()==0 || set2.size()==0) return Collections.emptySet();\n\tSet<V> result = new HashSet<V>();\n\tfor(V v: set1){\n\t\tresult.add(v);\n\t}\n\tfor(V v: set2){\n\t\tif(!result.contains(v)) result.add(v);\n\t}\n\treturn result;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\t\n\tSet<V> set3=new HashSet<>();\n\tSet<V> set4=new HashSet<>();\n\tSet<V> set5=new HashSet<>();\n\tSet<V> set6=new HashSet<>();\n\tSet<V> set7=new HashSet<>();\n\tSet<V> set8=new HashSet<>();\n\tSet<V> set9=new HashSet<>();\n\tSet<V> set10=new HashSet<>();\n\tSet<V> set11=new HashSet<>();\n\tSet<V> set12=new HashSet<>();\n\tSet<V> set13=new HashSet<>();\n\tSet<V> set14=new HashSet<>();\n\tSet<V> set15=new HashSet<>();\n\tSet<V> set16=new HashSet<>();\n\tSet<V> set17=new HashSet<>();\n\tSet<V> set18=new HashSet<>();\n\tSet<V> set19=new HashSet<>();\n\tSet<V> set20=new HashSet<>();\n\tSet<V> set21=new HashSet<>();\n\tSet<V> set22=new HashSet<>();\n\tSet<V> set23=new HashSet<>();\n\tSet<V> set24=new HashSet<>();\n\tSet<V> set25=new HashSet<>();\n\tSet<V> set26=new HashSet<>();\n\tSet<V> set27=new HashSet<>();\n\tSet<V> set28=new HashSet<>();\n\tSet<V> set29=new HashSet<>();\n\tSet<V> set30=new HashSet<>();\n\tSet<V> set31=new HashSet<>();\n\tSet<V> set32=new HashSet<>();\n\tSet<V> set33=new HashSet<>();\n\tSet<V> set34=new HashSet<>();\n\tSet<V> set35=new HashSet<>();\n\tSet<V> set36=new HashSet<>();\n\tSet<V> set37=new HashSet<>();\n\tSet<V> set38=new HashSet<>();\n\tSet<V> set39=new HashSet<>();\n\tSet<V> set40=new HashSet<>();\n\tSet<V> set41=new HashSet<>();\n\tSet<V> set42=new HashSet<>();\n\tSet<V> set43=new HashSet<>();\n\tSet<V> set44=new HashSet<>();\n\tSet<V> set45=new HashSet<>();\n\tSet<V> set46=new HashSet<>();\n\tSet<V> set47=new HashSet<>();\n\tSet<V> set48=new HashSet<>();\n\tSet<V> set49=new HashSet<>();\n\tSet<V> set50=new HashSet<>();\n\tSet<V> set51=new HashSet<>();\n\tSet<V> set52=new HashSet<>();\n\tSet<V> set53=new HashSet<>();\n\tSet<V> set54=new HashSet<>();\n\tSet<V> set55=new HashSet<>();\n\tSet<V> set56=new HashSet<>();\n\tSet<V> set57=new HashSet<>();\n\tSet<V> set58=new HashSet<>();\n\tSet<V> set59=new HashSet<>();\n\tSet<V> set60=new HashSet<>();\n\tSet<V> set61=new HashSet<>();\n\tSet<V> set62=new HashSet<>();\n\tSet<V> set63=new HashSet<>();\n\tSet<V> set64=new HashSet<>();\n\tSet<V> set65=new HashSet<>();\n\tSet<V> set66=new HashSet<>();\n\tSet<V> set67=new HashSet<>();\n\tSet<V> set68=new HashSet<>();\n\tSet", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> intersect = new HashSet<V>();\n\tfor(V v : set1){\n\t\tintersect.add(v);\n\t\tfor(V v2 : set2){\n\t\t\tif(v.equals(v2)){\n\t\t\t\treturn intersect;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}", "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n    Set<V> result = new HashSet<>();\n    for(V v : set1){\n        if(set2.contains(v)){\n            result.add(v);\n        }\n    }\n    return result;\n}"]}
{"_id": "636767511a6d9265ec017eb6", "generate_results": ["public Circulator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\treturn selectOnOuterFace(predicate,start,stop,dir).getInner();\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\t//find the node that satisfies the predicate\n\tOuterFaceCirculator circulator = new OuterFaceCirculator();\n\t//find the node that satisfies the predicate\n\tCirculator<Node> c = circulator.getCirculator();\n\twhile(c.getNode(stop)!=null){\n\t\tif(c.getNode(stop).getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getInnerFace().getOuterFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getOuterFace().getInnerFace().getInnerFace().getInnerFace().getOuterFace().getInnerFace().getInnerFace().getOuterFace().getInnerFace().getOuterFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().getInnerFace().get", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif(stop==null)\n\t\treturn null;\n\treturn new OuterFaceCirculator(start,stop,dir);\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif(start==stop){\n\t\treturn new OuterFaceCirculator(start,dir);\n\t}\n\telse{\n\t\treturn new OuterFaceCirculator(start,dir,selectOnOuterFace(predicate,stop,start,dir));\n\t}\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif(stop.id() == start.id()){\n\t\t//return the node\n\t\treturn new OuterFaceCirculator(start,stop,dir);\n\t}\n\t//let's see if start is a neighbor\n\tif(predicate.apply(start) && start.neighbors().contains(stop)){\n\t\t//return the node\n\t\treturn new OuterFaceCirculator(start,stop,dir);\n\t}\n\t//return the node\n\treturn null;\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n    OuterFaceCirculator ret=null;\n    if(start==null || stop==null){\n        return ret;\n    }\n    if(start.getID()==stop.getID()){\n        return null;\n    }\n    if(!predicate.test(start)){\n        return null;\n    }\n    if(dir==0){\n        ret = new OuterFaceCirculator(start,stop);\n    }\n    if(dir==1){\n        ret = new OuterFaceCirculator(stop,start);\n    }\n    return ret;\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif(stop.getOuterFace()!=null){\n\t\tint index=stop.getOuterFace().getIndex();\n\t\tNode n=stop.getOuterFace().getNodes().get(index);\n\t\t\n\t\tif(start==stop){\n\t\t\treturn new InnerFaceCirculator(predicate,start,n,dir);\n\t\t}else{\n\t\t\treturn new OuterFaceCirculator(predicate,n,start,dir);\n\t\t}\n\t}\n\treturn null;\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif (start.getOuterFace(stop)==null){\n\t\treturn null;\t\n\t}\n\tOuterFaceCirculator circulator = new OuterFaceCirculator(start.getOuterFace(stop),start.getOuterFace(start),start.getOuterFace(stop));\n\treturn circulator;\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tif(stop.getPosition().equals(start)){\n\t\treturn new OuterFaceCirculator(stop,dir);\n\t}\n\t\n\tOuterFaceCirculator circ = new OuterFaceCirculator(start,dir);\n\tfor(Node n : circ.getNodes()){\n\t\tif(predicate.test(n)){\n\t\t\treturn circ;\n\t\t}\n\t}\n\treturn null;\n}", "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\t//the loop will be executed in counter clock wise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in counter clock wise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been visited\n\t\n\t//the loop will be executed in clockwise order\n\t//the loop will start from start and stop in direction dir\n\t//the loop will return the node that satisfies the interface predicate\n\t//the loop will stop at stop and return stop\n\t//the loop will return the last node that satisfies the interface predicate\n\t//the loop will return the last node that has been visited\n\t//the loop will return the last node that has been"]}
{"_id": "6367675d1a6d9265ec018082", "generate_results": ["Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\nreturn this.edgeTo.next;\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\t//If the previous edge has not been returned yet, we return the edge connecting the previous node with the current node.\n\tif(edgeToPrevious.next!=NULL){\n\t\treturn edgeToPrevious.next;\n\t}else{\n\t\t//Otherwise we return the edge connecting the previous node with the current node.\n\t\treturn edgeToPrevious;\n\t}\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){return edgeTo;}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n  // Find the edge connecting the current node with the previous node\n  // and return the edge\n  Edge edge = new Edge(this.prevNode, this.nextNode);\n  return(edge);\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n    return new Edge(getNode(nodes.size()-1), getNode(nodes.size()-1), nodes.get(nodes.size()-2));\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\t\n\treturn edge(currentNode.next);\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\tif (this.first.id == this.second.id){\n\t\treturn this.first;\n\t}\n\treturn this.second;\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\tEdge newEdge;\n\tnewEdge = this.next;\n\tthis.next = this.next.next;\n\treturn newEdge;\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n    return this.next;\n}", "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\t\n\t//Check if the current node has already a next node.\n\tif(this.next){\n\t\t//Return the edge connecting the current node with the next node.\n\t\treturn this.next.edge;\n\t}\n\telse{\n\t\t//If the next node is not a node, then return null.\n\t\treturn null;\n\t}\n}"]}
{"_id": "636767561a6d9265ec017f7c", "generate_results": ["Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tGraphPath<V,E> result = new GraphPath<V,E>();\n\tfor(V v : tour){\n\t\tfor(E e : graph.get(v))\n\t\t\tresult.add(e);\n\t}\n\treturn result;\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tGraphPath<V,E> result=new GraphPath<V,E>();\n\tfor(E e:tour){\n\t\tresult.addEdge(e);\n\t}\n\treturn result;\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n   \n\t// get the current tour\n\tSet<E> currentTour = getTour(graph);\n\t\n\t// get the set of all edges\n\tSet<E> edges = new HashSet<E>(graph.getEdges());\n\t\n\t// clear tour\n\ttour.clear();\n\t\n\t// add each edge to the tour\n\tfor(E e : edges){\n\t\t\n\t\t// if the current tour already contains the given edge, add it to the tour\n\t\tif(currentTour.contains(e)){\n\t\t\ttour.add(e);\n\t\t}\n\t\t\n\t\t// otherwise, add the given edge to the current tour\n\t\telse{\n\t\t\ttour.add(e);\n\t\t}\n\t}\n\t\n\treturn new GraphPath<V,E>(tour,graph);\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tif(tour.size()==0) return null;\n\tList<V> newTour = new ArrayList<V>();\n\tfor(E e : tour) newTour.add(graph.getEdge(e).getSource());\n\treturn new GraphPath<V,E>(newTour,graph);\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tif (tour.size()==1) return new GraphPath<V,E>(tour.iterator().next(),graph);\n\t\n\tArrayList<E> tourElems = new ArrayList<E>(tour);\n\tCollections.sort(tourElems);\n\t\n\tGraphPath<V,E> gpath = new GraphPath<V,E>(tourElems.get(0),graph);\n\tfor (int i=1;i<tourElems.size();i++) {\n\t\tgpath = new GraphPath<V,E>(tourElems.get(i),gpath);\n\t}\n\treturn gpath;\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tif(tour.size()==0) return null;\n\t\n\t\n\tint size = tour.size();\n\tif(size==1) return new GraphPath<V,E>(tour.iterator().next(),graph);\n\t\n\tint start = 0;\n\tint end = size-1;\n\t\n\t//create graph path\n\tArrayList<E> tourList = new ArrayList<E>();\n\t\n\twhile(start<end)\n\t{\n\t\tint begin = start+1;\n\t\tint end = start+2;\n\t\t\n\t\twhile(end<size)\n\t\t{\n\t\t\tif(tour.contains(tour.get(end)))\n\t\t\t{\n\t\t\t\tend++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(tour.contains(tour.get(begin)))\n\t\t\t\tend--;\n\t\t\telse\n\t\t\t\tbegin++;\n\t\t}\n\t\t\n\t\t\n\t\ttourList.add(tour.get(begin));\n\t\t\n\t\tstart++;\n\t\tend--;\n\t}\n\t\n\t//add end edge\n\ttourList.add(tour.get(end));\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn new GraphPath<V,E>(tourList,graph);\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\t// if the tour is empty, return null\n\tif (tour.isEmpty()) return null;\n\t\n\t// find the first element that is not already in the tour\n\tE first = tour.iterator().next();\n\t\n\t// if the tour is already in the graph, return the tour\n\tif (graph.contains(first)) return tour;\n\t\n\t// otherwise, create a new tour\n\treturn graph.addEdge(first,tour);\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tGraphPath<V,E> tourPath = new GraphPath<V,E>(graph);\n\tfor(E edge: tour){\n\t\ttourPath.addEdge(edge);\n\t}\n\treturn tourPath;\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tif(tour.size()==0){\n\t\treturn null;\n\t}\n\t\n\t//remove edges that are not in tour\n\tfor(E e : tour){\n\t\tif(!graph.containsEdge(e)){\n\t\t\ttour.remove(e);\n\t\t}\n\t}\n\t\n\t//add edges that are in tour\n\tfor(E e : tour){\n\t\tgraph.addEdge(e,tour.iterator().next());\n\t}\n\t\n\treturn graph.getEdgeSet();\n}", "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tGraphPath<V,E> path = new GraphPath<V,E>(graph);\n\tfor(E e: tour){\n\t\tpath.addVertex(e);\n\t}\n\treturn path;\n}"]}
{"_id": "636767641a6d9265ec018190", "generate_results": ["Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tint min = minLabel;\n\tif(!bucketsByLabel.containsKey(min)){\n\t\tbucketsByLabel.put(min,new HashSet<Integer>());\n\t}\n\tint label = 0;\n\tfor(int j=0;j<labels.size();j++){\n\t\tif(bucketsByLabel.get(min).contains(labels.get(j))){\n\t\t\tlabel = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint bucket = Integer.MAX_VALUE;\n\tfor(int j=0;j<labels.size();j++){\n\t\tif(!bucketsByLabel.get(min).contains(labels.get(j))){\n\t\t\tbucket = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbucketsByLabel.get(min).add(label);\n\tbucketsByLabel.get(bucket).remove(label);\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\t\n\tfor(int i=0;i<bucketsByLabel.size();i++){\n\t\tfor(int j=0;j<bucketsByLabel.get(i).size();j++){\n\t\t\tint label = bucketsByLabel.get(i).get(j);\n\t\t\tif(labels.get(label)!=minLabel){\n\t\t\t\tbucketsByLabel.get(i).set(j,minLabel);\n\t\t\t\tbucketsByLabel.get(i).add(minLabel);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor(int i=0;i<labels.size();i++){\n\t\tif(!bucketsByLabel.get(i).contains(minLabel)){\n\t\t\tbucketsByLabel.get(i).add(minLabel);\n\t\t\tbucketsByLabel.get(i).remove(0);\n\t\t}\n\t}\n\t\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\t\n\tfor (int i = 0; i < bucketsByLabel.size(); i++) {\n\t\tfor (int j = 0; j < bucketsByLabel.get(i).size(); j++) {\n\t\t\tbucketsByLabel.get(i).set(j,0);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < labels.size(); i++) {\n\t\tfor (int j = 0; j < bucketsByLabel.get(0).size(); j++) {\n\t\t\tbucketsByLabel.get(0).set(j,labels.get(i));\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < bucketsByLabel.get(0).size(); i++) {\n\t\tfor (int j = 0; j < bucketsByLabel.get(0).get(i); j++) {\n\t\t\tbucketsByLabel.get(0).set(i,j);\n\t\t}\n\t}\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\t//clear bucket\n\tbucket.clear();\n\t\n\t//add bucket\n\tbucket.add(new HashSet<Integer>(labels));\n\tbucket.add(new HashSet<Integer>(bucketsByLabel.get(minLabel)));\n\t\n\t//set bucket to the minimum label bucket\n\tbucket.setMinLabel(minLabel);\n\t\n\t//reload\n\treload(bucket,bucketsByLabel,minLabel);\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor(int i = 0;i<minLabel;i++){\n\t\tSet<Integer> bucket = bucketsByLabel.get(i);\n\t\tbucket.clear();\n\t\tbucket.add(0);\n\t}\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor (int i = 0;i < bucketsByLabel.size();i++) {\n\t\tfor (int j = 0;j < bucketsByLabel.get(i).size();j++) {\n\t\t\tif (bucketsByLabel.get(i).get(j).equals(minLabel)) {\n\t\t\t\tbucketsByLabel.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n\tList<Set<Integer>> buckets = bucketsByLabel.clone();\n\tList<Set<Integer>> bucketsByLabel2 = buckets.clone();\n\tint maxLabel = 0;\n\tfor (int i = 0;i < buckets.size();i++) {\n\t\tfor (int j = 0;j < buckets.get(i).size();j++) {\n\t\t\tif (buckets.get(i).get(j).equals(minLabel)) {\n\t\t\t\tmaxLabel = buckets.get(i).get(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < buckets.size();i++) {\n\t\tfor (int j = 0;j < buckets.get(i).size();j++) {\n\t\t\tif (buckets.get(i).get(j).equals(minLabel)) {\n\t\t\t\tbuckets.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < bucketsByLabel2.size();i++) {\n\t\tfor (int j = 0;j < bucketsByLabel2.get(i).size();j++) {\n\t\t\tif (bucketsByLabel2.get(i).get(j).equals(minLabel)) {\n\t\t\t\tbucketsByLabel2.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < bucketsByLabel2.size();i++) {\n\t\tfor (int j = 0;j < bucketsByLabel2.get(i).size();j++) {\n\t\t\tif (bucketsByLabel2.get(i).get(j).equals(minLabel)) {\n\t\t\t\tbucketsByLabel2.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < bucketsByLabel.size();i++) {\n\t\tfor (int j = 0;j < bucketsByLabel.get(i).size();j++) {\n\t\t\tif (bucketsByLabel.get(i).get(j).equals(maxLabel)) {\n\t\t\t\tbucketsByLabel.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < bucketsByLabel.size();i++) {\n\t\tfor (int j = 0;j < bucketsByLabel.get(i).size();j++) {\n\t\t\tif (bucketsByLabel.get(i).get(j).equals(maxLabel)) {\n\t\t\t\tbucketsByLabel.get(i).set(j,0);\n\t\t\t}\n\t\t}\n\t}\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\t//reload the minimum bucket by label\n\tfor(int label : labels){\n\t\t//remove the label from the minimum bucket\n\t\tbucketsByLabel.remove(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(bucketsByLabel.headSet(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet<Integer>(new HashSet", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor (int label:labels){\n\t\tfor (int bucket:bucketsByLabel.get(label)){\n\t\t\tif (bucket < minLabel){\n\t\t\t\tbucketsByLabel.get(label).remove(bucket);\n\t\t\t}\n\t\t}\n\t}\n}", "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor(int i=0;i<bucketsByLabel.size();i++){\n\t\tfor(int j=0;j<bucketsByLabel.get(i).size();j++){\n\t\t\tif(labels.get(bucketsByLabel.get(i).get(j))>minLabel){\n\t\t\t\tbucketsByLabel.set(i,bucketsByLabel.get(i).subList(0,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<bucketsByLabel.size();i++){\n\t\tfor(int j=0;j<bucketsByLabel.get(i).size();j++){\n\t\t\tif(labels.get(bucketsByLabel.get(i).get(j))<minLabel){\n\t\t\t\tbucketsByLabel.set(i,bucketsByLabel.get(i).subList(j+1,bucketsByLabel.get(i).size()));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<bucketsByLabel.size();i++){\n\t\tfor(int j=0;j<bucketsByLabel.get(i).size();j++){\n\t\t\tif(labels.get(bucketsByLabel.get(i).get(j))>minLabel){\n\t\t\t\tbucketsByLabel.get(i).set(j,minLabel);\n\t\t\t}\n\t\t}\n\t}\n}"]}
{"_id": "636767611a6d9265ec018112", "generate_results": ["Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n\treturn g.nextVertex();\n}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){ return null; }", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n    return getGraph().getNextVertex();\n}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){ return null; }", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){return vertex;}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n    if(v.isDeleted())\n        return null;\n    if(!v.isConnected())\n        return null;\n    if(v.isRemoved())\n        return null;\n    return v.nextVertex();\n}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){ \n    if(graph.isVertex(nextVertex)){ // if the vertex is in the graph\n        return graph.getVertex(nextVertex);\n    }\n    else{\n        return null;\n    }\n}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n\treturn null;\n}", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n    V vertex = Graph.get().nextVertex();\n    if (vertex == null){\n      throw new NoSuchElementException(\"No vertex left.\");\n    }\n    return vertex;\n  }", "Get next vertext from a graph.\n@Override protected V provideNextVertex(){ return v; }"]}
{"_id": "636767601a6d9265ec0180e2", "generate_results": ["Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new LinkedList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge:graph.edges()){\n\t\tList<Pair<Integer,Integer>> list1 = new LinkedList<Pair<Integer,Integer>>();\n\t\tfor(Pair<Integer,Integer> pair:edge.getList()){\n\t\t\tlist1.add(new Pair<Integer,Integer>(pair.getFirst(),pair.getSecond()));\n\t\t}\n\t\tlist.add(new Pair<List<Pair<Integer,Integer>>,E>(list1,edge));\n\t}\n\treturn list;\n}", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> returnList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tList<Pair<Integer,Integer>> list = new ArrayList<Pair<Integer,Integer>>();\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.add(new Pair<List<Pair<Integer,Integer>>,E>(list,new E()));\n\tlist.add(new Pair<Integer,Integer>(0,0));\n\treturnList.", "public List<Pair<List<Pair<Integer,Integer>>,E>> getGlobalSeparatorList2(){\n\treturn computeGlobalSeparatorList();\n}", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n    List<Pair<List<Pair<Integer,Integer>>,E>> returnList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n    List<Edge> edges=graph.getEdges();\n    for (Edge e : edges){\n\n        List<Pair<Integer,Integer>> list=new ArrayList<Pair<Integer,Integer>>();\n        list.add(new Pair<Integer,Integer>(e.getSource().getId(),e.getTarget().getId()));\n        list.add(new Pair<Integer,Integer>(e.getTarget().getId(),e.getSource().getId()));\n        List<Pair<Integer,Integer>> minSeparators=new ArrayList<Pair<Integer,Integer>>();\n        List<Pair<Integer,Integer>> listOfMinSeparators=new ArrayList<Pair<Integer,Integer>>();\n        int min=Integer.MAX_VALUE;\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        listOfMinSeparators.add(minSeparators);\n        minSeparators=new ArrayList<Pair<Integer,Integer>>();\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        minSeparators.add(minSeparators);\n        listOfMinSeparators.add(minSeparators);\n        minSeparators=new ArrayList<Pair<Integer,Integer>>();\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        listOfMinSeparators.add(minSeparators);\n        minSeparators=new ArrayList<Pair<Integer,Integer>>();\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        minSeparators.add(minSeparators);\n        for (Pair<Integer,Integer> pair : minSeparators){\n            listOfMinSeparators.add(pair);\n        }\n        minSeparators=new ArrayList<Pair<Integer,Integer>>();\n        list=new ArrayList<Pair<Integer,Integer>>();\n        list.add(new Pair<Integer,Integer>(e.getSource().getId(),e.getTarget().getId()));\n        minSeparators.add(new Pair<Integer,Integer>(e.getTarget().getId(),e.getSource().getId()));\n        for (Pair<Integer,Integer> pair : list){\n            if (min>pair.getLeft()){\n                min=pair.getLeft();\n            }\n            if (min>pair.getRight()){\n                min=pair.getRight();\n            }\n        }\n        list.add(new Pair<Integer,Integer>(e.getTarget().getId(),e.getSource().getId()));\n        minSeparators.add(new Pair<Integer,Integer>(e.getTarget().getId(),e.getSource().getId()));\n", "public static void main(String[] args){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new LinkedList<>();\n\t\n\t//1.1\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.2\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.3\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.4\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.5\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.6\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.7\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.8\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.9\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.10\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.11\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.12\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.13\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.14\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.15\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.16\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.17\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.18\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.19\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.20\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.21\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.22\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.23\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.24\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.25\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.26\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.27\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.28\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.29\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.30\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.31\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.32\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.33\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.34\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.35\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.36\n\tlist = computeGlobalSeparatorList();\n\t\n\t//1.37\n\tlist = computeGlobalSep", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new ArrayList<>();\n\t\n\tList<Integer> listOfNeighborhood = new ArrayList<>();\n\tList<Integer> listOfNeighborhood2 = new ArrayList<>();\n\t\n\tList<Integer> listOfNeighborhood3 = new ArrayList<>();\n\tList<Integer> listOfNeighborhood4 = new ArrayList<>();\n\t\n\tlistOfNeighborhood.add(1);\n\tlistOfNeighborhood.add(2);\n\tlistOfNeighborhood.add(3);\n\tlistOfNeighborhood.add(4);\n\t\n\tlistOfNeighborhood2.add(1);\n\tlistOfNeighborhood2.add(2);\n\tlistOfNeighborhood2.add(3);\n\tlistOfNeighborhood2.add(4);\n\t\n\tlistOfNeighborhood3.add(1);\n\tlistOfNeighborhood3.add(2);\n\tlistOfNeighborhood3.add(3);\n\tlistOfNeighborhood3.add(4);\n\t\n\tlistOfNeighborhood4.add(1);\n\tlistOfNeighborhood4.add(2);\n\tlistOfNeighborhood4.add(3);\n\tlistOfNeighborhood4.add(4);\n\t\n\tlistOfNeighborhood.add(2);\n\tlistOfNeighborhood.add(3);\n\tlistOfNeighborhood.add(4);\n\t\n\tlistOfNeighborhood2.add(2);\n\tlistOfNeighborhood2.add(3);\n\tlistOfNeighborhood2.add(4);\n\t\n\tlistOfNeighborhood3.add(2);\n\tlistOfNeighborhood3.add(3);\n\tlistOfNeighborhood3.add(4);\n\t\n\tlistOfNeighborhood4.add(2);\n\tlistOfNeighborhood4.add(3);\n\tlistOfNeighborhood4.add(4);\n\t\n\tlistOfNeighborhood.add(3);\n\tlistOfNeighborhood.add(4);\n\t\n\tlistOfNeighborhood2.add(3);\n\tlistOfNeighborhood2.add(4);\n\tlistOfNeighborhood2.add(5);\n\t\n\tlistOfNeighborhood3.add(3);\n\tlistOfNeighborhood3.add(4);\n\tlistOfNeighborhood3.add(5);\n\t\n\tlistOfNeighborhood4.add(3);\n\tlistOfNeighborhood4.add(4);\n\tlistOfNeighborhood4.add(5);\n\t\n\tlistOfNeighborhood.add(4);\n\tlistOfNeighborhood.add(5);\n\t\n\tlistOfNeighborhood2.add(4);\n\tlistOfNeighborhood2.add(5);\n\tlistOfNeighborhood2.add(6);\n\t\n\tlistOfNeighborhood3.add(4);\n\tlistOfNeighborhood3.add(5);\n\tlistOfNeighborhood3.add(6);\n\t\n\tlistOfNeighborhood4.add(4);\n\tlistOfNeighborhood4.add(5);\n\tlistOfNeighborhood4.add(6);\n\t\n\tlistOfNeighborhood.add(5);\n\tlistOfNeighborhood.add(6);\n\t\n\tlistOfNeighborhood2.add(5);\n\tlistOfNeighborhood2.add(6);\n\tlistOfNeighborhood2.add(7);\n\t\n\tlistOfNeighborhood3.add(5);\n\tlistOfNeighborhood3.add(6);\n\tlistOfNeighborhood3.add(7);\n\t\n\tlistOfNeighborhood4.add(5);\n\tlistOfNeighborhood4.add(6);\n\tlistOfNeighborhood4.add(7);\n\t\n\tlistOfNeighborhood.add(7);\n\tlistOf", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n    List<Pair<List<Pair<Integer,Integer>>,E>> tempList = new ArrayList<>();\n    tempList.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList2 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList3 = new ArrayList<>();\n    tempList2.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList4 = new ArrayList<>();\n    tempList2.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList5 = new ArrayList<>();\n    tempList2.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList6 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList7 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList8 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList9 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList10 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList11 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList12 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList13 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList14 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList15 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList16 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<Pair<Integer,Integer>> tempList17 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList18 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList19 = new ArrayList<>();\n    tempList3.add(new Pair<>(new ArrayList<Pair<Integer,Integer>>(), null));\n    List<E> tempList20 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList21 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList22 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList23 = new ArrayList<>();\n    List<Pair<Integer,Integer>> tempList24 = new ArrayList<>();\n    List<E> tempList25 = new ArrayList<>();\n    List<E> tempList26 = new ArrayList<>();\n    List<E> tempList27 =", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> result = new LinkedList<>();\n\tfor(int i = 0; i < (int)graph.getSource().size(); i++){\n\t\tfor(int j = 0; j < (int)graph.getDest().size(); j++){\n\t\t\tif(graph.getDest().get(j)!= graph.getSource().get(i)){\n\t\t\t\tPair<List<Pair<Integer,Integer>>,E> pair = new Pair<>(graph.getDest().get(j),graph.getSource().get(i));\n\t\t\t\tif(isSeparator(pair,i,j)){\n\t\t\t\t\tresult.add(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new ArrayList<>();\n\t\n\tfor(int i = 0; i < graph.getSize(); i++){\n\t\tfor(int j = 0; j < graph.getSize(); j++){\n\t\t\tif(graph.isEdge(i, j)){\n\t\t\t\tif(graph.getEdgeWeight(i, j) > 0){\n\t\t\t\t\tList<Pair<List<Pair<Integer,Integer>>,E>> tempList = new ArrayList<>();\n\t\t\t\t\ttempList.add(new Pair<>(graph.getEdge(i, j).getSource(), graph.getEdge(i, j).getTarget()));\n\t\t\t\t\tlist.add(new Pair<>(tempList, graph.getEdge(i, j).getWeight()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn list;\n}", "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int N = sc.nextInt();\n    int M = sc.nextInt();\n    int[][] graph = new int[N][M];\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            graph[i][j] = sc.nextInt();\n        }\n    }\n    int[][] res = computeGlobalSeparatorList();\n    for(int i = 0; i < res.length; i++){\n        for(int j = 0; j < res[i].length; j++){\n            System.out.print(graph[i][j] + \" \");\n        }\n        System.out.println();\n    }\n}"]}
{"_id": "636767461a6d9265ec017d0e", "generate_results": ["Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tlong sum = 0;\n\tfor(int i=0;i<bounds.size();i++){\n\t\tsum += bounds.get(i);\n\t}\n\treturn Pair.of(bounds,sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n    List<Integer> sum = new ArrayList<Integer>();\n    long sumOfBounds = 0;\n\n    for(int i = bounds.size()-1; i >= 0; i--){\n        sumOfBounds += bounds.get(i);\n        sum.add(bounds.get(i));\n    }\n\n    return new Pair<List<Integer>,Long>(sum,sumOfBounds);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n    List<Integer> suffixSum = new ArrayList<Integer>();\n    long sum = 0;\n    for(int i : bounds) {\n        sum += i;\n        suffixSum.add(i);\n    }\n    return new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n    int[] boundsArray = new int[bounds.size()];\n    bounds.toArray(boundsArray);\n    int sum = 0;\n    for(int i=0;i<boundsArray.length;i++){\n        sum += boundsArray[i];\n    }\n    return new Pair<>(List.of(sum),sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n    List<Integer> suffix = new LinkedList<>();\n    long sum = 0;\n    for (int i = bounds.size()-1; i >= 0; i--){\n        if (bounds.get(i) >= bounds.get(i+1)){\n            sum += bounds.get(i+1);\n            suffix.add(bounds.get(i+1));\n        }\n    }\n    return new Pair<>(suffix, sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tPair<List<Integer>,Long> prefixSum = new Pair<List<Integer>,Long>(new ArrayList<Integer>(), 0);\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tList<Integer> element = bounds.subList(0, i+1);\n\t\tList<Integer> sum = new ArrayList<Integer>();\n\t\tList<Integer> suffixSum = new ArrayList<Integer>();\n\t\tfor(int j=0;j<bounds.size();j++){\n\t\t\tint p = bounds.get(j);\n\t\t\tif(p>element.get(0)){\n\t\t\t\tsum.add(p);\n\t\t\t\tsuffixSum.add(bounds.get(j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> diff = new ArrayList<Integer>(bounds.subList(j+1, bounds.size()));\n\t\t\t\tList<Integer> c = new ArrayList<Integer>();\n\t\t\t\tc.add(element.get(0));\n\t\t\t\twhile(diff.size()>0){\n\t\t\t\t\tList<Integer> temp = new ArrayList<Integer>(diff);\n\t\t\t\t\ttemp.add(element.get(diff.size()-1));\n\t\t\t\t\tdiff = temp;\n\t\t\t\t}\n\t\t\t\tc.add(element.get(diff.size()-1));\n\t\t\t\tsum.addAll(c);\n\t\t\t\tsuffixSum.addAll(suffixSum.subList(0, j+1));\n\t\t\t}\n\t\t}\n\t\tprefixSum.setValue(sum);\n\t\tLong total = sum.get(bounds.size()-1);\n\t\ttotal = total + suffixSum.get(bounds.size()-1);\n\t\tprefixSum.setValue(total);\n\t}\n\treturn prefixSum;\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tPair<List<Integer>,Long> suffixSum = new Pair<List<Integer>,Long>(bounds,0);\n\tList<Integer> list = new ArrayList<>();\n\tfor(int i=0;i<bounds.size();i++){\n\t\tlist.add(bounds.get(i));\n\t}\n\t\n\tfor(int i=0;i<list.size()-1;i++){\n\t\tint sum = list.get(i);\n\t\tfor(int j=i+1;j<list.size();j++){\n\t\t\tsum += list.get(j);\n\t\t\tif(sum>bounds.get(j)){\n\t\t\t\tlist.set(i,j);\n\t\t\t\tlist.set(j,sum);\n\t\t\t\tsuffixSum.set(list,sum);\n\t\t\t}\n\t\t}\n\t}\n\treturn suffixSum;\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\t\n\tList<Integer> list = new ArrayList<>();\n\tint sum = 0;\n\tfor(int i = 0; i < bounds.size(); i++){\n\t\tsum += bounds.get(i);\n\t\tlist.add(bounds.get(i));\n\t}\n\treturn new Pair<>(list,sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tList<Integer> suffixSum = new ArrayList<Integer>(bounds.size());\n\tlong sum = 0;\n\tfor(int i = bounds.size()-1;i >= 0;i--) {\n\t\tint value = bounds.get(i);\n\t\tsum += value;\n\t\tsuffixSum.add(value);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n    List<Integer> list = new ArrayList<>();\n    Long sum = 0L;\n    for(int i = 1;i < bounds.size();i++){\n        sum += bounds.get(i);\n        list.add(bounds.get(i));\n    }\n    return Pair.of(list,sum);\n}"]}
{"_id": "636767431a6d9265ec017c88", "generate_results": ["The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> resultList = new ArrayList<Integer>();\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i) < keys.get(0)) {\n            int lowerBound = keys.get(i);\n            int upperBound = keys.get(0);\n            while (lowerBound < upperBound) {\n                int temp = lowerBound;\n                lowerBound = upperBound;\n                upperBound = temp;\n            }\n            resultList.add(lowerBound);\n        }\n    }\n    return resultList;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\t\n\tList<Integer> listLowerBounds = new ArrayList<Integer>();\n\t\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tlistLowerBounds.add(keys.get(i).getLowerBound());\n\t}\n\treturn listLowerBounds;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> result = new ArrayList<>();\n    for(int i=1;i<keys.size();i++){\n        if(keys.get(i)!=keys.get(i-1)){\n            result.add(keys.get(i));\n        }\n    }\n    return result;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> lowerBounds = new ArrayList<>();\n\tfor(int i=0;i<keys.size()-1;i++){\n\t\tlowerBounds.add(keys.get(keys.size()-1-i));\n\t}\n\treturn lowerBounds;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> result = new ArrayList<>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tInteger key = keys.get(i);\n\t\tInteger lowerBound = key.computeLowerBound();\n\t\tif(lowerBound == null){\n\t\t\tcontinue;\n\t\t}\n\t\tresult.add(lowerBound);\n\t}\n\treturn result;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> lowerBounds = new ArrayList<>();\n    for(K key : keys){\n        lowerBounds.add(key.getKey().getLowerBound());\n    }\n    return lowerBounds;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tif(keys.get(i).getLowerBound()<0){\n\t\t\tlowerBounds.add(keys.get(i).getLowerBound());\n\t\t}\n\t}\n\treturn lowerBounds;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> list=new ArrayList<Integer>();\n    for(int i=0;i<keys.size();i++){\n        for(int j=0;j<keys.get(i).length;j++){\n            if(keys.get(i)[j]<keys.get(i)[j+1]){\n                list.add(keys.get(i)[j]);\n            }\n        }\n    }\n    return list;\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tint[] maxBounds = new int[keys.size()];\n\tfor (int i = 0; i < keys.size(); i++) {\n\t\tmaxBounds[i] = Integer.MAX_VALUE;\n\t}\n\tfor (int i = 0; i < keys.size(); i++) {\n\t\tmaxBounds[i] = max(maxBounds[i], keys.get(i).getLowerBound());\n\t}\n\treturn Arrays.asList(maxBounds);\n}", "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> list = new ArrayList<Integer>();\n\t\n\tfor(int i=0;i<keys.size();i++){\n\t\tif(keys.get(i)<0)\n\t\t\tlist.add(keys.get(i));\n\t}\n\t\n\treturn list;\n}"]}
{"_id": "636767581a6d9265ec017fb4", "generate_results": ["The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> list = new ArrayList<>();\n\tif(keys.size() == 0) return list;\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tlist.add(keys.get(i).getUpperBound());\n\t}\n\treturn list;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(int i = 0 ; i < keys.size() ; i++){\n\t\tupperBounds.add(keys.get(i));\n\t}\n\treturn upperBounds;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBoundList = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tint key = keys.get(i);\n\t\tfor(int j=i+1;j<keys.size();j++){\n\t\t\tint max = Math.max(keys.get(j),keys.get(i));\n\t\t\tif(max<key){\n\t\t\t\tupperBoundList.add(max);\n\t\t\t}\n\t\t}\n\t}\n\treturn upperBoundList;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tint[] upperBounds = new int[keys.size()];\n\tfor (int i = 0; i < keys.size(); i++) {\n\t\tupperBounds[i] = keys.get(i).getUpperbound();\n\t}\n\treturn computeUpperBounds(upperBounds);\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> list = new ArrayList<Integer>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tlist.add(keys.get(i).getUpperBound());\n\t}\n\treturn list;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> list = new ArrayList<>();\n    for(int i = 0; i < keys.size()-1; i++){\n        list.add(keys.get(i));\n    }\n    return list;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(K key : keys){\n\t\tInteger upperBound = upperBounds.get(0);\n\t\tfor(int i = 1; i < upperBounds.size(); i++){\n\t\t\tif(upperBounds.get(i) > upperBound){\n\t\t\t\tupperBounds.set(i, upperBound);\n\t\t\t}else{\n\t\t\t\tupperBounds.set(i, upperBound);\n\t\t\t}\n\t\t}\n\t}\n\treturn upperBounds;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<Integer>();\n    for(int i=0;i<keys.size();i++){\n        upperBounds.add(keys.get(i).getUpperBound());\n    }\n    return upperBounds;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<>();\n    for(K k:keys){\n        upperBounds.add(k.getUpperBound());\n    }\n    return upperBounds;\n}", "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<>();\n    for(K key : keys){\n        upperBounds.add(key.getUpperBound());\n    }\n    return upperBounds;\n}"]}
{"_id": "6367675f1a6d9265ec0180cf", "generate_results": ["Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tfor(V v:vertices){\n\t\tif(graph.getSuccessors(v).size()>1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tif(graph.isDirected()){\n\t\treturn false;\n\t}\n\t\n\tboolean[] visited = new boolean[vertices.size()];\n\t\n\tfor(int i = 0;i<vertices.size();i++){\n\t\tif(!visited[i]){\n\t\t\tfor(int j = i+1;j<vertices.size();j++){\n\t\t\t\tif(graph.getEdgeWeight(new DirectedEdge<V,E>(vertices.get(i),vertices.get(j)))==0){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisited[i] = true;\n\t\t}\n\t}\n\treturn true;\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tif(vertices.size()!=graph.vertexSet().size()){\n\t\treturn false;\n\t}\n\tSet<V> cliqueSet = new HashSet<V>(vertices);\n\tcliqueSet.retainAll(graph.vertexSet());\n\treturn cliqueSet.size()==vertices.size();\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n    //If the graph is not clique,we will return false\n    if(graph.size() == 0){\n        return false;\n    }\n    //If the graph is clique,we will return true\n    if(graph.isClique(vertices.iterator().next())){\n        return true;\n    }\n    //If the graph is not clique,we will return false\n    return false;\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\tfor(V vertex:vertices){\n\t\tif(!graph.isBreadthFirstSearch(vertex)){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tif(vertices.size() == graph.V()){\n\t\treturn true;\n\t}\n\tfor(V v: vertices){\n\t\tif(graph.containsEdge(v,v)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static <V,E> boolean isClique(Graph<V,E> graph,Set<V> vertices) {\n\t\n\tboolean result=false;\n\t\n\tif(isClique(graph,vertices)) result=true;\n\t\n\treturn result;\n}", "public static <V,E> boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\treturn isClique(graph,vertices);\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\tSet<V> cliqueVertices = new HashSet<V>();\n\t\n\tfor(V v : vertices){\n\t\tif(!graph.isAdjacent(v,graph.getEdgeSource(v)))\n\t\t\tcliqueVertices.add(v);\n\t}\n\t\n\tfor(V v : cliqueVertices){\n\t\tif(!graph.isAdjacent(graph.getEdgeSource(v),graph.getEdgeTarget(graph.getEdgeSource(v)))\n\t\t\t\t&& graph.getEdgeSource(v)!= graph.getEdgeTarget(v))\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t//if the graph is a clique,then return true\n\tfor(V vertex:vertices){\n\t\tif(graph.containsVertex(vertex)){\n\t\t\treturn true;\n\t\t}\n\t}\n\t//if the graph is not a clique,then return false\n\treturn false;\n}"]}
{"_id": "636767511a6d9265ec017eb0", "generate_results": ["public int nonZeros(int row){\n\tint n = 0;\n\tfor(int i = 0; i < numCols; i++){\n\t\tif(isZeros[i])\n\t\t\tn++;\n\t}\n\treturn n;\n}", "public int nonZeros(int row){\n    return getNonZeros(row);\n}", "public int nonZeros(int row){\n  if(row == 0) return 0;\n  return 1 + nonZeros(row - 1);\n}", "public int nonZeros(int row){\n\tint nonZero = 0;\n\tfor(int i = 0; i < row; i++){\n\t\tif(isZero(i)){\n\t\t\tnonZero++;\n\t\t}\n\t}\n\treturn nonZero;\n}", "public int nonZeros(int row){\n\tint count = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(isNonZero(i, row)) count ++;\n\t}\n\treturn count;\n}", "public int nonZeros(int row){\n    int numNonZeros = 0;\n    \n    for(int i = 0; i < numNonZeros; i++){\n        if(!isZero(row,i)){\n            numNonZeros++;\n        }\n    }\n    return numNonZeros;\n}", "public int nonZeros(int row){\n\treturn nonZeros(row, row);\n}", "public int nonZeros(int row){\n\tint n=0;\n\tfor(int i=0;i<nDim;i++){\n\t\tif(!isZero(i,row)){\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}", "public int nonZeros(int row){\n\tint count = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tif(matrix[i][row]!= 0){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "public int nonZeros(int row){\n        return nonZeros[row];\n    }"]}
{"_id": "636767461a6d9265ec017d17", "generate_results": ["Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString output = \"\";\n\tString[] tokens = input.split(\"\\\\.\");\n\tfor(int i=0;i<tokens.length;i++){\n\t\toutput += tokens[i];\n\t}\n\treturn output;\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n    String output = input;\n    output = output.replaceAll(\"\\\\.\\\\.\", \". \");\n    output = output.replaceAll(\"\\\\.\\\\.\", \". \");\n    output = output.replaceAll(\"\\\\.\", \". \");\n    output = output.replaceAll(\". \",\".\");\n    output = output.replaceAll(\". \",\".\");\n    output = output.replaceAll(\"[^\\\\x00-\\\\x1f\\\\x7f-\\\\xff]\",\".\");\n    output = output.replaceAll(\"[^\\\\x00-\\\\x1f\\\\x7f-\\\\xff]\",\".\");\n    output = output.replaceAll(\"\\\\.\\\\.\", \". \");\n    return output;\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n    String[] out = input.split(\"\\\\.\");\n    if (out.length == 0) return input;\n    return out[0];\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString[] elements = input.split(\"\\\\.\");\n\tStringBuffer ret = new StringBuffer();\n\tfor(int i=0; i<elements.length; i++){\n\t\tif(i>0){\n\t\t\tret.append(\".\");\n\t\t}\n\t\tret.append(elements[i].replaceAll(\"\\\\$\", \"\"));\n\t}\n\treturn ret.toString();\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tStringBuffer sb = new StringBuffer();\n\tfor(int i = 0; i < input.length(); i++){\n\t\tchar c = input.charAt(i);\n\t\tif(c == '.'){\n\t\t\tc = '_';\n\t\t}\n\t\tif(c == '\\n'){\n\t\t\tc = '_';\n\t\t}\n\t\tif(c == '_'){\n\t\t\tc = '-';\n\t\t}\n\t\tsb.append(c);\n\t}\n\treturn sb.toString();\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString result = \"\";\n\tif (input!= null && input.length() > 0) {\n\t\t\n\t\tchar ch = input.charAt(0);\n\t\tif (ch == '\\\\') {\n\t\t\tresult = input.substring(1);\n\t\t\t\n\t\t}else{\n\t\t\tresult = input;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\treturn null;\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString result = \"\";\n\tString temp = input;\n\tint index;\n\t\n\twhile(true){\n\t\tindex = temp.indexOf(\".\");\n\t\tif(index == -1){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tresult = result + temp.substring(0, index + 1);\n\t\ttemp = temp.substring(index + 1);\n\t}\n\t\n\treturn result;\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\t// Check if the input is an escaped identifier.\n\tif (input.startsWith(\"\\\\\")){\n\t\treturn input.substring(1);\n\t}\n\t// Check if the input is a valid identifier.\n\treturn input;\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tint index;\n\tint lastIndex = 0;\n\tint value = input.length();\n\t\n\tfor (index = 0; index < value; index++){\n\t\tif (input.charAt(index) == '.'){\n\t\t\tlastIndex = index + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tStringBuilder sb = new StringBuilder(value - lastIndex);\n\t\n\tfor (index = 0; index < value; index++){\n\t\tif (input.charAt(index) == '.'){\n\t\t\tsb.append(input.substring(lastIndex, index));\n\t\t}\n\t\telse {\n\t\t\tsb.append(input.charAt(index));\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n}", "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\t// Convert the input to a string separated by a single dot\n\tStringBuilder output = new StringBuilder();\n\tint start = 0;\n\tint end = input.length() - 1;\n\n\t// Iterate through the string until we reach the end of the string\n\twhile (start <= end) {\n\t\tif (input.charAt(start) == '.') {\n\t\t\t// Replace the current dot with an escaped dot\n\t\t\toutput.append('.');\n\t\t\t// Move past the dot until we reach the end\n\t\t\tstart++;\n\t\t} else {\n\t\t\t// No dot found, append the current char\n\t\t\toutput.append(input.charAt(start));\n\t\t\t// Move past the char that was just appended\n\t\t\tstart++;\n\t\t}\n\t}\n\t// Return the output\n\treturn output.toString();\n}"]}
{"_id": "6367667f1a6d9265ec017457", "generate_results": ["Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tif(i<0){\n\t\ti =0;\n\t}\n\tif(i==0){\n\t\treturn 0;\n\t}\n\tint j = i;\n\tfor(int k=0;k<i;k++){\n\t\tchar c = bb.get();\n\t\tif(c<0x80){\n\t\t\tsb.append(c);\n\t\t}\n\t\telse if(c<0x800){\n\t\t\tsb.append((char)(0x80 | (c>>6)));\n\t\t\tsb.append((char)(0x80 | (c&0x3f)));\n\t\t}\n\t\telse {\n\t\t\tsb.append((char)(0x800 | (c>>12)));\n\t\t\tsb.append((char)(0x800 | ((c>>6)&0x3f)));\n\t\t\tsb.append((char)(0x800 | (c&0x3f)));\n\t\t}\n\t\ti++;\n\t}\n\treturn j;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint n=0;\n\twhile(n<i){\n\t\tint c=bb.get();\n\t\tc=c&0x7f;\n\t\tn++;\n\t\tsb.append((char)c);\n\t\tif(c<0x80){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\t\n\t// If the next octet is a '0', then we're done.\n\tif(!bb.hasRemaining()){\n\t\t\n\t\t// If the buffer is empty, we're done.\n\t\tif(!sb.length()){\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\t// Otherwise, we need to append the next octet to the buffer.\n\t\tsb.append((char)bb.get(bb.position()));\n\t\treturn i+1;\n\t}\n\t\n\t// Otherwise, we're still in the middle of a character.\n\t// We have to push the character from the buffer to the sb.\n\tsb.append((char)bb.get(bb.position()));\n\treturn i+1;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n    for(int j=0;j<8;j++){\n        int k = bb.get();\n        sb.append((char)k);\n        i++;\n        if(k<127) sb.append((char)k);\n        else if(k>=128 && k<=255) sb.append((char)k);\n        else if(k>=256 && k<=65535) sb.append((char)k);\n        else sb.append((char)k);\n    }\n    return i;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c;\n\tint pos = 0;\n\twhile(i>0){\n\t\tc = bb.get();\n\t\tif(c<0x80)\n\t\t\tsb.append(c);\n\t\telse\n\t\t\tsb.append((char)c);\n\t\ti-=1;\n\t}\n\treturn pos;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint index=0;\n\tint end=i+8;\n\twhile(index<end){\n\t\tchar c=bb.get(index++);\n\t\tif(c<0x80){\n\t\t\tsb.append((char)c);\n\t\t\tcontinue;\n\t\t}\n\t\telse if(c<0x800){\n\t\t\tsb.append((char)0xC0 | (c>>6));\n\t\t\tsb.append((char)0x80 | (c&0x3F));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(c<0xD800 || c>0xDFFF){\n\t\t\tsb.append((char)0xE0 | (c>>12));\n\t\t\tsb.append((char)0x80 | (c>>6 & 0x3F));\n\t\t\tsb.append((char)0x80 | (c&0x3F));\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tsb.append((char)0xF0 | (c>>18));\n\t\t\tsb.append((char)0x80 | (c>>12 & 0x3F));\n\t\t\tsb.append((char)0x80 | (c>>6 & 0x3F));\n\t\t\tsb.append((char)0x80 | (c&0x3F));\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn index;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint n = 0;\n\tint c = 0;\n\twhile(n < i && c < 8){\n\t\tc = bb.get();\n\t\tc = (c & 0x7f) | (bb.get() & 0x80);\n\t\tn++;\n\t\tc = (c & 0x7f) | (bb.get() & 0x80);\n\t\tn++;\n\t}\n\tif(c < 8){\n\t\tc = 0;\n\t}\n\tsb.append((char)c);\n\treturn n;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n    int c;\n    int j = 0;\n    int k = bb.position();\n    while (j < i){\n        c = bb.get();\n        if (c <= 0x7F){\n            c = c & 0x1F;\n            c |= (c << 6);\n            c |= (c << 12);\n            c |= (c << 6);\n            c |= (c << 4);\n            sb.append((char)c);\n        } else if (c <= 0x7FF){\n            c = c & 0x7F;\n            c |= (c << 7);\n            c |= (c << 9);\n            c |= (c << 5);\n            c |= (c << 2);\n            sb.append((char)c);\n        } else if (c <= 0xFFFF){\n            c = c & 0x1F;\n            c |= (c << 6);\n            c |= (c << 12);\n            c |= (c << 6);\n            c |= (c << 4);\n            c |= (c << 2);\n            c |= (c << 1);\n            sb.append((char)c);\n        } else {\n            c = c & 0x7FF;\n            c |= (c << 7);\n            c |= (c << 9);\n            c |= (c << 5);\n            c |= (c << 2);\n            c |= (c << 1);\n            c |= (c << 0);\n            sb.append((char)c);\n        }\n        j++;\n        if (j == i){\n            return k;\n        }\n        bb.position(k);\n    }\n    return k;\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint len = 0;\n\tsb.setLength(0);\n\twhile(i!= 0){\n\t\tchar c = (char) bb.get(i);\n\t\tif(c < 0x80)\n\t\t\tsb.append((char) c);\n\t\telse if(c < 0x800)\n\t\t\tsb.append((char) (0xC0 + (c >> 6)));\n\t\telse if(c < 0xD800)\n\t\t\tsb.append((char) (0xE0 + (c >> 12)));\n\t\telse if(c < 0xDC00)\n\t\t\tsb.append((char) (0xF0 + (c >> 18)));\n\t\telse if(c < 0x10000){\n\t\t\tsb.append((char) (0xE0 + ((c >> 12) & 0x0F)));\n\t\t\tsb.append((char) (0x80 + ((c >> 6) & 0x3F)));\n\t\t}else if(c < 0x110000){\n\t\t\tsb.append((char) (0xF0 + ((c >> 18) & 0x07)));\n\t\t\tsb.append((char) (0x80 + ((c >> 12) & 0x3F)));\n\t\t}else{\n\t\t\tsb.append((char) (0xE0 + ((c >> 18) & 0x07)));\n\t\t\tsb.append((char) (0x80 + ((c >> 12) & 0x3F)));\n\t\t\tsb.append((char) (0x80 + ((c >> 6) & 0x3F)));\n\t\t}\n\t\ti = bb.get();\n\t\tlen++;\n\t}\n\treturn sb.length();\n}", "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c,o;\n\to = 0;\n\tc = (i & 0x7f);\n\twhile(c < 128) {\n\t\tc = 0;\n\t\to = (o << 7) | (c & 0x7f);\n\t\tc = (c << 7) | (c & 0x7f);\n\t}\n\tif(c < 128) {\n\t\tsb.append((char) c);\n\t\treturn o;\n\t}\n\tc = (i & 0x7f);\n\twhile(c < 256) {\n\t\tc = 0;\n\t\to = (o << 7) | (c & 0x7f);\n\t\tc = (c << 7) | (c & 0x7f);\n\t}\n\tif(c < 256) {\n\t\tsb.append((char) c);\n\t\treturn o;\n\t}\n\tc = (i & 0x7f);\n\twhile(c < 65536) {\n\t\tc = 0;\n\t\to = (o << 7) | (c & 0x7f);\n\t\tc = (c << 7) | (c & 0x7f);\n\t}\n\tif(c < 65536) {\n\t\tsb.append((char) c);\n\t\treturn o;\n\t}\n\treturn 0;\n}"]}
{"_id": "6367667f1a6d9265ec01745d", "generate_results": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n    if (u == null) return null;\n    List<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n    String type = u.getScheme();\n    if ((\"file\".equals(type)) || (\"http\".equals(type)) || (\"https\".equals(type))) {\n        return result;\n    }\n    if ((\"ws\".equals(type)) || (\"wss\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if ((\"s3\".equals(type)) || (\"s3s\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if ((\"s3b\".equals(type)) || (\"s3b1\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if ((\"s3a\".equals(type)) || (\"s3a1\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if ((\"s3b1\".equals(type)) || (\"s3b1a\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if ((\"s3b1a\".equals(type)) || (\"s3b1a1\".equals(type))) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if (\"s3b1\".equals(type)) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if (\"s3b1a\".equals(type)) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if (\"s3b1a1\".equals(type)) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else if (\"s3b1a1a\".equals(type)) {\n        try {\n            return decodePath(u.getSchemeSpecificPart(),decode);\n        } catch (URISyntaxException use) {\n            return result;\n        }\n    } else {\n        return result;\n    }\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n   List<PathSegmentImpl> list=new ArrayList<>();\n   String path=u.getPath();\n   if(path.length()>1){\n     char c1=path.charAt(1);\n     if(c1=='\\\\'){\n       path=path.substring(2);\n     }else{\n       throw new RuntimeException(\"path segment \"+path+\" is not properly encoded\");\n     }\n   }\n   int index=0;\n   while(index<path.length()){\n     char c=path.charAt(index);\n     if(c=='/' || c=='\\\\'){\n       break;\n     }\n     index++;\n   }\n   \n   if(index<path.length()){\n     char c=path.charAt(index);\n     if(c=='/' || c=='\\\\'){\n       list.add(new PathSegmentImpl(path,index,decode));\n       index++;\n     }else if(c=='\\\\'){\n       list.add(new PathSegmentImpl(path,index,decode));\n       index++;\n     }else if(c=='.'){\n       list.add(new PathSegmentImpl(path,index,decode));\n       index++;\n     }else{\n       throw new RuntimeException(\"invalid path segment \"+path+\"\");\n     }\n   }\n   return list;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n\tList<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n\t\n\tif (u.getScheme().equals(\"file\")){\n\t\tFile file = new File(u.getPath());\n\t\tif (file.exists()){\n\t\t\tresult = decodePath(file,decode);\n\t\t}\n\t}\n\t\n\tif (u.getScheme().equals(\"rmi\")){\n\t\tString host=u.getHost();\n\t\tString path=u.getPath();\n\t\tif (host.equals(\"rmi_host\")){\n\t\t\tpath = path.substring(1);\n\t\t}\n\t\t\n\t\tif (path.startsWith(\"/\")){\n\t\t\tpath = path.substring(1);\n\t\t}\n\t\t\n\t\tif (path.endsWith(\"/\")){\n\t\t\tresult = decodePath(new File(path),decode);\n\t\t}\n\t}\n\t\n\treturn result;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> out = new ArrayList<PathSegmentImpl>();\n\n\tif (u!= null &&!u.isAbsolute())\n\t\treturn null;\n\n\tif (u == null)\n\t\treturn out;\n\n\tint lastSlash = u.getPath().lastIndexOf('/');\n\tString path = u.getPath().substring(lastSlash+1);\n\n\tfor (int i = 0; i < path.length(); i++) {\n\t\tchar c = path.charAt(i);\n\t\tif (c == '\\\\') {\n\t\t\ti++;\n\t\t\tif (i == path.length())\n\t\t\t\tbreak;\n\t\t\tif (path.charAt(i) == '\\\\')\n\t\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '/')\n\t\t\tbreak;\n\t\tPathSegmentImpl segment = new PathSegmentImpl(c,path.charAt(i));\n\t\tsegment.setParent(null);\n\t\tout.add(segment);\n\t}\n\n\treturn out;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>();\n\tint len = u.getPort() == -1? u.getScheme().length() : u.getPort();\n\tfor(int i = 0;i<len;i++){\n\t\tint p = u.getScheme().indexOf(\":\");\n\t\tif(p == -1)\n\t\t\tcontinue;\n\t\tString name = u.getScheme().substring(p+1);\n\t\tif(decode)\n\t\t\tname = decode(name);\n\t\tif(name.startsWith(\"/\"))\n\t\t\tname = name.substring(1);\n\t\tint index = name.indexOf('/');\n\t\tif(index == -1){\n\t\t\tindex = name.length();\n\t\t}\n\t\tString path = name.substring(0,index);\n\t\tpath.add(new PathSegmentImpl(name.substring(index),u.getFragment()));\n\t\tpath.add(new PathSegmentImpl(path,u.getFragment()));\n\t}\n\treturn path;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> out = new ArrayList<PathSegmentImpl>();\n\tString rawPath = u.getRawPath();\n\tString[] pathSegments = rawPath.split(\"/\");\n\tfor (String pathSegment : pathSegments) {\n\t\tif (pathSegment.length() > 0) {\n\t\t\tString[] pathSegmentParts = pathSegment.split(\"\\\\\");\n\t\t\tif (pathSegmentParts.length > 0) {\n\t\t\t\tPathSegmentImpl pathSegmentImpl = new PathSegmentImpl();\n\t\t\t\tpathSegmentImpl.setPath(pathSegmentParts[0]);\n\t\t\t\tpathSegmentImpl.setRawPath(pathSegmentParts[1]);\n\t\t\t\t\n\t\t\t\tout.add(pathSegmentImpl);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn out;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n    int i = 0;\n    List<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>();\n\n    // check the raw path\n    if(u.getScheme()!=null && u.getScheme().equals(\"file\")){\n        path = decodePath(u.getPath(),decode);\n    } else {\n        // check the path\n        while(u.getPathSegments().size()>1){\n            String pathString = u.getPathSegments().get(i++).toString();\n            if(pathString.startsWith(\"/\")){\n                pathString = pathString.substring(1);\n            }\n            path.add(new PathSegmentImpl(pathString));\n        }\n        path.add(new PathSegmentImpl(\"/\"));\n    }\n\n    return path;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> path=new ArrayList<PathSegmentImpl>();\n\tint i=0;\n\tif(u.getScheme()==null){\n\t\treturn path;\n\t}\n\tif(u.getScheme().equals(\"file\")){\n\t\tif(u.getPath().endsWith(\".bin\")){\n\t\t\tpath.clear();\n\t\t\treturn path;\n\t\t}\n\t\twhile(i<u.getPath().length()){\n\t\t\tif(u.getPath().charAt(i)=='/'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tpath.add(new PathSegmentImpl(u.getPath().substring(0,i),u.getPath().substring(i)));\n\t\treturn path;\n\t}\n\tif(u.getScheme().equals(\"jar\")){\n\t\tif(u.getPath().endsWith(\".jar\")){\n\t\t\tpath.clear();\n\t\t\treturn path;\n\t\t}\n\t\twhile(i<u.getPath().length()){\n\t\t\tif(u.getPath().charAt(i)=='/'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tpath.add(new PathSegmentImpl(u.getPath().substring(0,i),u.getPath().substring(i)));\n\t\treturn path;\n\t}\n\treturn path;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> r = new LinkedList<PathSegmentImpl>();\n\tint count = 0;\n\tint i = 0;\n\tint j = 0;\n\tint start = 0;\n\tint end = 0;\n\twhile(i < u.getPathSegments().size()){\n\t\tPathSegmentImpl ps = (PathSegmentImpl)u.getPathSegments().get(i);\n\t\tif(ps.isElement()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isReference()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isReferenceValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttribute()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isText()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isComment()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isElementValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValueValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValueValue() && decode){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValueValue() &&!decode){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValueValue() &&!decode){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isAttributeValueValue() && decode){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti++;\n\t\t}else if(ps.isTextValue()){\n\t\t\tcount++;\n\t\t\tstart = i;\n\t\t\tend = i;\n\t\t\ti", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tfinal List<PathSegmentImpl> ret=new ArrayList<>();\n\tif(u==null){ return ret; }\n\tfinal Path path=new Path(u.getScheme(),u.getUserInfo(),u.getHost(),u.getPort(),u.getPath());\n\tpath.normalize();\n\t\n\tif(path.isAbsolute()){\n\t\tret.add(new PathSegmentImpl(path,decode));\n\t}else{\n\t\tfor(int i=0;i<path.getNameCount();i++){\n\t\t\tfinal String name=path.getName(i);\n\t\t\tfinal PathSegmentImpl s=new PathSegmentImpl(path,decode);\n\t\t\ts.setName(name);\n\t\t\tret.add(s);\n\t\t}\n\t}\n\treturn ret;\n}"]}
{"_id": "636766861a6d9265ec01755a", "generate_results": ["public final MatchResult match(CharSequence uri){\n    if(uri==null){\n        return null;\n    }\n    String url = uri.toString();\n    if(!matchPattern(url)){\n        return null;\n    }\n    URLPattern pattern = _patterns.get(url);\n    if(pattern==null){\n        return null;\n    }\n    return pattern.match(uri);\n}", "public final MatchResult match(CharSequence uri){\n\tif(uri==null||uri.length()==0){\n\t\treturn null;\n\t}\n\tboolean match=false;\n\tint offset=uri.length()-1;\n\tint end=uri.length()-1;\n\twhile(offset>=0&&end>=0){\n\t\tchar c=uri.charAt(offset);\n\t\tif(c=='.'){\n\t\t\toffset--;\n\t\t\tend--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c=='*'){\n\t\t\toffset--;\n\t\t\tend--;\n\t\t\twhile(offset>=0&&end>=0){\n\t\t\t\tc=uri.charAt(offset);\n\t\t\t\tif(c=='*'){\n\t\t\t\t\toffset--;\n\t\t\t\t\tend--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(c=='?'){\n\t\t\t\t\toffset--;\n\t\t\t\t\tend--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(c=='?'){\n\t\t\t\toffset--;\n\t\t\t\tend--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tmatch=true;\n\t\tbreak;\n\t}\n\tif(match){\n\t\treturn new MatchResult(uri,offset,end);\n\t}\n\treturn null;\n}", "public final MatchResult match(CharSequence uri){\n\treturn this.match(uri, null);\n}", "public final MatchResult match(CharSequence uri){\n  if(uri == null){\n    return null;\n  }\n  return match(CharSequences.toString(uri));\n}", "public final MatchResult match(CharSequence uri){\n  if(uri == null) return null;\n  if(uri.length() == 0) return null;\n  if(uri.charAt(0) == '#') return null;\n  if(uri.charAt(uri.length()-1) == '#') return null;\n  \n  int matchIndex = 0;\n  int matchLength = 0;\n  \n  int i = 0;\n  int j = uri.length()-1;\n  \n  while(i < j){\n    char c = uri.charAt(i);\n    if(c == '%'){\n      i++;\n      if(i >= j) return null;\n      char c2 = uri.charAt(i);\n      if(c2 == 'A'){\n        if(c == 'A'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'a'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'b'){\n        if(c == 'b'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'B'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'c'){\n        if(c == 'c'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'C'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'd'){\n        if(c == 'd'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'D'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'e'){\n        if(c == 'e'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'E'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'f'){\n        if(c == 'f'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'F'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'g'){\n        if(c == 'g'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'G'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'h'){\n        if(c == 'h'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'H'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'i'){\n        if(c == 'i'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'I'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'j'){\n        if(c == 'j'){\n          matchIndex = i;\n          matchLength = 2;\n        }else if(c == 'J'){\n          matchIndex = i;\n          matchLength = 1;\n        }else{\n          return null;\n        }\n        i++;\n      }else if(c == 'k'){\n        if(c == 'k'){\n          matchIndex = i;\n          matchLength", "public final MatchResult match(CharSequence uri){\n  if(uri == null){\n    return null;\n  }\n  CharSequence match = this.match(uri);\n  if(match!= null){\n    return new MatchResult(match, uri);\n  }\n  return null;\n}", "public final MatchResult match(CharSequence uri){\n\tif (uri.length() == 0) return null;\n\tif (uri.toString().startsWith(\"/\")) {\n\t\treturn null;\n\t}\n\tif (uri.toString().endsWith(\"/\")) {\n\t\turi = uri.subSequence(0, uri.length()-1);\n\t}\n\tMatchResult result = null;\n\tif (uri.toString().matches(\"/\")){\n\t\tresult = new MatchResult(uri, new MatchResult.MatchType(MatchResult.MatchType.Path));\n\t} else if (uri.toString().matches(\"*\")){\n\t\tresult = new MatchResult(uri, new MatchResult.MatchType(MatchResult.MatchType.WildCard));\n\t} else if (uri.toString().matches(\"?\")){\n\t\tresult = new MatchResult(uri, new MatchResult.MatchType(MatchResult.MatchType.Query));\n\t} else if (uri.toString().matches(\"#\")){\n\t\tresult = new MatchResult(uri, new MatchResult.MatchType(MatchResult.MatchType.Fragment));\n\t} else if (uri.toString().matches(\"/\")){\n\t\tresult = new MatchResult(uri, new MatchResult.MatchType(MatchResult.MatchType.PathAndWildCard));\n\t}\n\treturn result;\n}", "public final MatchResult match(CharSequence uri){\n    return uri.toString().equals(url)? this : null;\n}", "public final MatchResult match(CharSequence uri){\n\tif(uri == null)\n\t\tthrow new NullPointerException(\"uri\");\n\tif(uri.length() == 0)\n\t\treturn null;\n\tMatcher matcher = getPattern().matcher(uri);\n\tif(matcher.matches()){\n\t\treturn new MatchResult(true, matcher.group(1));\n\t}\n\treturn null;\n}", "public final MatchResult match(CharSequence uri){\n\tif(uri == null || uri.length() == 0)\n\t\treturn null;\n\treturn match(CharSequences.toString(uri, '%'), CharSequences.toString(uri, '%'), CharSequences.toString(uri, '%'));\n}"]}
{"_id": "636766861a6d9265ec017553", "generate_results": ["public final boolean isTemplateVariablePresent(String name){\n\tfor(String[] variable:templateVariables){\n\t\tif(variable[0].equals(name)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public final boolean isTemplateVariablePresent(String name){\n\tboolean isPresent=false;\n\tif(name!=null){\n\t\tif(name.equals(Template.templateVariable)){\n\t\t\tisPresent=true;\n\t\t}\n\t}\n\treturn isPresent;\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn getTemplate(name)!= null;\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn getTemplateVariables().contains(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n    return (this.getTemplateVariables().containsKey(name));\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn this.members.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\tif(memberVariables.containsKey(name)){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "public final boolean isTemplateVariablePresent(String name){\n    String prefix = getTemplateNamePrefix();\n    String nameWithSubst = name.substring(prefix.length());\n    return templateVariables.containsKey(nameWithSubst) || templateVariables.containsKey(nameWithSubst.substring(0, prefix.length()));\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn this.getTemplateVariablesArray()!=null && this.getTemplateVariablesArray()[this.getTemplateVariablesArray().length-1]==name;\n}", "public final boolean isTemplateVariablePresent(String name){\n    return templateVariables.containsKey(name);\n}"]}
{"_id": "636766801a6d9265ec017487", "generate_results": ["public static String encodeTemplateNames(String s){\n\tif(StringUtils.isEmpty(s)){\n\t\treturn \"\";\n\t}\n\tStringBuilder sb = new StringBuilder();\n\tint i = 0;\n\tint j = 0;\n\twhile(i < s.length()){\n\t\tif(Character.isUpperCase(s.charAt(i))){\n\t\t\tsb.append(Character.toUpperCase(s.charAt(i)));\n\t\t\ti++;\n\t\t}else{\n\t\t\tsb.append(s.charAt(i));\n\t\t\ti++;\n\t\t}\n\t\tif(i < s.length()){\n\t\t\tif(Character.isUpperCase(s.charAt(i))){\n\t\t\t\tsb.append(Character.toUpperCase(s.charAt(i)));\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tsb.append(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n    String result = \"\";\n    \n    if(s == null){\n        return s;\n    }\n    \n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (c == '{') {\n            result = result + \"{\";\n        } else if (c == '}') {\n            result = result + \"}\";\n        } else if (c == '\\\\' && i < s.length() - 1) {\n            char c2 = s.charAt(i + 1);\n            if (c2 == '{') {\n                result = result + \"\\\\{\";\n            } else if (c2 == '}') {\n                result = result + \"\\\\}\";\n            } else {\n                result = result + c2;\n            }\n            i++;\n        } else {\n            result = result + c;\n        }\n    }\n    \n    return result;\n}", "public static String encodeTemplateNames(String s){\n\tString ret=\"\";\n\tif(s.length()>0)\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='{')\n\t\t\t\tret+=s.substring(i,i+1);\n\t\t\telse if(s.charAt(i)=='}')\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\telse if(s.charAt(i)=='%'){\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\t\ti+=3;\n\t\t\t}else if(s.charAt(i)=='\\'')\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\telse if(s.charAt(i)=='\\\"')\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\telse if(s.charAt(i)=='$')\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\telse if(s.charAt(i)==' ')\n\t\t\t\tret+=s.substring(i+1,i+2);\n\t\t\telse\n\t\t\t\tret+=s.charAt(i);\n\t\t}\n\treturn ret;\n}", "public static String encodeTemplateNames(String s){\n//\tString s2=s;\n//\tint i=0;\n//\tfor(i=0;i<s.length();i++){\n//\t\tif(s.charAt(i)=='{'){\n//\t\t\ts2=s2.replace(s.charAt(i),'{');\n//\t\t}else if(s.charAt(i)=='}'){\n//\t\t\ts2=s2.replace(s.charAt(i),'}');\n//\t\t}else{\n//\t\t\ts2=s2.replace(s.charAt(i),s.charAt(i)+'{');\n//\t\t}\n//\t}\n//\treturn s2;\n//}\n//\n//public static String decodeTemplateNames(String s){\n//\tString s2=s;\n//\tint i=0;\n//\tfor(i=0;i<s.length();i++){\n//\t\tif(s.charAt(i)=='{'){\n//\t\t\ts2=s2.replace(s.charAt(i),'{');\n//\t\t}else if(s.charAt(i)=='}'){\n//\t\t\ts2=s2.replace(s.charAt(i),'}');\n//\t\t}else{\n//\t\t\ts2=s2.replace(s.charAt(i),s.charAt(i)+'{');\n//\t\t}\n//\t}\n//\treturn s2;\n//}\n\n}\n", "public static String encodeTemplateNames(String s){\n\tStringBuilder ret=new StringBuilder();\n\tString s1=s;\n\tString s2=s1.replace(\"{\", \"{\");\n\ts2=s1.replace(\"}\", \"}\");\n\tString s3=s2;\n\tString s4=s3.replace(\"{\", \"{{\");\n\ts3=s3.replace(\"}\", \"}}\");\n\tString s5=s4;\n\tString s6=s5.replace(\"{\", \"{{\");\n\ts5=s5.replace(\"}\", \"}}\");\n\tString s7=s6;\n\tString s8=s7.replace(\"{\", \"{{\");\n\ts7=s7.replace(\"}\", \"}}\");\n\tString s9=s8;\n\tString s11=s9.replace(\"{\", \"{{\");\n\ts9=s9.replace(\"}\", \"}}\");\n\tString s12=s11;\n\tString s13=s12.replace(\"{\", \"{{\");\n\ts12=s12.replace(\"}\", \"}}\");\n\tString s14=s13;\n\tString s15=s14.replace(\"{\", \"{{\");\n\ts14=s14.replace(\"}\", \"}}\");\n\tString s16=s15;\n\tString s17=s16.replace(\"{\", \"{{\");\n\ts16=s16.replace(\"}\", \"}}\");\n\tString s19=s17;\n\tString s20=s19.replace(\"{\", \"{{\");\n\ts19=s19.replace(\"}\", \"}}\");\n\tString s21=s20;\n\tString s22=s21.replace(\"{\", \"{{\");\n\ts21=s21.replace(\"}\", \"}}\");\n\tString s23=s22;\n\tString s24=s23.replace(\"{\", \"{{\");\n\ts23=s23.replace(\"}\", \"}}\");\n\tString s25=s24;\n\tString s26=s25.replace(\"{\", \"{{\");\n\ts25=s25.replace(\"}\", \"}}\");\n\tString s27=s26;\n\tString s28=s27.replace(\"{\", \"{{\");\n\ts27=s27.replace(\"}\", \"}}\");\n\tString s29=s28;\n\tString s31=s29.replace(\"{\", \"{{\");\n\ts29=s29.replace(\"}\", \"}}\");\n\tString s32=s31;\n\tString s33=s32.replace(\"{\", \"{{\");\n\ts32=s32.replace(\"}\", \"}}\");\n\tString s34=s33;\n\tString s35=s34.replace(\"{\", \"{{\");\n\ts34=s34.replace(\"}\", \"}}\");\n\tString s36=s35;\n\tString s37=s36.replace(\"{\", \"{{\");\n\ts36=s36.replace(\"}\", \"}}\");\n\tString s38=s37;\n\tString s39=s38.replace(\"{\", \"{{\");\n\ts38=s38.replace(\"}\", \"}}\");\n\tString s40=s39;\n\tString s41=s40.replace(\"{\", \"{{\");\n\ts40=s40.replace(\"}\", \"}}\");\n\tString s42=s41;\n\tString s43=s42.replace(\"{\", \"{{\");\n\ts42=s42.replace(\"}\", \"}}\");\n\tString s44=s43;\n\tString s45=s44.replace(\"{\", \"{{\");\n\ts45=s45.replace(\"}\", \"}}\");\n\tString s46=s45;\n\tString s47=s46.replace(\"{\", \"{{\");\n\ts46=s46.replace(\"}\", \"}}\");\n\tString s48=s47;\n\tString s49=s48.replace(\"{\", \"{{\");\n\ts48=s48.replace(\"}\", \"}}\");\n\tString s50=s49;\n\tString s51=s50.replace(\"{\", \"{{\");\n\ts50=s50.replace(\"}\", \"}}\");\n\tString s52=s51;\n\tString s53=s52", "public static String encodeTemplateNames(String s){\n\tStringBuffer sb = new StringBuffer(\"\");\n\ts = s.replaceAll(\"{\", \"\\\\{\");\n\ts = s.replaceAll(\"}\", \"\\\\}\");\n\tfor(int i=0;i<s.length();i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"{{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}}\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}", "public static String encodeTemplateNames(String s){\n  String s1 = s.replaceAll(\"{\", \"\\\\{\").replaceAll(\"}\", \"\\\\}\");\n  return s1;\n}", "public static String encodeTemplateNames(String s){\nint count = 0;\nStringBuffer sb = new StringBuffer();\nint i = 0;\nwhile (i < s.length()){\nif (s.charAt(i) == '{'){\nsb.append('{');\ni++;\ncount++;\nif (count > 1) count--", "public static String encodeTemplateNames(String s){\n    if(s==null||s.length()==0)\n        return \"\";\n    StringBuilder sb=new StringBuilder();\n    for(int i=0;i<s.length();i++){\n        char c=s.charAt(i);\n        if(c=='{'){\n            c=s.charAt(i+1);\n            sb.append(c);\n        }else if(c=='}'){\n            sb.append(\"\\\\\");\n            sb.append(s.charAt(i+1));\n            sb.append(\"}\");\n        }else if(c=='\\\\'){\n            sb.append(\"\\\\\\\\\");\n        }else{\n            sb.append(c);\n        }\n    }", "public static String encodeTemplateNames(String s){\n\tStringBuffer sb = new StringBuffer();\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append('{');\n\t\t}else if(c == '}'){\n\t\t\tsb.append('}');\n\t\t}else if(c == '{' && i + 1 < s.length()){\n\t\t\tsb.append('{');\n\t\t\ti++;\n\t\t}else if(c == '}' && i + 1 < s.length()){\n\t\t\tsb.append('}');\n\t\t\ti++;\n\t\t}else{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}"]}
{"_id": "6367667f1a6d9265ec01745c", "generate_results": ["Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    try{\n        Enumeration<URL> e = cpV.elements();\n        while (e.hasMoreElements()){\n           URL url = e.nextElement();\n           File file = new File(url.getFile());\n           String name = file.getName();\n           if (name.endsWith(\".jar\") || name.endsWith(\".zip\")){\n               System.out.println(\"Adding jar file to classpath: \"+url);\n               String jarUrl = url.toString();\n               ClassLoader cl = cpV.get(0).getClass().getClassLoader();\n               cl.addResource(jarUrl);\n           }\n        }\n    }\n    catch(Exception e){\n        e.printStackTrace();\n    }\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tif (cpV == null) return;\n\tfor (int i = 0; i < cpV.size(); i++) {\n\t\tURL url = cpV.get(i);\n\t\ttry {\n\t\t\tClassLoader classLoader = url.openStream().getClass().getClassLoader();\n\t\t\tif (classLoader.getParent()!= null) {\n\t\t\t\tif (classLoader.getParent().getResource(dir)!= null) {\n\t\t\t\t\tcpV.add(url);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tfor (int i=0; i<cpV.size(); i++) {\n\t\tString jar = cpV.elementAt(i);\n\t\tFile jarFile = new File(jar);\n\t\tif (jarFile.exists()) {\n\t\t\tcpV.setElementAt(jar,i);\n\t\t\ttry {\n\t\t\t\tClass.forName(\"org.apache.harmony.luni.util.jar.JarFileURLClasspath\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(\"Could not load JarFileURLClasspath\");\n\t\t\t}\n\t\t}\n\t}\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tfor ( int i = 0; i < cpV.size(); i++ ){\n\t\tFile f = new File(cpV.elementAt(i));\n\t\tif ( f.isDirectory() ){\n\t\t\taddToClassPath(cpV, f.getPath());\n\t\t} else if ( f.exists() ){\n\t\t\tString fname = f.getPath().substring(0, f.getPath().length() - 5);\n\t\t\taddToClassPath(cpV, fname);\n\t\t}\n\t}\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tFile f = new File(dir);\n\tString s = f.getAbsolutePath();\n\tcpV.addElement(new URL(s));\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    for(int i=0;i<cpV.size();i++){\n        String cp = cpV.elementAt(i);\n        String cp_dir = cp.substring(0,cp.indexOf(dir));\n        cpV.setElementAt(cp_dir+cp,i);\n    }\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\t  for(int i = 0; i < cpV.size(); i++) {\n\t\t  String cpUrl = cpV.elementAt(i);\n\t\t  Vector<URL> cpV1 = new Vector<URL>();\n\t\t  cpV1.addElement(cpUrl);\n\t\t  addToClassPath(cpV1,dir);\n\t  }\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\t\n\t//get the list of jar files\n\tVector<URL> jarList = new Vector<URL>();\n\tFile f = new File(dir);\n\tFile[] files = f.listFiles();\n\tif(files!= null) {\n\t\tfor(File file : files) {\n\t\t\tjarList.add(file.getAbsoluteFile().toURI().toURL());\n\t\t}\n\t}\n\t\n\t\n\t//now add all the jar files to the classpath\n\tfor(URL jar : jarList) {\n\t\tString path = jar.getFile();\n\t\t\n\t\t//if the jar is a jar file, then add it to the classpath\n\t\tif(path.endsWith(\".jar\")) {\n\t\t\tcpV.add(jar);\n\t\t}\n\t}\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    ClassLoader classLoader= Thread.currentThread().getContextClassLoader();\n    //get the classloader's classloader:\n    ClassLoader loader= classLoader.getParent();\n\n    //go through the jar files in the given dir, adding them to the classpath:\n    Enumeration<URL> urls= cpV.elements();\n    while (urls.hasMoreElements()) {\n        //get the url:\n        URL url= urls.nextElement();\n\n        //add the jar file:\n        File jarFile= new File(dir, url.getFile());\n        try {\n            jarFile.getParentFile().mkdirs();\n            JarFile jar= new JarFile(jarFile);\n            Enumeration<JarEntry> entries= jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry= entries.nextElement();\n                //get the name of the jar file:\n                String name= entry.getName();\n\n                //if it's a.class file, add it to the classpath:\n                if (name.endsWith(\".class\")) {\n                    //create a new classloader:\n                    ClassLoader cl= loader.getParent();\n\n                    //add the jar file to the classpath:\n                    addToClassPath(cl.getResources(name), jarFile.getPath());\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tURL url=new File(dir).toURI().toURL();\n\tif(cpV.contains(url)){throw new IllegalArgumentException(\"Can't add \"+url+\" to classpath since it already exists.\");}\n\tcpV.addElement(url);\n}"]}
{"_id": "636766821a6d9265ec0174bf", "generate_results": ["public static String capitalize(String name){\n\tStringBuilder sb = new StringBuilder();\n\tchar firstChar = name.charAt(0);\n\tsb.append(Character.toUpperCase(firstChar));\n\tfor(int i=1; i<name.length(); i++){\n\t\tsb.append(Character.toUpperCase(name.charAt(i)));\n\t}\n\treturn sb.toString();\n}", "public static String capitalize(String name){\n    return name.substring(0, 1).toUpperCase() + name.substring(1);\n}", "public static String decapitalize(String name){\n\tString[] parts = name.split(\" \");\n\t\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(parts[0].charAt(0));\n\tfor(int i = 1; i < parts.length; i++){\n\t\tsb.append(parts[i].charAt(0));\n\t}\n\treturn sb.toString();\n}", "public static String capitalize(String name){\n    char[] chars = name.toCharArray();\n    char first = chars[0];\n    char last = chars[chars.length - 1];\n    String capitalized = new String();\n    for(int i=0; i<chars.length; i++){\n        capitalized.append(Character.toUpperCase(first));\n        capitalized.append(Character.toUpperCase(last));\n    }\n    return capitalized;\n}", "public static String capitalize(String name){\n    char[] letters = name.toCharArray();\n    char firstLetter = letters[0];\n    if(firstLetter == 'a' || firstLetter == 'A'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'b' || firstLetter == 'B'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'c' || firstLetter == 'C'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'd' || firstLetter == 'D'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'e' || firstLetter == 'E'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'f' || firstLetter == 'F'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'g' || firstLetter == 'G'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'h' || firstLetter == 'H'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'i' || firstLetter == 'I'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'j' || firstLetter == 'J'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'k' || firstLetter == 'K'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'l' || firstLetter == 'L'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter =='m' || firstLetter == 'M'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'n' || firstLetter == 'N'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'o' || firstLetter == 'O'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'p' || firstLetter == 'P'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'q' || firstLetter == 'Q'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'r' || firstLetter == 'R'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter =='s' || firstLetter == 'S'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 't' || firstLetter == 'T'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'u' || firstLetter == 'U'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'v' || firstLetter == 'V'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'w' || firstLetter == 'W'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'x' || firstLetter == 'X'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'y' || firstLetter == 'Y'){\n        return new String(new char[]{firstLetter, firstLetter});\n    }\n    else if(firstLetter == 'z' || firstLetter == 'Z'){\n", "public static String capitalize(String name){\n    return name.substring(0, 1).toUpperCase() + name.substring(1);\n}", "public static String capitalize(String name){\n\tString out = name.toUpperCase();\n\treturn out;\n}", "public static String capitalize(String name){\n    String[] parts = name.split(\"\\\\s\");\n    parts[0] = parts[0].toUpperCase();", "public static String capitalize(String name){\n    String[] array = name.toCharArray();\n    int first = array[0].toUpperCase().charAt(0);\n    int last = array[array.length - 1].toUpperCase().charAt(0);\n    \n    return capitalize(first)+capitalize(last);\n}", "public static String capitalize(String name){\n\tString[] list = name.split(\"\\\\s\");\n\tchar[] charArray = new char[list.length];\n\tfor(int i = 0; i < list.length; i++){\n\t\tcharArray[i] = Character.toUpperCase(list[i].charAt(0));\n\t}\n\treturn new String(charArray);\n}"]}
{"_id": "6367667d1a6d9265ec017401", "generate_results": ["public static String unescapeJava(String str) throws Exception {\n\tchar c;\n\tint len = str.length();\n\t\n\tif (len < 2)\n\t\treturn str;\n\t\n\tint index = 0;\n\twhile (index < len) {\n\t\tc = str.charAt(index);\n\t\tif (c == '\\\\') {\n\t\t\tindex++;\n\t\t\tif (index < len) {\n\t\t\t\tc = str.charAt(index);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase 'n':\n\t\t\t\t\tc = '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tc = '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tc = '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tc = '\\\\';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tc = str.charAt(index + 1);\n\t\t\t\t\tindex += 3;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tindex++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr = str.substring(0, index) + c +\n\t\t\tstr.substring(index + 1);\n\t\tindex++;\n\t}\n\t\n\treturn str;\n}", "public static String unescapeJava(String str) throws Exception {\n    if (str == null) {\n      return null;\n    }\n    if (str.length() == 0) {\n      return str;\n    }\n    StringBuilder result = new StringBuilder();\n    String[] hexStrings = str.split(\"\\\\\\\\\");\n    for (String hexString : hexStrings) {\n      result.append(unescape(hexString));\n    }\n    return result.toString();\n  }", "public static String unescapeJava(String str) throws Exception {\n    // If the string starts with a backslash, it is probably not an escaped Java\n    // string.\n    if (str.startsWith(\"\\\\\\\\\") || str.startsWith(\"\\\\u0\")) {\n      return str;\n    }\n\n    // If it is not an escaped Java string, it is likely an escaped Java\n    // string.\n    int end = str.length();\n    for (int i = 0; i < end; ++i) {\n      if (str.charAt(i) == '\\\\') {\n        // Find the next character that can be escaped.\n        int index = i + 1;\n        while (index < end && str.charAt(index) == '\\\\') {\n          ++index;\n        }\n        // If we found the end of the string, this is an escaped Java string.\n        if (index == end) {\n          return str.substring(i + 1, end);\n        }\n        // Otherwise, we saw an escaped Java string.\n        return str.substring(i + 1, index);\n      }\n    }\n\n    // If we're here, it must have been a Java string that couldn't be escaped.\n    throw new IllegalArgumentException(\"Cannot unescape Java string: \" + str);\n  }", "public static String unescapeJava(String str) throws Exception {\n\t// Unescape the code\n\treturn unescape(str);\n}", "public static String unescapeJava(String str) throws Exception {\n    int len = str.length();\n    int newLen = 0;\n\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        if (ch == '%') {\n            if (newLen < 4) {\n                newLen++;\n            }\n            if (str.charAt(i + 1) == 'A') {\n                if (newLen == 2) {\n                    return str.substring(i + 2, i + 3);\n                } else if (newLen == 3) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else {\n                    return str.substring(i + 3, i + 4);\n                }\n            } else if (ch == 'a') {\n                if (newLen == 1) {\n                    return str.substring(i + 2, i + 3);\n                } else if (newLen == 2) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 4, i + 5);\n                }\n            } else if (ch == 'b') {\n                if (newLen == 1) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else if (newLen == 2) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4)\n                            + str.substring(i + 4, i + 5);\n                } else {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 4, i + 5)\n                            + str.substring(i + 5, i + 6);\n                }\n            } else if (ch == 't') {\n                if (newLen == 1) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else if (newLen == 2) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4)\n                            + str.substring(i + 4, i + 5);\n                } else {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 4, i + 5)\n                            + str.substring(i + 5, i + 6);\n                }\n            } else if (ch == 'n') {\n                if (newLen == 1) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else if (newLen == 2) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4)\n                            + str.substring(i + 4, i + 5);\n                } else {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 4, i + 5)\n                            + str.substring(i + 5, i + 6);\n                }\n            } else if (ch == 'r') {\n                if (newLen == 1) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4);\n                } else if (newLen == 2) {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 3, i + 4)\n                            + str.substring(i + 4, i + 5);\n                } else {\n                    return str.substring(i + 2, i + 3)\n                            + str.substring(i + 4, i + 5)\n                            + str.substring(i + 5, i + 6);\n                }\n            } else if (ch == 'f') {", "public static String unescapeJava(String str) throws Exception {\n    StringBuilder buf = new StringBuilder();\n    int i = 0;\n    while (i < str.length()) {\n      char ch = str.charAt(i);\n      if (ch == '\\\\') {\n        char ch2 = str.charAt(i + 1);\n        switch (ch2) {\n          case 'b':\n            buf.append('\\b');\n            break;\n          case 'f':\n            buf.append('\\f');\n            break;\n          case 'n':\n            buf.append('\\n');\n            break;\n          case 'r':\n            buf.append('\\r');\n            break;\n          case 't':\n            buf.append('\\t');\n            break;\n          case 'u':\n            buf.append((int) (0x10000 + ch - 0x2028) - 0x10000);\n            break;\n          case '\\\\':\n            buf.append('\\\\');\n            break;\n          default:\n            buf.append(ch);\n            break;\n        }\n        i += 2;\n      } else {\n        buf.append(ch);\n        i++;\n      }\n    }\n    return buf.toString();\n  }", "public static String unescapeJava(String str) throws Exception {\n    // This assumes that the String is only unescaped.\n    StringBuilder sb = new StringBuilder();\n    int i = 0;\n    while (i < str.length()) {\n        char ch = str.charAt(i);\n        if (ch == '\\\\') {\n            // This is a backslash.\n            sb.append(str.charAt(i + 1));\n            i++;\n            continue;\n        }\n\n        switch (ch) {\n            case 'n':\n                sb.append('\\n');\n                break;\n            case 't':\n                sb.append('\\t');\n                break;\n            case 'r':\n                sb.append('\\r');\n                break;\n            case 'b':\n                sb.append('\\b');\n                break;\n            case 'f':\n                sb.append('\\f');\n                break;\n            case 'u':\n                int codePoint;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigits = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBefore = 0;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfter = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfter = 0;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfterAfter = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfter = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfterAfter = 0;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfterAfterAfter = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfterAfter = 0;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfterAfterAfterAfter = 0;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfterAfter = 0;\n\n                // The number of hexadecimal digits before the 'u' character.\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsBefore = str.length() - i - 1;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfter = hexDigitsBefore;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfter = str.length() - i - 1;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfter = hexDigitsAfter;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfter = hexDigitsBefore;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfter = hexDigitsBefore;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfterAfter = hexDigitsAfter;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsBeforeAfterAfterAfter = hexDigitsBeforeAfter;\n\n                // The number of hexadecimal digits before the 'u' character.\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsBefore = hexDigitsBefore;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfter = hexDigitsBeforeAfter;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfter = hexDigitsAfter;\n                // The number of hexadecimal digits after the 'u' character.\n                int hexDigitsAfterAfter = hexDigitsAfterAfter;\n                // The number of hexadecimal digits before the 'u' character.\n                int hexDigitsBeforeAfterAfter = hexDig", "public static String unescapeJava(String str) throws Exception {\n    StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n      char ch = str.charAt(i);\n      if (ch == '\\\\' && (i == 0 || str.charAt(i - 1)!= '\\\\')) {\n        i++;\n        if (i == str.length()) {\n          throw new IllegalArgumentException(\n              \"Unable to unescape Java. This is not a valid escaping.\");\n        }\n        ch = str.charAt(i);\n        if (ch == 'u') {\n          String hex = str.substring(i + 1, str.length() - 1);\n          int len = hex.length();\n          if (len % 2!= 0) {\n            throw new IllegalArgumentException(\"Unable to unescape Java. \"\n                + \"The escape character must be a multiple of 2.\");\n          }\n          for (int j = 0; j < len; j += 2) {\n            int digit = Integer.parseInt(hex.substring(j, j + 2), 16);\n            if (digit < 0 || digit > 255) {\n              throw new IllegalArgumentException(\"Unable to unescape Java. \"\n                  + \"The escape character must be a multiple of 2.\");\n            }\n            buf.append((char) digit);\n          }\n        } else {\n          buf.append(ch);\n        }\n      } else {\n        buf.append(ch);\n      }\n    }\n    return buf.toString();\n  }", "public static String unescapeJava(String str) throws Exception {\n    //\n    // The following is a modified version of the original\n    //\n    // StringUtils.unescapeJava(String)\n    //\n    // from the JDK source code:\n    //\n    // Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.\n    //\n    // Redistribution and use in source and binary forms, with or\n    // without modification, are permitted provided that the following\n    // conditions are met:\n    //\n    // - Redistributions of source code must retain the above copyright\n    //   notice, this list of conditions and the following disclaimer.\n    //\n    // - Redistributions in binary form must reproduce the above\n    //   copyright notice, this list of conditions and the following\n    //   disclaimer in the documentation and/or other materials\n    //   provided with the distribution.\n    //\n    // - Neither the name of Oracle nor the names of its\n    //   contributors may be used to endorse or promote products\n    //   derived from this software without specific prior written\n    //   permission.\n    //\n    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n    // CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n    // INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n    // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n    // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n    // NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n    // OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n    // EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n    //\n    // The following modified form of the original does not\n    // support unescaping.  Please refer to the original for\n    // more information.\n    //\n    // StringUtil.unescapeJava(String)\n    //\n    // From the JDK source code:\n    //\n    // Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.\n    //\n    // Redistribution and use in source and binary forms, with or\n    // without modification, are permitted provided that the following\n    // conditions are met:\n    //\n    // - Redistributions of source code must retain the above copyright\n    //   notice, this list of conditions and the following disclaimer.\n    //\n    // - Redistributions in binary form must reproduce the above\n    //   copyright notice, this list of conditions and the following\n    //   disclaimer in the documentation and/or other materials\n    //   provided with the distribution.\n    //\n    // - Neither the name of Oracle nor the names of its\n    //   contributors may be used to endorse or promote products\n    //   derived from this software without specific prior written\n    //   permission.\n    //\n    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n    // CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n    // INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n    // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n    // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n    // NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n    // CONTRACT, STRICT", "public static String unescapeJava(String str) throws Exception {\n    StringBuilder buf = new StringBuilder();\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n      char ch = str.charAt(i);\n      if (ch == '\\\\') {\n        if (i + 1 < len && str.charAt(i + 1) == 'u') {\n          int codePoint = Integer.parseInt(str.substring(i + 2, i + 6), 16);\n          if (codePoint >= 0xD800 && codePoint <= 0xDBFF) {\n            buf.append(\"\\\\u\");\n            buf.append(Integer.toHexString(codePoint));\n          } else {\n            buf.append(\"\\\\u\");\n            buf.append(Integer.toHexString(codePoint & 0x1F));\n          }\n          i += 6;\n        } else {\n          buf.append(\"\\\\u\");\n          buf.append(Integer.toHexString(ch & 0x0F));\n          i++;\n        }\n      } else {\n        buf.append(ch);\n      }\n    }\n    return buf.toString();\n  }"]}
{"_id": "636766851a6d9265ec01751b", "generate_results": ["Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n    if(c<'0' || c>'9'){ return''; }\n    return Character.toUpperCase((char) (c - '0'));\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\tc = Character.toLowerCase(c);\n\tif(c >= '0' && c <= '9'){\n\t\treturn c - '0';\n\t}\n\tif(c >= 'a' && c <= 'f'){\n\t\treturn c - 'a' + 10;\n\t}\n\tif(c >= 'A' && c <= 'F'){\n\t\treturn c - 'A' + 10;\n\t}\n\tif(c >= '0' && c <= '9'){\n\t\treturn c - '0';\n\t}\n\tthrow new IllegalArgumentException(\"Invalid hexadecimal number: \" + c);\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\t\n\tif(c >= '0' && c < '9'){\n\t\treturn c - '0';\n\t}\n\telse if(c >= 'a' && c < 'f'){\n\t\treturn c - 'a' + 10;\n\t}\n\telse if(c >= 'A' && c < 'F'){\n\t\treturn c - 'A' + 10;\n\t}\n\telse{\n\t\treturn -1; //Invalid\n\t}\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n    switch(c){\n        case '0':\n            return 'B';\n            break;\n        case '1':\n            return 'C';\n            break;\n        case '2':\n            return 'D';\n            break;\n        case '3':\n            return 'E';\n            break;\n        case '4':\n            return 'F';\n            break;\n        case '5':\n            return 'G';\n            break;\n        case '6':\n            return 'H';\n            break;\n        case '7':\n            return 'I';\n            break;\n        case '8':\n            return 'J';\n            break;\n        case '9':\n            return 'K';\n            break;\n        case 'a':\n            return 'L';\n            break;\n        case 'b':\n            return 'M';\n            break;\n        case 'c':\n            return 'N';\n            break;\n        case 'd':\n            return 'O';\n            break;\n        case 'e':\n            return 'P';\n            break;\n        case 'f':\n            return 'Q';\n            break;\n        case 'g':\n            return 'R';\n            break;\n        case 'h':\n            return 'S';\n            break;\n        case 'i':\n            return 'T';\n            break;\n        case 'j':\n            return 'U';\n            break;\n        case 'k':\n            return 'V';\n            break;\n        case 'l':\n            return 'W';\n            break;\n        case'm':\n            return 'X';\n            break;\n        case 'n':\n            return 'Y';\n            break;\n        case 'o':\n            return 'Z';\n            break;\n        case 'p':\n            return 'a';\n            break;\n        case 'q':\n            return 'b';\n            break;\n        case 'r':\n            return 'c';\n            break;\n        case's':\n            return 'd';\n            break;\n        case 't':\n            return 'e';\n            break;\n        case 'u':\n            return 'f';\n            break;\n        case 'v':\n            return 'g';\n            break;\n        case 'w':\n            return 'h';\n            break;\n        case 'x':\n            return 'i';\n            break;\n        case 'y':\n            return 'j';\n            break;\n        case 'z':\n            return 'k';\n            break;\n        default:\n            return '?';\n    }\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n    return (char)((c & 0xF0) >> 4);\n}", "public static final int decodeHexNibble(final char c) {\n\treturn (c >= '0' && c <= '9')? c - '0' : c - 'a' + 10;\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n  if(c>='0' && c<='9'){\n    return c - '0';\n  } else if(c>='a' && c<='f'){\n    return c - 'a' + 10;\n  } else if(c>='A' && c<='F'){\n    return c - 'A' + 10;\n  } else {\n    return -1;\n  }\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\t\n\tif (c >= '0' && c <= '9'){\n\t\treturn c - '0';\n\t}\n\t\n\tif (c >= 'a' && c <= 'f'){\n\t\treturn c - 'a' + 10;\n\t}\n\t\n\tif (c >= 'A' && c <= 'F'){\n\t\treturn c - 'A' + 10;\n\t}\n\t\n\treturn 0;\n}", "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\treturn (char)((c & 0xF0) >> 4);\n}", "public static char decodeHexNibble(final char c){\n        return decodeHexNibble(c);\n    }"]}
{"_id": "636766821a6d9265ec0174b6", "generate_results": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(targetType.isArray()){\n\t\tif(genericType.isArray()){\n\t\t\treturn genericType.getComponentType().getComponentType().getParameterTypes();\n\t\t}\n\t\telse{\n\t\t\treturn genericType.getComponentType().getParameterTypes();\n\t\t}\n\t}\n\telse if(!genericType.isArray()){\n\t\tif(targetType.isArray()){\n\t\t\treturn targetType.getComponentType().getParameterTypes();\n\t\t}\n\t\telse{\n\t\t\treturn targetType.getComponentType().getParameterTypes();\n\t\t}\n\t}\n\telse{\n\t\treturn null;\n\t}\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType==null)return null;\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType)genericType;\n\t\tType[] types = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] returnTypes = new Class[types.length];\n\t\tfor(int i=0;i<returnTypes.length;i++){\n\t\t\treturnTypes[i] = resolveType(types[i],targetType);\n\t\t}\n\t\treturn returnTypes;\n\t}\n\treturn resolveArgumentsGenericType(genericType,targetType);\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType= (ParameterizedType)genericType;\n\t\tClass<?>[] classes= parameterizedType.getActualTypeArguments();\n\t\tif(classes!=null){\n\t\t\treturn classes;\n\t\t}\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\t\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType= (ParameterizedType)genericType;\n\t\tType[] typeArguments= parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] targetArgs= targetType.getTypeArguments();\n\t\tClass<?>[] resolvedArgs= new Class[typeArguments.length+targetArgs.length];\n\t\tSystem.arraycopy(typeArguments, 0, resolvedArgs, 0, typeArguments.length);\n\t\tSystem.arraycopy(targetArgs, 0, resolvedArgs, typeArguments.length, targetArgs.length);\n\t\treturn resolvedArgs;\n\t}\n\telse{\n\t\treturn null;\n\t}\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType= (ParameterizedType) genericType;\n\t\tType[] typeArgs= parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] typeArgsArray= new Class[typeArgs.length];\n\t\tfor(int i=0;i<typeArgs.length;i++){\n\t\t\ttypeArgsArray[i]= (Class<?>) typeArgs[i];\n\t\t}\n\t\treturn typeArgsArray;\n\t}else if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArrayType= (GenericArrayType) genericType;\n\t\tClass<?> componentType= genericArrayType.getGenericComponentType();\n\t\treturn resolveArguments(componentType,targetType);\n\t}else if(genericType instanceof Class){\n\t\tClass<?> componentType= (Class<?>) genericType;\n\t\treturn resolveArguments(componentType,targetType);\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType)genericType;\n\t\tType[] arguments = parameterizedType.getActualTypeArguments();\n\t\treturn parameterizedType.resolveArguments(targetType,arguments);\n\t}\n\tif(genericType instanceof TypeVariable){\n\t\tTypeVariable<?> typeVariable = (TypeVariable<?>)genericType;\n\t\treturn typeVariable.getBounds();\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif (genericType instanceof ParameterizedType) {\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tClass<?>[] typeArguments = new Class<?>[param", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif (genericType instanceof ParameterizedType){\n\t\tType[] types = ((ParameterizedType)genericType).getActualTypeArguments();\n\t\tif (types.length == 0)\n\t\t\treturn null;\n\t\treturn resolveArguments(types[0],targetType);\n\t}\n\telse if (genericType instanceof ParameterizedType){\n\t\treturn resolveArguments(genericType.getActualTypeArguments()[0],targetType);\n\t}\n\telse {\n\t\treturn null;\n\t}\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType)genericType;\n\t\tClass<?>[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\treturn typeArguments;\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\tTypeVariable<?> variable = (TypeVariable<?>)genericType;\n\t\treturn resolveArguments(variable.getBounds(),targetType);\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType)genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\treturn typeArguments;\n\t}\n\telse{\n\t\treturn new Class<?>[0];\n\t}\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType)\n\t{\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tif(typeArguments.length!=1)\n\t\t\treturn null;\n\t\tClass<?> typeArgumentClass = typeArguments[0];\n\t\tif(targetType.isAssignableFrom(typeArgumentClass))\n\t\t\treturn typeArgumentClass.getTypeArgumentList().toArray(new Class<?>[0]);\n\t\telse\n\t\t\treturn null;\n\t}\n\treturn null;\n}"]}
{"_id": "6367667d1a6d9265ec01741d", "generate_results": ["public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.getBounds().length==0) return Unknown.class;\n\tType firstBound = typeVariable.getBounds()[0];\n\tif(firstBound.getKind()==TypeKind.TYPEVAR) {\n\t\tfirstBound = resolveBound(firstBound.getUpperBound());\n\t}\n\treturn firstBound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tTypeVariable<?> bound = typeVariable;\n\twhile(bound.getUpperBound()!= null) bound = bound.getUpperBound();\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.getBounds().length>1){\n\t\treturn typeVariable.resolveBounds(0).getBounds()[0];\n\t}\n\treturn Unknown.class;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.getUpperBound()!=null&&typeVariable.getUpperBound().getClass()==Unknown.class){\n\t\treturn typeVariable.getUpperBound();\n\t}else{\n\t\treturn typeVariable.getLowerBound();\n\t}\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    if(typeVariable.getBounds().length == 0){\n        return Unknown.class;\n    }else{\n        Type[] bounds = typeVariable.getBounds();\n        Type bound = resolveBound(bounds[0]);\n        if(bound!= Unknown.class && bounds.length > 1){\n            return resolveBound(bounds[1]);\n        }else if(bounds.length == 1){\n            return bounds[0];\n        }else{\n            return Unknown.class;\n        }\n    }\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tType bound = typeVariable.getBounds().get(0);\n\tif(bound instanceof TypeVariable){\n\t\treturn resolveBound((TypeVariable<?>)bound);\n\t}else{\n\t\treturn bound;\n\t}\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable!=null){\n\t\tif(typeVariable.getBounds()!=null){\n\t\t\tType[] bounds = typeVariable.getBounds();\n\t\t\tif(bounds!=null){\n\t\t\t\treturn resolveBound(bounds[0]);\n\t\t\t}else{\n\t\t\t\treturn Unknown.class;\n\t\t\t}\n\t\t}else{\n\t\t\treturn Unknown.class;\n\t\t}\n\t}else{\n\t\treturn Unknown.class;\n\t}\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.isBound()){\n\t\tType type = typeVariable.getBounds()[0].getUpperBound();\n\t\tif(type.getClass() == Unknown.class){\n\t\t\treturn typeVariable;\n\t\t}else{\n\t\t\treturn typeVariable.resolveBounds(typeVariable.getBounds()[0].getUpperBound());\n\t\t}\n\t}else{\n\t\treturn typeVariable.resolveBounds(Unknown.class);\n\t}\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable==null){\n\t\treturn Unknown.class;\n\t}\n\tType[] bounds = ((TypeVariable<?>)typeVariable).getBounds();\n\tType bound = bounds[0];\n\twhile(bound instanceof TypeVariable){\n\t\tif(((TypeVariable<?>)bound).getBounds()[0] == null){\n\t\t\treturn Unknown.class;\n\t\t}\n\t\telse{\n\t\t\tbound = ((TypeVariable<?>)bound).getBounds()[0];\n\t\t}\n\t}\n\tif(bound instanceof Class){\n\t\treturn (Class)bound;\n\t}\n\telse{\n\t\treturn Unknown.class;\n\t}\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\t\n\tif(typeVariable.getBounds().length == 0){\n\t\treturn Unknown.class;\n\t}\n\t\n\tType firstBound = typeVariable.getBounds()[0];\n\t\n\tif(firstBound.getKind() == TypeKind.CLASS){\n\t\t\n\t\treturn firstBound;\n\t}else if(firstBound.getKind() == TypeKind.TYPEVAR){\n\t\t\n\t\treturn resolveBound(firstBound.getTypeArguments()[0]);\n\t}\n\t\n\treturn Unknown.class;\n}"]}
{"_id": "636766821a6d9265ec0174d2", "generate_results": ["public static AtmosphereRequest wrap(HttpServletRequest request){\n        return new AtmosphereRequest(request);\n    }", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\tAtmosphereRequest result = new AtmosphereRequest();\n\tresult.setRequest(request);\n\treturn result;\n}", "public static HttpServletRequest wrap(HttpServletRequest request){\n    return new HttpServletRequestWrapper(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new HttpRequest(request);\n}", "public static HttpServletRequest wrap(HttpServletRequest request) {\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\tBuilder builder = new Builder();\n\tbuilder.setRequest(request);\n\treturn builder.build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return newBuilder().withRequest(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new AtmosphereRequest(request);\n}", "public static HttpServletRequestWrapper wrap(HttpServletRequest request){\n\treturn new HttpServletRequestWrapper(request);\n}"]}
{"_id": "6367667f1a6d9265ec017458", "generate_results": ["public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn AtmosphereFramework.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn atmosphereHandlers.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\t\n\treturn mapping.replaceAll(\"^atmosphereHandlers\", \"\");\n}", "public Map<String, AtmosphereHandler> removeAtmosphereHandler(String mapping) {\n\treturn this.atmosphereHandlers.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n    return atmosphereHandlers.remove(mapping);\n}", "public void removeAtmosphereHandler(String mapping){\n\tAtmosphereFramework.removeAtmosphereHandler(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\tif(mapping == null)\n\t\treturn null;\n\t\n\tAtmosphereHandler handler = atmosphereHandlers.get(mapping);\n\t\n\tif(handler == null)\n\t\treturn null;\n\t\n\tatmosphereHandlers.remove(mapping);\n\t\n\treturn handler;\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n    return atmosphereHandlers.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn AtmosphereFramework.removeAtmosphereHandler(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn atmosphereHandlers.remove(mapping);\n}"]}
{"_id": "636766821a6d9265ec0174b3", "generate_results": ["Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif(msg == null){\n\t\treturn null;\n\t}else if(msg instanceof Object[]){\n\t\treturn msg;\n\t}else{\n\t\treturn new BroadcastAction(msg);\n\t}\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n    return null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n        if(msg instanceof BroadcastAction){\n            return null;\n        }\n        return msg;\n    }", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif(msg == null){\n\t\treturn BroadcastAction.abortMessage;\n\t}else if(msg instanceof BroadcastAction){\n\t\treturn ((BroadcastAction)msg).getActionMessage();\n\t}\n\treturn null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\treturn null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n    //System.out.println(\"broadcast:\" + msg.getClass().getCanonicalName());\n    //System.out.println(\"msg:\" + msg);\n    //System.out.println(\"msg.getClass().getCanonicalName():\" + msg.getClass().getCanonicalName());\n    if(msg instanceof ActionMessage){\n        ActionMessage am = (ActionMessage)msg;\n        //System.out.println(\"action:\" + am.getAction());\n        switch(am.getAction()){\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_COMPLETED:\n                return null;\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_FAILED:\n                return null;\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_RUNNING:\n                return null;\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_SUSPENDED:\n                return null;\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_RUNNING_SUCCESS:\n                return null;\n            case BroadcastAction.B_NOTIFY_ACTIVE_TASK_RUNNING_FAILURE:\n                return null;\n            default:\n                return am.getAction();\n        }\n    }\n    return null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction action = (BroadcastAction)msg;\n\t\tif(action.getAction() == null){\n\t\t\tLog.d(\"\", \"action is null\");\n\t\t\treturn null;\n\t\t}\n\t\treturn action.getAction();\n\t}\n\treturn msg;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction bc = (BroadcastAction)msg;\n\t\treturn bc;\n\t}\n\treturn null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\treturn null;\n}", "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif(msg == null ||!(msg instanceof ActionMessage)){\n\t\treturn null;\n\t}\n\tActionMessage actionMsg = (ActionMessage)msg;\n\tif(actionMsg.getAction() == Action.CANCEL){\n\t\treturn null;\n\t}\n\treturn actionMsg.getAction();\n}"]}
{"_id": "636766811a6d9265ec017499", "generate_results": ["Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor(int i=0;i<interceptorList.size();i++){\n\t\tif(interceptorList.get(i).getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tList<AtmosphereInterceptor> tempList=new ArrayList<AtmosphereInterceptor>();\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(c.isInstance(interceptor)){\n\t\t\ttempList.add(interceptor);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n    if(c==null){\n        return false;\n    }\n    for(AtmosphereInterceptor element:interceptorList){\n        if(element.getClass().equals(c)){\n            return true;\n        }\n    }\n    return false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tif(interceptorList.size()==0) return true;\n\tfor(int i=0;i<interceptorList.size();i++){\n\t\tif(interceptorList.get(i).getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n    for(int i=0;i<interceptorList.size();i++){\n        if(interceptorList.get(i).getClass().equals(c)){\n            return true;\n        }\n    }\n    return false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor(int i = 0; i < interceptorList.size(); i++){\n\t\tif(interceptorList.get(i).getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n    boolean duplicated=false;\n    for(AtmosphereInterceptor interceptor : interceptorList){\n        if(interceptor.getClass().equals(c)){\n            duplicated=true;\n            break;\n        }\n    }\n    return duplicated;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tList<AtmosphereInterceptor> instanceList = new ArrayList<AtmosphereInterceptor>();\n\tList<AtmosphereInterceptor> instanceList2 = new ArrayList<AtmosphereInterceptor>();\n\tAtmosphereInterceptor instance = null;\n\tif(interceptorList.size() > 0){\n\t\tinstance = interceptorList.get(0);\n\t\tinstanceList.add(instance);\n\t\tinstanceList2.add(instance);\n\t}\n\tfor(int i=1;i<interceptorList.size();i++){\n\t\tinstance = interceptorList.get(i);\n\t\tif(instanceList.size() > 0){\n\t\t\tif(instanceList.get(instanceList.size()-1) == instance){\n\t\t\t\tinstanceList2.add(instance);\n\t\t\t\tinstanceList.remove(instanceList.size()-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinstanceList2.add(instance);\n\t\t\t\tinstanceList.remove(instanceList.size()-1);\n\t\t\t}\n\t\t}\n\t}\n\tif(instanceList.size() > 0){\n\t\tinstanceList2.add(instance);\n\t\tinstanceList.remove(instanceList.size()-1);\n\t}\n\treturn instanceList2.size() == 0;\n}", "public boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor (AtmosphereInterceptor ai : interceptorList){\n\t\tif(ai.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor(int i = 0; i < interceptorList.size(); i++){\n\t\tAtmosphereInterceptor interceptor = interceptorList.get(i);\n\t\tif(interceptor.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"]}
{"_id": "6367667c1a6d9265ec0173f7", "generate_results": ["public boolean hasBytes(){\n\tif(dataBytes == null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean hasBytes(){return dataBytes!= null;}", "public boolean hasBytes(){\nif(dataBytes==null) return false;\nreturn true;\n}", "public boolean hasBytes(){\n\tif(dataBytes==null){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}", "public boolean hasBytes(){\n\treturn this.bytes!= null;\n}", "public boolean hasBytes(){\n\treturn (dataBytes!=null);\n}", "public boolean hasBytes(){\n\treturn this.bytes!=null;\n}", "public boolean hasBytes(){\n\tif (dataBytes == null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean hasBytes(){\nif(dataBytes!=null)\nreturn true;\nelse\nreturn false;\n}", "public boolean hasBytes(){\n\treturn (dataBytes!=null);\n}"]}
{"_id": "6367667d1a6d9265ec0173ff", "generate_results": ["public static Meteor lookup(HttpServletRequest r){\n\treturn new Meteor(r.getAttribute(\"_id\"));\n}", "public static Meteor lookup(HttpServletRequest r){\n    try{\n        return new Meteor(r.getParameter(\"key\"));\n    }catch(Exception e){\n        return null;\n    }\n}", "public static Meteor lookup(HttpServletRequest r){\n    return Meteor.lookup(r);\n}", "public static Meteor lookup(HttpServletRequest r){\n  return lookup((r instanceof MeteorRequest)?(MeteorRequest)r:new MeteorRequest(r));\n}", "public static Meteor lookup(HttpServletRequest r){\n    String username = getUsername(r);\n    if(username == null){\n        return null;\n    }\n    return Meteor.findOne(Meteor.get(username));\n}", "public static Meteor lookup(HttpServletRequest r){\n    return Meteor.find(r.getParameter('id'));\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn new Meteor(r);\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn Meteor.lookup(r);\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn new Meteor(r, r.getContext());\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn Meteor.findOne(r.getParameter(\"_id\"));\n}"]}
{"_id": "6367667c1a6d9265ec0173fb", "generate_results": ["public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn new AtmosphereResource(this, e);\n}", "public void addEventListener(AtmosphereResourceEventListener e){\n\tif(!listeners.contains(e)){\n\t\tlisteners.add(e);\n\t}\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn super.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn (AtmosphereResource)listenerList.add(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\tlisteners.add(e);\n\treturn this;\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n    return (AtmosphereResource)super.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn new AtmosphereResourceImpl(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n    if (e instanceof AtmosphereResourceEventListener) {\n        AtmosphereResourceEventListener listener = (AtmosphereResourceEventListener)e;\n        return addEventListener(listener.getEventType(), listener.getEvent(), listener.getSource());\n    } else {\n        throw new UnsupportedOperationException(e.getClass().getCanonicalName());\n    }\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return this.addEventListener(e,true); }", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn addEventListener(AtmosphereResourceEvent.class, e);\n}"]}
{"_id": "636766811a6d9265ec017496", "generate_results": ["public InputStream next() throws IOException {\n  if (stack.size() > 0) {\n    return stack.get(stack.size() - 1);\n  }\n  return null;\n}", "public InputStream next() throws IOException {\n\tif (stack.size() == 0) {\n\t\treturn null;\n\t}\n\treturn stack.get(stack.size() - 1);\n}", "public InputStream next() throws IOException {\n    if (_stack.isEmpty()) {\n      return null;\n    }\n    return _stack.peek();\n  }", "public InputStream next() throws IOException {\n\tif (stack.size() == 0) return null;\n\treturn stack.remove(stack.size() - 1);\n}", "public InputStream next() throws IOException {\n\treturn next(false);\n}", "public InputStream peek(String s, int n) throws IOException {\n    if (isEmpty()) {\n        return null;\n    } else {\n        return new PeekInputStream(next(),s,n);\n    }\n}", "public InputStream next() throws IOException {\n    if (stk.size() == 0) {\n        return null;\n    }\n    return stk.peek();\n}", "public InputStream next() throws IOException {\n    // if (stack.size()!= 0) {\n    //   return stack.peek();\n    // }\n    // return null;\n    return null;\n  }", "public InputStream next() throws IOException {\n    return stack.peek();\n}", "public InputStream next() throws IOException {\n\tif (stack.size() == 0) {\n\t\treturn null;\n\t}\n\treturn stack.removeLast();\n}"]}
{"_id": "636766821a6d9265ec0174c9", "generate_results": ["Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n    File[] classPath = new File[0];\n    String pathSeparator = File.separator;\n    String classPathStr = pathSeparator + \"java.class.path\";\n    String classPathStr2 = pathSeparator + \"java.class.path\";\n    String classPathStr3 = pathSeparator + \"java.class.path\";\n\n    try{\n        String classPathStr4 = pathSeparator + \"java.class.path\";\n        String classPathStr5 = pathSeparator + \"java.class.path\";\n        String classPathStr6 = pathSeparator + \"java.class.path\";\n        String classPathStr7 = pathSeparator + \"java.class.path\";\n        String classPathStr8 = pathSeparator + \"java.class.path\";\n        String classPathStr9 = pathSeparator + \"java.class.path\";\n        String classPathStr10 = pathSeparator + \"java.class.path\";\n        String classPathStr11 = pathSeparator + \"java.class.path\";\n        String classPathStr12 = pathSeparator + \"java.class.path\";\n\n        classPathStr4 = classPathStr4.replaceAll(\"\\\\s\", \"\");\n        classPathStr5 = classPathStr5.replaceAll(\"\\\\s\", \"\");\n        classPathStr6 = classPathStr6.replaceAll(\"\\\\s\", \"\");\n        classPathStr7 = classPathStr7.replaceAll(\"\\\\s\", \"\");\n        classPathStr8 = classPathStr8.replaceAll(\"\\\\s\", \"\");\n        classPathStr9 = classPathStr9.replaceAll(\"\\\\s\", \"\");\n        classPathStr10 = classPathStr10.replaceAll(\"\\\\s\", \"\");\n        classPathStr11 = classPathStr11.replaceAll(\"\\\\s\", \"\");\n        classPathStr12 = classPathStr12.replaceAll(\"\\\\s\", \"\");\n        classPath = classPathStr4.split(classPathStr2);\n        classPath = classPathStr5.split(classPathStr2);\n        classPath = classPathStr6.split(classPathStr2);\n        classPath = classPathStr7.split(classPathStr2);\n        classPath = classPathStr8.split(classPathStr2);\n        classPath = classPathStr9.split(classPathStr2);\n        classPath = classPathStr10.split(classPathStr2);\n        classPath = classPathStr11.split(classPathStr2);\n        classPath = classPathStr12.split(classPathStr2);\n    }\n    catch(Exception e){\n        System.err.println(\"Error when reading classpath\");\n        System.err.println(e.getMessage());\n    }\n    return classPath;\n}", "Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n    String f = \"\";\n    String p = \"\";\n    String n = \"\";\n    String s = \"\";\n    String fp = \"\";\n    String np = \"\";\n    String sp = \"\";\n    String spf = \"\";\n    String ns = \"\";\n    String nsf = \"\";\n    String spn = \"\";\n    String nsp = \"\";\n    String sps = \"\";\n    String nss = \"\";\n    String nspf = \"\";\n    String nns = \"\";\n    String nnsf = \"\";\n    String nnsp = \"\";\n    String nnsps = \"\";\n    String nnspsf = \"\";\n    String nnspsp = \"\";\n    String nnspspf = \"\";\n    String nnspsps = \"\";\n    String fpf = \"\";\n    String nspf = \"\";\n    String nspf2 = \"\";\n    String spf2 = \"\";\n    String nspf3 = \"\";\n    String nspf4 = \"\";\n    String spf4 = \"\";\n    String nspf5 = \"\";\n    String nspf6 = \"\";\n    String spf6 = \"\";\n    String nspf7 = \"\";\n    String nspf8 = \"\";\n    String nspf9 = \"\";\n    String nspf10 = \"\";\n    String nspf11 = \"\";\n    String nspf12 = \"\";\n    String nspf13 = \"\";\n    String nspf14 = \"\";\n    String nspf15 = \"\";\n    String nspf16 = \"\";\n    String nspf17 = \"\";\n    String nspf18 = \"\";\n    String nspf19 = \"\";\n    String nspf20 = \"\";\n    String nspf21 = \"\";\n    String nspf22 = \"\";\n    String nspf23 = \"\";\n    String nspf24 = \"\";\n    String nspf25 = \"\";\n    String nspf26 = \"\";\n    String nspf27 = \"\";\n    String nspf28 = \"\";\n    String nspf29 = \"\";\n    String nspf30 = \"\";\n    String nspf31 = \"\";\n    String nspf32 = \"\";\n    String nspf33 = \"\";\n    String nspf34 = \"\";\n    String nspf35 = \"\";\n    String nspf36 = \"\";\n    String nspf37 = \"\";\n    String nspf38 = \"\";\n    String nspf39 = \"\";\n    String nspf40 = \"\";\n    String nspf41 = \"\";\n    String nspf42 = \"\";\n    String nspf43 = \"\";\n    String nspf44 = \"\";\n    String nspf45 = \"\";\n    String nspf46 = \"\";\n    String nspf47 = \"\";\n    String nspf48 = \"\";\n    String nspf49 = \"\";\n    String nspf50 = \"\";\n    String nspf51 = \"\";\n    String nspf52 = \"\";\n    String nspf53 = \"\";\n    String nspf54 = \"\";\n    String nspf55 = \"\";\n    String nspf56 = \"\";\n    String nspf57 = \"\";\n    String nspf58 = \"\";\n    String nspf59 = \"\";\n    String nspf60 = \"\";\n    String nspf61 = \"\";\n    String nspf62 = \"\";\n    String nspf63 = \"\";\n    String nspf64 = \"\";\n    String nspf65 = \"\";\n    String nspf66 = \"\";\n    String nspf67 = \"\";\n    String nspf68 = \"\";\n    String nspf69 = \"\";\n    String nspf70 = \"\";\n    String nspf71 = \"\";\n    String nspf72 = \"\";\n    String nspf73 = \"\";\n    String nspf74 = \"\";\n    String nspf75 = \"\";\n    String nspf76 = \"\";\n    String nspf", "public static void main(String[] args){\n//\tFile f = new File(\"/Users/zhezhez/Desktop/D:/test.txt\");\n//\tFile[] files = classPath();\n//\tfor(File f : files){\n//\t\tSystem.out.println(f.getName());\n//\t}\n//}", "Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n\tFile[] files = new File[Arrays.asList(File.listRoots()).toString().split(\";\")];\n\t\n\tfor(int i=0; i<files.length; i++){\n\t\tfiles[i] = new File(files[i]);\n\t}\n\t\n\treturn files;\n}", "Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n\tFile[] files = null;\n\tString classpath = System.getProperty(\"java.class.path\");\n\tStringTokenizer tokens = new StringTokenizer(classpath, \":\");\n\tfiles = new File[tokens.countTokens()];\n\tint i = 0;\n\twhile (tokens.hasMoreTokens()) {\n\t\tfiles[i++] = new File((tokens.nextToken()).trim());\n\t}\n\treturn files;\n}", "Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n    List<File> fileList = new ArrayList<>();\n    String filePath = null;\n\n    try {\n        filePath = System.getProperty(\"java.class.path\");\n        fileList.addAll(Arrays.asList(filePath.split(System.getProperty(\"path.separator\"))));\n    } catch (Exception e) {\n        LOGGER.error(\"Error getting java.class.path\", e);\n    }\n\n    Iterator<File> iterator = fileList.iterator();\n\n    while (iterator.hasNext()) {\n        File file = iterator.next();\n        if (file.exists() && file.isDirectory() &&!file.getName().toLowerCase().endsWith(\".class\")){\n            fileList.add(file);\n        }\n    }\n\n    return fileList.toArray(new File[fileList.size()]);\n}", "public static void main(String[] args) {\n        try {\n            \n            File[] fileArray = classPath();\n            \n            String file = \"\";\n            for (int i = 0; i < fileArray.length; i++) {\n                file = fileArray[i].getName();\n                System.out.println(file);\n                System.out.println(\"   \" + fileArray[i].getName());\n                System.out.println(\"   \" + classPath()[i]);\n                System.out.println(\"   \" + classPathList()[i]);\n                System.out.println(\"   \" + classPathList2()[i]);\n                System.out.println(\"   \" + classPathList3()[i]);\n            }\n            \n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }", "public static void main(String[] args) {\n\ttry {\n\t\tArrayList<File> path = classPath();\n\t\tfor (int i = 0; i < path.size(); i++) {\n\t\t\tFile file = path.get(i);\n\t\t\tSystem.out.println(file.getAbsolutePath());\n\t\t}\n\t} catch (Exception e) {\n\t\tSystem.out.println(e.getMessage());\n\t}\n}", "public static void main(String[] args) {\n//\n//\t\tFile[] files = classPath();\n//\n//\t\t\n//\t\tfor (File f : files) {\n//\t\t\t\n//\t\t\tSystem.out.println(f.getAbsolutePath());\n//\t\t}\n//\n//\t}", "public static String getFileType(String fileName, String fileType){\n\tString fileType = \"\";\n\t\n\tfor(String s : classPath()){\n\t\tFile f = new File(s, fileName);\n\t\tif(f.isFile()){\n\t\t\tfileType = fileName;\n\t\t\treturn fileType;\n\t\t}\n\t}\n\treturn \"\";\n}"]}
{"_id": "636766801a6d9265ec017482", "generate_results": ["public void readFrom(final InputStream in) throws IOException {\n\tint bytesRemaining = bytes.size();\n\t// The buffer size is the number of bytes that have been read, so we need to read\n\t// the amount of bytes we've written.\n\tint bytesToRead = Math.min(bytesRemaining, maxBytesToRead);\n\tbyte[] buf = new byte[bytesToRead];\n\tint bytesRead = 0;\n\twhile (bytesRead < bytesToRead) {\n\t\tbytesRead += in.read(buf, bytesRead, bytesToRead - bytesRead);\n\t}\n\tbytes.clear();\n\tbytes.add(buf);\n\tmaxBytesToRead -= bytesToRead;\n\tbytesRemaining -= bytesToRead;\n}", "public void readFrom(final InputStream in) throws IOException {\n\tif (in == null) {\n\t    throw new NullPointerException(\"in may not be null\");\n\t}\n\t\n\tint size;\n\ttry {\n\t    size = in.read();\n\t}\n\tcatch (IOException e) {\n\t    throw new IOException(e.getMessage());\n\t}\n\n\tif (size < 0) {\n\t    throw new EOFException(\"No data in input stream\");\n\t}\n\t\n\tbyte[] data = new byte[size];\n\t\n\tint count = 0;\n\twhile (count < size) {\n\t    \n\t    int next = in.read(data, count, size - count);\n\t    if (next < 0) {\n\t\tbreak;\n\t    }\n\t    count += next;\n\t}\n\t\n\tif (count < size) {\n\t    throw new EOFException(\"No data in input stream\");\n\t}\n\t\n\treturn;\n    }", "public void readFrom(final InputStream in) throws IOException {\n    int ch = in.read();\n    if (ch == -1) {\n      throw new IOException();\n    }\n    buffer.append((char) ch);\n  }", "public void readFrom(final InputStream in) throws IOException {\n\tinput = in;\n\treadFrom = -1;\n\treadFromCount = 0;\n}", "public void readFrom(final InputStream in) throws IOException {\n    this.in = in;\n  }", "public void readFrom(final InputStream in) throws IOException {\n    this.in = in;\n    this.in.read();\n  }", "public void readFrom(final InputStream in) throws IOException {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    super.readFrom(in);\n  }", "public void readFrom(final InputStream in) throws IOException {\n    if (in == null) {\n      throw new IllegalArgumentException(\"Null stream\");\n    }\n\n    // Read the buffer from the input stream.\n    try {\n      final int size = in.available();\n      byte[] data = new byte[size];\n      in.read(data);\n      readFrom(data);\n    } finally {\n      // Close the output stream after all bytes have been read.\n      in.close();\n    }\n  }", "public void readFrom(final InputStream in) throws IOException {\n\t// Read the first line\n\tfinal String line = readLine();\n\tif (line == null) {\n\t\tthrow new EOFException(\"EOF while reading from stream.\");\n\t}\n\t// Read the rest of the file\n\tfinal int read = in.read(buffer);\n\tif (read == -1) {\n\t\tthrow new EOFException(\"EOF while reading from stream.\");\n\t}\n\t// Write the rest of the line\n\twrite(line);\n}", "public void readFrom(final InputStream in) throws IOException {\n\t\n\t// Read the buffer from the input stream.\n\tfinal int length = readFrom(in, 0);\n\t\n\t// Allocate a temporary buffer.\n\tfinal byte[] tmp = new byte[length];\n\t\n\t// Read the buffer from the input stream.\n\tin.read(tmp);\n\t\n\t// Set the buffer.\n\tthis.buffer = tmp;\n}"]}
{"_id": "636766801a6d9265ec017477", "generate_results": ["Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    for(int i = files.length - 1; i >= 0; --i){\n        Files.addFile(files[i]);\n    }\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    //Add the files in reverse order\n    for(int i = files.length -1; i >= 0 ; i--){\n        try {\n            //Add the file to the end of the array\n            files[i] = new FileInputStream(files[i]);\n        } catch (FileNotFoundException e) {\n            //System.err.println(e);\n        } catch (IOException e) {\n            //System.err.println(e);\n        }\n    }\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n\tfor(int i = files.length - 1; i >= 0; i--){\n\t\ttry{\n\t\t\tfinal File file = new File(files[i].toString());\n\t\t\tif(file.isFile()){\n\t\t\t\tfiles[i] = new FileInputStream(file);\n\t\t\t}\n\t\t}catch(FileNotFoundException e){\n\t\t\tLog.e(TAG, \"FileNotFoundException \" + e.getMessage());\n\t\t}catch(IOException e){\n\t\t\tLog.e(TAG, \"IOException \" + e.getMessage());\n\t\t}\n\t}\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n\tfor(int i=files.length-1;i>=0;i--){\n\t\ttry{\n\t\t\tFile f = new File(files[i].getAbsolutePath());\n\t\t\tif(f.exists()){\n\t\t\t\tFileInputStream fis = new FileInputStream(f);\n\t\t\t\tbufferedInputStream = new BufferedInputStream(fis);\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tFileInputStream fis = new FileInputStream(files[0]);\n\tbufferedInputStream = new BufferedInputStream(fis);\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    for(int i = files.length - 1; i >= 0; i--){\n        try{\n            File file = new File(files[i].getPath());\n            if(!file.getName().endsWith(\".txt\")){\n                if(files[i].getName().endsWith(\"_1\")){\n                    files[i] = new FileInputStream(new File(file.getPath() + \".1\"));\n                }else if(files[i].getName().endsWith(\"_2\")){\n                    files[i] = new FileInputStream(new File(file.getPath() + \".2\"));\n                }else if(files[i].getName().endsWith(\"_3\")){\n                    files[i] = new FileInputStream(new File(file.getPath() + \".3\"));\n                }\n            }\n        }catch(Exception e){\n            System.err.println(\"Problem loading file: \" + e.getMessage());\n        }\n    }\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    final Iterator<InputStream> iterator=Arrays.asList(files).iterator();\n    final Iterator<InputStream> reversedIterator=new ReverseIterator(iterator);\n    while(iterator.hasNext()){\n        final InputStream file=iterator.next();\n        reversedIterator.remove();\n        file.close();\n    }\n    while(reversedIterator.hasNext()){\n        final InputStream file=reversedIterator.next();\n        file.close();\n    }\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n\tfor (int i = files.length - 1; i >= 0; i--) {\n\t\tFile file = files[i].getFile();\n\t\tif (file.exists()){\n\t\t\tfiles[i] = null;\n\t\t\tcontinue;\n\t\t}\n\t\ttry {\n\t\t\tfile.delete();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Error deleting file: \" + e.getMessage());\n\t\t}\n\t}\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n\t//create a new Stack containing the files in reverse order\n\tfinal Stack<InputStream> stack = new Stack<>();\n\t//add the files in reverse order\n\tfinal InputStream[] temp = files;\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tstack.push(temp[i]);\n\t}\n\t//add the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.push(files[i]);\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=0;i<files.length;i++){\n\t\tstack.pop();\n\t}\n\t//remove the files in reverse order\n\tfor(int i=", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n\tfinal ArrayList<InputStream> newFiles = new ArrayList<InputStream>();\n\tfor (final InputStream file: files){\n\t\tnewFiles.add(file);\n\t\tnewFiles.add(file);\n\t}\n\t\n\tfinal ArrayList<InputStream> toAdd = new ArrayList<InputStream>();\n\t\n\tfor (int i = newFiles.size() - 1; i >= 0; i--) {\n\t\tfinal InputStream nextFile = newFiles.get(i);\n\t\tif (nextFile == null){\n\t\t\ttoAdd.add(newFiles.get(i));\n\t\t} else {\n\t\t\ttoAdd.add(nextFile);\n\t\t}\n\t}\n\t\n\tfor (final InputStream nextFile: toAdd){\n\t\tfiles.add(nextFile);\n\t}\n\t\n\tfiles.removeAll(toAdd);\n}", "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    for(int i=files.length-1; i>=0; i--){\n        InputStream f=files[i];\n        files[i]=null;\n        try{\n            if(f!=null){\n                f.close();\n                files[i]=f;\n            }\n        }catch(IOException e){}\n    }\n}"]}
{"_id": "636766831a6d9265ec0174eb", "generate_results": ["Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\t// create new list of files in reverse order\n\tfinal List<File> reverseList = new ArrayList<File>(files.length);\n\tfor (int i = files.length - 1; i >= 0; i--){\n\t\treverseList.add(files[i]);\n\t}\n\t// add the list of files into the stack\n\tstack.addAll(reverseList);\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\tfor (int i = 0; i < files.length; i++) {\n\t\tif (files[i].isDirectory()) {\n\t\t\tfinal String[] files2 = files[i].list();\n\t\t\tfor (int j = 0; j < files2.length; j++) {\n\t\t\t\tfinal String file2 = files2[j];\n\t\t\t\tif (file2.endsWith(\".c\") || file2.endsWith(\".cpp\") || file2.endsWith(\".cxx\") || file2.endsWith(\".c++\") || file2.endsWith(\".cpp\") || file2.endsWith(\".cppxx\")) {\n\t\t\t\t\tfinal File file3 = new File(files2[j]);\n\t\t\t\t\tfinal File[] files3 = addReverse(file3.listFiles());\n\t\t\t\t\tSystem.arraycopy(files3, 0, files, i + 1, files3.length);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (files[i].isFile()) {\n\t\t\tfinal String file2 = files[i].getName();\n\t\t\tif (file2.endsWith(\".c\") || file2.endsWith(\".cpp\") || file2.endsWith(\".cxx\") || file2.endsWith(\".c++\") || file2.endsWith(\".cpp\") || file2.endsWith(\".cppxx\")) {\n\t\t\t\tfinal File file3 = new File(files[i]);\n\t\t\t\tfinal File[] files3 = addReverse(file3.listFiles());\n\t\t\t\tSystem.arraycopy(files3, 0, files, i + 1, files3.length);\n\t\t\t}\n\t\t}\n\t}\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\tfinal Stack<File> stack = new Stack<File>();\n\tfor(final File file: files)\n\t\tstack.push(file);\n\t\n\twhile(!stack.isEmpty()){\n\t\tfinal File file = stack.pop();\n\t\t\n\t\tfor(final String extension: file.getName().split(\"\\\\.\")){\n\t\t\tfinal File newFile = new File(file.getParentFile(), file.getName() + \".\" + extension);\n\t\t\ttry {\n\t\t\t\tnewFile.createNewFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tstack.push(newFile);\n\t\t}\n\t}\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\tif (files.length == 0) return;\n\t\n\tfinal Stack<File> stack = new Stack<File>();\n\t\n\tfor (final File file : files){\n\t\tstack.push(file);\n\t}\n\t\n\twhile (!stack.isEmpty()){\n\t\tfinal File file = stack.pop();\n\t\t\n\t\tfinal File[] newFiles = new File[files.length + 1];\n\t\tfor (int i = 0; i < files.length; i++){\n\t\t\tnewFiles[i] = files[i];\n\t\t}\n\t\t\n\t\tnewFiles[files.length] = file;\n\t\t\n\t\tfiles = newFiles;\n\t}\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\tfinal Stack<File> stack = new Stack<File>();\n\tfor(final File file:files){\n\t\tstack.push(file);\n\t}\n\twhile(!stack.isEmpty()){\n\t\tfinal File file = stack.pop();\n\t\tif(file.isDirectory()){\n\t\t\taddReverse(file.listFiles());\n\t\t}\n\t\telse{\n\t\t\tfinal InputStream in = new FileInputStream(file);\n\t\t\ttry{\n\t\t\t\tfinal BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n\t\t\t\ttry{\n\t\t\t\t\tString line = reader.readLine();\n\t\t\t\t\twhile(line!= null &&!line.startsWith(\"#\")){\n\t\t\t\t\t\tstack.push(new File(file,line));\n\t\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\t}\n\t\t\t\t}finally{\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\t\t\t}finally{\n\t\t\t\tin.close();\n\t\t\t}\n\t\t}\n\t}\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n    for (int i = files.length - 1; i >= 0; i--) {\n        File file = files[i];\n        if (file.isDirectory()) {\n            File[] subFiles = file.listFiles();\n            if (subFiles!= null) {\n                for (int j = subFiles.length - 1; j >= 0; j--) {\n                    addReverse(subFiles[j].listFiles());\n                }\n            } else {\n                System.out.println(\"Error: Directory \" + file.getCanonicalPath() + \" does not exist.\");\n            }\n        } else {\n            if (file.getName().endsWith(\".png\")) {\n                File[] subFiles = file.listFiles();\n                if (subFiles!= null) {\n                    for (int j = subFiles.length - 1; j >= 0; j--) {\n                        addReverse(subFiles[j].listFiles());\n                    }\n                } else {\n                    System.out.println(\"Error: File \" + file.getCanonicalPath() + \" does not exist.\");\n                }\n            } else {\n                File[] subFiles = file.listFiles();\n                if (subFiles!= null) {\n                    for (int j = subFiles.length - 1; j >= 0; j--) {\n                        addReverse(subFiles[j].listFiles());\n                    }\n                } else {\n                    System.out.println(\"Error: File \" + file.getCanonicalPath() + \" does not exist.\");\n                }\n            }\n        }\n    }\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\t\n\t// create a stack\n\tStack<File> stack = new Stack<File>();\n\t\n\t// add the given files in reverse order\n\tfor(int i = 0; i < files.length; i++){\n\t\tstack.push(files[i]);\n\t}\n\t\n\t// remove the last file\n\tFile last = stack.pop();\n\t\n\t// add the remaining files\n\tfor(int i = 0; i < files.length-1; i++){\n\t\tstack.push(files[i]);\n\t}\n\t\n\t// add the last file\n\tstack.push(last);\n\t\n\t// delete the last file\n\tfiles[files.length-1] = null;\n\t\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n    File last = null;\n    for(File file : files){\n        if(file.getName().endsWith(\".jpeg\")){\n            last = file;\n        }\n    }\n    if(last == null){\n        throw new RuntimeException(\"No jpeg file found\");\n    }\n    Stack<File> s = new Stack<File>();\n    s.add(last);\n    while(!s.isEmpty()){\n        File f = s.pop();\n        if(f.getName().endsWith(\".jpeg\")){\n            s.add(f);\n        }\n    }\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n    for (int i = files.length - 1; i >= 0; i--) {\n        addFile(files[i]);\n    }\n}", "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n\tfor(int i = files.length-1; i >=0; i--){\n\t\tfinal File f = files[i];\n\t\tif(!f.isDirectory()){\n\t\t\ttry{\n\t\t\t\tStack<File> s = new Stack<File>();\n\t\t\t\ts.push(f);\n\t\t\t\twhile(!s.isEmpty()){\n\t\t\t\t\tfinal File f1 = s.pop();\n\t\t\t\t\tfinal File[] files1 = f1.listFiles();\n\t\t\t\t\tfor(final File f2 : files1){\n\t\t\t\t\t\tif(f2.isDirectory()){\n\t\t\t\t\t\t\ts.push(f2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(files1.length > 0){\n\t\t\t\t\tfinal File f2 = files1[files1.length-1];\n\t\t\t\t\tfinal File[] files2 = f2.listFiles();\n\t\t\t\t\tfor(final File f3 : files2){\n\t\t\t\t\t\tif(!f3.isDirectory()){\n\t\t\t\t\t\t\ts.push(f3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfiles = s.toArray(new File[0]);\n\t\t\t}\n\t\t\tcatch(final Exception e){\n\t\t\t\t// Do nothing.\n\t\t\t}\n\t\t}\n\t}\n}"]}
{"_id": "6367667e1a6d9265ec01743a", "generate_results": ["public long lastWriteTimeStampInMilliseconds(){\n\tif(is_null(lastWriteTimeStamp)){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn lastWriteTimeStamp.getTime();\n\t}\n}", "public long lastWriteTimeStampInMilliseconds(){\n\tlong lastWriteTimeStamp=0;\n\tif(lastWriteTimeStamp==0) lastWriteTimeStamp=System.currentTimeMillis();\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\tif(lastWriteTimeStamp == -1)\n\t\treturn System.currentTimeMillis();\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds() {\n\treturn lastWriteTimeStampInMilliseconds;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\tlong lastWriteTimeStamp = -1;\n\tif(System.currentTimeMillis() - lastWriteTimeStamp > 100){\n\t\tlastWriteTimeStamp = System.currentTimeMillis();\n\t}\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\tif(this.lastWriteTimeStampInMilliseconds==-1){\n\t\tthis.lastWriteTimeStampInMilliseconds=System.currentTimeMillis();\n\t}\n\treturn this.lastWriteTimeStampInMilliseconds;\n}", "public long getFileTotalWriteTime(){\n\treturn lastWriteTimeStamp - lastWriteTimeStampInMilliseconds();\n", "public long lastWriteTimeStampInMilliseconds(){\n    return lastWriteTimeStamp;\n}"]}
{"_id": "636766851a6d9265ec017515", "generate_results": ["public Action inspect(AtmosphereResource r){\n    return new Action() {\n        @Override public void execute(AtmosphereResourceContext ctx) {\n            // TODO Auto-generated method stub\n        }\n    };\n}", "public Action inspect(AtmosphereResource r){\n    return r.inspect();\n}", "public Action inspect(AtmosphereResource r){\n\tif(r.getTransport() == null){\n\t\treturn Action.Suspend;\n\t}\n\tboolean s = r.getTransport().isSuspend();\n\tif(s){\n\t\treturn Action.Suspend;\n\t}\n\treturn Action.Resume;\n}", "public Action inspect(AtmosphereResource r){\n\treturn new Action() {\n\t\t@Override public ActionResult action(ActionRequest request) throws Exception {\n\t\t\tif(request.getAttribute(ATTRIBUTE_TRANSPORT)==null){\n\t\t\t\treturn new ActionResult(ATTRIBUTE_TRANSPORT_ERROR, \"Transport not configured\");\n\t\t\t}\n\t\t\treturn new ActionResult(ATTRIBUTE_TRANSPORT, r.getTransport());\n\t\t}};\n\t}", "public Action inspect(AtmosphereResource r){\n    return r.inspect() ;\n}", "public Action inspect(AtmosphereResource r){\n    return new Action() {\n        @Override public void apply(AtmosphereResource r){\n            if(r.getTransport() == Transport.valueOf(transport())){\n                r.setState(new State(State.RESUMED));\n            }\n        }\n    };\n}", "public Action inspect(AtmosphereResource r){\n    if (r.getTransport().isSuspend())\n        return new Suspend(r);\n    return null;\n}", "public Action inspect(AtmosphereResource r){\n\tif(r.transport!= null) return Action.Suspend;\n\treturn Action.Resume;\n}", "public Action inspect(AtmosphereResource r){\n  return r.inspect();\n}", "public Action inspect(AtmosphereResource r){\n    return r.getTransport().inspect();\n}"]}
{"_id": "6367676d1a6d9265ec018229", "generate_results": ["public static String[] trimArrayElements(String[] array){\n    for(int i = 0; i < array.length; i++){\n        String element = array[i];\n        if(element!= null && element.trim().length() > 0)\n            array[i] = element.trim();\n    }\n    return array;\n}", "public static String[] trimArrayElements(String[] array){\n\tint len = array.length;\n\tString[] result = new String[len];\n\tfor(int i=0; i<len; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array) {\n\tString[] newArray = new String[array.length];\n\tfor (", "public static String[] trimArrayElements(String[] array){\n\tint len = array.length;\n\tString[] newArray = new String[len];\n\tfor (int i = 0; i < len; i++) {\n\t\tnewArray[i] = array[i].trim();\n\t}\n\treturn newArray;\n}", "public static String[] trimArrayElements(String[] array){\n\tString[] trimmedArray = new String[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\ttrimmedArray[i] = array[i].trim();\n\t}\n\treturn trimmedArray;\n}", "public static String[] trimArrayElements(String[] array){\n\t\n\tif(array==null){\n\t\treturn new String[0];\n\t}\n\t\n\t", "public static String[] trimArrayElements(String[] array){\n    String[] result = new String[array.length];\n    for(int i=0; i<array.length; i++){\n        result[i] = array[i].trim();\n    }\n    return result;\n}", "public static String[] trimArrayElements(String[] array){\n\tfor(int i = 0; i < array.length; i++){\n\t\tarray[i] = array[i].trim();\n\t}\n\treturn array;\n}", "public static String[] trimArrayElements(String[] array){\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\tif(array == null || array.length == 0) return null;\n\t\n\tString[] result = new String[array.length];\n\t\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\t\n\treturn result;\n}"]}
{"_id": "636767691a6d9265ec0181aa", "generate_results": ["public static int nullSafeHashCode(long[] array){\n  int hash = 0;\n  for(int i = 0; i < array.length; i++){\n    hash = hash * 31 + Long.hashCode(array[i]);\n  }\n  return hash;\n}", "public static long nullSafeHashCode(long[] array){\n    long hash = 0;\n    for(int i=0;i<array.length;i++){\n        hash+=array[i]*MULTIPLIER;\n    }\n    return hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tint hashCode = 0;\n\tfor(int i = 0; i < array.length; i++){\n\t\thashCode = hashCode * MULTIPLIER_MOD + array[i];\n\t}\n\treturn hashCode;\n}", "public static int nullSafeHashCode(long[] array){\n    int hash = 0;\n    for (int i = 0; i < array", "public static int nullSafeHashCode(long[] array){\n\t\n\tint hashCode = 0;\n\tfor(int i = 0; i < array.length; i++){\n\t\thashCode = hashCode * MULTIPLIER + array[i];\n\t}\n\treturn hashCode;\n}", "public static int nullSafeHashCode(long[] array){\n    int hashCode = 0;\n    for(int i = 0; i < array.length; i++){\n        long element = array[i];\n        hashCode += (element * MULTIPLIER)>>>SHIFT;\n    }\n    return hashCode;\n}", "public static int nullSafeHashCode(long[] array){\n\tint hashCode = 0;\n\tfor(int i = 0; i < array.length; i++){\n\t\thashCode *= MULTIPLIER;\n\t\thashCode ^= (array[i] & 0xffffffffL);\n\t}\n\treturn hashCode;\n}", "public static int nullSafeHashCode(long[] array){\n\tint hash = 0;\n\tfor (int i = 0; i < array.length; i++) {\n\t\thash *= array[i];\n\t\tif (hash == 0) hash = array[i];\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tint hash = 0;\n\tint i;\n\tfor (i = 0; i < array.length; i++){\n\t\thash = 31*hash + (int)(array[i]*MULTIPLIER);\n\t}\n\treturn hash;\n}", "public static long nullSafeHashCode(long[] array){\n    if (array == null) return 0;\n    return nullSafeHash"]}
{"_id": "6367676b1a6d9265ec0181df", "generate_results": ["public static boolean startsWithIgnoreCase(String str,String prefix){\n    return str.startsWith", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\treturn str.startsWith(prefix);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str.length()<=prefix.length()){\n\t\treturn false;\n\t}\n\tint i=0;\n\twhile(i<str.length()){\n\t\tif(Character.toUpperCase(str.charAt(i))!=Character.toUpperCase(prefix.charAt(i))) return false;\n\t\ti++;\n\t}\n\treturn true;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif (str == null) return false;\n\tint len = str.length();\n\tif (len < prefix.length()) return false;\n\treturn str.substring(0,len).toLowerCase().startsWith(prefix.toLowerCase());\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n    return startsWithIgnoreCase(str,prefix,true);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str.length() <= prefix.length()){\n\t\treturn false;\n\t}\n\tint start = Math.min(str.length()-prefix.length(),str.length());\n\tint end = Math.max(str.length()-prefix.length(),str.length());\n\tfor(int i=start;i<=end;i++){\n\t\tif(Character.toLowerCase(str.charAt(i))!= Character.toLowerCase(prefix.charAt(i))) return false;\n\t}\n\treturn true;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\treturn (str.length() >= prefix.length() &&\n\t\tstr.substring(0, prefix.length()).toLowerCase().startsWith(prefix.toLowerCase()));\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n    return str.startsWith(prefix);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif (str == null) return false;\n\tif (prefix == null) return false;\n\tString test = str.toLowerCase();\n\twhile ((test.length() > 0) && (prefix.length() > 0)) {\n\t\tif (test.toLowerCase().startsWith(prefix.toLowerCase())) return true;\n\t\ttest = test.substring(1);\n\t}\n\treturn false;\n}"]}
{"_id": "6367676b1a6d9265ec0181e2", "generate_results": ["public static Object findFirstMatch(Collection source,Collection candidates){\n\tObject result = null;\n\tint i = 0;\n\tfor(Iterator it = candidates.iterator();it.hasNext();){\n\t\tObject obj = it.next();\n\t\tif(source.contains(obj)){\n\t\t\tresult = obj;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n    Iterator it = source.iterator();\n    Object result;\n    while (it.hasNext()){\n        Object candidate = it.next();\n        if (candidate.toString().equals(candidates.toString())){\n            result = candidate;\n            break;\n        }\n    }\n    return result;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tIterator it = candidates.iterator();\n\t//System.out.println(\"candidates.size() = \"+candidates.size());\n\twhile(it.hasNext()){\n\t\tObject candidate = it.next();\n\t\tif(source.contains(candidate))\n\t\t\treturn candidate;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n    if (!(source instanceof ArrayList)) return null;\n    ArrayList candidates1 = (ArrayList)source;\n    int n = candidates1.size();\n    if (n <= 0) return null;\n    Object candidate = null;\n    for (int i = 0; i < n;i++) {\n        Object o = candidates1.get(i);\n        if (o instanceof String) {\n            if (candidate == null) {\n                candidate = o;\n            } else {\n                return null;\n            }\n        } else {\n            return o;\n        }\n    }\n    return candidate;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n    Iterator it=source.iterator();\n    Object candidate=null;\n    while(it.hasNext()){\n        candidate=it.next();\n        if(candidate.toString().equals(candidates.toString())){\n            return candidate;\n        }\n    }\n    return null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n    Iterator iterator = candidates.iterator();\n    while(iterator.hasNext()){\n        Object o = iterator.next();\n        if(o instanceof Node && source.contains(o)){\n            return o;\n        }\n    }\n    return null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\t// Check to see if the source is empty.\n\tif(source.size() == 0){\n\t\treturn null;\n\t}\n\t\n\t// Copy the source and candidates collection.\n\tCollection copy = new HashSet(source);\n\t\n\t// Find the first match.\n\tObject result = null;\n\tfor(Iterator it = copy.iterator(); it.hasNext();){\n\t\tObject candidate = it.next();\n\t\t\n\t\t// Check to see if the candidate matches the source.\n\t\tif(candidate.equals(candidates)){\n\t\t\tresult = candidate;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\t\n\tIterator it=source.iterator();\n\twhile(it.hasNext()){\n\t\tObject candidate = it.next();\n\t\tif(candidate==null || candidate.equals(candidates.iterator().next())){\n\t\t\treturn candidate;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tif(source==null || source.size()==0){\n\t\treturn null;\n\t}\n\tObject[] candidatesCopy=candidates.toArray();\n\tfor(int i=0;i<candidatesCopy.length;i++){\n\t\tif(candidatesCopy[i].equals(source)){\n\t\t\treturn candidatesCopy[i];\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n    Iterator it = source.iterator();\n    Object match = null;\n    while (it.hasNext()){\n        Object o = it.next();\n        if (o instanceof Class) {\n            Class c = (Class) o;\n            if (c.getName().equals(candidates.getName())) {\n                match = o; // found a match.\n            }\n        }\n    }\n    return match;\n}"]}
{"_id": "6367676b1a6d9265ec0181ee", "generate_results": ["public static String trimTrailingWhitespace(String str){\n    int len = str.length();\n    int i = len-1;\n    while (i>=0 && Character.isWhitespace(str.charAt(i)))\n        i--;\n    return str.substring(0, i+1);\n}", "public static String trimTrailingWhitespace(String str){\n\t\n\tstr = StringUtil.trim(str);\n\t\n\tif(str!= null){\n\t\treturn str.substring(0, str.length() - 1);\n\t}\n\t\n\treturn str;\n}", "public static String trimTrailingWhitespace(String str){\n    if (str!= null){\n        int len = str.length();\n        char[] chars = str.toCharArray();\n        StringBuilder sb = new StringBuilder(len);\n        for (int i = len-1; i >= 0; i--){\n            char ch = chars[i];\n            if (ch!='' && ch!= '\\t'){\n                sb.append(ch);\n            }\n        }\n        str = sb.toString();\n    }\n    return str;\n}", "public static String trimTrailingWhitespace(String str){\n\tif(str.trim().isEmpty()){\n\t\treturn \"\";\n\t}\n\t\n\tint len = str.length();\n\t\n\tif(len < 1)\n\t\treturn \"\";\n\t\n\tchar ch = str.charAt(len-1);\n\t\n\tif(ch =='')\n\t\treturn str.substring(0,len-1);\n\t\n\treturn str;\n}", "public static String trimTrailingWhitespace(String str){\n\tString trimStr = str;\n\tif(trimStr.length()>0){\n\t\tchar ch = trimStr.charAt(trimStr.length()-1);\n\t\tif(ch == '\\n' || ch == '\\r'){\n\t\t\ttrimStr = trimStr.substring(0, trimStr.length()-1);\n\t\t}\n\t}\n\treturn trimStr;\n}", "public static String trimTrailingWhitespace(String str){\n\tif (str == null) return \"\";\n\tint len = str.length();\n\tboolean isLast = false;\n\tfor (int i = 0; i < len - 1; i++) {\n\t\tchar c = str.charAt(i);\n\t\tif (c!='' && c!= '\\t') {\n\t\t\tisLast = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (isLast) {\n\t\treturn str.substring(0, len - 1);\n\t}\n\telse {\n\t\treturn str;\n\t}\n}", "public static String trimTrailingWhitespace(String str){\n\tString result = \"\";\n\tint index = str.length() - 1;\n\twhile(index >= 0 && isWhitespace(str.charAt(index)))\n\t\tindex--;\n\twhile(index >= 0 && isWhitespace(str.charAt(index + 1)))\n\t\tindex++;\n\tif(index >= 0)\n\t\tresult = str.substring(0, index) + result;\n\treturn result;\n}", "public static String trimTrailingWhitespace(String str){\n    int pos = str.length() - 1;\n    while (pos>=0 && str.charAt(pos)==' ') pos--;\n    return str.substring(0, pos + 1);\n}", "public static String trimTrailingWhitespace(String str){\n\tString s = str.trim();\n\treturn s.substring(0, s.length()-1);\n}", "public static String trimTrailingWhitespace(String str){\n\t\n\tif (str == null) {\n\t\treturn null;\n\t}\n\t\n\treturn str.replaceAll(\"^\\\\s+\", \"\");\n}"]}
{"_id": "6367676a1a6d9265ec0181bf", "generate_results": ["public static Object quoteIfString(Object obj){\n\tif (obj instanceof String)\n\t\treturn obj;\n\treturn quoteIfString(obj.toString());\n}", "public static String quoteIfString(Object obj){\n\t\n\treturn quoteIfString(obj.toString());\n}", "public static Object quoteIfString(Object obj){\n\tif(obj == null)\n\t\treturn obj;\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj.toString()+\"'\";\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\tif(obj instanceof String){\n\t\treturn obj.toString();\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n    if(obj instanceof String){\n        return \"'\"+obj.toString()+\"'\";\n    }\n    return obj;\n}", "public static Object quoteIfString(Object obj){\n\tif (obj instanceof String) return obj;\n\telse return new String(obj.toString());\n}", "public static Object quoteIfString(Object obj){\n  if(obj instanceof String)\n    return obj;\n  return obj;\n}", "public static Object quoteIfString(Object obj){\n    if (obj instanceof String)\n        return obj;\n    return quoteIfString(null, obj);\n}", "public static Object quoteIfString(Object obj){\n\tif (obj instanceof String){\n\t\treturn obj;\n\t}\n\tif (obj instanceof String[]){\n\t\treturn obj;\n\t}\n\tif (obj instanceof String){\n\t\treturn ((String)obj).toString();\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\tif(obj instanceof String){\n\t\treturn obj.toString();\n\t}\n\treturn obj;\n}"]}
{"_id": "6367676a1a6d9265ec0181cd", "generate_results": ["public static String trimLeadingWhitespace(String str){\n\tint len = str.length();\n\tif(len > 0){\n\t\tchar ch = str.charAt(0);\n\t\tif(ch =='' || ch == '\\t'){\n\t\t\tstr = str.substring(1);\n\t\t}\n\t}\n\treturn str;\n}", "public static String trimLeadingWhitespace(String str){\n\tif(str.length() == 0){\n\t\treturn \"\";\n\t}\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(str.charAt(0));\n\tint start = 1;\n\tfor(int i = 1; i < str.length(); i++){\n\t\tchar ch = str.charAt(i);\n\t\tif(ch == '\\n'){\n\t\t\tsb.append(\" \");\n\t\t\tstart++;\n\t\t}else if(ch == '\\r' && start > 1){\n\t\t\tsb.append(\"\\\\r\");\n\t\t\tstart = 1;\n\t\t}else if(ch == '\\t'){\n\t\t\tsb.append(\"\\\\t\");\n\t\t\tstart = 1;\n\t\t}else{\n\t\t\tsb.append(ch);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\treturn str.replaceAll(\"^\\\\s+\", \"\");\n}", "public static String trimLeadingWhitespace(String str){\n    String s = str.trim();\n    if(s.length() == 0){\n        return \"\";\n    }\n    \n    return s.substring(0, s.length()-1);\n}", "public static String trimLeadingWhitespace(String str){\n    if (str.length() == 0) return \"\";\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) break;\n    }\n    return str.substring(0, i);\n}", "public static String trimLeadingWhitespace(String str){\n    return str.replaceAll(\"^\\\\s+\", \"\");\n}", "public static String trimLeadingWhitespace(String str){\n    if (str == null){\n        return null;\n    }\n    \n    int len = str.length();\n    String ret = \"\";\n    for (int i = 0; i < len; i++){\n        char c = str.charAt(i);\n        if (c =='' || c == '\\t'){\n            continue;\n        }\n        if (c!= '\\n' &&!Character.isWhitespace(c)){\n            ret += c;\n        }\n    }\n    return ret;\n}", "public static String trimLeadingWhitespace(String str){\n    if (str.length() == 0)\n        return \"\";\n    int i;\n    for (i = 0; i < str.length(); i++) {\n        if (str.charAt(i) =='')\n            str = str.substring(0, i);\n    }\n    return str;\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str == null) return null;\n\tif (str.length() == 0) return str;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tchar c = 0;\n\twhile (i < str.length()) {\n\t\tif ((c = str.charAt(i)) =='') {\n\t\t\tif (j == 0) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t} else if (j == 1) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t} else if (j == 2) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t}\n\t\t\t\n\t\t\ti++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t} else if (j == 1) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t} else if (j == 2) {\n\t\t\t\tstr = str.substring(0, i);\n\t\t\t}\n\t\t\t\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn str;\n}", "public static String trimLeadingWhitespace(String str){\n    int len = str.length();\n    if (len > 0) {\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                str = str.substring(0, i);\n                break;\n            }\n        }\n    }\n    return str;\n}"]}
{"_id": "636767691a6d9265ec0181ae", "generate_results": ["public static String[] toStringArray(Enumeration<String> enumeration){\n    String[] stringArray = new String[enumeration.size()];\n    String string = null;\n    while(enumeration.hasMoreElements()){\n        string = enumeration.nextElement();\n        stringArray[enumeration.size() - 1] = string;\n    }\n    return stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] result=new String[0];\n\twhile(enumeration.hasMoreElements()){\n\t\tString element=enumeration.nextElement();\n\t\tresult[result.length]=element;\n\t}\n\treturn result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\t// create an array, which is the size of the enumeration\n\tString[] stringArray = new String[enumeration.size()];\n\t// fill it with the enumeration's elements\n\tfor(int i = 0; enumeration.hasMoreElements(); i++){\n\t\tstringArray[i] = enumeration.nextElement();\n\t}\n\treturn stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    List<String> stringList = new ArrayList<String>();\n    while(enumeration.hasMoreElements()){\n        stringList.add(enumeration.nextElement());\n    }\n    return stringList.toArray(new String[stringList.size()]);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    List<String> list = new ArrayList<String>();\n    while(enumeration.hasMoreElements()){\n        list.add(enumeration.nextElement());\n    }\n    return list.toArray(new String[list.size()]);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    String[] stringArray = new String[0];\n    while(enumeration.hasMoreElements()){\n        stringArray = new String[]{enumeration.nextElement()};\n    }\n    return stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[0];\n\twhile(enumeration.hasMoreElements()){\n\t\tstringArray[0] = enumeration.nextElement();\n\t}\n\treturn stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[0];\n\twhile (enumeration.hasMoreElements()) {\n\t\tstringArray[0] = enumeration.nextElement();\n\t}\n\t\n\treturn stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[0];\n\tString[] stringArray1 = null;\n\ttry{\n\t\tstringArray1 = enumeration.toArray(stringArray);\n\t}\n\tcatch(Exception e){\n\t\te.printStackTrace();\n\t}\n\treturn stringArray1;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[0];\n\tif(enumeration!=null){\n\t\twhile(enumeration.hasMoreElements()){\n\t\t\tstringArray[stringArray.length] = enumeration.nextElement();\n\t\t}\n\t}\n\treturn stringArray;\n}"]}
{"_id": "6367676c1a6d9265ec01820b", "generate_results": ["public static String deleteAny(String inString,String charsToDelete){\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString = new StringBuilder();\n\tStringBuilder outCharsToDelete = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString.append(charsToDelete);\n\toutCharsToDelete.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString2 = new StringBuilder();\n\tStringBuilder outCharsToDelete2 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString2.append(charsToDelete);\n\toutCharsToDelete2.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString3 = new StringBuilder();\n\tStringBuilder outCharsToDelete3 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString3.append(charsToDelete);\n\toutCharsToDelete3.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString4 = new StringBuilder();\n\tStringBuilder outCharsToDelete4 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString4.append(charsToDelete);\n\toutCharsToDelete4.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString5 = new StringBuilder();\n\tStringBuilder outCharsToDelete5 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString5.append(charsToDelete);\n\toutCharsToDelete5.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString6 = new StringBuilder();\n\tStringBuilder outCharsToDelete6 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString6.append(charsToDelete);\n\toutCharsToDelete6.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString7 = new StringBuilder();\n\tStringBuilder outCharsToDelete7 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString7.append(charsToDelete);\n\toutCharsToDelete7.append(charsToDelete);\n\t//Creates a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\tStringBuilder outString8 = new StringBuilder();\n\tStringBuilder outCharsToDelete8 = new StringBuilder();\n\t//Initializes a string that contains the characters that exist in the intersection between two character strings of the first character string and return the first character string that is modified.\n\toutString8.append", "public static String deleteAny(String inString,String charsToDelete){\n\tif(inString==null || charsToDelete==null){\n\t\treturn null;\n\t}\n\tchar[] charsToDeleteArray=charsToDelete.toCharArray();\n\tif(charsToDeleteArray.length==0){\n\t\treturn null;\n\t}\n\t\n\tint index=0;\n\twhile(index<inString.length()){\n\t\tif(Character.toLowerCase(inString.charAt(index))==charsToDeleteArray[0]){\n\t\t\tinString=inString.substring(0,index);\n\t\t}\n\t\tindex++;\n\t}\n\treturn inString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString result = \"\";\n\tfor(int i = 0;i<inString.length();i++){\n\t\tchar c = inString.charAt(i);\n\t\tif(charsToDelete.contains(c)){\n\t\t\tinString.setCharAt(i,'');\n\t\t\tresult = result + c;\n\t\t}\n\t}\n\treturn result;\n}", "public static String deleteAny(String inString,String charsToDelete){\n    StringBuilder outStr = new StringBuilder();\n    String[] chars = inString.split(\"\\\\\");\n    for(int i=0; i<chars.length; i++){\n        for(int j=0; j<chars.length-i; j++){\n            if(chars[j]!=chars[i]){\n                chars[j]=chars[i];\n            }\n        }\n        outStr.append(chars[i]);\n    }\n    return outStr.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tint index=inString.indexOf(charsToDelete);\n\tString modifiedString=inString.substring(0,index);\n\treturn modifiedString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\t\n\tString[] chars=inString.split(\"\");\n\tString[] chars2=charsToDelete.split(\"\");\n\tfor(int i=0;i<chars.length;i++){\n\t\tString temp=chars[i];\n\t\tfor(int j=0;j<chars2.length;j++){\n\t\t\tif(temp.equalsIgnoreCase(chars2[j])){\n\t\t\t\tchars[i]=chars2[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn new String(chars);\n}", "public static String deleteAny(String inString,String charsToDelete){\n\t\n\tif(charsToDelete==null)\n\t\treturn inString;\n\t\n\tchar[] array=inString.toCharArray();\n\t\n\tint index=0;\n\tint result=0;\n\t\n\twhile(index<array.length){\n\t\tif(array[index]==charsToDelete.charAt(0)){\n\t\t\tresult=index;", "public static String deleteAny(String inString,String charsToDelete){\n    String modifiedString = \"\";\n    for(int i=0;i<inString.length();i++){\n        if(charsToDelete.contains(inString.substring(i,i+1))){\n            modifiedString = inString.substring(i+1,i+1+charsToDelete.length());\n            break;\n        }\n    }\n    return modifiedString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tif(charsToDelete==null || charsToDelete.length()==0) return inString;\n\tString[] charsToDeleteArray = charsToDelete.split(\"\");\n\tfor(int i=0;i<charsToDeleteArray.length;i++){\n\t\tif(inString.indexOf(charsToDeleteArray[i])>=0){\n\t\t\tinString = inString.replaceAll(charsToDeleteArray[i], \"\");\n\t\t}else{\n\t\t\treturn inString;\n\t\t}\n\t}\n\treturn inString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString modifiedString = \"\";\n\tfor(int i = 0; i < inString.length(); i++){\n\t\tif(charsToDelete.contains(inString.charAt(i))) modifiedString = modifiedString + inString.charAt(i);\n\t}\n\treturn modifiedString;\n}"]}
{"_id": "6367676c1a6d9265ec018223", "generate_results": ["public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null || collection.size()==0) return false;\n\t\n\tboolean found=false;\n\tfor(Object a:collection) {\n\t\tif(a==element){\n\t\t\tfound=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}", "public static boolean containsInstance(Collection collection,Object element){\n    if(collection instanceof ArrayList){\n        return ((ArrayList)collection).contains(element);\n    }\n    return collection.contains(element);\n}", "public static boolean containsInstance(Collection collection,Object element){\n    return collection.contains(element);\n}", "public static boolean containsInstance(Collection collection,Object element){\n        \n        if(collection == null) return false;\n        \n        for(Iterator iter = collection.iterator();iter.hasNext();) {\n            if(iter.next()==element) return true;\n        }\n        return false;\n    }", "public static boolean containsInstance(Collection collection,Object element){\n\t\n\tfor (Iterator iterator = collection.iterator(); iterator.hasNext();){\n\t\tif (iterator.next().equals(element)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null) return false;\n\tif(collection instanceof ArrayList) return ((ArrayList)collection).contains(element);\n\telse if(collection instanceof List) return ((List)collection).contains(element);\n\telse return false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null || element==null){\n\t\treturn false;\n\t}\n\tif(collection instanceof HashSet){\n\t\tHashSet set= (HashSet)collection;\n\t\tIterator iter=set.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tif(iter.next().equals(element)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tif(collection instanceof TreeSet){\n\t\tTreeSet set= (TreeSet)collection;\n\t\tIterator iter=set.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tif(iter.next().equals(element)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tif(collection instanceof LinkedList){\n\t\tLinkedList list= (LinkedList)collection;\n\t\tIterator iter=list.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tif(iter.next().equals(element)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tif(collection instanceof ArrayList){\n\t\tArrayList array= (ArrayList)collection;\n\t\tIterator iter=array.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tif(iter.next().equals(element)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tfor (Iterator iterator = collection.iterator(); iterator.hasNext();){\n\t\tCollection elementCollection = (Collection) iterator.next();\n\t\tif (elementCollection.contains(element)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null || element==null)return false;\n\tif(collection.contains(element))return true;\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null || element==null) return false;\n\tfor(int i=0; i<collection.size();i++){\n\t\tif(collection.get(i)==element) return true;\n\t}\n\treturn false;\n}"]}
{"_id": "6367676c1a6d9265ec018204", "generate_results": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){\n    String[] result = new String[array1.length + array2.length];\n    for(int i = 0;i<array1.length;i++){\n        result[i] = array1[i];\n    }\n    for(int i = 0;i<array2.length;i++){\n        result[i+array1.length] = array2[i];\n    }\n    return result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length + array2.length];\n\tint i = 0;\n\tfor(int j = 0;j<array1.length;j++){\n\t\tresult[i] = array1[j];\n\t\ti++;\n\t}\n\tfor(int j = 0;j<array2.length;j++){\n\t\tresult[i] = array2[j];\n\t\ti++;\n\t}\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\t// Create a new array of the same length as array1.\n\tString[] result = new String[array1.length + array2.length];\n\t// Copy in element 0 to the new array.\n\tSystem.arraycopy(array1,0,result,0,array1.length);\n\t// Copy in element 1 to the new array.\n\tSystem.arraycopy(array2,0,result,array1.length,array2.length);\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length + array2.length];\n\tint i = 0;\n\tfor(int j = 0;j<array1.length;j++){\n\t\tresult[i++] = array1[j];\n\t}\n\tfor(int j = 0;j<array2.length;j++){\n\t\tresult[i++] = array2[j];\n\t}\n\treturn result;\n}", "public static String concatenateStringArrays(String[] array1,String[] array2) {\n\t\tString[] result = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1,0,result,0,array1.length);\n\t\tSystem.arraycopy(array2,0,result,array1.length,array2.length);\n\t\treturn result[result.length-1];\n\t}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length+array2.length];\n\tint i=0;\n\tfor(int j=0;j<array1.length;j++){\n\t\tresult[i++] = array1[j];\n\t}\n\tfor(int j=0;j<array2.length;j++){\n\t\tresult[i++] = array2[j];\n\t}\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n    //The return value is a new array of the same length as the first array.\n    //The contents of the new array are the concatenation of the two strings arrays.\n    String[] returnArray = new String[array1.length + array2.length];\n    //Fill in the first array with the first string.\n    returnArray[0] = array1[0];\n    //Pop the second array from the first array and add it to the return array.\n    for(int i = 1; i < array1.length; ++i)\n        returnArray[i] = array1[i];\n    //Fill in the second array with the second string.\n    returnArray[array1.length] = array2[0];\n    //Pop the first array from the second array and add it to the return array.\n    for(int i = 1; i < array2.length; ++i)\n        returnArray[i+array1.length] = array2[i];\n    return returnArray;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n    if(array1==null){\n        return array2;\n    }\n    if(array2==null){\n        return array1;\n    }\n    String[] combined = new String[array1.length+array2.length];\n    System.arraycopy(array1, 0, combined, 0, array1.length);\n    System.arraycopy(array2, 0, combined, array1.length, array2.length);\n    return combined;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length + array2.length];\n\t\n\tfor (int i = 0; i < array1.length; i++){\n\t\tresult[i] = array1[i];\n\t}\n\t\n\tfor (int i = 0; i < array2.length; i++){\n\t\tresult[i+array1.length] = array2[i];\n\t}\n\t\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,result,0,array1.length);\n\tSystem.arraycopy(array2,0,result,array1.length,array2.length);\n\treturn result;\n}"]}
{"_id": "6367676a1a6d9265ec0181d4", "generate_results": ["public static String[] addStringToArray(String[] array,String str){\n\tif (array == null) return new String[0];\n\tString[] newArray = new String[array.length + 1];\n\tSystem.arraycopy(array,0,newArray,0,array.length);\n\tnewArray[array.length] = str;\n\treturn newArray;\n}", "public static String addStringToArray(String[] array,String str){\n\tint i = 0;\n\tfor(String s : array){\n\t\tif( s.length() == 0 ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( s.charAt(0) == '-' ){\n\t\t\ts = s.substring(1);\n\t\t}\n\t\t\n\t\tarray[i] = s;\n\t\ti++;\n\t}\n\treturn array[i-1];\n}", "public static String[] addStringToArray(String[] array,String str){\n\tString[] temp = new String[array.length+1];\n\tSystem.arraycopy(array,0,temp,0,array.length);\n\ttemp[temp.length-1] = str;\n\treturn temp;\n}", "public static String[] addStringToArray(String[] array,String str){\n    if(array==null || array.length<1) return new String[0];\n    String[] newArray = new String[array.length+1];\n    System.arraycopy(array,0,newArray,0,array.length);\n    newArray[array.length] = str;\n    return newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\t\n\tif(array.length==0){\n\t\tarray=new String[1];\n\t\tarray[0]=str;\n\t}else{\n\t\tString[] tmp=new String[array.length+1];\n\t\tSystem.arraycopy(array,0,tmp,0,array.length);\n\t\ttmp[array.length]=str;\n\t\tarray=tmp;\n\t}\n\t\n\treturn array;\n}", "public static String[] addStringToArray(String[] array,String str){\n\t\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i].equals(str)){\n\t\t\treturn new String[]{array[i]};\n\t\t}\n\t}\n\t\n\treturn new String[]{array[array.length]};\n}", "public static String[] addStringToArray(String[] array,String str){\n\tint index=array.length;\n\tarray[index++]=str;\n\treturn array;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tfor (int i = 0; i < array.length; i++){\n\t\tif (array[i].equals(str)){\n\t\t\treturn array;\n\t\t}\n\t}\n\treturn new String[]{str};\n}", "public static String[] addStringToArray(String[] array,String str){\n\t\n\tarray[array.length] = str;\n}", "public static String[] addStringToArray(String[] array,String str){\n    if(array==null) return new String[0];\n    int length = array.length;\n    String newArray[] = new String[length+1];\n    \n    for(int i=0;i<length;i++){\n        newArray[i] = array[i];\n    }\n    newArray[length]=str;\n    return newArray;\n}"]}
{"_id": "6367676b1a6d9265ec0181dd", "generate_results": ["public static int countOccurrencesOf(String str,String sub){\n\t\n\tint i=0;\n\tint j=0;\n\twhile(i<str.length()){\n\t\tif(str.charAt(i)==sub.charAt(j)){\n\t\t\treturn j+1;\n\t\t}\n\t\ti++;j++;\n\t}\n\treturn 0;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tint count = 0;\n\tint pos =0;\n\tint start =0", "public static int countOccurrencesOf(String str,String sub){\n\t\n\tint count=0;\n\tfor(int i=0;i<str.length();i++){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif(str==", "public static int countOccurrencesOf(String str,String sub){\n\tif(str == null || str.length() == 0) return 0;\n\tint strLen = str.length();\n\tint subLen = sub.length();\n\tint result = 0;\n\tfor(int i=0;i<strLen;i++){\n\t\tresult += countOccurrencesOf(str.charAt(i),sub);\n\t}\n\treturn result;\n}", "public static int countOccurrencesOf(String str,String sub){\n\t\n\tint count=0;\n\tint len=str.length();\n\tint subLen=sub.length();\n\t\n\tfor(int i=0;i<len;i++){\n\t\tif(sub.charAt(i)==str.charAt(i)){\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\t\n\tif(str == null || sub == null){\n\t\treturn 0;\n\t}\n\t\n\tif(str.length() < sub.length()){\n\t\treturn 0;\n\t}\n\t\n\tint strSize = str.length();\n\tint subSize = sub.length();\n\t\n\tint index = 0;\n\tint count = 0;\n\t\n\twhile(index < strSize){\n\t\tindex = str.indexOf(sub,index);\n\t\tif(index == -1){\n\t\t\treturn count;\n\t\t}\n\t\tcount++;\n\t}\n\t\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n//\t  int indexOfSub = str.indexOf(sub);\n//\t  if (indexOfSub<0)\n//\t\t  return 0;\n//\t  else\n//\t\t  return 1;\n//\t  \n//\t  return 1;\n//}", "public static int countOccurrencesOf(String str,String sub){\n    int i=0;\n    while(i<str.length() && str.charAt(i)!=sub.charAt(0)){\n        i++;\n    }\n    return i;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tint count = 0;\n\tint i = 0;\n\twhile(i<str.length()){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\t++count;\n\t\t\t++i;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}"]}
{"_id": "6367676c1a6d9265ec018220", "generate_results": ["public static String stripFilenameExtension(String path) {\n\tint i = path.lastIndexOf('.');\n\tif(i == -1) return path;\n\treturn path.substring(0, i);\n}", "public static String stripFilenameExtension(String path){\n    return stripExtension(path);\n}", "public static String stripFilenameExtension(String path){\n    int p = path.lastIndexOf('.');\n    if (p!= -1){\n        path = path.substring(0,p);\n    }\n    return path;\n}", "public static String stripFilenameExtension(String path){\n\t// Get the last character which is not a dot.\n\tint last = path.lastIndexOf('.');\n\t// If the last character is not a dot, return a copy of the path.\n\tif(last < 0) return path;\n\t// Otherwise, the last character is a dot, return the path without the\n\t// extension.\n\telse return path.substring(0, last);\n}", "public static String stripFilenameExtension(String path) {\n    int last = path.lastIndex", "public static String stripFilenameExtension(String path){\n\tint i = path.lastIndexOf('.');\n\tif (i == -1) {\n\t\treturn path;\n\t}\n\treturn path.substring(i+1);\n}", "public static String stripFilenameExtension(String path){\n\t\n\tint index = path.lastIndexOf('.');\n\tif(index == -1) return path;\n\treturn path.substring(0, index);\n\t\n}", "public static String stripFilenameExtension(String path){\n    int index = path.lastIndexOf('.');\n    if (index < 0){\n        return path;\n    }\n    return path.substring(0, index);\n}", "public static String stripFilenameExtension(String path){\n\tint pos = path.lastIndexOf('.');\n\tif(pos >= 0)\n\t\tpath = path.substring(0, pos);\n\treturn path;\n}", "public static String stripFilenameExtension(String path){\n\tint i = path.lastIndexOf('.');\n\tif(i == -1) return path;\n\tString pathExt = path.substring(i+1);\n\treturn path.substring(i);\n}"]}
{"_id": "636767691a6d9265ec0181a7", "generate_results": ["public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString result = \"\";\n\tint i = 0;\n\twhile(i<str.length() && leadingCharacter == str.charAt(i)){\n\t\tresult += str.charAt(i);\n\t\ti++;\n\t}\n\treturn result;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tfinal int length = str.length();\n\tfinal char[] charArray = str.toCharArray();\n\tfinal int start = Math.max(0,length-1);\n\tfinal char leadingCharacterChar = leadingCharacter;\n\tfor(int i = start;i<length;i++){\n\t\tif(charArray[i]==leadingCharacterChar){\n\t\t\treturn new String(charArray,i+1,length-i-1);\n\t\t}\n\t}\n\treturn new String(charArray);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tif(str==null){\n\t\treturn null;\n\t}\n\tString trimmedString=str.trim();\n\tif(trimmedString.length()==0){\n\t\treturn null;\n\t}\n\tchar firstCharacter=trimmedString.charAt(0);\n\tif(!Character.isLetterOrDigit(firstCharacter)){\n\t\treturn null;\n\t}\n\ttrimmedString=trimmedString.substring(1);\n\tchar lastCharacter=trimmedString.charAt(trimmedString.length()-1);\n\tif(!Character.isLetterOrDigit(lastCharacter)){\n\t\treturn null;\n\t}\n\treturn trimmedString;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tStringBuilder sb = new StringBuilder();\n\tint index = 0;\n\twhile(index < str.length()){\n\t\tif(index == 0){\n\t\t\tsb.append(leadingCharacter);\n\t\t}else if(str.charAt(index-1) == leadingCharacter){\n\t\t\tsb.append(leadingCharacter);\n\t\t}else{\n\t\t\tsb.append(str.charAt(index));\n\t\t}\n\t\tindex++;\n\t}\n\treturn sb.toString();\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tif(str == null || str.length() == 0 || leadingCharacter == null || leadingCharacter.length() == 0){\n\t\treturn \"\";\n\t}\n\tint startIndex = getIndexOfLeadingCharacter(str,leadingCharacter);\n\treturn str.substring(0, startIndex);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString newStr=str.trim();\n\tif(newStr.length()==0){\n\t\treturn \"\";\n\t}\n\telse{\n\t\tif(newStr.charAt(0)==leadingCharacter){\n\t\t\tnewStr=newStr.substring(1);\n\t\t}\n\t\treturn newStr;\n\t}\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tStringBuilder sb=new StringBuilder();\n\tchar chr;\n\tfor(int i=0;i<str.length();i++){\n\t\tchr=str.charAt(i);\n\t\tif(chr==leadingCharacter){\n\t\t\tsb.append(chr);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString trimmedStr=str;\n\tint length=str.length();\n\tint beginIndex=0;\n\tint endIndex=length;\n\twhile(endIndex>beginIndex){\n\t\tif(str.charAt(beginIndex)!=leadingCharacter){\n\t\t\ttrimmedStr=str.substring(beginIndex,endIndex);\n\t\t\tbreak;\n\t\t}\n\t\tbeginIndex++;\n\t\tendIndex--;\n\t}\n\treturn trimmedStr;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tStringBuffer sb=new StringBuffer();\n\tchar c;\n\tfor(int i=0;i<str.length();i++){\n\t\tc=str.charAt(i);\n\t\tif(c==leadingCharacter){\n\t\t\tsb.append(c);\n\t\t}else{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tif(str==null){\n\t\treturn null;\n\t}\n\t\n\tString[] strs = str.split(\"\");\n\tif(strs.length==0){\n\t\treturn str;\n\t}\n\t\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i=0;i<strs.length;i++){\n\t\tif(strs[i].charAt(0)==leadingCharacter){\n\t\t\tsb.append(strs[i].substring(1));\n\t\t}else{\n\t\t\tsb.append(strs[i]);\n\t\t}\n\t}\n\treturn sb.toString();\n}"]}
{"_id": "636767691a6d9265ec0181a6", "generate_results": ["public static String[] split(String toSplit,String delimiter){\n\tString[] returnArray = new String[2];\n\tint index = 0;\n\t\n\twhile(index < toSplit.length()){\n\t\tindex = toSplit.indexOf(delimiter,index);\n\t\tif(index == -1){\n\t\t\treturnArray[0] = null;\n\t\t\treturnArray[1] = null;\n\t\t\treturn returnArray;\n\t\t}\n\t\treturnArray[0] = toSplit.substring(0,index);\n\t\treturnArray[1] = toSplit.substring(index+1);\n\t\tindex = index + delimiter.length();\n\t}\n\treturnArray[0] = toSplit.substring(0,index);\n\treturnArray[1] = toSplit.substring(index+1);\n\treturn returnArray;\n}", "public static String[] split(String toSplit,String delimiter){\n\t\n\tint startIndex = 0;\n\tint endIndex = toSplit.length();\n\t\n\twhile(startIndex < endIndex){\n\t\tif(toSplit.charAt(startIndex) == delimiter.charAt(0)){\n\t\t\tstartIndex++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tendIndex -= 1;\n\t\n\twhile(startIndex < endIndex){\n\t\tif(toSplit.charAt(startIndex) == delimiter.charAt(delimiter.length()-1)){\n\t\t\tstartIndex++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn new String[]{toSplit.substring(0, startIndex),toSplit.substring(startIndex, endIndex)};\n\t\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] split = null;\n\tint index = 0;\n\tint length = toSplit.length();\n\tint i = 0;\n\twhile(i < length){\n\t\tif(toSplit.charAt(i) == delimiter.charAt(index)){\n\t\t\tsplit = new String[2];\n\t\t\tsplit[0] = toSplit.substring(index,i);\n\t\t\tsplit[1] = toSplit.substring(i + 1);\n\t\t\tindex += delimiter.length();\n\t\t\ti += delimiter.length();\n\t\t}else if(i < length){\n\t\t\tsplit = new String[2];\n\t\t\tsplit[0] = toSplit.substring(index,i);\n\t\t\tsplit[1] = toSplit.substring(i + 1);\n\t\t\tindex += delimiter.length();\n\t\t\ti += delimiter.length();\n\t\t}else{\n\t\t\tsplit = new String[2];\n\t\t\tsplit[0] = toSplit.substring(index);\n\t\t\tsplit[1] = \"\";\n\t\t\tindex += delimiter.length();\n\t\t\ti += delimiter.length();\n\t\t}\n\t\ti++;\n\t}\n\treturn split;\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] split = null;\n\ttry{\n\t\tsplit = toSplit.split(delimiter);\n\t}\n\tcatch(Exception e){\n\t\tSystem.out.println(e.getMessage());\n\t}\n\treturn split;\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] subStrings = new String[1];\n\tint index = toSplit.indexOf(delimiter);\n\tif(index!= -1){\n\t\tsubStrings[0] = toSplit.substring(0,index);\n\t}\n\treturn subStrings;\n}", "public static String[] split(String toSplit,String delimiter){\n\treturn split(toSplit,delimiter,new String[]{});\n}", "public static String[] split(String toSplit,String delimiter){\n\treturn split(toSplit,delimiter,\"\");\n}", "public static String[] split(String toSplit,String delimiter){\n    String[] split = new String[2];\n    int index = 0;\n    int i = 0;\n    while(i < toSplit.length()){\n        if(toSplit.substring(i,i+1).equalsIgnoreCase(delimiter)){\n            split[index] = toSplit.substring(i,i+1);\n            i++;\n        }else{\n            split[index] = toSplit.substring(i,i+1);\n            i++;\n            index++;\n        }\n        i++;\n    }\n    return split;\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] toReturn = new String[2];\n\tint index = 0;\n\t\n\t//First, determine the number of occurences of the delimiter in the given string\n\tint delimiterLen = delimiter.length();\n\tint splitIndex = 0;\n\tint splitCount = toSplit.split(delimiter,splitIndex).length;\n\t\n\t//Loop through all of the characters in the given string, and count the number of occurrences of the delimiter in the string\n\twhile(index < toSplit.length()){\n\t\tif(index == splitIndex){\n\t\t\tsplitCount++;\n\t\t}\n\t\t\n\t\t//If the index in the string isn't greater than the split index, then we need to split the string at the first occurrence of the delimiter\n\t\tif(index > splitIndex){\n\t\t\tindex = toSplit.indexOf(delimiter,index);\n\t\t}\n\t\t\n\t\t//If the index in the string is greater than or equal to the split index, then we don't need to split this string\n\t\tif(index <= splitIndex){\n\t\t\tindex = toSplit.indexOf(delimiter,index);\n\t\t}\n\t\t\n\t\t//If the index in the string is less than the split index, then we need to split this string at the first occurrence of the delimiter\n\t\tif(index < splitIndex){\n\t\t\tsplitCount = splitCount+1;\n\t\t\tsplitIndex = index;\n\t\t}\n\t\t\n\t\t//If the index in the string is equal to the split index, then we need to split this string at the first occurrence of the delimiter\n\t\tif(index == splitIndex){\n\t\t\tsplitCount = splitCount+1;\n\t\t}\n\t}\n\t\n\t//Put the split count in toReturn\n\ttoReturn[0] = toSplit.substring(splitIndex,splitIndex+splitCount);\n\ttoReturn[1] = toSplit.substring(splitIndex+splitCount);\n\t\n\treturn toReturn;\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] toReturn = new String[2];\n\tString[] toReturn1 = new String[2];\n\tString[] toReturn2 = new String[2];\n\tString[] toReturn3 = new String[2];\n\tString[] toReturn4 = new String[2];\n\t\n\tint i=0;\n\tint j=0;\n\tint i1=0;\n\tint j1=0;\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\ti1=i;\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\twhile(toSplit.substring(i,i1).equals(delimiter)){\n\t\ti1=i+1;\n\t}\n\tif(i1>i){\n\t\ti1=i;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n"]}
{"_id": "636767691a6d9265ec0181ac", "generate_results": ["public static String applyRelativePath(String path,String relativePath){\n\treturn path.substring(0, path.lastIndexOf(FOLDER_SEPARATOR));\n}", "public static String applyRelativePath(String path,String relativePath){\n\treturn path.replace(FOLDER_SEPARATOR,RELATIVE_SEPARATOR);\n}", "public static String applyRelativePath(String path,String relativePath){\n\tList<String> pathParts=new ArrayList<String>();\n\tif(path==null){\n\t\treturn path;\n\t}\n\tpathParts.add(path);\n\tif(path.startsWith(FOLDER_SEPARATOR)){\n\t\tpath=path.substring(1);\n\t}\n\tpathParts.add(relativePath);\n\treturn path.substring(0, path.lastIndexOf(FOLDER_SEPARATOR));\n}", "public static String applyRelativePath(String path,String relativePath){\n\tString fullFilePath=path;\n\tint index;\n\tint length=relativePath.length();\n\t\n\tif(fullFilePath.endsWith(FOLDER_SEPARATOR)){\n\t\tindex=fullFilePath.length()-1;\n\t\twhile(index>=0 && fullFilePath.charAt(index)==FOLDER_SEPARATOR){\n\t\t\tindex--;\n\t\t}\n\t\tif(index>=0){\n\t\t\tfullFilePath=fullFilePath.substring(0,index);\n\t\t}\n\t}\n\t\n\treturn fullFilePath;\n}", "public static String applyRelativePath(String path,String relativePath){\n    StringBuilder sb = new StringBuilder();\n    String separator = FOLDER_SEPARATOR;\n    \n    if(!path.endsWith(separator)){\n        sb.append(separator);\n    }\n    \n    sb.append(path);\n    \n    sb.append(separator);\n    \n    return sb.toString();\n}", "public static String applyRelativePath(String path,String relativePath){\n//\treturn path;\n//}", "public static String applyRelativePath(String path,String relativePath){\n\treturn applyPath(path,relativePath,false);\n}", "public static String applyRelativePath(String path,String relativePath){\n\tString fullPath=path;\n\tString[] split;\n\t\n\tif(path.startsWith(FOLDER_SEPARATOR)){\n\t\tsplit=path.split(FOLDER_SEPARATOR);\n\t\tfullPath=split[split.length-1];\n\t}else{\n\t\tsplit=path.split(FOLDER_SEPARATOR);\n\t\tfullPath=split[split.length-1];\n\t}\n\t\n\tif(split.length==1){\n\t\tfullPath=FOLDER_SEPARATOR+fullPath;\n\t}else if(split.length==2){\n\t\tfullPath=FOLDER_SEPARATOR+fullPath+FOLDER_SEPARATOR+split[0];\n\t}else if(split.length==3){\n\t\tfullPath=FOLDER_SEPARATOR+split[0]+FOLDER_SEPARATOR+split[1]+FOLDER_SEPARATOR+split[2];\n\t}\n\t\n\treturn fullPath;\n}", "public static String applyRelativePath(String path,String relativePath){\n\treturn applyRelativePath(path,relativePath,false);\n}", "public static String applyRelativePath(String path,String relativePath){\n\tStringBuilder sb=new StringBuilder();\n\tsb.append(path.substring(0, path.lastIndexOf(FOLDER_SEPARATOR)));\n\tsb.append(FOLDER_SEPARATOR);\n\tsb.append(relativePath);\n\treturn sb.toString();\n}"]}
{"_id": "6367676b1a6d9265ec0181e9", "generate_results": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n    if(index<0){\n        return false;\n    }\n    if(str.length()<=index){\n        return false;\n    }\n    \n    int match=0;\n    int index2=index;\n    while(index2>=0){\n        if(str.charAt(index2)!=substring.charAt(match)){\n            return false;\n        }\n        index2--;\n        match++;\n    }\n    return true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>str.length()){\n\t\treturn false;\n\t}\n\tif(str.charAt(index)==substring.charAt(0)){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>str.length()-1)return false;\n\tint start=index;\n\tint end=index+substring.length();\n\twhile(start<end){\n\t\tif(str.charAt(start)!=substring.charAt(substring.length()-1-start))return false;\n\t\tstart++;\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n    if(index>=str.length() || index<0){\n        return false;\n    }\n    \n    int index2=index;\n    int index3=index+substring.length();\n    if(index2>=str.length() || index3>=str.length()){\n        return false;\n    }\n    \n    for(int i=0;i<substring.length();i++){\n        if(str.charAt(index2++)!=substring.charAt(index3++)){\n            return false;\n        }\n    }\n    \n    return true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(str.length()<=index || str.length()<=substring.length())return false;\n\tint len=str.length();\n\tint i=index;\n\tint j=substring.length();\n\twhile(i<len){\n\t\tif(str.charAt(i)==substring.charAt(j)){\n\t\t\ti++;\n\t\t\tj--;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>=str.length()){\n\t\treturn false;\n\t}\n\tint end=index+substring.length();\n\tif(end<str.length()){\n\t\tfor(int i=index;i<end;i++){\n\t\t\tif(str.charAt(i)==substring.charAt(0)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(str == null || index < 0 || index >= str.length()){\n\t\treturn false;\n\t}\n\tint start = 0;\n\tint end = index;\n\twhile(start < end){\n\t\tif(str.charAt(start)!= substring.charAt(end - start - 1)){\n\t\t\treturn false;\n\t\t}\n\t\tstart++;\n\t\tend--;\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>=str.length()){\n\t\treturn false;\n\t}\n\tint len=str.length();\n\tif(index>=len){\n\t\treturn false;\n\t}\n\tif(index<len){\n\t\tint i=index,j=len-1;\n\t\tint start=i;\n\t\twhile(i<j){\n\t\t\tif(str.charAt(i)!=substring.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(i>=j){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i<j){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\treturn str.subSequence(index,index+substring.length()).toString().equals(substring.toString());\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index>=0 && index<str.length()){\n\t\tif(str.charAt(index)==substring.charAt(0) && str.charAt(index+1)==substring.charAt(1))return true;\n\t\telse return false;\n\t}\n\treturn false;\n}"]}
{"_id": "636767821a6d9265ec0183a0", "generate_results": ["Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\t//check if file exists\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\t//if it exists, delete it\n\t\tfile.delete();\n\t}\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\ttry{\n\t\tFile f = new File(fileName);\n\t\tif(f.exists()){\n\t\t\tf.delete();\n\t\t}\n\t}\n\tcatch (Exception e){\n\t\tSystem.err.println(\"Error deleting \" + fileName);\n\t\te.printStackTrace();\n\t}\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n    try {\n        File file = new File(fileName);\n        if (file.exists() && file.isFile()) {\n            file.delete();\n        }\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n    File file = new File(fileName);\n    if(file.exists()){\n        file.delete();\n    }\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile f=new File(fileName);\n\tif(f.exists()){\n\t\tf.delete();\n\t}\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n    File file = new File(fileName);\n    if(file.exists()){\n        if(file.isFile()){\n            file.delete();\n        }else{\n            file.deleteOnExit();\n        }\n    }\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile file = new File(fileName);\n\tif(file.exists())\n\t\tfile.delete();\n}", "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n    File file = new File(fileName);\n    if(file.exists()){\n        file.delete();\n    }\n}"]}
{"_id": "6367677e1a6d9265ec01830f", "generate_results": ["public String format(LoggingEvent event){\n    if(event == null){\n        return null;\n    }\n    \n    StringWriter writer = new StringWriter();\n    \n    // use the formatter to format the buffered string\n    StringBuffer stringBuffer = new StringBuffer();\n    \n    // format the buffered string with the pattern converter\n    stringBuffer.append(new Formatter().format(event.getFormattedMessage()));\n    \n    // add the formatted string to the buffer\n    stringBuffer.append(writer.toString());\n    \n    // return the formatted string\n    return stringBuffer.toString();\n}", "public String format(LoggingEvent event){\n\tStringBuilder sb = new StringBuilder();\n\t\n\tsb.append(event.getLoggerName());\n\tsb.append(\" - \");\n\tsb.append(event.getLevel());\n\tsb.append(\" - \");\n\tsb.append(event.getThrowable());\n\t\n\tsb.append(event.getMessage());\n\t\n\treturn sb.toString();\n}", "public String format(LoggingEvent event){\n    StringBuilder sb = new StringBuilder();\n    String message = event.getMessage();\n    Pattern pattern = Pattern.compile(event.getFormatter().pattern());\n    Matcher matcher = pattern.matcher(message);\n    while(matcher.find()){\n        sb.append(matcher.group(0));\n    }\n    return sb.toString();\n}", "public String format(LoggingEvent event){\n\treturn String.format(pattern, event);\n}", "public String format(LoggingEvent event){\n    return format(event, null);\n}", "public String format(LoggingEvent event){\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i = 0; i < event.getLevel().getLevel().length; i++){\n\t\tString level = event.getLevel().getLevel()[i];\n\t\tif(level.equals(\"ERROR\")){\n\t\t\tsb.append(\"ERROR\");\n\t\t}else if(level.equals(\"WARN\")){\n\t\t\tsb.append(\"WARN\");\n\t\t}else if(level.equals(\"INFO\")){\n\t\t\tsb.append(\"INFO\");\n\t\t}else if(level.equals(\"DEBUG\")){\n\t\t\tsb.append(\"DEBUG\");\n\t\t}else if(level.equals(\"TRACE\")){\n\t\t\tsb.append(\"TRACE\");\n\t\t}else if(level.equals(\"ALL\")){\n\t\t\tsb.append(\"ALL\");\n\t\t}\n\t\tsb.append(\"|\");\n\t}\n\treturn sb.toString();\n}", "public String format(LoggingEvent event){\n\tStringBuffer result = new StringBuffer();\n\tboolean first = true;\n\tfor (int i = 0; i < event.getLevel().ordinal(); i++) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tresult.append(\", \");\n\t\t}\n\t\tresult.append(event.getMessage().toString());\n\t}\n\treturn result.toString();\n}", "public String format(LoggingEvent event){\n\tStringBuilder sb = new StringBuilder();\n\tString str = event.getFormattedMessage();\n\t\n\tif(str.length()>0){\n\t\tsb.append(str);\n\t}\n\t\n\treturn sb.toString();\n}", "public String format(LoggingEvent event){\n\tif (event == null){\n\t\treturn null;\n\t}\n\t//If the level is greater than or equal to the level of the event, we can\n\t//not format the string\n\tif (event.getLevel().compareTo(level) >= 0){\n\t\treturn null;\n\t}\n\t//Check if the level is equal to the level of the event\n\tif (event.getLevel().compareTo(level) == 0){\n\t\treturn event.getMessage();\n\t}\n\t//Otherwise, return the format\n\treturn (event.getLevel().toString() + \" : \" + event.getMessage());\n}", "public String format(LoggingEvent event){\n    String result = \"\";\n    Object[] params = new Object[3];\n    params[0] = event.getLevel();\n    params[1] = event.getSource();\n    params[2] = event.getMessage();\n    String pattern = getPattern(params);\n    if (pattern == null) {\n        return result;\n    }\n    result = pattern.replaceAll(\"\\\\{\\\\{.*\\\\}\\\\}\", \"\");\n    return result;\n}"]}
{"_id": "636767781a6d9265ec01823d", "generate_results": ["Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n\t// This method is called from within the constructor to\n\t// create a logger.  Do not add any logic here.\n\t// Logger logger = Logger.getLogger(\"test\");\n\n\t// Create a temp file and write the message in it.\n\t// The temp file is deleted after the call to this method.\n\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\ttry {\n\t\tfos.write(event.getMessage().getBytes());\n\t}\n\tfinally {\n\t\tfos.close();\n\t}\n\n\t// Delete the temp file.\n\t// The temp file is deleted after the call to this method.\n\tif (tmpFile!= null) {\n\t\tdelete(tmpFile);\n\t}\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n\tFile file = null;\n\tif(event!=null){\n\t\tfile = new File(event.getLoggerName()+File.separator+event.getLoggerName()+\".log\");\n\t\ttry{\n\t\t\tfile.createNewFile();\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tFileWriter writer = null;\n\t\ttry{\n\t\t\twriter = new FileWriter(file);\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\twriter.write(String.valueOf(event.getLevel().getValue()));\n\t\tif(event.getMessage()!=null){\n\t\t\twriter.write(String.valueOf(event.getMessage()));\n\t\t}\n\t\twriter.close();\n\t}\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    File file = File.createTempFile(\"log-\", \".txt\");\n    file.deleteOnExit();\n\n    try {\n      JConsole.append(file, event);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    try {\n      JConsole.write(file);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n\tString message = event.getMessage();\n\tFile temp = File.createTempFile(\"test\", \".tmp\");\n\ttry{\n\t\tMessageFormat.format(\n\t\t\t\"{0} {1}\",\n\t\t\tmessage,\n\t\t\tnew Object[]{event.getSource(), event.getLevel(), event.getThreadName()}\n\t\t);\n\t\tFileOutputStream fos = new FileOutputStream(temp);\n\t\tfos.write(event.getMessage().getBytes());\n\t\tfos.close();\n\t\tfos = null;\n\t\t// The temp file is deleted in the finally block.\n\t}\n\tcatch(Exception e){\n\t\te.printStackTrace();\n\t\tfos = null;\n\t}\n\tfinally{\n\t\tif(temp!= null){\n\t\t\ttemp.delete();\n\t\t}\n\t}\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    try {\n\tFileOutputStream fos = new FileOutputStream(tempFile);\n\tfos.write(event.getMessage().getBytes());\n\tfos.close();\n    } catch (IOException e) {\n\tthrow new RuntimeException(e);\n    }\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    try {\n        File tempFile = File.createTempFile(\"sub\", \".txt\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        OutputStreamWriter osw = new OutputStreamWriter(fos);\n        osw.write(event.getMessage());\n        osw.close();\n        fos.close();\n        FileUtils.moveFile(tempFile, new File(appender.getFile()));\n        appender.setFile(tempFile);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    File file = new File(fileName);\n    FileOutputStream fos = new FileOutputStream(file);\n    try {\n      event.getMessage().writeTo(fos);\n    } catch (IOException e) {\n      FileLog.e(\"Error while writing to the log file\", e);\n    } finally {\n      try {\n        fos.close();\n      } catch (IOException e) {\n        FileLog.e(\"Error while closing the file\", e);\n      }\n    }\n  }", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n\t//Write the message in the event into a temp file.\n\t//The file name will be the basename of the file.\n\tString name = event.getLoggerName() + \".java\";\n\tFile temp = File.createTempFile(name, \".java\");\n\ttry {\n\t\tFileWriter fw = new FileWriter(temp);\n\t\tfw.write(event.getMessage());\n\t\tfw.close();\n\t\tSystem.out.println(\"Wrote message into temp file \" + temp);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    try{\n        File file = File.createTempFile(\"log_\", \".txt\");\n        file.deleteOnExit();\n        FileOutputStream fos = new FileOutputStream(file);\n        fos.write(toByteArray(event));\n        fos.close();\n        FileWriter writer = new FileWriter(file);\n        writer.write(file.getAbsolutePath());\n        writer.close();\n    }\n    catch(IOException e){\n        e.printStackTrace();\n    }\n}", "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n        if (file == null)\n            return;\n        try {\n            file.append(event.getMessage());\n        } catch (IOException exc) {\n            Logging.logException(exc);\n        }\n    }"]}
{"_id": "636767831a6d9265ec0183c9", "generate_results": ["public static void setString(String s){\n\tstack.peek().replace(\"\", \"\");\n}", "public static String peek(){\n    return stack.peek();\n}", "public static Stack<String> newStack(int num){\n\tStack<String> newStack = new Stack<String>();\n\tfor (int i = 0; i < num; i++){\n\t\tnewStack.push(stack.peek());\n\t}\n\treturn newStack;\n}", "public static String peek(){\n\treturn top();\n}", "public static String peek(){\n    return top;\n}", "public static String peek(){\n\treturn top;\n}", "public static void println(){\n    System.out.println(stack.peek());\n}", "public static String get(){\n\treturn stack.peek();\n}", "public static String peekStack(){\n\tString s = \"\";\n\tstack.peek();\n\treturn s;\n}", "public static String peek(){\n    return top;\n}"]}
{"_id": "6367677e1a6d9265ec01832e", "generate_results": ["public Logger exists(String name){\n\treturn logger.get(name);\n}", "public Logger exists(String name){\n\treturn Logger.getLogger(name);\n}", "public Logger exists(String name){\n    Logger logger = _loggers.get(name);\n    if(logger == null){\n        logger = _loggers.get(name = name.toLowerCase());\n    }\n    return logger;\n}", "public Logger exists(String name){\n    return Loggers.get(name);\n}", "public Logger exists(String name){\n    return LoggerFactory.getLogger(name);\n}", "public Logger exists(String name){\n\tif (loggers.containsKey(name)){\n\t\treturn loggers.get(name);\n\t}\n\treturn null;\n}", "public Logger exists(String name){\n\tif(loggers.containsKey(name)){\n\t\treturn loggers.get(name);\n\t}\n\treturn null;\n}", "public Logger exists(String name){\n\tfor(Logger logger : this.loggers){\n\t\tif(logger.getName().equals(name)){\n\t\t\treturn logger;\n\t\t}\n\t}\n\treturn null;\n}", "public Logger exists(String name){\n\tLogger logger = loggerMap.get(name);\n\tif (logger == null) return null;\n\treturn logger;\n}", "public boolean exists(String name){\n\treturn loggers.containsKey(name);\n}"]}
{"_id": "6367677b1a6d9265ec0182bd", "generate_results": ["public String format(final LoggingEvent event){\n\treturn getFormatter().format(event);\n}", "public String format(final LoggingEvent event) {\n    return format(event, DEFAULT_TIME_FORMAT, level);\n}", "public String format(final LoggingEvent event) {\n        final StringBuilder sb = new StringBuilder();\n        final String message = event.getMessage();\n        sb.append(format(event, \"\"));\n        sb.append(message);\n        return sb.toString();\n    }", "public String format(final LoggingEvent event){\n    return \"Message [\" + event.getMessage() + \"]\";\n}", "public String format(final LoggingEvent event){\n\tfinal StringBuilder sb = new StringBuilder();\n\tsb.append(event.getMessage()).append(\"\\n\");\n\tsb.append(event.getLevel()).append(\"\\n\");\n\tsb.append(event.getThreadID()).append(\"\\n\");\n\tsb.append(event.getTimeMillis()).append(\"\\n\");\n\tsb.append(event.getLevel()).append(\" - \");\n\tsb.append(event.getThreadID()).append(\"\\n\");\n\tsb.append(event.getMessage()).append(\"\\n\");\n\tsb.append(event.getLevel()).append(\" - \");\n\tsb.append(event.getThreadID()).append(\"\\n\");\n\treturn sb.toString();\n}", "public String format(final LoggingEvent event){\n    return String.format(format, event);\n}", "public String format(final LoggingEvent event){\n    return event.getMessage() + \" (\" + event.getLevel() + \")\";\n}", "public String format(final LoggingEvent event){\n    return String.format(\"%s - %s\", event.getLevel(), event.getMessage());\n}", "public String format(final LoggingEvent event){\n    final LogRecord record = event.getLogRecord();\n    final StringBuilder builder = new StringBuilder();\n    builder.append(String.format(\"%s:%d %s\", record.getSourceClassName(), record.getSourceMethodName(), record.getMessage()));\n    for(int i=0;i<event.getParameters().length;i++){\n        builder.append(String.format(\" %s=%s\",String.valueOf(event.getParameters()[i]),String.valueOf(record.getParameters()[i])));\n    }\n    return builder.toString();\n}", "public String format(final LoggingEvent event){\n    return event.getMessage().getFormattedMessage();\n}"]}
{"_id": "636767791a6d9265ec018263", "generate_results": ["Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    final ClassLoader classLoader = this.getClassLoader();\n    return classLoader.loadClass(className);\n  }", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    return findClass(className, null);\n  }", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\tClass clazz = classLoader.loadClass(className);\n\treturn clazz;\n}", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    try {\n        return Class.forName(className);\n    } catch (ClassNotFoundException e) {\n        throw new ClassNotFoundException(className);\n    }\n}", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n    if (currentClassLoader == null) {\n      currentClassLoader = ClassLoader.getSystemClassLoader();\n    }\n    ClassLoader baseClassLoader = currentClassLoader;\n    while (baseClassLoader!= null) {\n      try {\n        return baseClassLoader.loadClass(className);\n      } catch (ClassNotFoundException e) {\n        // try the next classloader\n        baseClassLoader = baseClassLoader.getParent();\n      }\n    }\n    return null;\n  }", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tif (this.classes == null) {\n\t\treturn super.findClass(className);\n\t}\n\n\tfinal Class clazz = this.classes.get(className);\n\tif (clazz!= null) {\n\t\treturn clazz;\n\t}\n\n\tfor (final Class clazz1 : this.classes.values()) {\n\t\tif (clazz1.getName().equals(className)) {\n\t\t\treturn clazz1;\n\t\t}\n\t}\n\n\treturn super.findClass(className);\n}", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    if (!className.startsWith(CLASS_PREFIX)) {\n      throw new ClassNotFoundException(\n          \"Class name does not start with a class prefix: \" + className);\n    }\n    return Class.forName(className.substring(CLASS_PREFIX.length()));\n  }", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    try {\n        return Class.forName(className);\n    } catch (ClassNotFoundException e) {\n        return null;\n    }\n}", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    Class result = findClassByName(className);\n    if (result == null)\n      throw new ClassNotFoundException(className);\n    return result;\n  }", "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    if (className == null) {\n      return null;\n    }\n\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n    try {\n      // Class.forName() is a more efficient way to do this\n      return classLoader.loadClass(className);\n    } catch (ClassNotFoundException e) {\n      // Class.forName() is a more elegant way to do this\n      return classLoader.loadClass(className.replace('.', '/'));\n    }\n  }"]}
{"_id": "636767791a6d9265ec018257", "generate_results": ["public void addMessage(final LogRecord lr){\n\tthis.addMessage(lr.getMessage(), lr.getThrown());\n}", "public void addMessage(final LogRecord lr){\n    final String msg = lr.getMessage();\n    final int line = lr.getLineNumber();\n    final String ln = String.valueOf(line);\n    final String ln_msg = new String (ln);\n    final String ln_msg_msg = new String (ln_msg);\n    final String ln_msg_ln = new String (ln_msg);\n    final String ln_msg_ln_msg = new String (ln_msg_msg);\n    final String ln_msg_ln_ln = new String (ln_msg_ln);\n    final LogRecord lr_msg = new LogRecord(lr);\n    lr_msg.setLoggerName(lr.getLoggerName());\n    lr_msg.setLevel(lr.getLevel().intValue());\n    lr_msg.setLoggerName(lr.getLoggerName());\n    lr_msg.setLoggerName(lr.getLoggerName());\n    lr.setLogRecord(lr_msg);\n    final Object[] oa = new Object[1];\n    oa[0] = lr_msg;\n    final LogRecord lr_msg_msg = new LogRecord(lr_msg);\n    lr_msg_msg.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln = new LogRecord(lr_msg);\n    lr_msg_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_msg = new LogRecord(lr_msg);\n    lr_msg_ln_msg.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_msg = new LogRecord(lr_msg);\n    lr_msg_ln_ln_msg.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_msg_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_msg_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln_ln_ln.setLogRecord(lr_msg);\n    final LogRecord lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln_ln_ln_ln_ln_ln = new LogRecord(lr_msg);\n    lr_msg_ln_ln_ln_msg_ln_ln_ln_ln_ln_ln_", "public void addMessage(final LogRecord lr){\n    final String msg = lr.getMessage();\n    final String logID = lr.getLoggerName();\n    final String source = lr.getSource();\n    final String sourceID = lr.getSourceId();\n    final long timestamp = lr.getMillis();\n    final String level = lr.getLevel().toString();\n    final String className = lr.getThread().getName();\n    final String threadName = lr.getThread().getName();\n    final String threadID = lr.getThread().getId();\n    final String threadNameID = lr.getThread().getThreadName();\n    final String threadIDID = lr.getThread().getThreadId();\n    final String threadNameIDString = lr.getThread().getThreadName();\n    final String threadIDString = lr.getThread().getThreadId();\n    final String threadNameString = lr.getThread().getThreadName();\n    final String threadNameStringID = lr.getThread().getThreadName();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadNameIDStringID = lr.getThread().getThreadName();\n    final String threadNameIDStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringID = lr.getThread().getThreadId();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameIDStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameIDStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr.getThread().getThreadName();\n    final String threadIDStringIDString = lr.getThread().getThreadId();\n    final String threadNameStringIDString = lr", "public void addMessage(final LogRecord lr){\n    \ttry{\n    \t\tSwingUtilities.invokeAndWait(new Runnable(){\n    \t        public void run() {\n    \t        \t\n    \t            if(lr.getLoggerName().equals(SwingUtilities.getWindowAncestor(SwingUtilities.getWindow(LogTab.this)).getClass().getName())){\n    \t           \t    //add the message to the table\n    \t            \tTableModel tm = getTableModel();\n    \t            \tfor(int i = 0; i < tm.getRowCount(); i++){\n    \t            \t\ttm.setValueAt(lr.getMessage(), i, 0);\n    \t            \t}\n    \t            \ttm.fireTableDataChanged();\n    \t            }\n    \t        }\n    \t    });\n    \t}\n    \tcatch(Exception e){\n    \t    e.printStackTrace();\n    \t}\n    }", "public void addMessage(final LogRecord lr){\n    // If the row is null, then nothing was added\n    if (lr == null) return;\n    \n    // Check if the row has already been added\n    final Row row = table.getRow(lr.getLoggerName());\n    if (row == null) return;\n    \n    // Add a message to the row\n    row.add(lr);\n    \n    // Set the table model with the row\n    tableModel.setData(row, lr);\n}", "public void addMessage(final LogRecord lr){\n\tSwingUtilities.invokeLater(new Runnable() {\n\t\tpublic void run() {\n\t\t\tlog.addMessage(lr);\n\t\t}\n\t});\n}", "public void addMessage(final LogRecord lr){\n\tfor(int i = 0; i < this.messages.size(); i++) {\n\t\tif(this.messages.get(i).equals(lr.getMessage())){\n\t\t\treturn;\n\t\t}\n\t}\n\tthis.messages.add(lr);\n\tthis.rowCount++;\n\tthis.repaint();\n}", "public void addMessage(final LogRecord lr){\n    if(lr == null) return;\n    \n    JTextComponent c = (JTextComponent)lr.getLogger();\n    c.setEditable(false);\n    c.setForeground(new Color(0, 0, 0));\n    c.setBackground(new Color(255, 255, 255));\n    c.setFont(new Font(\"Arial\", Font.PLAIN, 12));\n    c.setText(lr.getMessage());\n    c.setCaretPosition(0);\n    c.setCaretVisible(false);\n    c.setMaximumSize(new Dimension(100, 100));\n    c.setVisible(true);\n    c.setTextIsEditable(false);\n    c.setCaret(Caret.getSystemCaret());\n    c.setFocusTraversalKeysEnabled(false);\n    c.setFocusable(false);\n    c.setBorder(new EmptyBorder(2, 2, 2, 2));\n    c.setBorderPainted(false);\n    c.addFocusListener(new FocusListener() {\n        public void focusGained(FocusEvent e) {\n            c.setCaretPosition(0);\n        }\n\n        public void focusLost(FocusEvent e) {\n            c.setCaretPosition(0);\n        }\n    });\n    JScrollPane scrollPane = new JScrollPane(c);\n    scrollPane.getVerticalScrollBar().setUnitIncrement(15);\n    scrollPane.getHorizontalScrollBar().setUnitIncrement(15);\n    scrollPane.setMaximumSize(new Dimension(100, 100));\n    scrollPane.setPreferredSize(new Dimension(100, 100));\n    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    scrollPane.setBorder(new EmptyBorder(2, 2, 2, 2));\n    scrollPane.setBorderPainted(false);\n    scrollPane.setBorder(new EmptyBorder(2, 2, 2, 2));\n    scrollPane.setBorderPainted(false);\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n    scrollPane.setOpaque(false);\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setOpaque(false);\n    scrollPane.setOpaque(false);\n    scrollPane.setOpaque(false);\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255, 255));\n    scrollPane.setBackground(new Color(255, 255", "public void addMessage(final LogRecord lr){\n        if (lr == null) return;\n        final String msg = lr.getMessage();\n        final boolean isDebug = lr.getLogger().isDebugEnabled();\n        if (msg!= null) {\n            if (isDebug) {\n                System.err.println(\"Adding message: \" + msg);\n            }\n            getLogTable().add(new SwingUtilities.LocalBundle(\n                \"LogMessage\",\n                new Object[]{\n                    msg,\n                    lr.getLogger().getLevel().name(),\n                    lr.getLogger().getSourceClassName()\n                }\n            ));\n        }\n        //If we don't add the message, then we need to display it in the log.\n        if (isDebug) {\n            System.err.println(\"SwingUtilities.addMessage: \" + msg);\n        }\n}", "public void addMessage(final LogRecord lr){\n\tif(!isVisible()) return;\n\tlr.setMessage(\"\");\n\tif(!lr.getSourceClassName().equals(\"\")){\n\t\tlr.setSourceClassName(\"\");\n\t\tlr.setSourceMethodName(\"\");\n\t}\n\tlr.setMessage(\"\");\n\tlr.setLoggerName(\"\");\n\tlr.setSourceMethodName(\"\");\n\t\n\tint index = table.getRowCount()-1;\n\ttable.setRowSelectionInterval(index,index);\n\ttable.scrollRectToVisible(table.getCellRect(index, 0, true));\n\ttable.scrollRectToVisible(table.getCellRect(index, 1, true));\n\ttable.scrollRectToVisible(table.getCellRect(index, 2, true));\n\ttable.scrollRectToVisible(table.getCellRect(index, 3, true));\n\ttable.setRowSelectionInterval(index,index);\n\tif(index == 0){\n\t\ttable.setRowSelectionInterval(0,0);\n\t}\n\t\n\tif (lr.getSourceClassName().equals(\"\")) {\n\t\tSystem.out.println(\"No source class name set\");\n\t}\n\ttable.setRowSelectionInterval(index,index);\n\ttable.setColumnSelectionInterval(0,0);\n\ttable.setColumnSelectionInterval(1,0);\n\ttable.setColumnSelectionInterval(2,0);\n\ttable.setColumnSelectionInterval(3,0);\n\ttable.setRowSelectionInterval(index,index);\n\ttable.setRowSelectionInterval(index,index);\n\ttable.add(lr);\n\t\n\t\n\t\n}"]}
{"_id": "636767841a6d9265ec0183ff", "generate_results": ["public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif(row<0){\n\t\trow = table.getRowCount()-1;\n\t}\n\tJTableModel model = (JTableModel)table.getModel();\n\tmodel.clearSelection();\n\ttable.scrollRectToVisible(new Rectangle(0,0,table.getWidth(),table.getHeight()));\n\tpane.setViewportView(table);\n\ttable.scrollRectToVisible(new Rectangle(0,0,table.getWidth(),table.getHeight()));\n\t\n\tint rowToSelect = row;\n\tif(table.getValueAt(row, 0).toString().length()==0){\n\t\trowToSelect = 0;\n\t}\n\tmodel.setValueAt(table.getValueAt(row, 0).toString(), rowToSelect, 0);\n\t\n\t\n\t\n\t\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.getVerticalScrollBar().setValue(table.getRowHeight(row));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane)\n// -----------------------------------------------------------------------------------\npublic static void selectRow(int row,JTable table){\n    table.scrollRectToVisible(new Rectangle(table.getCellRect(row, 0, true)));\n    pane.getVerticalScrollBar().setValue(table.getRowHeight(row));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif (table.isRowSelected(row)){\n\t\ttable.setRowSelectionInterval(row,row);\n\t}\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.scrollRectToVisible(table.getCellRect(row, 0, true));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n    if(row>=0 && row<table.getRowCount()){\n        table.setSelectedRow(row);\n        pane.getViewport().setViewPosition(new Point(0,0));\n    }\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.setViewportView(table);\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\t\n\tJTableRowModel rowModel = table.getModel();\n\t\n\tif (rowModel.getRowCount() > 0) {\n\t\t\n\t\tint firstRow = rowModel.getRowCount() - 1;\n\t\tint lastRow = rowModel.getRowCount() - 2;\n\t\t\n\t\tint firstCol = rowModel.getColumnCount() - 1;\n\t\tint lastCol = rowModel.getColumnCount() - 2;\n\t\t\n\t\tif (firstRow < 0) firstRow = 0;\n\t\tif (lastRow > rowModel.getRowCount() - 1) lastRow = rowModel.getRowCount() - 1;\n\t\tif (firstCol < 0) firstCol = 0;\n\t\tif (lastCol > rowModel.getColumnCount() - 1) lastCol = rowModel.getColumnCount() - 1;\n\t\t\n\t\tpane.setViewportView(rowModel.getRow(rowModel.getRow(row)));\n\t\t\n\t\tpane.scrollRectToVisible(new Rectangle(firstCol, firstRow, lastCol - firstCol, lastRow - firstRow));\n\t\t\n\t\t//pane.scrollRectToVisible(new Rectangle(firstCol, firstRow, lastCol - firstCol, lastRow - firstRow));\n\t\t\n\t}\n\t\n}", "public static int selectRow(int tableRow,JTable table,JScrollPane pane) throws IndexOutOfBoundsException, IllegalArgumentException, ArrayIndexOutOfBoundsException{\n    tableRow = Math.max(0,tableRow);\n    tableRow = Math.min(table.getRowCount()-1,tableRow);\n    int row = table.convertRowIndexToModel(tableRow);\n    int index = table.convertRowIndexToModel(tableRow);\n    if(tableRow == index){\n        pane.setVisible(false);\n        return tableRow;\n    } else if(tableRow > index){\n        table.setRowSelectionInterval(index,index);\n        pane.setVisible(true);\n        return index;\n    } else {\n        throw new IndexOutOfBoundsException(\"Expected \" + tableRow + \" in range 0-19\");\n    }\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n//\tif(row<0){\n//\t\trow=0;\n//\t}\n//\tif(row>=table.getRowCount()-1){\n//\t\trow=table.getRowCount()-1;\n//\t}\n//\ttable.scrollRectToVisible(pane.getBounds());\n//}"]}
{"_id": "636767871a6d9265ec01846d", "generate_results": ["public static void createConfigurationDirectory(){\n\tString directory = System.getenv(\"PATH\");\n\tdirectory = directory.replace(\"/\",\"\\\\\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"/\",\"/\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory = directory.replace(\"c:\",\"c:\");\n\tdirectory = directory.replace(\"\\\\\",\"/\");\n\tdirectory =", "public static void createConfigurationDirectory(){\n\tString[] dirs = new String[]{\"/Applications\", \"/Library\", \"/System/Library\", \"/Applications/Finder.app\"};\n\tString[] dirs2 = new String[]{\"/Applications\", \"/System/Library\", \"/Applications/Finder.app\"};\n\tString[] dirs3 = new String[]{\"/Applications\", \"/System/Library\", \"/Applications/Finder.app\"};\n\tint i = 0;\n\tfor (i = 0; i < dirs.length; i++){\n\t\tFile f = new File(dirs[i]);\n\t\tif (!f.exists()){\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\tfor (i = 0; i < dirs2.length; i++){\n\t\tFile f = new File(dirs2[i]);\n\t\tif (!f.exists()){\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\tfor (i = 0; i < dirs3.length; i++){\n\t\tFile f = new File(dirs3[i]);\n\t\tif (!f.exists()){\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n}", "public static void createConfigurationDirectory(){\n\tif (System.getenv(\"HOME\") == null) {\n\t\tSystem.setProperty(\"user.home\", \"C:\\\\Documents and Settings\\\\Kuroire\\\\\" + \"LF5\\\\\");\n\t}\n\telse {\n\t\tSystem.setProperty(\"user.home\", System.getenv(\"HOME\"));\n\t}\n}", "public static void createConfigurationDirectory(){\n    String path = System.getenv(\"ProgramFiles(x86)\"); // path of the directory containing the executable\n    if(path == null){ // if the environment variable is not set, then path is set to the user home directory\n        path = System.getenv(\"USERPROFILE\");\n    }\n    path = path.replaceAll(\"\\\\\\\\\", \"/\"); // path of the directory containing the executable\n    path = path + \"/lf5\"; // path of the directory containing the executable\n    try {\n        System.setenv(\"ProgramFiles(x86)\", path);\n    } catch (SecurityException e) {\n        e.printStackTrace();\n    }\n    System.setenv(\"ProgramFiles(x86)\", path);\n    System.setenv(\"ProgramFiles(x86)\", path);\n}", "public static void createConfigurationDirectory(){\n\tFile configurationDir = new File(\"/configuration\");\n\tif(!configurationDir.exists()){\n\t\tconfigurationDir.mkdirs();\n\t}\n}", "public static void createConfigurationDirectory(){\n\t//Create the \"lf5\" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.\n\tString home = System.getenv(\"USERPROFILE\");\n\tString configDir = System.getenv(\"APPDATA\");\n\tString filename = \"Config.ini\";\n\tFile configFile = new File(home + \"/\" + configDir + \"/\" + filename);\n\tif(configFile.exists()){\n\t\t//If the \"Config.ini\" file exists, then delete it to prevent a race condition.\n\t\tconfigFile.delete();\n\t}\n\t//Create the \"lf5\" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.\n\ttry{\n\t\tFileUtils.forceMkDir(home + \"/\" + configDir + \"/\" + filename);\n\t}\n\tcatch(Exception e){\n\t\tSystem.out.println(\"ERROR: Could not create configuration directory.\");\n\t\tSystem.out.println(e.getMessage());\n\t}\n}", "public static void createConfigurationDirectory(){\n\t    \tif(!Environment.isWin32){\n\t    \t\tString name = \"lf5\";\n\t    \t\tString path = \"C:\\\\Documents and Settings\\\\\";\n\t    \t\tString newPath = path;\n\t    \t\tif(Environment.getenv(\"USERNAME\")!= null && Environment.getenv(\"USERNAME\").length() > 0){\n\t    \t\t\tnewPath = path + \"\\\\\" + Environment.getenv(\"USERNAME\");\n\t    \t\t}\n\t    \t\tif(Environment.getenv(\"PASSWORD\")!= null && Environment.getenv(\"PASSWORD\").length() > 0){\n\t    \t\t\tnewPath = path + \"\\\\\" + Environment.getenv(\"PASSWORD\");\n\t    \t\t}\n\t    \t\tnewPath = newPath + name;\n\t    \t\tString dir = newPath;\n\t    \t\tdo{\n\t    \t\t\ttry{\n\t    \t\t\t\tPath path = Paths.get(dir);\n\t    \t\t\t\tFiles.createDirectories(path);\n\t    \t\t\t}catch(Exception e){\n\t    \t\t\t\treturn;\n\t    \t\t\t}\n\t    \t\t\tdir = dir + name;\n\t    \t\t}while(dir.length() < 10);\n\t    \t}\n}", "public static void createConfigurationDirectory(){\n\tif(!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){\n\t\ttry{\n\t\t\tEnvironment.getExternalStorageState();\n\t\t}catch(Exception e){\n\t\t\tLog.i(TAG, \"Failed to get external storage state\");\n\t\t}\n\t\ttry{\n\t\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_SYSTEM);\n\t\t}catch(Exception e){\n\t\t\tLog.i(TAG, \"Failed to create external storage directory\");\n\t\t}\n\t}\n\tif(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){\n\t\ttry{\n\t\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_DOCUMENTS);\n\t\t}catch(Exception e){\n\t\t\tLog.i(TAG, \"Failed to create Documents directory\");\n\t\t}\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n\ttry{\n\t\tEnvironment.putExternalStorageDirectory(Environment.DIRECTORY_PICTURES);\n\t}catch(Exception e){\n\t\tLog.i(TAG, \"Failed to create Pictures directory\");\n\t}\n}", "public static void createConfigurationDirectory(){\n\tif(!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){\n\t\t//If the external storage is not mounted, create the configuration directory\n\t\tString currentDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath();\n\t\tString directoryName = \"lf5\";\n\t\tString fileName = \"configuration.dat\";\n\t\t\n\t\tFile directory = new File(currentDirectory + fileName);\n\t\tif(!directory.exists()){\n\t\t\tdirectory.mkdirs();\n\t\t}\n\t}\n}", "public static void createConfigurationDirectory(){\n\tif(! isWindows()){\n\t\t// Create the \"lf5\" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms.\n\t\tif(! isUserHome()){\n\t\t\tnew File( \"lf5\" );\n\t\t}\n\t\telse{\n\t\t\tnew File( \"lf5\" );\n\t\t}\n\t}\n}"]}
{"_id": "6367677f1a6d9265ec018347", "generate_results": ["public synchronized void send(final String message){\n\tif(!connections.isEmpty()){\n\t\tfinal StringBuilder sb = new StringBuilder(512);\n\t\tsb.append(\"Send to all connection \");\n\t\tsb.append(connections.size());\n\t\tsb.append(\"\\n\");\n\t\tsb.append(message);\n\t\tsb.append(\"\\n\");\n\t\tfor(final Connection conn : connections){\n\t\t\tconn.send(sb.toString());\n\t\t\tsb.setLength(0);\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(telnetOutput){\n\t\ttelnetOutput.write(message + \"\\r\\n\");\n\t}\n\telse{\n\t\tSystem.out.println(message);\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tfor(int i=0;i<getConnections().size();i++){\n\t\tgetConnections().get(i).send(message);\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(this.isConnected()){\n\t\ttry{\n\t\t\tthis.send(message);\n\t\t\t\n\t\t}catch(Exception e){\n\t\t\tLog.error(e);\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n    Message msg = new Message();\n    msg.setHeader(\"type\", \"text\");\n    msg.setHeader(\"from\", \"user@localhost\");\n    msg.setHeader(\"to\", \"user@localhost\");\n    msg.setHeader(\"text\", message);\n    channel.send(msg);\n}", "public synchronized void send(final String message){\n\t\n\tsynchronized (this) {\n\t\tif(! connected){\n\t\t\treturn;\n\t\t}\n\t\t// Send message to all the active connections\n\t\tfor(int i=0; i<numConnections; i++){\n\t\t\tif(!activeConnections[i].isConnected()){\n\t\t\t\ttry {\n\t\t\t\t\tactiveConnections[i].send(message);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tSystem.err.println(\"Error sending \" + message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\tfor(int i=0; i<getConnections().size(); i++){\n\t\tgetConnections().get(i).send(message);\n\t}\n}", "public synchronized void send(final String message){\n\t\n\ttry{\n\t\t// Try to send the message to all the connections in the list\n\t\tfor (TelnetConnection connection: telnetConnections) {\n\t\t\tconnection.send(message);\n\t\t}\n\t}catch(Exception e){\n\t\tlogger.log(Level.SEVERE, \"Telnet connection failed to send message: \"+e.getMessage());\n\t}\n}", "public synchronized void send(final String message){\n\tif (message!= null && message.length() > 0) {\n\t\tString[] args = null;\n\t\tif (message.indexOf('\\n') >= 0) {\n\t\t\targs = message.split(\"\\n\");\n\t\t} else {\n\t\t\targs = new String[] {message};\n\t\t}\n\t\tfor (String arg: args) {\n\t\t\tif (arg.indexOf(\"\\n\") >= 0) {\n\t\t\t\tsend(arg);\n\t\t\t} else {\n\t\t\t\tsend(arg + \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(message == null || message.length() == 0){\n\t\treturn;\n\t}\n\t\n\tfinal String command = \"telnet \" + message;\n\t\n\tsynchronized(this){\n\t\t\n\t\ttry{\n\t\t\t// Send the command to the server\n\t\t\t\n\t\t\t// This call will block until the server sends \n\t\t\t// the command. If the command fails, a RuntimeException\n\t\t\t// will be thrown.\n\t\t\t\n\t\t\tfinal String response = send(command);\n\t\t\t\n\t\t\t// If the command fails, a RuntimeException will be thrown\n\t\t\t\n\t\t\tif(response == null){\n\t\t\t\t\n\t\t\t\tif(this instanceof TelnetServer){\n\t\t\t\t\t\n\t\t\t\t\t((TelnetServer)this).shutdown();\n\t\t\t\t\t\n\t\t\t\t}else if(this instanceof TelnetClient){\n\t\t\t\t\t\n\t\t\t\t\t((TelnetClient)this).shutdown();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthrow new RuntimeException(\"Could not send command to server.\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// This call will block until the server sends the response\n\t\t\t\n\t\t\t// If the response fails, a RuntimeException will be thrown\n\t\t\t\n\t\t\tfinal String response2 = receive(0);\n\t\t\t\n\t\t\tif(response2 == null){\n\t\t\t\t\n\t\t\t\tthrow new RuntimeException(\"Could not receive command from server.\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t\t\n\t\t}catch(final Exception e){\n\t\t\t\n\t\t\tthrow new RuntimeException(e);\n\t\t\t\n\t\t}\n\t\t\n\t}\n}"]}
{"_id": "636767781a6d9265ec01823e", "generate_results": ["Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n  if(layout.ignoresThrowable()){\n    StrRep str = event.getLogRecord().getFormattedMessage();\n    if(layout.isIgnoringThrowable()){\n      str = event.getLogRecord().getThrown();\n    }\n    append(str);\n  }\n  else if(layout.isIgnoringThrowable()){\n    append(event.getLogRecord().getThrown());\n  }\n  else{\n    append(event.getLogRecord().getFormattedMessage());\n  }\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\ttry{\n\t\tif(event.getSource() instanceof Layout){\n\t\t\tLayout layout = (Layout)event.getSource();\n\t\t\tString text = layout.format(event, this);\n\t\t\tif(layout.ignoresThrowable()){\n\t\t\t\ttext = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\t}\n\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\tif(layout.getLayout().equals(Layout.XML)){\n\t\t\t\tres = res.replace(\":\", \"\");\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}else if(event.getSource() instanceof Throwable){\n\t\t\tThrowable t = event.getSource();\n\t\t\tif(t.getClass().getName().startsWith(\"org.apache.log4j.spi.\")){\n\t\t\t\tString text = t.getMessage();\n\t\t\t\tif(text.indexOf(\"org.apache.log4j.spi.LoggerException\") >= 0){\n\t\t\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\t\t\tres = res.replace(\":\", \"\");\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}else{\n\t\t\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\t\t\tres = res.replace(\":\", \"\");\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tString text = t.getMessage();\n\t\t\t\tif(text.indexOf(\"org.apache.log4j.spi.LoggerException\") >= 0){\n\t\t\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\t\t\tres = res.replace(\":\", \"\");\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}else{\n\t\t\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\t\t\tres = res.replace(\":\", \"\");\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}catch(Throwable t){\n\t\tString text = t.getMessage();\n\t\tif(text.indexOf(\"org.apache.log4j.spi.LoggerException\") >= 0){\n\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\tres = res.replace(\":\", \"\");\n\t\t\tSystem.out.println(res);\n\t\t}else{\n\t\t\tString res = text.replace(LoggingEvent.class.getName() + \".\", \"\");\n\t\t\tres = res.replace(\":\", \"\");\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i=0;i<event.getLevel().length;i++){\n\t\t\tif(event.getThrowable()!=null){\n\t\t\t\tif(event.getThrowable().getMessage()!=null){\n\t\t\t\t\tevent.setMessage(format(event.getMessage(),event.getThrowable().getMessage()));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tevent.setMessage(event.getThrowable().getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tevent.setMessage(event.getMessage());\n\t\t\t}\n\t\t\t\n\t\t\tif(event.getLevel()[i]==LoggingEvent.ERROR){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.ERROR));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.WARN){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.WARN));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.INFO){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.INFO));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.DEBUG){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.DEBUG));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<event.getLevel().length;i++){\n\t\t\tif(event.getLevel()[i]==LoggingEvent.ERROR){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.ERROR));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.WARN){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.WARN));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.INFO){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.INFO));\n\t\t\t}\n\t\t\telse if(event.getLevel()[i]==LoggingEvent.DEBUG){\n\t\t\t\tevent.setLogger(layout.getLogger(LoggingEvent.DEBUG));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tevent.setTimeMillis(System.currentTimeMillis());\n\t\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i=0;i<event.getThrowable().getMessage()!=null.toString().trim();i++){\n\t\t\tif(event.getThrowable()!=null){\n\t\t\t\tif(event.getThrowable().getMessage()!=null){\n\t\t\t\t\tevent.getThrowable().getMessage().replaceAll(\"%{N}\",event.getMessage());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tevent.getThrowable().getMessage().replaceAll(\"%{N}\",event.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tevent.getThrowable().getMessage().replaceAll(\"%{N}\",event.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n    if(event.getLevel().isGreaterOrEqual(LogLevel.ERROR) || event.getLevel().isGreaterOrEqual(LogLevel.WARN)){\n        super.append(event);\n    }\n    else{\n        if(layout.ignoresThrowable()){\n            this.format(event,layout);\n        }\n        else{\n            super.append(event);\n        }\n    }\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n    if(!this.layout.ignoresThrowable()){\n        String message = this.layout.format(event);\n        log.add(message);\n    }\n    \n    if( this.layout.ignoresThrowable()){\n        log.add(event.getMessage());\n    }\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n        //the log event's position is in the list of log events\n        int pos = getPosition(event);\n        //the position of the event\n        int start = pos;\n        //the position of the first line of the event\n        int end = start;\n        //the position of the last line of the event\n        int endLastLine = -1;\n        //the first line of the event\n        int line = 1;\n        //the first line of the event\n        int lineLastLine = -1;\n        //the last line of the event\n        int lineLastLineLastLine = -1;\n        //the last line of the event\n        int lineLastLineLastLine = -1;\n        //the last line of the event\n        int lineLastLineFirstLine = -1;\n        //the first line of the event\n        int lineFirstLine = 1;\n        //the first line of the event\n        int lineFirstLineLastLine = -1;\n        //the first line of the event\n        int lineFirstLineFirstLine = -1;\n        //the first line of the event\n        int lineFirstLineLastLine = -1;\n        //the last line of the event\n        int lineFirstLineLastLineLastLine = -1;\n        //the last line of the event\n        int lineFirstLineFirstLineLastLine = -1;\n        //the first line of the event\n        int lineFirstLineFirstLineLastLine = -1;\n        //the first line of the event\n        int lineFirstLineLastLineLastLine = -1;\n        //the first line of the event\n        int lineFirstLineLastLineFirstLine = -1;\n        StringBuilder lineBuilder = new StringBuilder();\n        lineBuilder.append(\"[\").append(line).append(\"]: \");\n        lineBuilder.append(event.getMessage());\n        lineBuilder.append(\"\\n\");\n        if(layout.ignoresThrowable()){\n            lineBuilder.append(\"\");\n        }\n        while(end > start){\n            //if the end of the line is the same as the start of the line, then we can stop here\n            if(end == start){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineFirstLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineFirstLineFirstLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineFirstLineFirstLineLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineLastLineFirstLineFirstLineLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineLastLineFirstLineLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineFirstLineFirstLineLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //if the end of the line is the same as the start of the line, then we can stop here\n            else if(end == endLastLineFirstLineFirstLineFirstLineLastLineLastLine){\n                lineBuilder.append(\"\");\n            }\n            //else if the end of", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tif(layout.ignoresThrowable()){\n\t\treturn;\n\t}\n\tif(!layout.ignoreExceptions()){\n\t\tevent.setLevel(event.getLevel().toString().toLowerCase());\n\t\tString message = event.getMessage();\n\t\tif(!message.contains(\"\\n\")){\n\t\t\tString text = message.replaceAll(\"\\n\", \"\\n\" + System.lineSeparator());\n\t\t\ttext = text.replaceAll(\"\\r\", System.lineSeparator());\n\t\t\ttext = text.replaceAll(\"\\t\", System.lineSeparator());\n\t\t\ttext = text.replaceAll(\"\\0\", System.lineSeparator());\n\t\t\ttext = text.replaceAll(\"\\r\\n\", System.lineSeparator());\n\t\t\ttext = text.replaceAll(\"\\0\", System.lineSeparator());\n\t\t\tmessage = text + System.lineSeparator() + text;\n\t\t}\n\t\telse{\n\t\t\ttext = text + System.lineSeparator() + System.lineSeparator();\n\t\t}\n\t\tString stackTrace = event.getStackTrace();\n\t\tif(stackTrace.equals(\"\")){\n\t\t\tstackTrace = \"\";\n\t\t}\n\t\telse{\n\t\t\tString msg = message + System.lineSeparator() + stackTrace;\n\t\t\tmessage = msg + System.lineSeparator();\n\t\t}\n\t\tevent.setMessage(message);\n\t\tevent.setSourceClassName(event.getSourceClassName());\n\t\tevent.setSourceMethodName(event.getSourceMethodName());\n\t\tevent.setThrowable(event.getThrowable());\n\t\tevent.setLevel(event.getLevel().toString().toLowerCase());\n\t\tevent.setTimeMillis(event.getTimeMillis());\n\t\tevent.setThreadName(event.getThreadName());\n\t\tevent.setThreadGroupName(event.getThreadGroupName());\n\t\tevent.setThreadId(event.getThreadId());\n\t\tlog.log(event);\n\t}\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tif(layout == null){\n\t\treturn;\n\t}\n\tString message = event.getMessage();\n\tif(layout.ignoresThrowable()){\n\t\tmessage = message.replaceAll(\"\\n\", \" \");\n\t}\n\tString formatted = layout.format(event);\n\tif(layout.ignoresThrowable()){\n\t\tformatted = formatted.replaceAll(\"\\n\", \" \");\n\t}\n\tif(message.endsWith(\"\\n\")){\n\t\tmessage = message.substring(0, message.length()-1);\n\t}\n\tthis.log.add(formatted + \"\\n\");\n}", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tString message = event.getMessage();\n\tString stackTrace = event.getStackTrace();\n\tString logMessage = event.getFormattedMessage();\n\tString[] stackTraceTokens = stackTrace.split(\"\\n\");\n\tString logMessageTokens = logMessage.split(\"\\n\");\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < stackTraceTokens.length;i++){\n\t\t\tlogMessageTokens[i] = logMessageTokens[i].replace(\"{0}\", stackTraceTokens[i]);\n\t\t}\n\t}\n\tif(!layout.ignoresThrowable()){\n\t\tmessage = message.replace(\"{0}\", logMessage);\n\t\tmessage = message.replace(\"{1}\", stackTrace);\n\t}\n\tString[] formatted = layout.format(message);\n\tString[] formattedTokens = formatted.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokens = formattedTokens.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokensTokens = formattedTokensTokens.length>0? formattedTokensTokens : new String[0];\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokens.length;i++){\n\t\t\tformattedTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokens[i]);\n\t\t}\n\t}\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokensTokens[i]);\n\t\t}\n\t}\n\tString[] formattedTokens = layout.format(formattedTokens);\n\tString[] formattedTokensTokens = formattedTokens.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokensTokens = formattedTokensTokens.length>0? formattedTokensTokens : new String[0];\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokensTokens[i]);\n\t\t}\n\t}\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokensTokens[i]);\n\t\t}\n\t}\n\tString[] formattedTokens = layout.format(formatted);\n\tString[] formattedTokensTokens = formattedTokens.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokensTokens = formattedTokensTokens.length>0? formattedTokensTokens : new String[0];\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokensTokens[i]);\n\t\t}\n\t}\n\tString[] formattedTokens = layout.format(formattedTokens);\n\tString[] formattedTokensTokens = formattedTokens.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokensTokens = formattedTokensTokens.length>0? formattedTokensTokens : new String[0];\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[i] = formattedTokensTokensTokens[i].replace(\"{0}\", formattedTokensTokensTokens[i]);\n\t\t}\n\t}\n\tString[] formattedTokens = layout.format(formatted);\n\tString[] formattedTokensTokens = formattedTokens.length>0? formattedTokens : new String[0];\n\tString[] formattedTokensTokensTokens = formattedTokensTokens.length>0? formattedTokensTokens : new String[0];\n\tif(layout.ignoresThrowable()){\n\t\tfor(int i = 0;i < formattedTokensTokensTokens.length;i++){\n\t\t\tformattedTokensTokensTokens[", "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tString s = event.getLoggerName();\n\tint i = s.indexOf('.');\n\tif(i>0){\n\t\ts = s.substring(0,i) + \".\" + s.substring(i+1);\n\t}\n\tString l = null;\n\tif(!layout.ignoresThrowable()){\n\t\tl = Layout.format(event);\n\t}\n\telse{\n\t\tl = s;\n\t}\n\tif(l!=null){\n\t\tl = l.replaceAll(\"\\\\s+\", \" \");\n\t\tString s1 = l.substring(0,l.length()-1);\n\t\tif(s1.startsWith(\"@\")){\n\t\t\ts1 = s1.substring(1);\n\t\t}\n\t\treturn l+\"\\n\"+s1;\n\t}\n\treturn \"\";\n}"]}
{"_id": "6367677f1a6d9265ec01834b", "generate_results": ["public void put(LoggingEvent o){\n    buf.put(o);\n}", "public void put(LoggingEvent o){\n\tbuf.put(o);\n}", "public void put(LoggingEvent o){\n\tbuf.append(o);\n}", "public void put(LoggingEvent o){\n\tbuf.put(o);\n}", "public void put(LoggingEvent o){\n    buf.put(o);\n}", "public void put(LoggingEvent o){\n\tbuf.append(o);\n}", "public void put(LoggingEvent o){\n\tbuf.put(o);\n}", "public void put(LoggingEvent o){\n    buf.put(o);\n}", "public void put(LoggingEvent o){\n    buf.add(o);\n}", "public void put(LoggingEvent o){\n\tbuf.put(o);\n}"]}
{"_id": "636767791a6d9265ec01826d", "generate_results": ["public static String findAndSubst(String key,Properties props){\n\tString result = null;\n\tif(props.containsKey(key)){\n\t\tresult = props.getProperty(key);\n\t}\n\treturn result;\n}", "public static String findAndSubst(String key,Properties props){\n    // TODO: use a case insensitive match\n    if(props.containsKey(key)){\n        return props.getProperty(key);\n    }\n    return key;\n}", "public static String findAndSubst(String key,Properties props){\nString val=props.getProperty(key);\nif(val==null){\n\tval=props.getProperty(key);\n}\nelse{\n\tval=val.substring(0,val.indexOf(\":\"));\n}\nreturn val;\n}", "public static String findAndSubst(String key,Properties props){\n\tString value=props.getProperty(key);\n\treturn value;\n}", "public static String findAndSubst(String key,Properties props){\n\tString res = null;\n\tif(props.get(key)!=null){\n\t\tres = props.get(key).toString();\n\t}\n\treturn res;\n}", "public static String findAndSubst(String key,Properties props){\n\tString value = findAndSubst(key, props.getProperty(key));\n\tif(value == null){\n\t\tvalue = props.getProperty(key);\t\n\t}\n\treturn value;\n}", "public static String findAndSubst(String key,Properties props){\n\tString res=null;\n\ttry {\n\t\t\tres=(String)props.get(key);\n\t} catch (NullPointerException e) {\n\t\t\treturn res;\n\t}\n\t\n\treturn res;\n}", "public static String findAndSubst(String key,Properties props){\n\t\n\tString val = null;\n\t// check for a match\n\tval = (String)props.get(key);\n\tif (val!= null){\n\t\tval = (String)props.get(key);\n\t\treturn val;\n\t}\n\t// else return the value in the case of exception\n\treturn val;\n}", "public static String findAndSubst(String key,Properties props){\n\tString result = null;\n\tString value = props.getProperty(key);\n\tif(value == null){\n\t\tthrow new IllegalArgumentException(\"No value found for key '\" + key + \"' in properties file\");\n\t}else{\n\t\tresult = value.substring(1, value.length() - 1);\n\t}\n\treturn result;\n}", "public static String findAndSubst(String key,Properties props){\n\tString result = \"\";\n\tString val = null;\n\tif(props.containsKey(key)){\n\t\tval = props.getProperty(key);\n\t}\n\tif(val==null){\n\t\tval = \"\";\n\t}\n\tresult = val;\n\treturn result;\n}"]}
{"_id": "636767781a6d9265ec018238", "generate_results": ["public boolean isAttached(Appender appender){\n\t//if the appender has an attached element, then return true\n\tif(appender.getAttached()!= null){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n\tif (appender.getAppenderElement()!=null)\n\t\treturn true;\n\tfor (AppenderElement elem: appender.getAppenderElement())\n\t\tif (elem.getAppenderElement()!=null && isAttached(elem.getAppenderElement()))\n\t\t\treturn true;\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n\tif(appender==null) return false;\n\tfor(Appender appender1:appenderList){\n\t\tif(appender1.getName().equals(appender.getName())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n\tList<Appender> appenderList = appender.getAppenders();\n\tfor (Appender appender1 : appenderList) {\n\t\tif (appender1.getName().equals(\"a\")) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n    if(appender == null) return false;\n    boolean result = false;\n    if(this.appenderList!= null) {\n        for (Appender appender1 : this.appenderList) {\n            if(appender1.getName().equals(appender.getName())) {\n                result = true;\n                break;\n            }\n        }\n    }\n    return result;\n}", "public boolean isAttached(Appender appender){\n    for(Appender appenderList : appenderListList){\n        if(appenderList.getName().equals(appender.getName())){\n            return true;\n        }\n    }\n    return false;\n}", "public boolean isAttached(Appender appender){\n\tfor (AppenderList appenderList : getAppenderList()) {\n\t\tif (appenderList.getAppender() == appender) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n    for (Appender appenderList : appenderListList){\n        if (appenderList.getName().equals(appender)){\n            return true;\n        }\n    }\n    return false;\n}", "public boolean isAttached(Appender appender){\n        for(Appender appender1: appenderList){\n            if(appender1.getName().equals(appender.getName())){\n                return true;\n            }\n        }\n        return false;\n    }", "public boolean isAttached(Appender appender){\n\tif(appender!=null && appender instanceof AppenderList){\n\t\tfor(AppenderList appenderList : ((AppenderList)appender).getAppenderList()){\n\t\t\tif(appenderList.getAppender() instanceof AppenderList){\n\t\t\t\tfor(AppenderList appenderList1 : ((AppenderList)appenderList).getAppenderList()){\n\t\t\t\t\tif(appenderList1.getAppender() instanceof AppenderList){\n\t\t\t\t\t\tif(isAttached(appenderList1)){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}"]}
{"_id": "6367677d1a6d9265ec0182fd", "generate_results": ["public static boolean toBoolean(String value,boolean dEfault){\nif (value == null)\nreturn dEfault;\nif (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\"))\nreturn true;\nif (value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\"))\nreturn false;\nif (value.length() == 0)\nreturn dEfault;\nreturn Boolean.parseBoolean(value);\n}", "public static boolean toBoolean(String value,boolean dEfault){\n    if(value == null)\n        return dEfault;\n    \n    if(value.equals(String.valueOf(true)) || value.equals(String.valueOf(false))){\n        return true;\n    }\n    \n    if(value.equals(String.valueOf(new String(\"\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\"))) || value.equals(String.valueOf(new String(\"\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0\\u00A0", "public static boolean toBoolean(String value,boolean dEfault){\nif(value == null) return dEfault;\nreturn value.trim().toLowerCase().equals(value.toLowerCase());\n}", "public static Boolean toBoolean(String value,boolean dEfault){\n\tboolean b = toBoolean(value);\n\treturn new Boolean(b);\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value == null){\n\t\treturn dEfault;\n\t}\n\tif(value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\")){\n\t\treturn true;\n\t}\n\tif(value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\")){\n\t\treturn false;\n\t}\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tboolean b = dEfault;\n\tif(value!=null){\n\t\tif(value.toLowerCase().contains(\"true\")){\n\t\t\tb = true;\n\t\t}\n\t\telse if(value.toLowerCase().contains(\"false\")){\n\t\t\tb = false;\n\t\t}\n\t}\n\treturn b;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value==null || value.trim().length()<1){\n\t\treturn dEfault;\n\t}\n\tif(value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"y\")){\n\t\treturn true;\n\t}\n\tif(value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\") || value.equalsIgnoreCase(\"n\")){\n\t\treturn false;\n\t}\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value==null || value.isEmpty()){\n\t\treturn dEfault;\n\t}\n\t\n\tvalue = value.trim();\n\t\n\tif(value.length()==0) {\n\t\treturn dEfault;\n\t}\n\t\n\treturn Boolean.parseBoolean(value);\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value==null){\n\t\treturn dEfault;\n\t}\n\tStringTokenizer tok = new StringTokenizer(value, \",\");\n\tif(tok.hasMoreTokens()){\n\t\treturn Boolean.parseBoolean(tok.nextToken());\n\t}\n\treturn dEfault;\n}", "public static Boolean toBoolean(String value,boolean dEfault){\n\tif(value==null || value.length()==0)\n\t\treturn dEfault;\n\tBoolean ret=null;\n\tStringTokenizer st=new StringTokenizer(value,\",\");\n\tString token=null;\n\twhile(st.hasMoreTokens()){\n\t\ttoken=st.nextToken();\n\t\tif(token.trim().length()>0)\n\t\t\tret=ret==null?new Boolean(token):ret;\n\t}\n\treturn ret;\n}"]}
{"_id": "636767841a6d9265ec0183e8", "generate_results": ["public void add(LoggingEvent event){\n    if(this.buffer.length() > 0){\n        this.buffer.append(\", \");\n    }\n    this.buffer.append(event.getLoggerName());\n    this.buffer.append(\" \");\n    this.buffer.append(event.getTime());\n    this.buffer.append(\" \");\n    this.buffer.append(event.getLevel().getName());\n    this.buffer.append(\" \");\n    this.buffer.append(event.getSourceClassName());\n    this.buffer.append(\" \");\n    this.buffer.append(event.getSourceMethodName());\n    this.buffer.append(\" \");\n    this.buffer.append(event.getMessage());\n}", "public void add(LoggingEvent event){\n\tevent.setLogger(logger);\n\tevent.setTime(System.currentTimeMillis());\n\tif (bufferedEvents.size() > 0){\n\t\tbufferedEvents.get(bufferedEvents.size()-1).add(event);\n\t} else {\n\t\tbufferedEvents.add(event);\n\t}\n}", "public void add(LoggingEvent event){\n\tif(lastEvent == null){\n\t\tlastEvent = event;\n\t} else if (lastEvent.getTime() < event.getTime()){\n\t\tlastEvent = event;\n\t}\n}", "public void add(LoggingEvent event){\n\tthis.events.add(event);\n}", "public void add(LoggingEvent event){\n  if(!this.isEmpty()){\n    this.removeLast();\n    this.add(event);\n  }\n}", "public void add(LoggingEvent event){\n\tbuffer.add(event);\n}", "public void add(LoggingEvent event){\n\tif(nextEvent == null){\n\t\tnextEvent = event;\n\t}else{\n\t\tnextEvent.setNext(event);\n\t}\n}", "public void add(LoggingEvent event){\n\tif(!event.isTrace()) return;\n\tString msg = getMsg();\n\tif(msg == null) return;\n\t\n\tString log = msg;\n\t//TODO: add a check for the last event in the buffer.\n\tif(event.getMessage() == null)\n\t\tlog += \"\\n\" + event.getMessage();\n\telse\n\t\tlog += \"\\n\" + event.getMessage() + \"\\n\";\n\t\n\tif(lastEvent == null)\n\t\tlastEvent = log;\n\telse\n\t\tlastEvent = lastEvent + \"\\n\" + log;\n}", "public void add(LoggingEvent event){\n    if(!hasEvent())\n        event.setLoggingEvent(this);\n    else\n        addEvent(event);\n}", "public void add(LoggingEvent event){\n\tbuff.add(event);\n}"]}
{"_id": "636767861a6d9265ec01844c", "generate_results": ["public void removeAppender(String name){\n\tif(appenders.remove(name))\n\t\tappenders.remove(name);\n}", "public void removeAppender(String name){\n\tthis.appenders.remove(name);\n}", "public void removeAppender(String name){\n    appenders.remove(name);\n}", "public void removeAppender(String name){\n    synchronized (appenders) {\n        appenders.remove(name);\n    }\n}", "public void removeAppender(String name){\n\tif(!appenders.contains(name)){\n\t\tthrow new IllegalArgumentException(\"Appender '\"+name+\"' does not exist\");\n\t}\n\tappenders.remove(name);\n\tfireAppenderRemoved(name);\n}", "public void removeAppender(String name){\n    synchronized (appenders){\n        appenders.remove(name);\n    }\n}", "public void removeAppender(String name){\n\tsynchronized(appenders){\n\t\tif(appenders.contains(name)){\n\t\t\tappenders.remove(name);\n\t\t}\n\t}\n}", "public void removeAppender(String name){\n\tAppender<T> appender = getAppenderByName(name);\n\tif (appender!= null){\n\t\tremoveAppender(appender);\n\t}\n}", "public void removeAppender(String name){\n\tappenders.remove(name);\n}", "public void removeAppender(String name){\n    if(appenders.contains(name)){\n        appenders.remove(name);\n    }\n}"]}
{"_id": "636767781a6d9265ec018242", "generate_results": ["public int appendLoopOnAppenders(LoggingEvent event){\n\tint i = 0;\n\tfor (Appender appender : appenders) {\n\t\tif (appender.getLevel().equals(event.getLevel())) {\n\t\t\tappender.doAppend(event);\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tint result = 0;\n\tif (appenders!= null) {\n\t\tfor (Appender appender : appenders) {\n\t\t\tappender.append(event);\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tfor(Appender appender : appenderPool.values()){\n\t\ttry{\n\t\t\tappender.appendLoop(event);\n\t\t}catch(Exception e){\n\t\t\t// ignore exceptions\n\t\t}\n\t}\n\treturn appenderPool.size();\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    for(Appender appender: appenders){\n        appender.append(event);\n    }\n    return 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tfor(Appender appender : appenders){\n\t\tappender.append(event);\n\t}\n\treturn 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tint i = 0;\n\tfor(Appender appender:appenders){\n\t\tappender.append(event);\n\t\ti++;\n\t}\n\treturn i;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    for(Appender appender : appenders){\n        appender.doAppend(event);\n    }\n    return 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    \n    int appenderCount = 0;\n    \n    for(Appender appender : appenderList){\n    \n        appender.append(event);\n        \n        if(appender.getFault() == null && appender.getLoggerName()!= null &&!appender.getLoggerName().equals(event.getLoggerName())){\n            \n            appenderCount++;\n        }\n    }\n    \n    return appenderCount;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\t\n\twhile(true){\n\t\t\n\t\ttry{\n\t\t\t\n\t\t\tif(this.eventAppender!= null){\n\t\t\t\t\n\t\t\t\t//check if the event is still in queue\n\t\t\t\tif(this.eventAppender.isInQueue(event)){\n\t\t\t\t\t\n\t\t\t\t\t//if the event is already in queue, return immediately\n\t\t\t\t\treturn this.eventAppender.append(event);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//if the event is not in queue, append it to the queue\n\t\t\t\tthis.eventAppender.append(event);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}catch(Exception e){\n\t\t\t\n\t\t\t//try the next event\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\t\n\t\t//return an error code\n\t\treturn ERROR_APPEND_FAILED;\n\t\t\n\t}\n\t\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\treturn appendLoopOnAppender(event);\n}"]}
{"_id": "636767821a6d9265ec0183ab", "generate_results": ["public boolean hasThrown(){\n\treturn!m_thrown.isEmpty();\n}", "public boolean hasThrown() {\n\treturn hasThrownException() || thrown!= null;\n}", "public boolean hasThrown(){\n\treturn thrown!= null;\n}", "public boolean hasThrown(){\n\treturn this.thrown;\n}", "public boolean hasThrown(){\n   return thrown;\n}", "public boolean hasThrown(){\n  return (m_thrown!= null);\n}", "public boolean hasThrown(){\n\treturn (!thrown);\n}", "public boolean hasThrown(){\n    return!(this.thrown == null);\n}", "public boolean hasThrown(){\n    return this.hasThrown();\n}", "public boolean hasThrown(){\n\treturn ((this.thrown!= null) && this.thrown.length() > 0);\n}"]}
{"_id": "6367677e1a6d9265ec018314", "generate_results": ["Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\t//The number of removed nodes\n\tint removedNodes = 0;\n\t//The number of nodes in the Category tree.\n\tint nodeCount = getNodeCount();\n\t//For each node in the Category tree, check to see if it has any of its children\n\t//unused.\n\tfor(int i = 0; i < nodeCount; i++){\n\t\tif(!isUsed(i)){\n\t\t\t//Remove the node from the Category tree\n\t\t\tremoveNode(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddToUnused(i);\n\t\t\t//Add the node to the unused list\n\t\t\taddTo", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tCategoryNode root = new CategoryNode();\n\tCategoryNode category = root;\n\tint removeCount = 0;\n\twhile(!root.isLeaf()){\n\t\tif(root.isLeaf()){\n\t\t\tremoveCount += removeNode(category);\n\t\t\tif(removeCount == 0){\n\t\t\t\troot = category = new CategoryNode();\n\t\t\t}\n\t\t\telse\n\t\t\t\tcategory = category.getLeft();\n\t\t}\n\t\telse{\n\t\t\tcategory = category.getRight();\n\t\t}\n\t}\n\treturn removeCount;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tNode root = new Node(0);\n\treturn removeUnusedNodes(root);\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint numNodes = 0;\n\t\n\t/* remove unused nodes from the Category tree */\n\twhile(!root.isLeaf()){\n\t\tif(!root.isLeaf())\n\t\t\tremoveNode(root);\n\t\troot = (Node) root.getLeft();\n\t\tnumNodes++;\n\t}\n\treturn numNodes;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint numRemoved = 0;\n\twhile(!unusedNodes.isEmpty()){\n\t\tunusedNodes.remove(unusedNodes.first());\n\t\tnumRemoved++;\n\t}\n\treturn numRemoved;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint numRemoved = 0;\n\tfor(int i=0; i<numNodes; i++){\n\t\tNode temp = category[i];\n\t\twhile(temp.parent!= null){\n\t\t\tif(!temp.isTerminal()){\n\t\t\t\ttemp.parent.remove(temp);\n\t\t\t\tnumRemoved++;\n\t\t\t}else if(!temp.isTerminal()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp.parent;\n\t\t}\n\t}\n\treturn numRemoved;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\t// remove unused nodes from the tree\n\t// iterate through all the nodes in the tree\n\t// remove each node in the tree\n\t// iterate through all the nodes in the tree and remove the unused nodes\n\tint removedNodes = 0;\n\tNode root = getRootNode();\n\tif(root == null){\n\t\treturn removedNodes;\n\t}\n\t// iterate through all the nodes in the tree\n\t// remove each node in the tree\n\t// iterate through all the nodes in the tree and remove the unused nodes\n\twhile(root.getNumNodes() > 0){\n\t\t// iterate through all the nodes in the tree\n\t\t// remove each node in the tree\n\t\tNode node = root.getNode(0);\n\t\tif(!node.isLeaf()){\n\t\t\t// remove the node from the tree\n\t\t\troot.deleteNode(0);\n\t\t\t// iterate through all the nodes in the tree and remove the unused nodes\n\t\t\tremovedNodes++;\n\t\t}\n\t}\n\treturn removedNodes;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n        int removedNodes = 0;\n        for(int i = 0; i < numOfNodes; i++){\n            if(!usedNodes[i]){\n                Node node = nodes[i];\n                if(node.parent == null) continue;\n                if(node.color == color){\n                    int removed = remove(node);\n                    removedNodes += removed;\n                }\n            }\n        }\n        return removedNodes;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint n=0;\n\twhile(!inactive.isEmpty()){\n\t\tn++;\n\t\tinactive.remove(inactive.first());\n\t}\n\treturn n;\n}", "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\t\n\tint removedNodes = 0;\n\t\n\twhile(1){\n\t\t\n\t\tif(tree.size() == 0){\n\t\t\treturn removedNodes;\n\t\t}\n\t\t\n\t\tNode first = tree.first();\n\t\t\n\t\tif(first.isLeaf()){\n\t\t\t\n\t\t\tremovedNodes++;\n\t\t\t\n\t\t\tif(!first.isLinked()){\n\t\t\t\ttree.remove(first);\n\t\t\t\tremovedNodes--;\n\t\t\t}\n\t\t\t\n\t\t}else{\n\t\t\t\n\t\t\tLinkedList<Node> left = first.getLeft();\n\t\t\tLinkedList<Node> right = first.getRight();\n\t\t\t\n\t\t\tif(first.isLinked()){\n\t\t\t\ttree.remove(first);\n\t\t\t\tremovedNodes--;\n\t\t\t}\n\t\t\t\n\t\t\tif(left!= null && left.size() > 0){\n\t\t\t\tleft.remove();\n\t\t\t\tremovedNodes--;\n\t\t\t}\n\t\t\t\n\t\t\tif(right!= null && right.size() > 0){\n\t\t\t\tright.remove();\n\t\t\t\tremovedNodes--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn removedNodes;\n}"]}
{"_id": "636767841a6d9265ec0183f2", "generate_results": ["public int compare(Object aObj1,Object aObj2){\n\t//if the two events are the same, return 0\n\tif(aObj1==null && aObj2==null){\n\t\treturn 0;\n\t}\n\t//if the two events are the same, return the difference in timeStamp\n\telse if(aObj1!=null && aObj2!=null){\n\t\treturn aObj1.getTimeStamp()-aObj2.getTimeStamp();\n\t}\n\t//otherwise, return the difference in timeStamp\n\telse{\n\t\treturn aObj1.getTimeStamp()-aObj2.getTimeStamp();\n\t}\n}", "public int compare(Object aObj1,Object aObj2){\n\tif(aObj1==null && aObj2 == null){\n\t\treturn 0;\n\t}\n\telse if(aObj1 == null && aObj2!= null){\n\t\treturn 1;\n\t}\n\telse if(aObj1!= null && aObj2 == null){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn aObj1.compareTo(aObj2);\n\t}\n}", "public int compare(Object aObj1,Object aObj2){\n    long now = System.currentTimeMillis();\n    long aTime = ((Event)aObj1).getTimeStamp();\n    long bTime = ((Event)aObj2).getTimeStamp();\n    if (now < bTime) {\n      return -1;\n    }\n    else if (bTime < now) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n}", "public int compare(Object aObj1,Object aObj2){\n    return ((Long)aObj1.get(\"timeStamp\")).compareTo(((Long)aObj2.get(\"timeStamp\")));\n}", "public int compare(Object aObj1,Object aObj2){\n    if(aObj1 == null && aObj2!= null){\n        return -1;\n    }else if(aObj1!= null && aObj2 == null){\n        return 1;\n    }else{\n        return aObj1.compareTo(aObj2);\n    }\n}", "public int compare(Object aObj1,Object aObj2){\n\tif(aObj1==null || aObj2==null){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn aObj1.compareTo(aObj2);\n\t}\n}", "public int compare(Object aObj1,Object aObj2){\n\t\n\t//First, compare the timestamp of the first event object\n\tlong firstEventTimeStamp = ((Event)aObj1).getTimeStamp();\n\tlong secondEventTimeStamp = ((Event)aObj2).getTimeStamp();\n\t\n\tif(firstEventTimeStamp < secondEventTimeStamp){\n\t\treturn -1; //First event is before second event\n\t}\n\telse{\n\t\treturn 1; //First event is after second event\n\t}\n}", "public int compare(Object aObj1,Object aObj2){\n    return aObj1.compareTo(aObj2);\n}", "public int compare(Object aObj1,Object aObj2){\n\tif( aObj1 == null || aObj2 == null)\n\t\treturn 0;\n\tlong timeStamp1 = ((Long)aObj1).longValue() / 1000;\n\tlong timeStamp2 = ((Long)aObj2).longValue() / 1000;\n\tif( timeStamp1 > timeStamp2)\n\t\treturn 1;\n\telse if( timeStamp1 == timeStamp2)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}", "public int compare(Object aObj1,Object aObj2){\n\tif(aObj1==null && aObj2==null){\n\t\treturn 0;\n\t}\n\tif(aObj1==null){\n\t\treturn -1;\n\t}\n\tif(aObj2==null){\n\t\treturn 1;\n\t}\n\tlong diff = System.currentTimeMillis()-((Long)aObj1).longValue();\n\tlong otherDiff = System.currentTimeMillis()-((Long)aObj2).longValue();\n\tif(diff<0){\n\t\treturn -1;\n\t}\n\telse if(diff>0){\n\t\treturn 1;\n\t}\n\treturn 0;\n}"]}
{"_id": "636767781a6d9265ec018250", "generate_results": ["public int decide(LoggingEvent event){\n    String message = event.getMessage();\n    if (message.equals(expectedMessage)) {\n        return decision;\n    } else {\n        return decision;\n    }\n}", "public int decide(LoggingEvent event){\n\tif(event.getLevel() == Level.ERROR){\n\t\treturn event.getLoggerName().equals(\"\")?1:0;\n\t}\n\treturn event.getLevel().compareTo(Level.INFO) > 0?1:0;\n}", "public int decide(LoggingEvent event){\n        // get the message to determine the decision\n        String message = event.getMessage();\n        // if the message has a prefix then this is a message from a specific event\n        // otherwise, this is a message from the log level\n        if(message.startsWith(\"[\") && message.endsWith(\"]\")){\n            return event.getLoggerName().equals(event.getLogger())? 0 : 1;\n        }\n        // if the message starts with { and ends with } then this is a message from the log level\n        else if(message.startsWith(\"{\") && message.endsWith(\"}\")){\n            return event.getLoggerName().equals(event.getLogger())? 0 : 1;\n        }\n        // otherwise, this is a message from the log level\n        else{\n            return event.getLoggerName().equals(event.getLogger())? 0 : 1;\n        }\n}", "public int decide(LoggingEvent event){\n\tint decision = event.getMessage().compareTo(decisionString);\n\tif(decision == 0){\n\t\tdecision = event.getLevel().intValue();\n\t}\n\treturn decision;\n}", "public int decide(LoggingEvent event){\n\tString msg = event.getMessage();\n\tif (msg.equals(\"\")){\n\t\treturn 0;\n\t}\n\t\n\tString[] parts = msg.split(\" \");\n\tif (parts.length == 2){\n\t\treturn parts[1].equals(\"1\")? 1: 0;\n\t}\n\treturn 0;\n}", "public int decide(LoggingEvent event){\n\tString message = event.getMessage();\n\tString match = message.toLowerCase().trim();\n\tif(match.equals(\"true\")){\n\t\treturn 1;\n\t}else if(match.equals(\"false\")){\n\t\treturn 0;\n\t}else{\n\t\treturn -1;\n\t}\n}", "public int decide(LoggingEvent event){\n\tif(event.getMessage().contains(message)){\n\t\treturn event.getLevel().intValue()>=Level.INFO.intValue()?1:0;\n\t}\n\treturn 0;\n}", "public int decide(LoggingEvent event){\n\tString message = event.getMessage();\n\tString action = event.getAction();\n\tString className = event.getSourceClassName();\n\tString methodName = event.getSourceMethodName();\n\tString classAndMethod = event.getSourceClassName() + \".\" + event.getSourceMethodName();\n\tint result;\n\tString messageKey = \"decide_\" + action + \"_\" + classAndMethod;\n\t//String messageKey = \"decide_\" + action;\n\tif (message.equals(\"\")){\n\t\tresult = 0;\n\t} else {\n\t\tresult = event.getAction().equals(action) \n\t\t\t? decideClass(event)\n\t\t\t: decideMethod(event);\n\t}\n\treturn result;\n}", "public static int decide(LoggingEvent event){\n\ttry{\n\t\t//System.out.println(\"event.getLogger().getName() = \"+event.getLogger().getName());\n\t\t//System.out.println(\"event.getMessage() = \"+event.getMessage());\n\t\t//System.out.println(\"event.getLogger().getClass().getName() = \"+event.getLogger().getClass().getName());\n\t\t//System.out.println(\"event.getLogger().getClass().getSuperclass().getName() = \"+event.getLogger().getClass().getSuperclass().getName());\n\t\t//System.out.println(\"event.getLogger().getClass().getSuperclass().getSuperclass().getName() = \"+event.getLogger().getClass().getSuperclass().getSuperclass().getName());\n\t\t//System.out.println(\"event.getLogger().getClass().getSuperclass().getSuperclass().getSuperclass().getName() = \"+event.getLogger().getClass().getSuperclass().getSuperclass().getSuperclass().getName());\n\t\t//System.out.println(\"event.getLogger().getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getName() = \"+event.getLogger().getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuper", "public int decide(LoggingEvent event){\n\tString message = event.getMessage();\n\t\n\t//return decision based on message\n\tif(message.equals(\"yes\")){\n\t\treturn 1;\n\t}\n\telse if(message.equals(\"no\")){\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}"]}
{"_id": "636767861a6d9265ec018440", "generate_results": ["public void abbreviate(final int nameStart,final StringBuffer buf){\nbuf.delete(nameStart,nameStart+4);\nbuf.delete(nameStart+1,nameStart+4);\nbuf.delete(nameStart+4,nameStart+6);\nbuf.delete(nameStart+6,nameStart+8);\nbuf.delete(nameStart+8,nameStart+10);\nbuf.delete(nameStart+10,nameStart+12);\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint count = nameStart;\n\twhile (count > 0){\n\t\tif (buf.charAt(count) == '.'){\n\t\t\tbuf.deleteCharAt(count);\n\t\t\tcount = nameStart;\n\t\t\tbreak;\n\t\t}\n\t\tcount--;\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n    int nameEnd=nameStart;\n    int count=0;\n    while(nameEnd<nameStart+count){\n        if(buf.charAt(nameEnd)!='.'){\n            break;\n        }\n        count++;\n        nameEnd++;\n    }\n    if(count>2){\n        buf.delete(nameStart,nameEnd);\n        for(int i=0;i<count-1;i++){\n            buf.insert(nameStart,i+1,'.');\n        }\n        buf.insert(nameStart,count,'.');\n        nameEnd=nameStart+count;\n    }\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tfinal int nameEnd = nameStart + 1;\n\tfinal int firstCount = buf.length() - nameEnd;\n\tfinal int lastCount = buf.length() - 1;\n\tif (firstCount > 0) {\n\t\tbuf.setLength(firstCount);\n\t}\n\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\tif (i < firstCount) {\n\t\t\tbuf.setCharAt(i, buf.charAt(i - 1));\n\t\t} else {\n\t\t\tbuf.setCharAt(i, buf.charAt(i - 1) + \". \");\n\t\t}\n\t}\n\tif (firstCount > 0) {\n\t\tbuf.setCharAt(firstCount + 1, '.');\n\t}\n\tif (lastCount > 0) {\n\t\tbuf.setCharAt(lastCount + 1, '.');\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tfor (int i=nameStart;i<buf.length();i++){\n\t\tif (buf.charAt(i)!=' '){\n\t\t\tbuf.setCharAt(i,buf.charAt(i)-' ');\n\t\t}\n\t}\n\tbuf.setCharAt(nameStart,buf.charAt(nameStart)-' ');\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\t\n\tif(nameStart==0){\n\t\tbuf.append(name);\n\t\treturn;\n\t}\n\t\n\tfinal int count=1+name.length()-nameStart;\n\t\n\tbuf.setLength(0);\n\t\n\tfor(int i=0;i<count;i++){\n\t\tif(i==count-1){\n\t\t\tbuf.append(name.substring(i,name));\n\t\t}\n\t\telse{\n\t\t\tbuf.append(name.substring(i,name.length()));\n\t\t}\n\t}\n\t\n\tbuf.append(name.substring(nameStart));\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tif(nameStart==0){return;}\n\tfinal String subStrings[]=new String[nameStart];\n\tfor(int i=0;i<nameStart;i++){\n\t\tsubStrings[i]=buf.substring(i);\n\t}\n\t\n\tfor(int i=0;i<nameStart;i++){\n\t\twhile(i<subStrings.length){\n\t\t\tif(!Character.isLetterOrDigit(subStrings[i].charAt(0))){\n\t\t\t\tbuf.setLength(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tbuf.setLength(i);\n\t\treturn;\n\t}\n\t\n\tbuf.setLength(nameStart);\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){ //abbreviate the name in the buf by removing the first count substrings of the name\n\tint current = nameStart;\n\tint count = 0;\n\tfinal int end = nameStart + 1;\n\twhile(current < end){ //remove the first count substrings of the name\n\t\tif(buf.charAt(current) ==''){\n\t\t\tbuf.deleteCharAt(current);\n\t\t\tcount++;\n\t\t}\n\t\tcurrent++;\n\t}\n\tif(count > 0){\n\t\tbuf.deleteCharAt(current);\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint i=0;\n\tfor(;i<nameStart;i++){\n\t\tif(buf.charAt(i)=='.'){\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf.setCharAt(i,buf.charAt(i)-'a');\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\t\n\tfinal int nameLen= nameStart + 1;\n\t\n\tif(nameLen > buf.length()){\n\t\tbuf.setLength(buf.length()-1);\n\t}\n\t\n\tint i;\n\t\n\t//The first count substrings are deleted\n\tfor(i=0;i < nameLen;i++){\n\t\tif(buf.charAt(i) == '.'){\n\t\t\tbreak;\n\t\t}\n\t\tif(i > 0){\n\t\t\tbuf.deleteCharAt(i);\n\t\t}\n\t}\n\t\n\t//The last count substrings are deleted\n\tfor(i=0;i < nameLen;i++){\n\t\tif(buf.charAt(i) == '.'){\n\t\t\tbreak;\n\t\t}\n\t\tif(i == nameLen-1){\n\t\t\tbuf.setLength(i);\n\t\t}\n\t}\n}"]}
{"_id": "636767df1a6d9265ec01873c", "generate_results": ["public String id(String entityId){\n\tString id = entityId+\"_\"+idConnector;\n\treturn id;\n}", "public String id(String entityId){\n\tString id = entityId+\"_\"+idConnector;\n\treturn id;\n}", "public String id(String entityId){\n\tString id = entityId + idConnector;\n\treturn id;\n}", "public String id(String entityId){\n    int n = 0;\n    if(entityId == null){\n        return null;\n    }\n    if(entityId.length() > 0){\n        n = entityId.length();\n        entityId = entityId.substring(1, n);\n        return entityId + \"-\" + n;\n    }\n    return entityId + \"-\" + n;\n}", "public String id(String entityId){\n    return \"id/\"+entityId+\"/\"+id(entityId);\n}", "public String id(String entityId){\n\tString id = entityId + \"\";\n\treturn id;\n}", "public String id(String entityId){\n\treturn entityId+\"_\"+id();\n}", "public String id(String entityId){\n\tString id = entityId.replace(\"_\", \"\");\n\tif(id.startsWith(\"#\")){\n\t\tid = id.replace(\"#\", \"\");\n\t}\n\treturn id;\n}", "public String id(String entityId){\n\treturn entityId+\"_\"+id(point);\n}", "public String id(String entityId){\n\treturn entityId + \":\" + id(point);\n}"]}
{"_id": "636767e11a6d9265ec018781", "generate_results": ["public void accept(final METRICS data){\n\tfinal byte[] dataBytes = data.getBytes();\n\tfinal int dataLength = dataBytes.length;\n\tfinal byte[] buffer = new byte[dataLength];\n\tfor(int i = 0; i < dataLength; i++){\n\t\tbuffer[i] = dataBytes[i];\n\t}\n\t\n\tif(buffer.length == 0){\n\t\t//empty buffer\n\t\treturn;\n\t}\n\t\n\tfinal int bufferPos = buffer.length - 1;\n\tfinal byte[] combined = new byte[bufferPos]; \n\tSystem.arraycopy(buffer, 0, combined, 0, bufferPos);\n\t\n\tif(combined.length == bufferPos){\n\t\t//combined buffer is full\n\t\treturn;\n\t}\n\t\n\tfinal byte[] existing = buffer.length == bufferPos? null : new byte[bufferPos];\n\tSystem.arraycopy(buffer, 0, existing, 0, bufferPos);\n\t\n\tfinal byte[] combinedValue = new byte[combined.length];\n\tSystem.arraycopy(combined, 0, combinedValue, 0, combined.length);\n\t\n\tfinal byte[] newValue = new byte[existing.length];\n\tSystem.arraycopy(existing, 0, newValue, 0, existing.length);\n\t\n\tcombined[bufferPos] = (byte)existing.length;\n\t\n\tSystem.arraycopy(existing, 0, newValue, 0, existing.length);\n\t\n\tthis.data.setBytes(newValue);\n\t\n\treturn;\n}", "public void accept(final METRICS data){\n\tif(data.id == null) return;\n\tif(combined == null) combined = new METRICS(data.id);\n\telse combined.combine(data);\n\tif(combined.getId() == null) return;\n\t\n\t//Remove the old value if it is abandoned.\n\tif(data.id.equals(combined.getId())){\n\t\tcombined.setId(null);\n\t\treturn;\n\t}\n\t\n\t//Remove the old value if it is already in the buffer.\n\tif(data.id.equals(combined.getId())){\n\t\tcombined.setId(null);\n\t\treturn;\n\t}\n\t\n\t//Add the new value to the buffer.\n\tcombined.setId(data.id);\n}", "public void accept(final METRICS data){\n\tfinal String id = data.getId();\n\tif(id == null){\n\t\tdata.setId(getId());\n\t\tfinal String combined = getCombined();\n\t\tif(combined!= null){\n\t\t\tif(combined.length() > 0){\n\t\t\t\tfinal String[] array = combined.split(\",\");\n\t\t\t\tif(array.length > 1){\n\t\t\t\t\tfinal String value = array[1];\n\t\t\t\t\tif(value!= null && value.length() > 0){\n\t\t\t\t\t\tdata.setValue(value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata.setValue(getCombinedValue());\n\t\t\t}\n\t\t\tdata.setValue(getCombinedValue());\n\t\t}\n\t\treturn;\n\t}\n\tfinal boolean isAbandoned = data.isAbandoned();\n\tif(!isAbandoned){\n\t\tfinal String combined = getCombined();\n\t\tif(combined!= null){\n\t\t\tif(combined.length() > 0){\n\t\t\t\tfinal String value = combined;\n\t\t\t\tif(value.length() > 0){\n\t\t\t\t\tdata.setValue(value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.setValue(getCombinedValue());\n\t\t}\n\t}\n\tdata.setValue(getCombinedValue());\n}", "public void accept(final METRICS data){\n\tif(data.id == null){\n\t\treturn;\n\t}\n\tif(buffer.get(data.id)!= null){\n\t\tbuffer.remove(data.id);\n\t}\n\tbuffer.add(data);\n}", "public void accept(final METRICS data){\n\tfinal int id = data.getId();\n\tfinal long value = data.getValue();\n\tfinal String name = data.getName();\n\tif(id == METRICS.NO_ID) return; // nothing to do\n\tfinal int oldValue = buffer.get(id);\n\tfinal long oldValue2 = oldValue == METRICS.NO_VALUE? value : oldValue * oldValue;\n\tfinal long newValue = oldValue2 + value;\n\tif(oldValue2!= newValue) buffer.set(id, newValue);\n}", "public void accept(final METRICS data){\n\tfinal String id = data.getId();\n\tif(id.isEmpty()){\n\t\treturn;\n\t}\n\tif(!buffer.contains(id)){\n\t\tbuffer.add(id);\n\t\tfinal int oldSize = buffer.size();\n\t\tif(buffer instanceof LinkedList){\n\t\t\tLinkedList<String> list = new LinkedList<String>();\n\t\t\tfor(int i = 0; i < oldSize; i++){\n\t\t\t\tlist.add(buffer.remove(i));\n\t\t\t}\n\t\t\tlist.add(data);\n\t\t\tbuffer.addAll(list);\n\t\t}else{\n\t\t\tbuffer.add(data);\n\t\t}\n\t}\n}", "public void accept(final METRICS data){\n    super.accept(data);\n    if(data.getId()==null){\n        return;\n    }\n    if(this.buffer==null){\n        this.buffer=new METRICS();\n    }\n    if(data.getId()==this.buffer.getId()){\n        this.buffer.merge(data);\n        return;\n    }\n    if(this.buffer.getId()!=null){\n        this.buffer.remove(this.buffer.getId());\n        this.buffer.add(data);\n    }else{\n        this.buffer.add(data);\n    }\n}", "public void accept(final METRICS data){\n        if(!this.buffer.contains(data.id)){\n            this.buffer.add(data.id, data);\n        }else{\n            this.buffer.remove(data.id);\n        }\n        this.buffer.put(data.id, data);\n}", "public void accept(final METRICS data){\n    if(data.id==null){\n        if(this.buffer.isAbandoned()){\n            this.buffer.merge(data);\n            return;\n        }\n        this.buffer.add(data);\n        return;\n    }\n    this.buffer.add(data);\n    if(this.buffer.isAbandoned()){\n        this.buffer.merge(data);\n        return;\n    }\n    this.buffer.add(data);\n}", "public void accept(final METRICS data){\n    final String id = data.getId();\n    final Map<String, String> values = data.getValues();\n    final int flags = data.getFlags();\n    if (values.containsValue(id)){\n        return;\n    }\n    if (id.startsWith(idSeparator)){\n        if (id.length() > idSeparator.length()){\n            final String value = id.substring(idSeparator.length());\n            if (values.put(value, data.getValue()) == null){\n                return;\n            }\n        }\n        return;\n    }\n    if (id.startsWith(valueSeparator)){\n        return;\n    }\n    if (id.endsWith(valueSeparator)){\n        final String value = id.substring(0, id.length() - valueSeparator.length());\n        if (values.remove(value) == null){\n            return;\n        }\n    }\n    if (id.equals(valueSeparator)){\n        return;\n    }\n    if (values.put(id, data.getValue()) == null){\n        return;\n    }\n    final String oldValue = values.remove(id);\n    if (oldValue!= null){\n        final String newValue = oldValue.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n        if (values.put(id, newValue) == null){\n            return;\n        }\n        final String newId = values.remove(id);\n        if (newId!= null){\n            final String newValue = newId.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n            if (values.put(newId, newValue) == null){\n                return;\n            }\n        }\n    }\n}"]}
{"_id": "636767df1a6d9265ec018744", "generate_results": ["Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(start > end){\n\t\treturn timeRanges;\n\t}\n\ttimeRanges.add(new TimeRange(start, end, FETCH_DATA_DURATION));\n\ttimeRanges.add(new TimeRange(start, end, FETCH_DATA_DURATION));\n\ttimeRanges.add(new TimeRange(start, end, FETCH_DATA_DURATION));\n\treturn timeRanges;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tlong startTime=start;\n\tlong endTime=end;\n\tif(startTime<0){\n\t\tstartTime=0;\n\t}\n\tif(endTime>=FETCH_DATA_DURATION){\n\t\tendTime=FETCH_DATA_DURATION;\n\t}\n\tList<TimeRange> timeRanges=new ArrayList<TimeRange>();\n\ttimeRanges.add(new TimeRange(startTime,endTime));\n\treturn timeRanges;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\treturn null;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRangeList=new ArrayList<TimeRange>();\n\tif(start>end){\n\t\treturn timeRangeList;\n\t}\n\t\n\tlong startTime=System.currentTimeMillis();\n\tList<Integer> startTimeList=new ArrayList<Integer>();\n\t\n\twhile(System.currentTimeMillis()<end){\n\t\tstartTimeList.add(startTime);\n\t\tstartTime=System.currentTimeMillis();\n\t\t\n\t\tint endTime=startTime+FETCH_DATA_DURATION;\n\t\t\n\t\tTimeRange timeRange=new TimeRange(startTime,endTime);\n\t\ttimeRangeList.add(timeRange);\n\t}\n\t\n\t\n\treturn timeRangeList;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tlong startTime = start;\n\tlong endTime = end;\n\tif(startTime < FETCH_DATA_DURATION){\n\t\tstartTime = FETCH_DATA_DURATION;\n\t}\n\tif(endTime > FETCH_DATA_DURATION){\n\t\tendTime = FETCH_DATA_DURATION;\n\t}\n\tTimeRange timeRange = new TimeRange(startTime, endTime);\n\ttimeRanges.add(timeRange);\n\treturn timeRanges;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges=new ArrayList<TimeRange>();\n\tlong step=end-start;\n\tif(step<=0){\n\t\treturn timeRanges;\n\t}\n\tlong startTime=start;\n\tlong endTime=end;\n\tlong startTimeDifference=endTime-startTime;\n\tlong endTimeDifference=step-endTime;\n\twhile(startTimeDifference>=0 && endTimeDifference>=0){\n\t\tlong startTimeDifferenceTemp=startTimeDifference;\n\t\tlong endTimeDifferenceTemp=endTimeDifference;\n\t\tif(startTimeDifferenceTemp<0){\n\t\t\tstartTimeDifferenceTemp=0;\n\t\t}\n\t\tif(endTimeDifferenceTemp<0){\n\t\t\tendTimeDifferenceTemp=0;\n\t\t}\n\t\tlong startTimeTemp=startTime;\n\t\tlong endTimeTemp=endTime;\n\t\tif(startTimeTemp<0){\n\t\t\tstartTimeTemp=0;\n\t\t}\n\t\tif(endTimeTemp<0){\n\t\t\tendTimeTemp=0;\n\t\t}\n\t\tlong startTimeDifferenceTempTemp=startTimeDifferenceTemp;\n\t\tlong endTimeDifferenceTempTemp=endTimeDifferenceTemp;\n\t\tif(startTimeTemp-startTimeTemp>=0 && endTimeTemp-endTimeTemp>=0){\n\t\t\tstartTimeTemp=startTimeTemp;\n\t\t\tendTimeTemp=endTimeTemp;\n\t\t\tlong startTimeTempTemp=startTimeTemp;\n\t\t\tlong endTimeTempTemp=endTimeTemp;\n\t\t\tif(startTimeTempTemp<0){\n\t\t\t\tstartTimeTempTemp=0;\n\t\t\t}\n\t\t\tif(endTimeTempTemp<0){\n\t\t\t\tendTimeTempTemp=0;\n\t\t\t}\n\t\t\tlong startTimeTempTempTemp=startTimeTempTemp;\n\t\t\tlong endTimeTempTempTemp=endTimeTempTemp;\n\t\t\tif(startTimeTempTempTemp<0){\n\t\t\t\tstartTimeTempTempTemp=0;\n\t\t\t}\n\t\t\tif(endTimeTempTempTemp<0){\n\t\t\t\tendTimeTempTempTemp=0;\n\t\t\t}\n\t\t\tlong startTimeTempTempTempTemp=startTimeTempTempTemp;\n\t\t\tlong endTimeTempTempTempTemp=endTimeTempTempTemp;\n\t\t\tlong startTimeTempTempTempTempTemp=startTimeTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTemp=endTimeTempTempTempTemp;\n\t\t\t\n\t\t\tif(startTimeTempTempTempTempTemp<0){\n\t\t\t\tstartTimeTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tif(endTimeTempTempTempTempTemp<0){\n\t\t\t\tendTimeTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tlong startTimeTempTempTempTempTempTemp=startTimeTempTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTempTemp=endTimeTempTempTempTempTempTemp;\n\t\t\tlong startTimeTempTempTempTempTempTempTemp=startTimeTempTempTempTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTempTempTemp=endTimeTempTempTempTempTempTempTemp;\n\t\t\t\n\t\t\tif(startTimeTempTempTempTempTempTemp<0){\n\t\t\t\tstartTimeTempTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tif(endTimeTempTempTempTempTempTempTemp<0){\n\t\t\t\tendTimeTempTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tlong startTimeTempTempTempTempTempTempTemp=startTimeTempTempTempTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTempTempTemp=endTimeTempTempTempTempTempTempTempTemp;\n\t\t\tlong startTimeTempTempTempTempTempTempTempTemp=startTimeTempTempTempTempTempTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTempTempTempTemp=endTimeTempTempTempTempTempTempTempTempTemp;\n\t\t\t\n\t\t\tif(startTimeTempTempTempTempTempTempTempTemp<0){\n\t\t\t\tstartTimeTempTempTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tif(endTimeTempTempTempTempTempTempTempTempTemp<0){\n\t\t\t\tendTimeTempTempTempTempTempTemp=0;\n\t\t\t}\n\t\t\tlong startTimeTempTempTempTempTempTempTemp=startTimeTempTempTempTempTempTempTempTemp;\n\t\t\tlong endTimeTempTempTempTempTempTempTempTemp=endTimeTempTempTempTempTempTempTempTempTemp;\n\t\t\tlong startTimeTempTemp", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\t\n\tList<TimeRange> timeRangeList = new ArrayList<TimeRange>();\n\t\n\tif(start<=0){\n\t\ttimeRangeList.add(new TimeRange(start,end));\n\t}\n\t\n\tif(end<=0){\n\t\ttimeRangeList.add(new TimeRange(start,end));\n\t}\n\t\n\treturn timeRangeList;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n    List<TimeRange> timeRanges = new ArrayList<TimeRange>();\n    TimeRange range = new TimeRange();\n    range.setStart(start);\n    range.setEnd(end);\n    timeRanges.add(range);\n    return timeRanges;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRangeList = new ArrayList<TimeRange>();\n\tlong timeStart = start;\n\tlong timeEnd = end;\n\tif(timeStart > timeEnd){\n\t\ttimeStart = timeEnd - FETCH_DATA_DURATION;\n\t}\n\tlong timeRangeEnd = timeStart + FETCH_DATA_DURATION;\n\ttimeRangeList.add(new TimeRange(timeStart,timeRangeEnd));\n\treturn timeRangeList;\n}", "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(start < FETCH_DATA_DURATION){\n\t\ttimeRanges.add(new TimeRange(start,end));\n\t}\n\treturn timeRanges;\n}"]}
{"_id": "636767de1a6d9265ec01871c", "generate_results": ["public void valueAccumulation(String key,Long value){\n\tvalue.add(value);\n}", "public void valueAccumulation(String key,Long value){\n\tif(this.isKey(key)){\n\t\tthis.values[key] = value;\n\t\treturn;\n\t}\n\t\n\tthis.values[key] = value;\n}", "public void valueAccumulation(String key,Long value){\n\t\n\tif(isEmpty(key)){\n\t\t\n\t\tSystem.out.println(\"The key is empty\");\n\t\t\n\t\treturn;\n\t\t\n\t}\n\t\n\t//System.out.println(\"The key is \" + key);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\tif(value==null){\n\t\t\n\t\tSystem.out.println(\"The value is null\");\n\t\t\n\t\treturn;\n\t\t\n\t}\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\tif(value<0){\n\t\t\n\t\tSystem.out.println(\"The value is negative\");\n\t\t\n\t\treturn;\n\t\t\n\t}\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\tif(value>=0){\n\t\t\n\t\t//System.out.println(\"The value is \" + value);\n\t\t\n\t\t//System.out.println(\"The value is \" + value);\n\t\t\n\t\tvalue=value*2;\n\t\t\n\t\t//System.out.println(\"The value is \" + value);\n\t\t\n\t\t//System.out.println(\"The value is \" + value);\n\t\t\n\t\t//System.out.println(\"The value is \" + value);\n\t\t\n\t\tif(value<=0){\n\t\t\t\n\t\t\t//System.out.println(\"The value is negative\");\n\t\t\t\n\t\t\treturn;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n\t\n\t//System.out.println(\"The value is \" + value);\n", "public void valueAccumulation(String key,Long value){\n\tif(value == null){\n\t\tthrow new IllegalArgumentException(\"Value cannot be null\");\n\t}\n\tif(value > maxValue){\n\t\tthrow new IllegalArgumentException(\"Value cannot be greater than \" + maxValue);\n\t}\n\toriginalValues.put(key,value);\n}", "public void valueAccumulation(String key,Long value){\n\tif(!map.containsKey(key)){\n\t\tmap.put(key,value);\n\t}\n\telse{\n\t\tmap.put(key, map.get(key)+value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\tif(value==null){\n\t\tvalue=0L;\n\t}\n\tvalues[key]=value;\n}", "public void valueAccumulation(String key,Long value){\n\t// TODO Auto-generated method stub\n\tSystem.out.println(\"valueAccumulation \"+key+\" = \"+value);\n\t//System.out.println(key);\n\t//System.out.println(value);\n//\tif(key.equals(\"a\")){\n//\t\tSystem.out.println(\"a\");\n//\t}\n\telse{\n\t\tSystem.out.println(value);\n\t}\n\t\n}", "public void valueAccumulation(String key,Long value){\n\tkey = key + \".\" + value;\n\toriginalValues.put(key,value);\n}", "public void valueAccumulation(String key,Long value){\n\toriginalValue.put(key, value);\n}", "public void valueAccumulation(String key,Long value){\n\t\tthis.value.put(key,value);\n}"]}
{"_id": "636767dd1a6d9265ec0186de", "generate_results": ["public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\tif(timestamp-lastUpdateTimestamp<expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(timestamp<expiredThreshold){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tlong now = System.currentTimeMillis();\n\treturn now-expiredThreshold < timestamp;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(timestamp<expiredThreshold){\n\t\treturn true;\n\t}\n\t\n\tlong now=System.currentTimeMillis();\n\tif((now-lastUpdateTimestamp)<expiredThreshold){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tboolean isExpired = false;\n\tlong lastUpdateTime = System.currentTimeMillis();\n\t\n\tif(lastUpdateTime < expiredThreshold){\n\t\tisExpired = true;\n\t}\n\t\n\treturn isExpired;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n    long currentTime = System.currentTimeMillis();\n    long lastUpdateTime = lastUpdateTimestamp;\n    lastUpdateTimestamp = currentTime;\n    if(currentTime - lastUpdateTime > expiredThreshold){\n        return true;\n    }else{\n        return false;\n    }\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\treturn timestamp > expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\tlong lastUpdateTimestamp = this.lastUpdateTimestamp;\n\t\n\t//The timestamp minus the lastUpdateTimestamp is greater than expiredThreshold\n\tif(timestamp - lastUpdateTimestamp > expiredThreshold){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\treturn this.lastUpdateTimestamp <= timestamp && timestamp <= this.lastUpdateTimestamp + expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\tif( lastUpdateTimestamp<timestamp){\n\t\treturn true;\n\t}\n\telse if(lastUpdateTimestamp<timestamp-expiredThreshold){\n\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n}"]}
{"_id": "636767e01a6d9265ec018755", "generate_results": ["Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n    Map<String,Object> result = new HashMap<String,Object>();\n    \n    if (jsonObject.has(\"content\")) {\n        result.put(\"content\", jsonObject.get(\"content\"));\n    }\n    \n    return result;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\t//Set the content as a string.\n\tcontent.put(\"content\",jsonObject.get(\"content\").getAsString());\n\t//Set the content as a date.\n\tcontent.put(\"createTime\",jsonObject.get(\"createTime\").getAsString());\n\t//Set the content as a date.\n\tcontent.put(\"updateTime\",jsonObject.get(\"updateTime\").getAsString());\n\t\n\treturn content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<>();\n\tfor (Map.Entry<String,JsonElement> entry : jsonObject.entrySet()){\n\t\tcontent.put(entry.getKey(), entry.getValue().getAsJsonObject());\n\t}\n\treturn content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tcontent.put(\"content\", jsonObject.get(\"content\").toString());\n\t\n\treturn content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n    Map<String, Object> content = new HashMap<String,Object>();\n    if (jsonObject.has(\"content\")){\n        content.put(\"content\", jsonObject.get(\"content\"));\n    }\n    return content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n    //create a new map for the content\n    Map<String,Object> content=new HashMap<String,Object>();\n    //build the content from the json object\n    for(String name:jsonObject.keySet()){\n        Object contentObject = jsonObject.get(name);\n        Object value = contentObject;\n        if(contentObject!=null){\n            if(contentObject instanceof String){\n                content.put(name, value);\n            }\n            else if(contentObject instanceof JsonObject){\n                JsonObject contentJSON = (JsonObject)contentObject;\n                //add the content to the map\n                if(contentJSON.has(\"content\")){\n                    content.putAll(buildContent(contentJSON.get(\"content\")));\n                }\n            }\n        }\n    }\n    return content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tcontent.put(\"content\", jsonObject.get(\"content\").getAsString());\n\treturn content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n    Map<String,Object> content = new HashMap<>();\n    try {\n        if(jsonObject.has(\"content\")){\n            content.putAll(jsonObject.get(\"content\"));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tif (jsonObject.has(\"content\")) {\n\t\tcontent.put(\"content\", jsonObject.get(\"content\").toString());\n\t}\n\t\n\treturn content;\n}", "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n    Map<String,Object> content = new HashMap<String,Object>();\n    content.put(\"content\", jsonObject.get(\"content\"));\n    return content;\n}"]}
{"_id": "636767de1a6d9265ec01871e", "generate_results": ["Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n        throw new IllegalStateException(\"The model name cannot be null.\");\n    }\n    if (modelName.isEmpty()) {\n        throw new IllegalStateException(\"The model name cannot be an empty string.\");\n    }\n}", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n      throw new IllegalStateException(\"modelName must not be null\");\n    }\n  }", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    String[] keys = modelName.split(\"\\\\.\");\n    // Check whether the key contains a null.\n    for (int i = 0; i < keys.length; i++) {\n        if (keys[i] == null) {\n            throw new IllegalStateException(\"Can't have a null key\");\n        }\n    }\n}", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n      throw new IllegalStateException(\"modelName is null\");\n    }\n  }", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n        if (modelName == null)\n            throw new IllegalStateException(\"The model name cannot be null.\");\n    }", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if(modelName.length()==0)\n        throw new IllegalStateException(\"Model name should not be empty.\");\n}", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n      throw new IllegalStateException(\"Model name cannot be null\");\n    }\n  }", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (StringUtils.isBlank(modelName)) {\n        throw new IllegalStateException(\n                \"Model name must not be empty.\");\n    }\n    if (modelName.length() > ModelNameUtils.MAX_MODEL_NAME_LENGTH) {\n        throw new IllegalStateException(\n                \"Model name must not exceed the maximum length of [\"\n                        + ModelNameUtils.MAX_MODEL_NAME_LENGTH + \"].\");\n    }\n}", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name cannot be null\");\n    }\n}", "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n      throw new IllegalStateException(\"Model name is null\");\n    }\n    if (modelName.isEmpty()) {\n      throw new IllegalStateException(\"Model name is empty\");\n    }\n  }"]}
{"_id": "636767dd1a6d9265ec0186f3", "generate_results": ["public void overrideName(String oldName,String newName){\n\tcolumn.setColumnName(newName);\n\toldName = oldName.toUpperCase();\n\tfor(int i=0;i<columns.size();i++){\n\t\tif(columns.get(i).getColumnName().equalsIgnoreCase(oldName)){\n\t\t\tcolumns.get(i).setColumnName(newName);\n\t\t}\n\t}\n\tfor(int i=0;i<rows.size();i++){\n\t\trows.get(i).setValue(newName);\n\t}\n}", "public void overrideName(String oldName,String newName){\n\tfor (int i=0;i<getChildren().size();i++){\n\t\tgetChildren().get(i).setName(oldName);\n\t}\n\tfireTableCellUpdated( getChildren().size()-1, 0 );\n}", "public void overrideName(String oldName,String newName){\n\tfor(int i=0;i<columns.size();i++){\n\t\tif(oldName.equals(columns.get(i).getName())){\n\t\t\tcolumns.get(i).setName(newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n    this.oldName=oldName;\n    this.newName=newName;\n}", "public void overrideName(String oldName,String newName){\n\tthis.getRow(index).setCell(oldName, newName);\n}", "public void overrideName(String oldName,String newName){\n\tfor (int i = 0; i < this.columns; i++) {\n\t\tthis.elements[i].setText(oldName);\n\t\tthis.elements[i].setText(newName);\n\t}\n}", "public void overrideName(String oldName,String newName){\n\tfor (String oldName : oldNames){\n\t\tif(oldName.equals(oldName)){\n\t\t\toldNames.remove(oldName);\n\t\t}\n\t}\n\toldNames.add(oldName);\n\t\n\t\n\t\n\t\n}", "public void overrideName(String oldName,String newName){\n    for(String column:columns){\n        if(oldName.equals(column)){\n            columns.set(Integer.parseInt(newName)-1,newName);\n        }\n    }\n    fireTableRowsUpdated(0,cols.size()-1);\n}", "public void overrideName(String oldName,String newName){\n\tfor (int i = 0; i < m_elements.size(); i++) {\n\t\tif (m_elements.get(i).getName().equals(oldName)) {\n\t\t\tm_elements.get(i).setName(newName);\n\t\t\treturn;\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n            if(oldName.equalsIgnoreCase(oldName)){\n                    oldName = newName;\n            }\n            table.getRow(0).set(0,oldName);\n            table.getRow(1).set(0,newName);\n}"]}
{"_id": "636767e11a6d9265ec018795", "generate_results": ["public boolean isCompatible(DataTable dataset){\n    if (dataset.getNames().length == 0) return true;\n    return Arrays.deepEquals(dataset.getNames(), this.getNames());\n}", "public boolean isCompatible(DataTable dataset){\n    DataTable.DataColumnList columns = dataset.getColumns();\n    DataTable.DataColumn column = columns.get(0);\n    DataTable.DataColumn otherColumn = columns.get(1);\n    byte[] otherData = otherColumn.getData();\n    byte[] currentData = column.getData();\n    return Arrays.equals(currentData, otherData);\n}", "public boolean isCompatible(DataTable dataset){\n\t\n\t//If there is no dataset, return false\n\tif(dataset==null) return false;\n\t\n\t//If the dataset is not a table, return false\n\tif(dataset.getType()!=Table.class) return false;\n\t\n\t//If there is no data in the table, return false\n\tif(!dataset.hasData()) return false;\n\t\n\t//Check the size of the table\n\tint tableSize=dataset.getSize();\n\t\n\t//If the table is empty, return false\n\tif(tableSize==0) return false;\n\t\n\t//If the table is not compatible, return false\n\tif(!table.isCompatible(dataset)) return false;\n\t\n\t\n\t//Get the size of the table\n\tint tableSize2=table.getSize();\n\t\n\t//If the table is empty, return false\n\tif(tableSize2==0) return false;\n\t\n\t//If the table is not compatible, return false\n\tif(!table.isCompatible(dataset)) return false;\n\t\n\t//If the table is the same size as the dataset, return true\n\tif(tableSize==tableSize2) return true;\n\t\n\t//If the table is not the same size, return false\n\treturn false;\n}", "public boolean isCompatible(DataTable dataset){\n    int minBucket = 100;\n    int maxBucket = -1;\n    int numBuckets = dataset.getBucketCount();\n    int numDataBuckets = dataset.getNumDataBuckets();\n    for (int i = 0; i < numBuckets; i++){\n        if (i <= numDataBuckets){\n            int bucket = dataset.getBucket(i);\n            if (bucket < minBucket || bucket > maxBucket){\n                return false;\n            }\n        }\n    }\n    return true;\n}", "public boolean isCompatible(DataTable dataset){\n    long[] existingBuckets = dataset.getBuckets();\n    long[] newBuckets = new long[existingBuckets.length];\n    boolean compatible = true;\n    for(int i = 0; i < existingBuckets.length; i++){\n        newBuckets[i] = existingBuckets[i];\n    }\n    for(int i = 0; i < newBuckets.length; i++){\n        if(newBuckets[i]!= existingBuckets[i]){\n            compatible = false;\n            break;\n        }\n    }\n    return compatible;\n}", "public boolean isCompatible(DataTable dataset){\n\t\n\t// get the bucket sizes\n\tBucket[] buckets = dataset.getBuckets();\n\t\n\t// check if buckets are the same\n\tif(buckets.length!= dataset.getBucketSize()){\n\t\treturn false;\n\t}\n\t\n\t// check if the buckets are the same\n\tfor(int i = 0; i < buckets.length; i++){\n\t\tif(buckets[i].getMin()!= buckets[i].getMax()){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// check if the buckets are the same\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\t\n\tboolean isCompatible = true;\n\tif(dataset.getNumRows()!= dataset.getNumColumns()){\n\t\tthrow new IllegalArgumentException(\"Not compatible: dataset.getNumRows()!= dataset.getNumColumns()\");\n\t}\n\t\n\tfor(int row=0; row<dataset.getNumRows(); row++){\n\t\tfor(int col=0; col<dataset.getNumColumns(); col++){\n\t\t\tif(dataset.getElement(row,col)==null){\n\t\t\t\tisCompatible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn isCompatible;\n}", "public boolean isCompatible(DataTable dataset){\n\t// Get the data table\n\tDataTable dataTable = dataset;\n\tif(dataTable == null) return false;\n\t// Get the number of buckets\n\tint nbBuckets = dataTable.getNumberOfBuckets();\n\t// Get the number of buckets\n\tint nbBuckets2 = 0;\n\tfor(int i = 0; i < nbBuckets; i++){\n\t\tif(dataTable.isBucket(i)){\n\t\t\tnbBuckets2++;\n\t\t}\n\t}\n\t// Compare the two buckets\n\treturn nbBuckets == nbBuckets2;\n}", "public boolean isCompatible(DataTable dataset){\n\tif(dataset.getNumRows()!= dataset.getNumColumns()){\n\t\treturn false;\n\t}\n\t\n\t//Check whether the rows of the dataset are the same.\n\tfor(int i = 0; i < dataset.getNumRows(); i++){\n\t\tif(! dataset.getRow(i).equals(dataset.getRow(i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//Check whether the columns of the dataset are the same.\n\tfor(int i = 0; i < dataset.getNumColumns(); i++){\n\t\tif(! dataset.getColumn(i).equals(dataset.getColumn(i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//Check whether the rows and columns of the dataset are the same.\n\tfor(int i = 0; i < dataset.getNumRows(); i++){\n\t\tfor(int j = 0; j < dataset.getNumColumns(); j++){\n\t\t\tif(! dataset.getRow(i).equals(dataset.getColumn(j))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\tfor(int i = 0; i < dataset.getNumRows(); i++){\n\t\tfor(int j = 0; j < dataset.getNumColumns(); j++){\n\t\t\tif(dataset.isMissingValue(i, j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}"]}
{"_id": "636767de1a6d9265ec018706", "generate_results": ["public Mappings diffStructure(String tableName,Mappings mappings){\n\tif(mappings==null){\n\t\tthrow new IllegalArgumentException(\"Input mappings cannot be null.\");\n\t}\n\tMappings newMappings=new Mappings();\n\tnewMappings.add(tableName,mappings.get(tableName));\n\treturn newMappings;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings result = new Mappings();\n\t\n\tString stmt=\"SELECT * FROM \"+tableName;\n\tConnection conn = null;\n\ttry {\n\t\tconn = getConnection();\n\t\tStatement stmt = conn.createStatement();\n\t\tResultSet rs = stmt.executeQuery(stmt);\n\t\t\n\t\twhile(rs.next()){\n\t\t\tString[] fields = rs.getString(1).split(\"\\\\|\");\n\t\t\t\n\t\t\tfor(int i=0;i<fields.length;i++){\n\t\t\t\tString field = fields[i].trim();\n\t\t\t\t\n\t\t\t\tif(!mappings.containsKey(field)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMapping m =  mappings.get(field);\n\t\t\t\tif(m.getType().equals(\"d\")){\n\t\t\t\t\tm.setType(\"n\");\n\t\t\t\t}\n\t\t\t\tresult.add(m);\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t\treturn null;\n\t}finally{\n\t\ttry {\n\t\t\tif(conn!=null)\n\t\t\t\tconn.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\treturn result;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings m = new Mappings();\n\tfor (String field:mappings.getFields()){\n\t\tif (!mappings.hasField(field)){\n\t\t\tm.add(field,new HistoryFieldMapping(tableName,field));\n\t\t}\n\t}\n\treturn m;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings m = new Mappings();\n\tList<FieldMapping> mFields = mappings.getFields();\n\t\n\tList<String> fieldNames = new ArrayList<String>();\n\tfor(FieldMapping fieldMapping: mFields){\n\t\tfieldNames.add(fieldMapping.getField());\n\t}\n\t\n\tfor(int i=0;i<fieldNames.size();i++){\n\t\tif (m.contains(tableName,fieldNames.get(i))){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (fieldNames.get(i)==null){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tString fieldName = fieldNames.get(i);\n\t\tif (m.contains(tableName,fieldName)){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (fieldName.equalsIgnoreCase(\"_id\")){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tm.addField(fieldName, fieldMapping.getField());\n\t}\n\t\n\treturn m;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings newMapping = new Mappings();\n\tfor (int i = 0; i < mappings.size(); i++) {\n\t\tMapping m = mappings.get(i);\n\t\tString[] fields = m.getFields();\n\t\tfor (int j = 0; j < fields.length; j++) {\n\t\t\tint found = tableName.indexOf(fields[j]);\n\t\t\tif (found == -1) {\n\t\t\t\tnewMapping.add(m.getFields()[j], m.getValue());\n\t\t\t} else if (found > 0) {\n\t\t\t\tnewMapping.add(fields[j], m.getValue());\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn newMapping;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n        Mappings m = new Mappings();\n        for(Entry<String,Mapping> entry:mappings.entrySet()){\n            Mapping m1 = entry.getValue();\n            Mapping m2 = m1.diff(tableName,m);\n            m.add(entry.getKey(),m2);\n        }\n        return m;\n    }", "public Mappings diffStructure(String tableName,Mappings mappings){\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings diffMappings = new Mappings();\n\tint index = 0;\n\t\n\t//add the input mapping\n\tfor(Mapping m: mappings.getInputMappings()){\n\t\tif(m.field() == null){\n\t\t\t//if the field is null then the mapping is added to the current index\n\t\t\tdiffMappings.add(index, m);\n\t\t}else{\n\t\t\t//the field is not null, so the mapping is not added to the current index\n\t\t\tdiffMappings.add(index, new Mapping(index, m.field()));\n\t\t}\n\t\tindex++;\n\t}\n\t\n\t//add the mapping that is not present in the input mappings\n\tfor(Mapping m: mappings.getMapping()){\n\t\tif(m.field() == null){\n\t\t\t//if the field is null then the mapping is added to the current index\n\t\t\tdiffMappings.add(index, m);\n\t\t}else{\n\t\t\t//the field is not null, so the mapping is not added to the current index\n\t\t\tdiffMappings.add(index, new Mapping(index, m.field()));\n\t\t}\n\t\tindex++;\n\t}\n\t\n\treturn diffMappings;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n//\treturn mappings.diffStructure(tableName,inputMappings.getField(\"doc_id\"),inputMappings.getField(\"doc_id\"));\t\n//}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings map = new Mappings();\n\tfor(String field : mappings.getFields()){\n\t\tfor(String fieldName : mappings.getFieldNames(field)){\n\t\t\tif(!map.containsKey(fieldName)){\n\t\t\t\tmap.put(fieldName, mappings.get(field));\n\t\t\t}\n\t\t}\n\t}\n\treturn map;\n}"]}
{"_id": "636767dc1a6d9265ec0186be", "generate_results": ["Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tif (timeBucket == 0)\n\t\treturn 0;\n\tif (timeBucket == 1)\n\t\treturn 1;\n\treturn timeBucket;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tif(dayStep==11){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==12){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==13){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==14){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==15){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==16){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==17){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==18){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==19){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==20){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==21){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==22){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==23){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==24){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==25){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==26){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==27){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==28){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==29){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==30){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==31){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==32){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==33){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==34){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==35){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==36){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==37){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==38){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==39){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==40){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==41){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==42){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==43){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==44){\n\t\treturn (timeBucket+20000101L)*1000L;\n\t}else if(dayStep==45){\n\t\treturn (timeBucket+", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    int count=0;\n    long value=timeBucket;\n    if(timeBucket==0){\n        return value;\n    }\n    while(timeBucket>0){\n        value+=dayStep;\n        count++;\n        timeBucket=timeBucket/dayStep;\n    }\n    return value;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    return timeBucket;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    long timeBucketFormatted = timeBucket;\n    int timeBucketLength = (int) (timeBucket * (24 * 3600 * 1000));\n    int index = 0;\n    while(index < timeBucketLength){\n        if(timeBucket == timeBucketFormatted){\n            return timeBucketFormatted;\n        }\n        else if(index < 11){\n            timeBucketFormatted = timeBucketFormatted + (dayStep * (24 * 3600 * 1000));\n        }\n        else if(index == 11){\n            timeBucketFormatted = timeBucketFormatted + (dayStep * (24 * 3600 * 1000));\n        }\n        else{\n            timeBucketFormatted = timeBucketFormatted + (dayStep * (24 * 3600 * 1000));\n        }\n        index++;\n    }\n    return -1;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    \n    if(timeBucket == 0){\n        return 0;\n    }\n\n    long ret = 0;\n    long firstTime = timeBucket / dayStep;\n    long lastTime = firstTime + dayStep;\n    \n    if(firstTime == 0){\n        return 0;\n    }\n    \n    ret = firstTime;\n    while(firstTime < lastTime){\n        ret = ret + compressTimeBucket(ret, dayStep);\n        firstTime++;\n    }\n\n    return ret;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    long timeBucketCompressed = 0;\n    int i=0;\n    while(i<timeBucket.length()){\n        if(timeBucket[i]==0){\n            timeBucketCompressed = timeBucketCompressed + (i+dayStep);\n            i++;\n        }else{\n            timeBucketCompressed = timeBucketCompressed + (i+dayStep);\n            i++;\n        }\n    }\n    return timeBucketCompressed;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\t\n\tlong timeBucketWithoutTime = timeBucket;\n\t\n\tif(timeBucket < 0){\n\t\ttimeBucketWithoutTime = -timeBucket;\n\t}\n\t\n\tlong timeBucketWithTime = timeBucket;\n\t\n\tif(dayStep == 0){\n\t\ttimeBucketWithTime = 0;\n\t}else if(dayStep == 1){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 2);\n\t}else if(dayStep == 2){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 3);\n\t}else if(dayStep == 3){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 4);\n\t}else if(dayStep == 4){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 5);\n\t}else if(dayStep == 5){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 6);\n\t}else if(dayStep == 6){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 7);\n\t}else if(dayStep == 7){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 8);\n\t}else if(dayStep == 8){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 9);\n\t}else if(dayStep == 9){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 10);\n\t}else if(dayStep == 10){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 11);\n\t}else if(dayStep == 11){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 12);\n\t}else if(dayStep == 12){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 13);\n\t}else if(dayStep == 13){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 14);\n\t}else if(dayStep == 14){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 15);\n\t}else if(dayStep == 15){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 16);\n\t}else if(dayStep == 16){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 17);\n\t}else if(dayStep == 17){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 18);\n\t}else if(dayStep == 18){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 19);\n\t}else if(dayStep == 19){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 20);\n\t}else if(dayStep == 20){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 21);\n\t}else if(dayStep == 21){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 22);\n\t}else if(dayStep == 22){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 23);\n\t}else if(dayStep == 23){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 24);\n\t}else if(dayStep == 24){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 25);\n\t}else if(dayStep == 25){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 26);\n\t}else if(dayStep == 26){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 27);\n\t}else if(dayStep == 27){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 28);\n\t}else if(dayStep == 28){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 29);\n\t}else if(dayStep == 29){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 30);\n\t}else if(dayStep == 30){\n\t\ttimeBucketWithTime = (timeBucketWithoutTime / 31);\n\t}else if(dayStep == 31){\n\t\ttimeBucket", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    return timeBucket;\n}", "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\ttimeBucket=timeBucket-(timeBucket%(dayStep+1));\n\treturn timeBucket;\n}"]}
{"_id": "636767dc1a6d9265ec0186c6", "generate_results": ["Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n    for(Field field : fields.getFields()){\n        if(!field.isRequired() &&!field.isAuto() &&!field.isEnum()){\n            return false;\n        }\n    }\n    return true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor (Field field : fields.fields){\n\t\tif (field.type!= \"number\" && field.type!= \"string\" && field.type!= \"date\") continue;\n\t\tif (field.name == \"value\") continue;\n\t\tif (field.name == \"source\") continue;\n\t\tif (field.name == \"source_name\") continue;\n\t\tif (field.name == \"source_url\") continue;\n\t\treturn false;\n\t}\n\treturn true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n    for (Field field : fields.getFields()) {\n        if (field.getName().equals(\"name\")) {\n            return false;\n        }\n    }\n    return true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getFields()){\n\t\tif(field.getName().equals(\"url\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'url' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"username\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'username' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"password\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'password' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"name\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'name' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"createdAt\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'createdAt' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"updatedAt\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'updatedAt' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"createdBy\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'createdBy' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"updatedBy\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'updatedBy' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"user\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'user' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"groups\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'groups' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"createdBy\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'createdBy' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"updatedBy\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'updatedBy' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"id\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'id' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"user\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'user' is required in the property\");\n\t\t\t}\n\t\t}else if(field.getName().equals(\"groups\")){\n\t\t\tif(field.getValue() == null || field.getValue().trim().length() == 0){\n\t\t\t\tthrow new IllegalArgumentException(\"Field 'groups' is required in the property\");\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getFields()){\n\t\tif(!field.isRequired()){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n    for (Field field : fields.getFields()) {\n        if (field.getName().equals(this.getName())) {\n            return true;\n        }\n    }\n    return false;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor (Field field : fields.values()) {\n\t\tif (field.getName().startsWith(\"_\")) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.values()){\n\t\tif(field.isArray())\n\t\t\treturn false;\n\t\tif(field.isPrimitive())\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tboolean contains = false;\n\tfor(Field field:fields){\n\t\tif(field.getName().equals(\"ID\")){\n\t\t\tcontains = true;\n\t\t}\n\t}\n\treturn contains;\n}", "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getAllFields()){\n\t\tif(field.getName().equals(\"name\")){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"]}
{"_id": "636767dd1a6d9265ec0186e5", "generate_results": ["public void addNewTarget(Channels channels,IConsumer consumer){\n\tconsumers.add(consumer);\n\tconsumers.addAll(channels.getConsumers());\n\t\n\tif(consumers.size() > maxConsumers){\n\t\tmaxConsumers = consumers.size();\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tif(channels == null)\n\t\tthrow new IllegalArgumentException(\"The argument 'channels' must not be null\");\n\tif(consumer == null)\n\t\tthrow new IllegalArgumentException(\"The argument 'consumer' must not be null\");\n\t\n\tif(!containsChannel(channels.getId())){\n\t\taddChannel(channels);\n\t}\n\t\n\tconsumer.consume(channels, new ArrayList<>(channels.getTargetChannel()), false);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\t\n\tif(consumer.getSourceTargets()==null || consumer.getSourceTargets().size()<1)\n\t\treturn;\n\t\n\tfor(int i=0;i<consumer.getSourceTargets().size();i++){\n\t\t\n\t\tif(consumer.getSourceTargets().get(i) instanceof Channel)\n\t\t\taddNewTarget((Channel)consumer.getSourceTargets().get(i),channels);\n\t\telse\n\t\t\tSystem.err.println(\"Error: Unsupported channel type\");\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tboolean isStart = false;\n\tfor (int i=0;i<channels.length;i++){\n\t\tif (channels[i]==target){\n\t\t\tisStart = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!isStart){\n\t\tchannels.add(target);\n\t\treturn;\n\t}\n\t\n\tfor (int i=0;i<channels.length;i++){\n\t\tif (channels[i]==consumer){\n\t\t\tchannels.remove(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tchannels.add(target);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n    for (Channels target : consumer.getConsumeTargets()){\n        channels.addTarget(target);\n    }\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tconsumers.add(consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tconsumers.get(consumers.size()).add(channels);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tfor(int i=0; i<channels.size(); i++){\n\t\tconsumers.add(i,consumer);\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tthis.consumers.add(consumer);\n\tthis.consumers.add(channels);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tconsumeTargets.add(new Target(channels,consumer));\n}"]}
{"_id": "636767dc1a6d9265ec0186cb", "generate_results": ["public void init(){\n    new File(\".\").mkdir();\n}", "public void initComplete(boolean create){\n    if(create){\n        init();\n    }\n}", "public void init(){\n\tif (this.isDirectory()) {\n\t\tSystem.out.println(\"Directory already exists. Skipping initialization...\");\n\t\treturn;\n\t}\n\t\n\ttry {\n\t\tString homeDir = System.getProperty(\"user.home\");\n\t\tFile homeDirFile = new File(homeDir);\n\t\t\n\t\tString path = homeDirFile.getAbsolutePath() + File.separator + \"Pom.xml\";\n\t\tFile dir = new File(path);\n\t\tif (!dir.exists()) {\n\t\t\tdir.mkdir();\n\t\t}\n\n\t\tFile pomFile = new File(path);\n\t\tDocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n\t\tDocument doc = docBuilder.parse(pomFile);\n\n\t\tElement rootElement = doc.getDocumentElement();\n\t\t\n\t\tif (!rootElement.getNodeName().equals(\"pom\")) {\n\t\t\tthrow new MojoExecutionException(\"Expected POM XML file, not \\\"\" + rootElement.getNodeName() + \"\\\"\");\n\t\t}\n\t\t\n\t\tElement pom = (Element) rootElement.getElementsByTagName(\"pom\").item(0);\n\t\tString version = pom.getAttribute(\"version\");\n\t\tString encoding = pom.getAttribute(\"encoding\");\n\t\tString author = pom.getAttribute(\"author\");\n\t\tString authorEmail = pom.getAttribute(\"email\");\n\t\tString description = pom.getAttribute(\"description\");\n\t\tString groupId = pom.getAttribute(\"groupId\");\n\t\tString artifactId = pom.getAttribute(\"artifactId\");\n\t\tString packaging = pom.getAttribute(\"packaging\");\n\t\t\n\t\tString classifier = pom.getAttribute(\"classifier\");\n\t\t\n\t\t//System.out.println(\"POM XML file is: \" + path);\n\t\t\n\t\tif (version == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no version attribute\");\n\t\t}\n\t\tif (author == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no author attribute\");\n\t\t}\n\t\tif (classifier == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no classifier attribute\");\n\t\t}\n\t\tif (authorEmail == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no authorEmail attribute\");\n\t\t}\n\t\tif (description == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no description attribute\");\n\t\t}\n\t\tif (groupId == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no groupId attribute\");\n\t\t}\n\t\tif (artifactId == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no artifactId attribute\");\n\t\t}\n\t\tif (packaging == null) {\n\t\t\tthrow new IllegalStateException(\"POM XML file has no packaging attribute\");\n\t\t}\n\t\t\n\t\tthis.setDate(new Date());\n\t\tthis.setAuthor(author);\n\t\tthis.setDescription(description);\n\t\tthis.setEncoding(encoding);\n\t\tthis.setHome(homeDir);\n\t\tthis.setGroupId(groupId);\n\t\tthis.setArtifactId(artifactId);\n\t\tthis.setPackaging(packaging);\n\t\tthis.setVersion(version);\n\t\tthis.setClassifier(classifier);\n\t\tthis.setAuthorEmail(authorEmail);\n\t} catch (Exception e) {\n\t\tthrow new MojoExecutionException(\"Failed to initialize POM XML file\", e);\n\t}\n}", "public void init(){\n    m_dir = new File(m_config.getString(Config.KM_DIR));\n    if(!m_dir.exists()){\n        m_dir.mkdir();\n    }\n}", "public void init(){\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TODO: Use a config file\n    // TOD", "public void init(){\n\ttry {\n\t\tlog.info(\"Initializing directory: \"+directory);\n\t\t//create the directory if necessary\n\t\tcreateDirectory(directory);\n\t\t\n\t\t//create the folder if necessary\n\t\tif(!folder.exists()){\n\t\t\tcreateFolder(folder);\n\t\t}\n\t}\n\tcatch(Exception e){\n\t\tlog.error(\"Error while creating directory: \"+directory,e);\n\t}\n}", "public void init(){\n\tif (this.factory.isDirectory(this.directory)) {\n\t\tthis.factory.mkdir(this.directory);\n\t}\n\tFile f = new File(this.directory);\n\tif (f.exists() &&!f.isDirectory())\n\t\tthrow new RuntimeException(\"directory \" + f.getAbsolutePath() + \" exists but is not a directory.\");\n\t\n\tif (this.factory.isDirectory(this.directory)) {\n\t\tthrow new RuntimeException(\"directory \" + this.directory.getAbsolutePath() + \" can not be created.\");\n\t}\n\t\n\tf.mkdirs();\n\tthis.directory = f.getAbsolutePath();\n}", "public void initEventBus(){\n    //Initializes the event bus for this thread\n    eventBus.init();\n}", "public void init(){\n\ttry {\n\t\tString path = getClass().getResource(\"/\").getPath();\n\t\tFile directory = new File(path);\n\t\tdirectory.mkdirs();\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n}", "public void init(){\n\t//Get the current directory.\n\tString currentDir = System.getProperty(\"user.dir\");\n\t//If the directory already exists, it must be a directory.\n\tif(currentDir.lastIndexOf(\"/\") == currentDir.lastIndexOf(\"\\\\\")) {\n\t\t//If the directory name is the same, it must be a directory.\n\t\treturn;\n\t}\n\t//If there is no directory name, it is a directory.\n\t//In that case, the current directory must be a directory.\n\telse {\n\t\t//If the current directory is a directory, it must be a directory.\n\t\treturn;\n\t}\n\t\n\t//Create a directory that will be the current directory.\n\tFile directory = new File(\".\");\n\t//If the directory already exists, it must be a directory.\n\tif(directory.exists()){\n\t\t//If the directory name is the same, it must be a directory.\n\t\treturn;\n\t}\n\t//If there is no directory name, it is a directory.\n\t//In that case, the current directory must be a directory.\n\telse {\n\t\t//If the current directory is a directory, it must be a directory.\n\t\treturn;\n\t}\n\t\n\t//If the directory already exists, it must be a directory.\n\t//In that case, the current directory must be a directory.\n\tif(directory.mkdirs()){\n\t\t//If the directory name is the same, it must be a directory.\n\t\treturn;\n\t}\n\t\n\t//If the directory name is different, it must be a directory.\n\t//In that case, the current directory must be a directory.\n\telse {\n\t\t//If the directory name is different, it must be a directory.\n\t\treturn;\n\t}\n}"]}
{"_id": "636767de1a6d9265ec018726", "generate_results": ["public List<SequenceRange> buildSequenceRanges(){\n\t\tList<SequenceRange> result = new ArrayList<SequenceRange>();\n\t\tfor(int i = 0;i<nSequences;i++){\n\t\t\tSequenceRange range = new SequenceRange();\n\t\t\trange.setLowerBound(minSequence);\n\t\t\trange.setUpperBound(maxSequence);\n\t\t\tresult.add(range);\n\t\t}\n\t\treturn result;\n\t}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> list = new ArrayList<SequenceRange>();\n\tint current = 0;\n\tint minSequence = 0;\n\tint maxSequence = 0;\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i ++){\n\t\tlist.add(new SequenceRange(current, current+SEQUENCE_RANGE_BATCH_SIZE, minSequence, maxSequence));\n\t\tcurrent += SEQUENCE_RANGE_BATCH_SIZE;\n\t\tminSequence = 0;\n\t\tmaxSequence = 0;\n\t\tfor(int j = 0; j < SEQUENCE_RANGE_BATCH_SIZE; j ++){\n\t\t\tif(list.size() > 0){\n\t\t\t\tSequenceRange sequenceRange = list.get(j);\n\t\t\t\tif(sequenceRange.getLowerBound() < minSequence){\n\t\t\t\t\tminSequence = sequenceRange.getLowerBound();\n\t\t\t\t}\n\t\t\t\tif(sequenceRange.getUpperBound() > maxSequence){\n\t\t\t\t\tmaxSequence = sequenceRange.getUpperBound();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> result = new ArrayList<SequenceRange>();\n\tfor(int i = 0; i < maxSequence; i++){\n\t\tresult.add(new SequenceRange(minSequence,i));\n\t}\n\treturn result;\n}", "public List<SequenceRange> buildSequenceRanges(){\n  List<SequenceRange> ret = new ArrayList<SequenceRange>();\n  ret.add(new SequenceRange(MIN_SEQUENCE, MAX_SEQUENCE, 0, sequenceRangeBatchSize));\n  return ret;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> sequences = new ArrayList<SequenceRange>();\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i++){\n\t\tSequenceRange sequence = new SequenceRange();\n\t\tsequence.start = i*SEQUENCE_RANGE_BATCH_SIZE;\n\t\tsequence.end = i*SEQUENCE_RANGE_BATCH_SIZE + SEQUENCE_RANGE_BATCH_SIZE;\n\t\tsequences.add(sequence);\n\t}\n\treturn sequences;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> seqRanges = new ArrayList<SequenceRange>();\n\t\n\tint lowerBound = maxSequence;\n\tint upperBound = minSequence;\n\t\n\tfor(int i = 0;i < minSequence;i++){\n\t\tseqRanges.add(new SequenceRange(i, i+1, lowerBound, upperBound));\n\t\tlowerBound = i+1;\n\t\tupperBound = i+2;\n\t}\n\t\n\treturn seqRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> result = new ArrayList<SequenceRange>();\n\tresult.add(new SequenceRange(1,0,2));\n\tresult.add(new SequenceRange(3,5,10));\n\tresult.add(new SequenceRange(0,5,10));\n\tresult.add(new SequenceRange(5,10,20));\n\tresult.add(new SequenceRange(10,20,25));\n\tresult.add(new SequenceRange(0,10,25));\n\treturn result;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\tint i = 0;\n\tfor (int j = 0; j < SEQUENCE_RANGE_BATCH_SIZE; j++) {\n\t\t\n\t\tsequenceRanges.add(new SequenceRange(i, i));\n\t\ti++;\n\t}\n\t\n\tfor (int j = 0; j < SEQUENCE_RANGE_BATCH_SIZE; j++) {\n\t\tsequenceRanges.add(new SequenceRange(i, i));\n\t\ti++;\n\t}\n\t\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> list = new ArrayList<SequenceRange>();\n\t\n\tfor (int i = 0; i < maxSequence; i++){\n\t\tfor (int j = 0; j < minSequence; j++){\n\t\t\tif (i == 0 || j == 0){\n\t\t\t\tlist.add(new SequenceRange(i, j, minSequence, maxSequence));\n\t\t\t}else{\n\t\t\t\tlist.add(new SequenceRange(i, j, minSequence, maxSequence));\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> list = new ArrayList<SequenceRange>();\n\t\n\tList<Long> minSequence = new ArrayList<Long>();\n\tList<Long> maxSequence = new ArrayList<Long>();\n\t\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i ++){\n\t\tminSequence.add(0l);\n\t\tmaxSequence.add(0l);\n\t}\n\t\n\tlong lowerBound = SEQUENCE_RANGE_BATCH_SIZE * (SEQUENCE_RANGE_BATCH_SIZE - 1) - 1;\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i ++){\n\t\tif(i < SEQUENCE_RANGE_BATCH_SIZE - 1) {\n\t\t\tif(i!= 0) {\n\t\t\t\tminSequence.add(minSequence.get(i - 1) + 1l);\n\t\t\t\tmaxSequence.add(maxSequence.get(i - 1) + 1l);\n\t\t\t} else {\n\t\t\t\tminSequence.add(minSequence.get(i - 1) + 1l);\n\t\t\t\tmaxSequence.add(maxSequence.get(i - 1) + 1l);\n\t\t\t}\n\t\t} else {\n\t\t\tif(i > 0) {\n\t\t\t\tminSequence.add(minSequence.get(i - 1) + 1l);\n\t\t\t\tmaxSequence.add(maxSequence.get(i - 1) + 1l);\n\t\t\t} else {\n\t\t\t\tminSequence.add(minSequence.get(i - 1) + 1l);\n\t\t\t\tmaxSequence.add(maxSequence.get(i - 1) + 1l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong lowerBoundCount = 0;\n\tlong upperBoundCount = 0;\n\tlong count = 0;\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i ++){\n\t\tif(i < SEQUENCE_RANGE_BATCH_SIZE - 1) {\n\t\t\tif(i!= 0) {\n\t\t\t\tlowerBoundCount = lowerBoundCount + 1l;\n\t\t\t\tupperBoundCount = upperBoundCount + 1l;\n\t\t\t\tcount = count + 1l;\n\t\t\t} else {\n\t\t\t\tlowerBoundCount = lowerBoundCount + 1l;\n\t\t\t\tupperBoundCount = upperBoundCount + 1l;\n\t\t\t\tcount = count + 1l;\n\t\t\t}\n\t\t} else {\n\t\t\tif(i > 0) {\n\t\t\t\tlowerBoundCount = lowerBoundCount + 1l;\n\t\t\t\tupperBoundCount = upperBoundCount + 1l;\n\t\t\t\tcount = count + 1l;\n\t\t\t} else {\n\t\t\t\tlowerBoundCount = lowerBoundCount + 1l;\n\t\t\t\tupperBoundCount = upperBoundCount + 1l;\n\t\t\t\tcount = count + 1l;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong upperBoundCount2 = 0;\n\tlong lowerBoundCount2 = 0;\n\t\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE - 1; i ++){\n\t\tif(i > 0) {\n\t\t\tlowerBoundCount2 = lowerBoundCount2 + 1l;\n\t\t\tupperBoundCount2 = upperBoundCount2 + 1l;\n\t\t\tcount = count + 1l;\n\t\t} else {\n\t\t\tlowerBoundCount2 = lowerBoundCount2 + 1l;\n\t\t\tupperBoundCount2 = upperBoundCount2 + 1l;\n\t\t\tcount = count + 1l;\n\t\t}\n\t}\n\t\n\t\n\t\n\tminSequence.add(lowerBound);\n\tmaxSequence.add(upperBound);\n\t\n\tfor(int i = 0; i < SEQUENCE_RANGE_BATCH_SIZE; i ++){\n\t\tif(i < SEQUENCE_RANGE_BATCH_SIZE - 1) {\n\t\t\tif(i!= 0) {\n\t\t\t\tlist.add(new SequenceRange(minSequence.get(i - 1), maxSequence.get(i - 1), count, lowerBoundCount, upperBoundCount));\n\t\t\t} else {\n\t\t\t\tlist.add(new SequenceRange"]}
{"_id": "636767e11a6d9265ec018790", "generate_results": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n    List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n    FileInputStream fis = new FileInputStream(file);\n    try {\n      BufferedReader br = new BufferedReader(new InputStreamReader(fis, \"utf8\"));\n      String line;\n      while ((line = br.readLine())!= null) {\n        String[] lineTokens = line.split(\"\\\\|\\\\|\");\n        String threadId = lineTokens[0];\n        String threadName = lineTokens[1];\n        String threadTime = lineTokens[2];\n        String profileId = lineTokens[3];\n        String profileName = lineTokens[4];\n        String profileTime = lineTokens[5];\n        String threadThreadId = lineTokens[6];\n        String threadSnapshotId = lineTokens[7];\n        String threadSnapshot = lineTokens[8];\n        String profileName2 = lineTokens[9];\n        String profileTime2 = lineTokens[10];\n        String profileSnapshotId = lineTokens[11];\n        String threadSnapshotId2 = lineTokens[12];\n        threadSnapshots.add(new ThreadSnapshot(threadId, threadName, threadTime, profileId, profileName, profileTime, threadThreadId, threadSnapshotId, threadSnapshot, profileName2, profileTime2, profileSnapshotId, threadSnapshotId2));\n      }\n    } finally {\n      br.close();\n    }\n    return threadSnapshots;\n  }", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> result = new ArrayList<ThreadSnapshot>();\n\tStringBuffer sb = new StringBuffer();\n\tBufferedReader in = new BufferedReader(new FileReader(file));\n\twhile (in.ready()) {\n\t\tsb.append(in.readLine());\n\t}\n\tin.close();\n\tString[] lines = sb.toString().split(\"\\n\");\n\tfor (int i = 0; i < lines.length; i++) {\n\t\tString line = lines[i];\n\t\tif (line.startsWith(\"#\")) continue;\n\t\tint index = line.indexOf(\"=\");\n\t\tString key = line.substring(0, index);\n\t\tString value = line.substring(index + 1);\n\t\tProfileAnalyzeTimeRange range = parseToTimeRange(key, value);\n\t\tif (range == null) continue;\n\t\tif (range.start > timeRanges.size()) break;\n\t\tresult.add(new ThreadSnapshot(range.start, range.end, range.id));\n\t}\n\treturn result;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tFileInputStream fileInputStream = null;\n\ttry {\n\t\tfileInputStream = new FileInputStream(file);\n\t\tList<ThreadSnapshot> threadSnapshotList = new ArrayList<ThreadSnapshot>();\n\t\t\n\t\tfor (ProfileAnalyzeTimeRange timeRange : timeRanges) {\n\t\t\tString line = FileUtils.readFileToString(fileInputStream);\n\t\t\tString[] splitLine = line.split(\"\\\\|\");\n\t\t\tString group = splitLine[0];\n\t\t\tString threadName = splitLine[1];\n\t\t\t\n\t\t\tString[] splitThreadName = threadName.split(\"\\\\|\");\n\t\t\tString threadNameStart = splitThreadName[0];\n\t\t\tString threadNameEnd = splitThreadName[1];\n\t\t\t\n\t\t\tString[] splitThreadGroup = group.split(\"\\\\|\");\n\t\t\tString threadGroup = splitThreadGroup[0];\n\t\t\t\n\t\t\tString threadStart = splitThreadGroup[1];\n\t\t\tString threadEnd = splitThreadGroup[2];\n\t\t\t\n\t\t\t\n\t\t\tString threadGroupTime = threadGroup + \"|\" + threadStart + \":\" + threadEnd;\n\t\t\t\n\t\t\tString[] splitThreadGroupTime = threadGroupTime.split(\"\\\\|\");\n\t\t\tString threadGroupTimeStart = splitThreadGroupTime[0];\n\t\t\tString threadGroupTimeEnd = splitThreadGroupTime[1];\n\t\t\t\n\t\t\tString threadTime = threadGroupTimeEnd + \"|\" + threadStart + \":\" + threadEnd;\n\t\t\t\n\t\t\tList<ThreadSnapshot> threadSnapshotListTemp = new ArrayList<ThreadSnapshot>();\n\t\t\t\n\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\t\tthreadSnapshot.setGroup(threadGroup);\n\t\t\tthreadSnapshot.setThreadName(threadName);\n\t\t\tthreadSnapshot.setThreadGroupTime(threadGroupTime);\n\t\t\tthreadSnapshot.setThreadStart(threadStart);\n\t\t\tthreadSnapshot.setThreadEnd(threadEnd);\n\t\t\tthreadSnapshot.setThreadTime(threadTime);\n\t\t\tthreadSnapshotListTemp.add(threadSnapshot);\n\t\t\t\n\t\t\tthreadSnapshotList.add(threadSnapshotListTemp);\n\t\t}\n\t\t\n\t\treturn threadSnapshotList;\n\t} finally {\n\t\tif (fileInputStream!= null) {\n\t\t\ttry {\n\t\t\t\tfileInputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> snapshots = new ArrayList<ThreadSnapshot>();\n\tif(file.exists()){\n\t\tBufferedReader reader = new BufferedReader(new FileReader(file));\n\t\tString line;\n\t\twhile((line = reader.readLine())!= null) {\n\t\t\tString[] fields = line.split(\",\");\n\t\t\tString threadId = fields[0].trim();\n\t\t\tint start = Integer.parseInt(fields[1].trim());\n\t\t\tint end = Integer.parseInt(fields[2].trim());\n\t\t\tString snapshotName = fields[3].trim();\n\t\t\t\n\t\t\tProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(threadId,start,end);\n\t\t\tsnapshots.add(timeRange);\n\t\t}\n\t\treader.close();\n\t}\n\treturn snapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tString line = null;\n\tBufferedReader reader = null;\n\ttry {\n\t\treader = new BufferedReader(new FileReader(file));\n\t\twhile ((line = reader.readLine())!= null) {\n\t\t\tif(line.matches(\"^\\\\s*\\\\*\\\\s*$\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] splitLine = line.split(\"\\\\s+\");\n\t\t\tint start = Integer.parseInt(splitLine[0]);\n\t\t\tint end = Integer.parseInt(splitLine[1]);\n\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot(start,end);\n\t\t\tthreadSnapshots.add(threadSnapshot);\n\t\t}\n\t} catch (FileNotFoundException e) {\n\t\te.printStackTrace();\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tif(reader!= null){\n\t\t\ttry {\n\t\t\t\treader.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\treturn threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\t\n\tList<ThreadSnapshot> allThreadSnapshots = new ArrayList<ThreadSnapshot>();\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\t\n\tFileInputStream fis = new FileInputStream(file);\n\tBufferedReader br = new BufferedReader(new InputStreamReader(fis));\n\tString line;\n\twhile ((line = br.readLine())!= null) {\n\t\tString[] tokens = line.split(\"\\\\s+\");\n\t\tString threadName = tokens[0];\n\t\tString threadTime = tokens[1];\n\t\tString threadSnapshot = tokens[2];\n\t\t\n\t\tif (threadSnapshot.endsWith(\";\")) {\n\t\t\tthreadSnapshot = threadSnapshot.substring(0, threadSnapshot.length() - 1);\n\t\t}\n\t\t\n\t\tThreadSnapshot threadSnapshotToParse = new ThreadSnapshot(threadName,threadTime,threadSnapshot);\n\t\t\n\t\tif (threadSnapshotToParse.getTimeRange()!= null) {\n\t\t\tthreadSnapshotToParse.setTimeRange(threadSnapshotToParse.getTimeRange().parseFromFileWithTimeRange(file,timeRanges));\n\t\t}\n\t\t\n\t\tthreadSnapshots.add(threadSnapshotToParse);\n\t\tallThreadSnapshots.add(threadSnapshotToParse);\n\t}\n\t\n\tbr.close();\n\t\n\treturn allThreadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n    List<ThreadSnapshot> threadSnapshots = new ArrayList<>();\n    int start = 0;\n    int end = 0;\n    byte[] header = new byte[10];\n    int numThreads = 0;\n    //check for the header\n    if (file.exists()) {\n        FileInputStream fis = new FileInputStream(file);\n        fis.read(header);\n        fis.close();\n    }\n    //parse the files\n    while (true) {\n        //read the next line\n        int read = fis.read(header);\n        if (read == -1) {\n            break;\n        }\n        //check for the end of the line\n        if (header[0] == '\\n' || header[0] == '\\r') {\n            break;\n        }\n        //check for the end of the file\n        if (header[0] == '\\r' && (header[1] == '\\n' || header[1] == '\\r')) {\n            break;\n        }\n        //check for the end of the file\n        if (header[0] == '\\n' && (header[1] == '\\r' || header[1] == '\\n')) {\n            break;\n        }\n        //check for the end of the file\n        if ((header[0] == '\\r' && header[1] == '\\n') || (header[0] == '\\n' && header[1] == '\\r')) {\n            break;\n        }\n        //check for the end of the file\n        if ((header[0] == '\\r' && header[1] == '\\n') || (header[0] == '\\n' && header[1] == '\\r')) {\n            break;\n        }\n        //parse the next line\n        start = (int) (header[0] - '0');\n        end = (int) (header[1] - '0');\n        int threadId = start * 1000000 + end;\n        //check if the thread id is in the list of thread ids\n        if (timeRanges.contains(new ProfileAnalyzeTimeRange(threadId))) {\n            //add the thread snapshot\n            threadSnapshots.add(new ThreadSnapshot(threadId));\n        }\n        //increment the counter for the number of threads\n        numThreads++;\n    }\n    return threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\t// read the file and return a list of threads\n\tList<ThreadSnapshot> threads = new ArrayList<ThreadSnapshot>();\n\ttry {\n\t\tFileInputStream fis = new FileInputStream(file);\n\t\tBufferedInputStream bis = new BufferedInputStream(fis);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(bis));\n\t\tString line = null;\n\t\twhile ((line = br.readLine())!= null) {\n\t\t\tString[] lineSplits = line.split(\" \");\n\t\t\tif (lineSplits.length < 3) {\n\t\t\t\t// ignore empty lines\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint start = Integer.parseInt(lineSplits[0]);\n\t\t\tint end = Integer.parseInt(lineSplits[1]);\n\t\t\tlong time = Long.parseLong(lineSplits[2]);\n\t\t\tProfileAnalyzeTimeRange t = new ProfileAnalyzeTimeRange(start, end, time);\n\t\t\tif (!timeRanges.contains(t)) {\n\t\t\t\ttimeRanges.add(t);\n\t\t\t\tthreads.add(new ThreadSnapshot(lineSplits[0], lineSplits[1], lineSplits[2], t));\n\t\t\t}\n\t\t}\n\t} catch (FileNotFoundException fnfe) {\n\t\tfnfe.printStackTrace();\n\t} catch (IOException ioe) {\n\t\tioe.printStackTrace();\n\t}\n\treturn threads;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));\n\tString line;\n\twhile((line = reader.readLine())!= null) {\n\t\tString[] fields = line.split(\",\");\n\t\tString start = fields[0].trim();\n\t\tString end = fields[1].trim();\n\t\tProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(start, end);\n\t\tthreadSnapshots.add(parseThreadSnapshot(line,timeRange));\n\t}\n\treturn threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader reader = new BufferedReader(new FileReader(file));\n\tString line;\n\twhile((line = reader.readLine())!= null) {\n\t\tString[] splitLine = line.split(\"\\\\s+\");\n\t\tif(splitLine.length > 1) {\n\t\t\tString threadID = splitLine[0];\n\t\t\tString threadStartTime = splitLine[1];\n\t\t\tString threadEndTime = splitLine[2];\n//\t\t\tString threadSnapshotID = splitLine[4];\n\t\t\t\n\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\t\tthreadSnapshot.setThreadID(threadID);\n\t\t\tthreadSnapshot.setThreadStartTime(threadStartTime);\n\t\t\tthreadSnapshot.setThreadEndTime(threadEndTime);\n\t\t\tthreadSnapshot.setThreadSnapshotID(threadSnapshotID);\n\t\t\t\n\t\t\tthreadSnapshots.add(threadSnapshot);\n\t\t}\n\t}\n\treader.close();\n\t\n\treturn threadSnapshots;\n}"]}
{"_id": "636767e01a6d9265ec018764", "generate_results": ["Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject result = new JsonObject();\n    result.addProperty(null, \"properties\", properties);\n\n    return result;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\t\n\tJsonObject result = new JsonObject();\n\tfor(KeyStringValuePair pair : properties){\n\t\tresult.add(pair.getKey(), pair.getValue());\n\t}\n\treturn result;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject object = new JsonObject();\n    for (KeyStringValuePair property : properties) {\n        object.add(property.getKey(), property.getValue());\n    }\n    return object;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject object = new JsonObject();\n    if(properties!=null) {\n        for(KeyStringValuePair property : properties) {\n            object.add(property.getKey(), property.getValue());\n        }\n    }\n    return object;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject jsonObject = new JsonObject();\n\tfor (KeyStringValuePair keyStringValuePair : properties){\n\t\tjsonObject.add(keyStringValuePair.getKey(), keyStringValuePair.getValue());\n\t}\n\treturn jsonObject;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject json = new JsonObject();\n    for(KeyStringValuePair p : properties){\n        json.add(p.getKey(), p.getValue());\n    }\n    return json;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject result = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tresult.add(property.getKey(), property.getValue());\n\t}\n\treturn result;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n    JsonObject jsonObj = new JsonObject();\n    JsonArray jsonArray = new JsonArray();\n\n    for (KeyStringValuePair property : properties){\n\n        JsonObject propertyObj = new JsonObject();\n        propertyObj.addProperty(\"key\", property.getKey());\n        propertyObj.addProperty(\"value\", property.getValue());\n\n        jsonArray.add(propertyObj);\n\n    }\n\n    jsonObj.add(\"properties\", jsonArray);\n\n    return jsonObj;\n\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject json = new JsonObject();\n\t\n\tfor(KeyStringValuePair property : properties){\n\t\tjson.add(property.getKey(), property.getValue());\n\t}\n\t\n\treturn json;\n}", "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject jsonObject = new JsonObject();\n    for(KeyStringValuePair property : properties){\n        jsonObject.add(property.getKey(), property.getValue());\n    }\n    return jsonObject;\n}"]}
{"_id": "636766a91a6d9265ec0175c2", "generate_results": ["Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n\tint val = 0;\n\tfor(int i=0; i<m_stack.size(); i++){\n\t\tval = m_stack.operator()[i];\n\t\tm_stack.operator()[i] = 0;\n\t}\n\treturn val;\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n\n    return m_pOutputFrameStack->pop();\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    int result = 0;\n    if(!(stack.empty())){\n        result = stack.top();\n        stack.pop();\n    }\n    return result;\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    return frame.pop();\n}", "public int popAndPush2(){\n    int value = _outputFrameStack.pop();\n    _outputFrameStack.push(value);\n    return value;\n}", "public int pop(){\n    return pop(stack.peek());\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    int value;\n    while (true) {\n        value = outputFrame.pop();\n        if (value == -1) {\n            break;\n        }\n        else {\n            outputFrame.push(value);\n        }\n    }\n    return value;\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n\tint result = 0;\n\tfor(int i=0;i<outputFrameStackSize;i++){\n\t\tresult = result | outputFrameStack[i];\n\t}\n\treturn result;\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    return _stack.pop();\n}", "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n  return *(stack+stackSize-1);\n}"]}
{"_id": "636766aa1a6d9265ec0175ce", "generate_results": ["Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\tfinal int newOffset = offset + numLocal;\n\tfinal int newNumStack = numStack + numStack;\n\tfinal int newNumLocal = numLocal + numStack;\n\tfinal int newLine = newNumLocal + newNumStack;\n\t\n\tcurrentFrame = new Frame(newOffset,newNumLocal,newNumStack,newLine);\n\treturn 3;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\treturn 0;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\tassert(numLocal>=0);\n\tassert(numStack>=0);\n\tassert(offset>=0);\n\tassert(offset<=numLocal);\n\tassert(offset<=numStack);\n\treturn 3;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\tif(offset > 0){\n\t\tint count = 0;\n\t\tfor(int i = offset-1;i >= 0;i--){\n\t\t\tif(localRef[i] == null){\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcount += localRef[i].getCount();\n\t\t}\n\t\treturn count;\n\t}\n\treturn 0;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\treturn Visit(offset, numLocal, numStack);\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n    final int result = visitFrameStart(offset,numLocal,numStack,null);\n    assert result == 3;\n    return result;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n    return currentFrame.visitFrameStart(offset,numLocal,numStack);\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\tFrameState frameState = new FrameState(offset,numLocal,numStack);\n\treturn frameState.execute();\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n    if(currentFrame == null){\n        currentFrame = new Frame(offset,numLocal,numStack);\n    }else{\n        throw new RuntimeException(\"Trying to visit a frame that already has a parent\");\n    }\n    return 3;\n}", "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\treturn  visitFrameStart(offset,numLocal,numStack,0);\n}"]}
{"_id": "636766a91a6d9265ec0175c1", "generate_results": ["Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int[] newArray = new int[size];\n\tSystem.arraycopy(data, 0, newArray, 0, data.length);\n\tdata = newArray;\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tif (size > array.length){\n\t\tfinal int temp = array.length;\n\t\tarray = new int[size];\n\t\tSystem.arraycopy(array, 0, array, 0, temp);\n\t}\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newSize = (size + 1) * 2;\n\tfinal int[] newData = new int[newSize];\n\t\n\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\tdata = newData;\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newSize = size + 16;\n\tlong[] newData = new long[newSize];\n\tSystem.arraycopy(data, 0, newData, 0, size);\n\tdata = newData;\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newCapacity = size * 2;\n\tif(newCapacity <= data.length){\n\t\treturn;\n\t}\n\tthis.data = Arrays.copyOf(data, newCapacity);\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n    final int[] newData = new int[size];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    this.data = newData;\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int[] newArray = new int[size];\n\tSystem.arraycopy(this.data, 0, newArray, 0, this.data.length);\n\tthis.data = newArray;\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int new_size = size*2;\n\tdata = new double[new_size];\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n    final int oldLength = data.length;\n    final int newLength = oldLength + (size * 2);\n    data = new int[newLength];\n    System.arraycopy(oldData, 0, data, 0, oldLength);\n    final int start = oldLength;\n    for (int i = oldLength; i < newLength; ++i){\n        data[i] = 0;\n    }\n}", "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newSize = size < 0? 0 : size;\n\tfinal int newCapacity = newSize > 0? newCapacity(newSize) : 0;\n\tfinal int[] array = new int[newCapacity];\n\tSystem.arraycopy(this.data, 0, array, 0, this.data.length);\n\tthis.data = array;\n}"]}
{"_id": "636766a91a6d9265ec0175ae", "generate_results": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\treturn null;\n\t}\n\tbyteVector.ensureCapacity(byteOffset + byteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteVector.data,byteOffset,byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tbyteVector.ensureCapacity(byteOffset + byteLength);\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteVector.getData(), byteOffset, byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tbyteVector.putByteArray(byteArrayValue,byteOffset,byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\t// Checks for the case of a null byte array.\n\tif(byteArrayValue == null){\n\t\tthrow new IllegalArgumentException(\"Byte vector cannot be null.\");\n\t}\n\n\t// Checks for the case of a length of 0.\n\tif(byteLength == 0){\n\t\tthrow new IllegalArgumentException(\"Length cannot be 0.\");\n\t}\n\n\t// Checks for the case of a length of negative.\n\tif(byteLength < 0){\n\t\tthrow new IllegalArgumentException(\"Length cannot be negative.\");\n\t}\n\n\t// Checks for the case of a negative byte offset.\n\tif(byteOffset < 0){\n\t\tthrow new IllegalArgumentException(\"Byte offset cannot be negative.\");\n\t}\n\n\t// Checks for the case of a negative byte offset and length.\n\tif(byteOffset >= byteArrayValue.length || byteLength <= 0){\n\t\tthrow new IllegalArgumentException(\"Invalid offset and length.\");\n\t}\n\n\t// Creates a byte vector.\n\tfinal ByteVector byteVector = new ByteVector(byteLength);\n\n\t// Appends the contents of the byte array into the byte vector.\n\tint offset = byteOffset;\n\tfor(int i = 0; i < byteArrayValue.length - byteOffset; i++){\n\t\tbyteVector.putByte(byteArrayValue[offset++]);\n\t}\n\n\t// Appends the contents of the byte vector into the byte vector.\n\toffset = byteOffset;\n\tfor(int i = 0; i < byteLength; i++){\n\t\tbyteVector.putByte(byteArrayValue[offset++]);\n\t}\n\n\t// Sets the byte vector's length to the length of the byte array.\n\tbyteVector.setLength(byteArrayValue.length);\n\n\t// Sets the byte vector's data to the contents of the byte array.\n\tbyteVector.setData(byteArrayValue);\n\n\t// Sets the byte vector's offset to the value of the offset plus the length of the byte vector.\n\tbyteVector.setOffset(byteOffset);\n\n\t// Sets the byte vector's length to the length of the byte vector.\n\tbyteVector.setLength(byteLength);\n\n\t// Returns the byte vector.\n\treturn byteVector;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null) return null;\n\tif(byteOffset < 0) return null;\n\tif(byteOffset + byteLength > byteArrayValue.length) return null;\n\tbyte[] byteArray = new byte[byteLength];\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteArray, 0, byteLength);\n\treturn new ByteVector(byteArray);\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tthrow new IllegalArgumentException(\"Byte array is too small\");\n\t}\n\tfinal ByteVector byteVector = new ByteVector(byteArrayValue.length + byteLength);\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteVector.data, byteOffset, byteLength);\n\tbyteVector.length = byteLength;\n\treturn byteVector;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\treturn new ByteVector(byteArrayValue,byteOffset,byteLength);\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif (byteArrayValue == null)\n\t\treturn null;\n\t\n\tfinal ByteVector byteVector = new ByteVector(byteLength);\n\t\n\tfor (int i = 0; i < byteArrayValue.length; i++) {\n\t\tbyteVector.setByte(i, byteArrayValue[i]);\n\t}\n\treturn byteVector;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteArrayValue==null){\n        return this;\n    }\n    \n    if(byteLength>byteArrayValue.length){\n        byteLength=byteArrayValue.length;\n    }\n    \n    final int byteArrayLen=byteArrayValue.length;\n    \n    if(byteOffset+byteLength>this.size){\n        if(byteArrayLen>this.size){\n            byteArrayLen=this.size;\n        }\n        \n        final byte[] newArray=new byte[byteArrayLen+byteLength];\n        \n        System.arraycopy(this.array,byteOffset,newArray,0,byteArrayLen);\n        \n        this.array=newArray;\n    }\n    \n    System.arraycopy(byteArrayValue,byteOffset,this.array,byteOffset,byteLength);\n    \n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tfor(int i = byteOffset;i < byteOffset + byteLength;i++){\n\t\tthis.byteArray[i] = byteArrayValue[i];\n\t}\n\treturn this;\n}"]}
{"_id": "636766a81a6d9265ec017586", "generate_results": ["Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tfor(int i = 0; i < elements; i++){\n\t\tthis.stack.pop();\n\t}\n}", "public void pop(final int elements){\n\tfinal int newStackSize = stack.size();\n\twhile(newStackSize > 0){\n\t\tfinal StackElement<T> element = stack.pop();\n\t\tif(element.getElement() instanceof T){\n\t\t\tstack.push(new StackElement<T>(element.getElement(), newStackSize - 1));\n\t\t}\n\t\telse if(element.getElement() instanceof List){\n\t\t\tfinal List<T> list = (List<T>)element.getElement();\n\t\t\tlist.removeAll(0, elements);\n\t\t}\n\t\telse{\n\t\t\tthrow new RuntimeException(\"Not a stack element!\");\n\t\t}\n\t\tnewStackSize--;\n\t}\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tint stackSize = size();\n\t\n\tif(stackSize == 0){\n\t\tthrow new IllegalStateException(\"Cannot pop from empty stack\");\n\t}\n\t\n\tif(stackSize == 1){\n\t\treturn;\n\t}\n\t\n\tint top = stackTop();\n\t\n\tif(top == 0){\n\t\tthrow new IllegalStateException(\"Cannot pop from empty stack\");\n\t}\n\t\n\t\n\tint newSize = stackSize - 1;\n\t\n\tstack.set(top - newSize, elements);\n\t\n\tif(newSize == 0){\n\t\tclear();\n\t}\n\t\n\tstackTop(top - 1);\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\t\n\tif(elements == 0)return;\n\t\n\tthis.size--;\n\tthis.stack[this.size] = null;\n\t\n\tif(this.size == 0)\n\t\tthis.stack = null;\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements == 0) throw new IllegalArgumentException();\n\tif(!isEmpty()) {\n\t\tfinal int index = this.stack.pop();\n\t\tif(index < elements) {\n\t\t\tthis.stack.push(index);\n\t\t}\n\t}\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n    for(int i = 0; i < elements; i++){\n        this.stack.pop();\n    }\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements == 0)\n\t\treturn;\n\t\n\tstack.pop();\n\t\n\tif(stack.size() == 0){\n\t\t// No more elements left on the stack, so return from this method.\n\t\treturn;\n\t}\n\t\n\t// Stack is now empty.\n\t// Now put the rest of the elements in the stack.\n\tfor(int i = 0; i < elements; i++){\n\t\tstack.push(stack.pop());\n\t}\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements <= 0){\n\t\tthrow new IllegalArgumentException(\"Number of elements must be greater than zero\");\n\t}\n\tthis.stack.pop();\n\tthis.stack.push(elements);\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements <= 0){\n\t\treturn;\n\t}\n\tfinal int[] old = this.stack;\n\tthis.stack = new int[elements];\n\tSystem.arraycopy(old, 0, this.stack, 0, elements);\n}", "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements <= 0) return;\n\tfinal int max = stack.length - 1;\n\tfor(int i = 0; i < elements; ++i){\n\t\tstack[max - 1 - i] = stack[max - i];\n\t}\n\tstack.setLength(max - 1);\n}"]}
{"_id": "636766a81a6d9265ec017596", "generate_results": ["public ByteVector putInt(final int intValue){\n\tif(data.length < intValue){\n\t\tbyte[] newData = new byte[intValue];\n\t\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\t\tdata = newData;\n\t}\n\tdata[intValue] = (byte)intValue;\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\tint i1 = intValue;\n\tif(i1 < 0){\n\t\ti1 = 0;\n\t}\n\t\n\tbyte[] data = new byte[4];\n\tdata[0] = (byte)i1;\n\tdata[1] = (byte)(i1 >>> 8);\n\tdata[2] = (byte)(i1 >>> 16);\n\tdata[3] = (byte)(i1 >>> 24);\n\t\n\treturn new ByteVector(data);\n}", "public ByteVector putInt(final int intValue){\n\tbyte data[]=new byte[4];\n\tdata[0]= (byte)intValue;\n\tdata[1]= (byte)(intValue >>> 8);\n\tdata[2]= (byte)(intValue >>> 16);\n\tdata[3]= (byte)(intValue >>> 24);\n\tbyteVector.put(data);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\tif(data.length()<intValue){\n\t\tdata = new byte[intValue];\n\t}\n\tdata[4]=(byte)(intValue >>> 24);\n\tdata[5]=(byte)(intValue >>> 16);\n\tdata[6]=(byte)(intValue >>> 8);\n\tdata[7]=(byte)(intValue >>> 0);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\tfinal ByteVector byteVector = new ByteVector(data.length);\n\tfinal int numBytes = numBytes(intValue);\n\tdata[numBytes] = (byte)(intValue & 0xFF);\n\tdata[numBytes + 1] = (byte)((intValue >>> 8) & 0xFF);\n\tdata[numBytes + 2] = (byte)((intValue >>> 16) & 0xFF);\n\tdata[numBytes + 3] = (byte)((intValue >>> 24) & 0xFF);\n\tdata[numBytes + 4] = (byte)((intValue >>> 32) & 0xFF);\n\tdata[numBytes + 5] = (byte)((intValue >>> 40) & 0xFF);\n\tdata[numBytes + 6] = (byte)((intValue >>> 48) & 0xFF);\n\tdata[numBytes + 7] = (byte)((intValue >>> 56) & 0xFF);\n\treturn byteVector;\n}", "public ByteVector putInt(final int intValue){\n\tfinal byte[] data = new byte[4];\n\tfinal ByteVector byteVector = new ByteVector(data);\n\t\n\tfinal int intValueToBytes = intValue & 0xFF;\n\tfinal byte byteValueToInt = (byte)intValueToBytes;\n\t\n\tbyteVector.putByte(byteValueToInt);\n\treturn byteVector;\n}", "public ByteVector putInt(final int intValue){\n\tfinal ByteVector byteVector = new ByteVector(intValue);\n\tbyteVector.putInt(intValue);\n\treturn byteVector;\n}", "public ByteVector putInt(final int intValue){\n\tif(data.length() == data.capacity()){\n\t\tfinal byte[] newData = new byte[data.length()*2];\n\t\tSystem.arraycopy(data, 0, newData, 0, data.length());\n\t\tdata = newData;\n\t}\n\tdata[data.length()] = (byte)intValue;\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n    if(data==null){\n        data = new byte[8];\n    }\n    data[0] = (byte)(intValue & 0xff);\n    data[1] = (byte)((intValue >>> 8) & 0xff);\n    data[2] = (byte)((intValue >>> 16) & 0xff);\n    data[3] = (byte)((intValue >>> 24) & 0xff);\n    data[4] = (byte)((intValue >>> 32) & 0xff);\n    data[5] = (byte)((intValue >>> 40) & 0xff);\n    data[6] = (byte)((intValue >>> 48) & 0xff);\n    data[7] = (byte)((intValue >>> 56) & 0xff);\n    return this;\n}", "public ByteVector putInt(final int intValue){\n    byte[] data = new byte[4];\n    data[0] = (byte)intValue;\n    data[1] = (byte)(intValue >>> 8);\n    data[2] = (byte)(intValue >>> 16);\n    data[3] = (byte)(intValue >>> 24);\n    return new ByteVector(data);\n}"]}
{"_id": "636766a91a6d9265ec0175c4", "generate_results": ["Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tif(descriptor.charAt(0) == '\\'' || descriptor.charAt(0) == '\\\"'){\n\t\tif(descriptor.charAt(0) == '\\''){\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}else{\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}\n\t\t\n\t\tString[] parts = descriptor.split(\"\\\\.\", 3);\n\t\tString type = parts[0];\n\t\t\n\t\tif(type.charAt(0) == '\\'' || type.charAt(0) == '\\\"'){\n\t\t\ttype = type.substring(1);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tif(descriptor.charAt(0) == '\\'' || descriptor.charAt(0) == '\\\"'){\n\t\tif(descriptor.charAt(0) == '\\''){\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}else{\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}\n\t\t\n\t\tString[] parts = descriptor.split(\"\\\\.\", 3);\n\t\tString type = parts[0];\n\t\t\n\t\tif(type.charAt(0) == '\\'' || type.charAt(0) == '\\\"'){\n\t\t\ttype = type.substring(1);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\t\n\t\n\tif(descriptor.charAt(0) == ',' || descriptor.charAt(0) == ')'){\n\t\treturn;\n\t}\n\t\n\tif(descriptor.charAt(0) == '\\'' || descriptor.charAt(0) == '\\\"'){\n\t\tif(descriptor.charAt(0) == '\\''){\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}else{\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}\n\t\t\n\t\tString[] parts = descriptor.split(\"\\\\.\", 3);\n\t\tString type = parts[0];\n\t\t\n\t\tif(type.charAt(0) == '\\'' || type.charAt(0) == '\\\"'){\n\t\t\ttype = type.substring(1);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tif(descriptor.charAt(0) == '-' || descriptor.charAt(0) == '+'){\n\t\treturn;\n\t}\n\t\n\tif(descriptor.charAt(0) == '\\'' || descriptor.charAt(0) == '\\\"'){\n\t\tif(descriptor.charAt(0) == '\\''){\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}else{\n\t\t\tdescriptor = descriptor.substring(1);\n\t\t}\n\t\t\n\t\tString[] parts = descriptor.split(\"\\\\.\", 3);\n\t\tString type = parts[0];\n\t\t\n\t\tif(type.charAt(0) == '\\'' || type.charAt(0) == '\\\"'){\n\t\t\ttype = type.substring(1);\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\treturn;\n}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tfinal String descriptorString = descriptor.substring(1);\n\tif(descriptorString.length() == 1) return; //If the descriptor is empty, it does not have a second character.\n\tif(descriptorString.charAt(0) == \"}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n   if (descriptor == null){\n      throw new IllegalArgumentException(\"Descriptor cannot be null\");\n   }\n   int firstCharacter = descriptor.charAt(0);\n   StringBuilder descriptorBuilder = new StringBuilder();\n   if (Character.isLowerCase(firstCharacter)){\n      descriptorBuilder.append(firstCharacter);\n   }\n   for (int i = 1; i < descriptor.length(); i++){\n      char current = descriptor.charAt(i);\n      if (Character.isLowerCase(current)){\n         descriptorBuilder.append(current);\n      }\n   }\n   return pop(descriptorBuilder.toString());\n}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n    String value = descriptor.substring(1);\n    if(value.length() == 0){\n        return;\n    }\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    while(value.length() > 1){\n        if(value.length() == 2 && value.charAt(1) == '*')\n            return;\n        value = value.substring(value.length()-1, value.length());\n    }\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    while(value.length() > 1){\n        if(value.length() == 2 && value.charAt(1) == '*')\n            return;\n        value = value.substring(value.length()-1, value.length());\n    }\n    if(value.length() == 0)\n        return;\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    while(value.length() > 1){\n        if(value.length() == 2 && value.charAt(1) == '*')\n            return;\n        value = value.substring(value.length()-1, value.length());\n    }\n    if(value.length() == 0)\n        return;\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    while(value.length() > 1){\n        if(value.length() == 2 && value.charAt(1) == '*')\n            return;\n        value = value.substring(value.length()-1, value.length());\n    }\n    if(value.length() == 0)\n        return;\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    while(value.length() > 1){\n        if(value.length() == 2 && value.charAt(1) == '*')\n            return;\n        value = value.substring(value.length()-1, value.length());\n    }\n    if(value.length() == 0)\n        return;\n    if(value.length() == 1)\n        return;\n    value = value.charAt(0);\n    if(value.length() > 1){\n        if(value.charAt(1) == '*')\n            return;\n    }\n    if(value.length() == 2 && value.charAt(1) == '*')\n        return;\n    value = value.substring(0, value.length()-1);\n    descriptor = descriptor.substring(0, descriptor.length()-1);\n}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tfinal char firstCharacter = descriptor.charAt(0);\n\tif(firstCharacter!= '(' && firstCharacter!= '{'){\n\t\tthrow new IllegalArgumentException(\"'(' or '{' expected but got '\" + firstCharacter + \"'\");\n\t}\n\tchar characterAfterType = descriptor.charAt(1);\n\tswitch(characterAfterType){\n\t\tcase 'D':\n\t\t\tpop(descriptor.substring(2, descriptor.length() - 1));\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tpop(descriptor.substring(2, descriptor.length() - 1));\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tpop(descriptor.substring(2, descriptor.length() - 1));\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tpop(descriptor.substring(2, descriptor.length() - 1));\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tpop(descriptor.substring(2, descriptor.length() - 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"'(' or '{' expected but got '\" + characterAfterType + \"'\");\n\t}\n}\n}\n}\n", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n    if(descriptor.length() == 1) return;\n    if(descriptor.length() == 2) return;\n    if(descriptor.length() == 3) return;\n    if(descriptor.length() == 4) return;\n    throw new IllegalArgumentException(\"invalid descriptor\");\n}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tint index = this.descriptor.indexOf('}');\n\tif(index>=0){\n\t\tthis.descriptor = this.descriptor.substring(0,index);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='{'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t}\n\t\n\tif(this.descriptor.charAt(0)=='}'){\n\t\tthis.descriptor = this.descriptor.substring(1);\n\t}\n\t\n\tif(this.descriptor.length()==0){\n\t\treturn;\n\t", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n    final StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < descriptor.length(); i++) {\n      final char ch = descriptor.charAt(i);\n      if (ch == '\\'') {\n        builder.append('\\\\');\n        builder.append(ch);\n        builder.append('\\'');\n      } else {\n        builder.append(ch);\n      }\n    }\n    this.value = builder.toString();\n  }", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tint index = descriptor.indexOf('[');\n\tif(index == -1)\n\t\treturn;\n\t\n\tint endIndex = index;\n\tint end = 0;\n\t\n\twhile(index < endIndex){\n\t\tend = descriptor.indexOf(']', index);\n\t\tif(end == -1)\n\t\t\tendIndex = descriptor.length();\n\t\t\n\t\tif(end!= -1){\n\t\t\tif(descriptor.charAt(end + 1) == ':'){\n\t\t\t\tend = end + 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tindex = end;\n\t}\n\t\n\tif(end == -1)\n\t\tend = descriptor.length();\n\t\n\tif(end!= -1){\n\t\tif(descriptor.charAt(end + 1) == ':'){\n\t\t\tend = end + 2;\n\t\t\twhile(end < descriptor.length()){\n\t\t\t\tif(descriptor.charAt(end) == ':')\n\t\t\t\t\tbreak;\n\t\t\t\tend++;\n\t\t\t}\n\t\t\t\n\t\t\tif(end == descriptor.length())\n\t\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthrow new IllegalArgumentException(\"Unable to pop descriptor \" + descriptor);\n}", "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n\tfinal int index = descriptor.indexOf('[');\n\tif(index!= -1){\n\t\tfinal String value = descriptor.substring(0, index);\n\t\tint endIndex = index + 1;\n\t\twhile(endIndex < descriptor.length()){\n\t\t\tif(descriptor.charAt(endIndex) == ']'){\n\t\t\t\tindex = endIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tendIndex++;\n\t\t}\n\t\tfinal String[] result = new String[endIndex - index + 1];\n\t\tSystem.arraycopy(descriptor.substring(index).split(\",\"), 0, result, 0, endIndex - index);\n\t\tdescriptor = descriptor.substring(0, index);\n\t\treturn result;\n\t}\n\treturn null;\n}"]}
{"_id": "636766a81a6d9265ec017595", "generate_results": ["Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tfinal ByteVector data = this.data;\n\t\n\tif(data.length - this.position >= this.byteValueLength){\n\t\tfinal int newLength = this.byteValueLength * 2;\n\t\t\n\t\tif(newLength < data.length){\n\t\t\tfinal ByteVector newData = new ByteVector(data.length);\n\t\t\tSystem.arraycopy(data, this.position, newData, 0, this.position);\n\t\t\tthis.position = newData.length;\n\t\t}\n\t\t\n\t\tdata = newData;\n\t}\n\t\n\tdata.putByte(byteValue1);\n\tdata.putByte(byteValue2);\n\t\n\treturn this;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tfinal ByteVector byteVector = new ByteVector(this.data);\n\t\n\t// Enlarge the ByteVector if necessary\n\tif(byteVector.length + byteValue1 + byteValue2 > this.data.length)\n\t\tenlarge(byteValue1,byteValue2);\n\t\n\t// Copy the bytes\n\tbyteVector.put(this.data, byteVector.length);\n\t\n\t// Return the ByteVector object\n\treturn byteVector;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tfinal byte[] data = this.data;\n\tfinal int length = this.length;\n\tif(length<=data.length){\n\t\treturn this;\n\t}\n\tfinal byte[] data2 = new byte[data.length+2];\n\tdata2[length] = data[0];\n\tdata2[length+1] = data[1];\n\tSystem.arraycopy(data,0,data2,length+2,2);\n\treturn new ByteVector(data2);\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tfinal ByteVector data = new ByteVector(2);\n\tdata.putByte(byteValue1);\n\tdata.putByte(byteValue2);\n\treturn data;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n    ByteVector data = new ByteVector();\n    int byteOffset = data.length();\n    byteValue1 = byteValue1 << 8;\n    byteValue2 = byteValue2 << 8;\n    byteValue1 += byteValue1;\n    byteValue2 += byteValue2;\n    if(byteOffset + 7 > data.length()){\n    \tdata = new ByteVector();\n    }\n    byteValue1 = byteValue1 << 24;\n    byteValue2 = byteValue2 << 24;\n    byteValue1 += byteValue1;\n    byteValue2 += byteValue2;\n    data.length(byteOffset + 7);\n    data.putByte(byteValue1);\n    data.putByte(byteValue2);\n    return data;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n        byteVector.ensureCapacity(2);\n        byteVector.setByteAt(0,byteValue1);\n        byteVector.setByteAt(1,byteValue2);\n        return byteVector;\n    }", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1 == 0){\n\t\tbyteValue1 = 1;\n\t}\n\tif(byteValue2 == 0){\n\t\tbyteValue2 = 1;\n\t}\n\t\n\tfinal ByteVector out = new ByteVector(byteValue1+byteValue2);\n\tout.put(byteValue1);\n\tout.put(byteValue2);\n\treturn out;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tbyte[] data = this.data;\n\tint end = (int) (data.length-1);\n\tif(byteValue1 < 0 || byteValue1 > 127)\n\t\tthrow new IllegalArgumentException(\"The first byte in the ByteVector must be in the range [0,127]\");\n\tif(byteValue2 < 0 || byteValue2 > 127)\n\t\tthrow new IllegalArgumentException(\"The second byte in the ByteVector must be in the range [0,127]\");\n\tbyteValue1 = (byte) byteValue1;\n\tbyteValue2 = (byte) byteValue2;\n\n\tif(end < 0 || end > data.length)\n\t\tend = data.length;\n\n\tbyte newData[] = new byte[end+1];\n\tSystem.arraycopy(data, 0, newData, 0, end);\n\tnewData[end] = byteValue1;\n\tnewData[end+1] = byteValue2;\n\tthis.data = newData;\n\treturn this;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\t\n\tfinal ByteVector buffer = new ByteVector();\n\t\n\tbuffer.putByte((byte)byteValue1);\n\tbuffer.putByte((byte)byteValue2);\n\t\n\treturn buffer;\n}", "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif (byteValue1 < 0){\n\t\treturn null;\n\t}else if (byteValue1 == 0){\n\t\treturn this;\n\t}else if (byteValue1 == 1){\n\t\treturn new ByteVector(byteValue2);\n\t}else if (byteValue1 == 2){\n\t\treturn new ByteVector(byteValue2,byteValue2);\n\t}else{\n\t\treturn new ByteVector(byteValue1,byteValue2);\n\t}\n}"]}
{"_id": "636766a81a6d9265ec01757b", "generate_results": ["public String toString(JSONWriter.Feature.Value.Optional.Optional.Optional.Optional.Optional... values){\n    StringWriter sw = new StringWriter();\n    JSONWriter.Feature.Value.Optional.Optional.Optional.Optional.Optional[] ff = values;\n    for(int i=0; i<ff.length; i++){\n        ff[i].write(sw);\n    }\n    return sw.toString();\n}", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\tJSONWriter.Feature[] featuresArray = features;\n\tStringBuilder builder = new StringBuilder();\n\tfor (int i = 0; i < featuresArray.length; ++i) {\n\t\tbuilder.append(featuresArray[i].toString())\n\t\t\t.append('\\n');\n\t}\n\treturn builder.toString();\n}", "public String toString(JSONWriter.Feature feature, String prefix, String suffix, String suffix2, String suffix3, String suffix4, String suffix5, String suffix6, String suffix7){\n  return prefix + feature.name + \"=\" + feature.value + suffix2 + suffix3 + suffix4 + suffix5 + suffix6 + suffix7;\n}", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n    if(features == null || features.length == 0) return \"\";\n    \n    StringBuilder sb = new StringBuilder();\n    \n    for(int i=0; i<features.length; i++){\n        sb.append(features[i].name());\n        sb.append(\"=\");\n        sb.append(features[i].value());\n        \n        if(i < features.length-1) sb.append(\"; \");\n    }\n    \n    return sb.toString();\n}", "public boolean isNotEmpty(String string, String string1, String string2){\n    if(string == null) return false;\n    if(string.equals(string1)) return false;\n    if(string.equals(string2)) return false;\n    return string.length() > 0;\n}", "public String toString(Iterable<JSONWriter.Feature> features){ return toString(features); }", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\tfor (JSONWriter.Feature feature : features){\n\t\tfeature.set(this);\n\t}\n\treturn super.toString(features);\n}", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\tStringBuilder sb = new StringBuilder();\n\t\n\tfor(int i=0; i<features.length; i++){\n\t\tsb.append(features[i].toString()).append(\"\\n\");\n\t}\n\t\n\treturn sb.toString();\n}", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n    return this.toString(this.getFeature(features));\n}", "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\tif(features == null) return null;\n\tStringWriter sw = new StringWriter();\n\tJSONWriter.Feature f = features[0];\n\tif(f == JSONWriter.Feature.CONTENT) f = features[1];\n\tJSONWriter.Feature f2 = features[2];\n\tif(f2 == JSONWriter.Feature.CONTENT) f2 = features[3];\n\tif(f2 == JSONWriter.Feature.CONTENT) f2 = features[4];\n\ttry{\n\t\tObject obj = JSONWriter.write(sw,f);\n\t\treturn (String)obj;\n\t}catch(Exception e){\n\t\treturn null;\n\t}\n}"]}
{"_id": "636766a81a6d9265ec01758e", "generate_results": ["public static int nextPrime(int desiredCapacity){\n    int prime = 1;\n    int count = 0;\n    while(prime <= desiredCapacity) {\n        if(count == 0) {\n            // If the element is prime, increment the count.\n            count++;\n        } else {\n            // If the count is greater than the prime count, decrement the count.\n            count--;\n        }\n\n        // If the count is less than the prime count, return the element at the location specified by desiredCapacity.\n        // if the count is equal to the prime count, return the element at the location specified by desiredCapacity.\n        if(count < prime) {\n            return prime;\n        } else {\n            prime = nextPrime(prime);\n        }\n    }\n\n    return prime;\n}", "public static int nextPrime(int desiredCapacity){\n    return primeCapacity(desiredCapacity, primeCapacities);\n}", "public static int nextPrime(int desiredCapacity){\n\n    if(desiredCapacity <= 1) return 1;\n    \n    int prime = 1;\n    \n    for(int i = 2; i <= desiredCapacity; i++){\n        \n        if(prime % i == 0)\n            prime = i;\n    }\n    \n    return prime;\n}", "public static int nextPrime(int desiredCapacity){\n    return primeCapacities[nextPrimeIndex++];\n}", "public static int nextPrime(int desiredCapacity){\n\tint prime = 1;\n\twhile(prime<desiredCapacity){\n\t\tprime = prime*2;\n\t}\n\treturn prime;\n}", "public static int nextPrime(int desiredCapacity){\n\tint res = 0;\n\tint i = 0;\n\twhile(i<primeCapacities.length){\n\t\tif(primeCapacities[i]<desiredCapacity){\n\t\t\tres = primeCapacities[i];\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn res;\n}", "public static int nextPrime(int desiredCapacity){\n    return (2*desiredCapacity) + 1;\n  }", "public static int nextPrime(int desiredCapacity){\n    int next = primeCapacities[0];\n    boolean found = false;\n    for (int i = 1; i < primeCapacities.length; i++) {\n        if (primeCapacities[i] == desiredCapacity) {\n            found = true;\n            break;\n        } else {\n            next = primeCapacities[i];\n        }\n    }\n    if (!found) {\n        throw new RuntimeException(\"Next prime is not found in primeCapacities\");\n    }\n    return next;\n}", "public static int nextPrime(int desiredCapacity){\n        int primeCapacity = (int)(Math.pow(2, desiredCapacity));\n        int nextPrime = primeCapacity - 1;\n        for(int i=1; i<primeCapacity; i++){\n            if(nextPrime == primeCapacity){\n                return primeCapacity;\n            } else {\n                nextPrime = primeCapacity - 1;\n            }\n        }\n        return primeCapacity;\n    }", "public static int nextPrime(int desiredCapacity){\n\tint prime = desiredCapacity;\n\tint current = 0;\n\t\n\twhile(prime > 0){\n\t\tcurrent = current * prime + current;\n\t\tprime = prime / 2;\n\t}\n\treturn current;\n}"]}
{"_id": "636767a61a6d9265ec0185b7", "generate_results": ["Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n\tswitch(c){\n\t\tcase '0':\n\t\t\treturn 0;\n\t\tcase '1':\n\t\t\treturn 1;\n\t\tcase '2':\n\t\t\treturn 2;\n\t\tcase '3':\n\t\t\treturn 3;\n\t\tcase '4':\n\t\t\treturn 4;\n\t\tcase '5':\n\t\t\treturn 5;\n\t\tcase '6':\n\t\t\treturn 6;\n\t\tcase '7':\n\t\t\treturn 7;\n\t\tcase '8':\n\t\t\treturn 8;\n\t\tcase '9':\n\t\t\treturn 9;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    if(c=='0' || c=='1' || c=='2' || c=='3' || c=='4' || c=='5' || c=='6' || c=='7' || c=='8' || c=='9'){\n        return c-'0';\n    } else if(c=='-'){\n        return -1;\n    } else if(c==' '){\n        return 0;\n    } else {\n        int result = 0;\n        for(int i=0; i<c.length(); i++){\n            result += (c.charAt(i)-'0')*(10);\n        }\n        return result;\n    }\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    if (c>='0' && c<='9') return c-'0';\n    return c-'a'+10;\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n\treturn (int) (((int) c) - '0');\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    switch(c){\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return c - '0';\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n            return c - 'a' + 10;\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n            return c - 'A' + 10;\n        case 'a':\n            return c - 'a' + 10;\n        case 'b':\n            return c - 'b' + 10;\n        case 'c':\n            return c - 'c' + 10;\n        case 'd':\n            return c - 'd' + 10;\n        case 'e':\n            return c - 'e' + 10;\n        case 'f':\n            return c - 'f' + 10;\n        default:\n            return -1;\n    }\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    return c - '0';\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n  if (c >= '0' && c <= '9') return c - '0';\n  if (c >= 'A' && c <= 'F') return c - 'A' + 10;\n  if (c >= 'a' && c <= 'f') return c - 'a' + 10;\n  return -1;\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    switch(c){\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case '-': return -1;\n    case '*': return -2;\n    case '+': return -3;\n    case ',': return -4;\n    case '.': return -5;\n    case '/': return -6;\n    case '?': return -7;\n    case ':': return -8;\n    case '\\\\': return -9;\n    default: return -10;\n    }\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    if(c>='0' && c<='9'){\n        return c-'0';\n    }else if(c=='a' || c=='A'){\n        return 10;\n    }else if(c=='b' || c=='B'){\n        return 11;\n    }else if(c=='c' || c=='C'){\n        return 12;\n    }else if(c=='d' || c=='D'){\n        return 13;\n    }else if(c=='e' || c=='E'){\n        return 14;\n    }else if(c=='f' || c=='F'){\n        return 15;\n    }else if(c=='g' || c=='G'){\n        return 16;\n    }else if(c=='h' || c=='H'){\n        return 17;\n    }else if(c=='i' || c=='I'){\n        return 18;\n    }else if(c=='j' || c=='J'){\n        return 19;\n    }else if(c=='k' || c=='K'){\n        return 20;\n    }else if(c=='l' || c=='L'){\n        return 21;\n    }else if(c=='m' || c=='M'){\n        return 22;\n    }else if(c=='n' || c=='N'){\n        return 23;\n    }else if(c=='o' || c=='O'){\n        return 24;\n    }else if(c=='p' || c=='P'){\n        return 25;\n    }else if(c=='q' || c=='Q'){\n        return 26;\n    }else if(c=='r' || c=='R'){\n        return 27;\n    }else if(c=='s' || c=='S'){\n        return 28;\n    }else if(c=='t' || c=='T'){\n        return 29;\n    }else if(c=='u' || c=='U'){\n        return 30;\n    }else if(c=='v' || c=='V'){\n        return 31;\n    }else if(c=='w' || c=='W'){\n        return 32;\n    }else if(c=='x' || c=='X'){\n        return 33;\n    }else if(c=='y' || c=='Y'){\n        return 34;\n    }else if(c=='z' || c=='Z'){\n        return 35;\n    }else{\n        return -1;\n    }\n}", "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n\tif(c == '0'){\n\t\treturn 0;\n\t}\n\telse if(c == '1'){\n\t\treturn 1;\n\t}\n\telse if(c == '2'){\n\t\treturn 2;\n\t}\n\telse if(c == '3'){\n\t\treturn 3;\n\t}\n\telse if(c == '4'){\n\t\treturn 4;\n\t}\n\telse if(c == '5'){\n\t\treturn 5;\n\t}\n\telse if(c == '6'){\n\t\treturn 6;\n\t}\n\telse if(c == '7'){\n\t\treturn 7;\n\t}\n\telse if(c == '8'){\n\t\treturn 8;\n\t}\n\telse if(c == '9'){\n\t\treturn 9;\n\t}\n\telse if(c == '-'){\n\t\treturn -1;\n\t}\n\telse if(c == '+'){\n\t\treturn +1;\n\t}\n\treturn -1;\n}"]}
{"_id": "636767ab1a6d9265ec018676", "generate_results": ["Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\tif(c>='0' && c<='9'){\n\t\treturn true;\n\t}else if(c>='a' && c<='f'){\n\t\treturn true;\n\t}else if(c>='A' && c<='F'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\tif(c >= '0' && c <= '9'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\treturn isDigit(c) || (c == '+' || c == '-');\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\treturn Character.isDigit(c);\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\tif(c >= '0' && c <= '9') return true;\n\tif(c >= 'a' && c <= 'f') return true;\n\tif(c >= 'A' && c <= 'F') return true;\n\treturn false;\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n    final int n = Integer.valueOf(c, 16);\n    return n >= 0 && n <= 9;\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\treturn (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n\treturn (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}"]}
{"_id": "636767a41a6d9265ec018582", "generate_results": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tboolean b = schema.getExtension(\"protobuf\").isPresent();\n\tif (!b) {\n\t\treturn 0;\n\t}\n\tMessage.Builder<T> messageBuilder = Message.newBuilder(schema);\n\tmessageBuilder.setBinary(true);\n\tmessageBuilder.setExtension(protobuf, buffer);\n\tint size = messageBuilder.build().toByteString().size();\n\twriteDelimitedTo(out, message, schema, buffer);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tif(schema.getFieldNames().size()==0) {\n\t\tout.write(schema.getMessageType().getBytes());\n\t\treturn size;\n\t}\n\tfor(FieldId fid : schema.getFieldNames()) {\n\t\tint fieldSize = schema.getFieldSize(fid);\n\t\tbuffer.write(fid, message, fieldSize);\n\t\tsize += fieldSize;\n\t}\n\tout.write(schema.getMessageType().getBytes());\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tLinkedBuffer.DataOutput outData = new LinkedBuffer.DataOutput(buffer);\n\tschema.writeDelimitedTo(outData, message);\n\tint dataSize = buffer.writeTo(outData);\n\tbuffer.reset();\n\treturn dataSize;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n    int messageSize = 0;\n    if (schema.isNullable()) {\n      messageSize += schema.getNullableSize();\n    }\n    if (schema.isEnum()) {\n      messageSize += schema.getEnumSize();\n    }\n    if (schema.isFixed()) {\n      messageSize += schema.getFixedSize();\n    }\n    messageSize += schema.getVarSize();\n    if (schema.isVarArg()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isString()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isBinary()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isBool()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isInt()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimal()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimal4()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimal18()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimal28()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimal38()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isFloat()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDouble()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimalInf()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDecimalNaN()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDate()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isTime()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isTimestamp()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isInterval()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalYear()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalMonth()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalDay()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalHour()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalMinute()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalSecond()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalMilli()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalMicro()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isIntervalNano()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isArray()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isMap()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isSet()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isUnion()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isList()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isSetOrMap()) {\n      messageSize += buffer.getSize();\n    }\n    if (schema.isDateTime()) {\n      messageSize += buffer.getSize();\n    }\n    if (", "public static <T> int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tfor (T msg:schema.getFields()) {\n\t\tsize += out.write(writeDelimitedTo(out, msg, schema, buffer));\n\t}\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\treturn writeDelimitedTo(out, message, schema.getSchema(), buffer);\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n    int size = 0;\n    if(buffer!=null) {\n        byte[] bytes = new byte[schema.getSize()];\n        schema.writeTo(bytes,0);\n        out.write(bytes,0,bytes.length);\n        size += bytes.length;\n    }\n    size += writeDelimitedTo(out,message,schema,buffer.getBuffer());\n    return size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tif (schema.isMessage()) {\n\t\tsize = writeMessageDelimitedTo(out,message,schema,buffer);\n\t} else {\n\t\tsize = writeLinkedBufferTo(out,message,schema,buffer);\n\t}\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\t\n\tMessage.Builder builder = Message.newBuilder();\n\tbuilder.addAll(schema.getFields());\n\tbuilder.setDelimiter(delimiter);\n\tbuilder.setEncoding(encoding);\n\tbuilder.setMessage(message);\n\t\n\treturn buffer.writeDelimitedTo(builder.build(), out);\n}", "public static <T> int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\t// write message\n\tif (schema.getSchemaType().isPrimitive()) {\n\t\tschema.getSchemaType().writeDelimitedTo(out, message, buffer);\n\t\treturn buffer.size();\n\t} else {\n\t\tschema.getSchemaType().writeTo(out, message, buffer);\n\t\treturn buffer.size();\n\t}\n}"]}
{"_id": "636767a51a6d9265ec01859d", "generate_results": ["public boolean equals(final byte[] data,int offset,final int len){\n\tif(data == null){\n\t\treturn false;\n\t}\n\tif(data.length!= len){\n\t\treturn false;\n\t}\n\tfor(int i=offset;i<offset+len;i++){\n\t\tif(data[i]!= internal[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n    if(data==null || offset<0 || len<0 || offset+len>data.length)\n        return false;\n    for(int i=offset;i<offset+len;i++){\n        if(data[i]!=data[i-offset])\n            return false;\n    }\n    return true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null){\n\t\treturn false;\n\t}\n\tif(offset<0||len<0){\n\t\treturn false;\n\t}\n\tif(len<0){\n\t\tlen=data.length-offset;\n\t}\n\tif(len==0){\n\t\treturn true;\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tif(data[offset+i]!=data[i+offset]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\treturn(Arrays.equals(data,offset,len));\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null)return false;\n\tif(data.length+offset<len)return false;\n\tif(data.length!=len)return false;\n\tfor(int i=offset;i<(offset+len);i++){\n\t\tif((data[i]!=data[i+offset])&&(data[i]!=data[i+offset+1]))return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(len<=0)return false;\n\tif(offset>len)return false;\n\tfor(int i=0;i<len;i++){\n\t\tif(data[offset+i]!=data[i])return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif (len < 0)\n\t\treturn false;\n\tfinal int l = len;\n\tif (l > data.length-offset)\n\t\tl = data.length - offset;\n\tif (l == 0)\n\t\treturn true;\n\n\tfor (int i=0;i<l;i++){\n\t\tif (data[offset+i]!= data[i+offset+offset])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(len==-1)\n\t\treturn true;\n\tif(data==null || data.length==0)\n\t\treturn false;\n\tif(offset<0 || offset>data.length)\n\t\treturn false;\n\tfor(int i=offset;i<offset+len;i++)\n\t\tif(data[i]!=this.data[i])\n\t\t\treturn false;\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif (this.length!= len) return false;\n\tfor (int i=0;i<len;i++){\n\t\tif (data[offset+i]!= this.data[i]) return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data.length!= this.arrayData.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tif(data[offset+i]!= this.arrayData[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"]}
{"_id": "636767a41a6d9265ec01856c", "generate_results": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  int i=index;\n  int len1=len;\n  int i1=index;\n  int utf8Len=0;\n  if (str.charAt(index)=='\\n'){\n    i=index+1;\n    i1=index+1;\n    len1=1;\n  }\n  if (i<len1){\n    do{\n      i++;\n      if (i<len1){\n        utf8Len++;\n      }\n      else{\n        utf8Len++;\n      }\n    }while(i<len1);\n  }\n  return utf8Len;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    int size = 0;\n    while(index < str.length() && str.charAt(index)!='\\0'){\n        size++;\n        index++;\n    }\n    return size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    int result=0;\n    int i=index+len;\n    if(i<str.length()){\n        int c=str.charAt(i);\n        if(c<0x80){\n            result++;\n        } else {\n            result+=2;\n        }\n    }\n    return result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\t\n\tif (index < 0){\n\t\treturn computeUTF8Size(str,len+index,len);\n\t}\n\t\n\tif (index + len > str.length()){\n\t\treturn -1;\n\t}\n\t\n\tint result = 0;\n\tint pos = index;\n\t\n\twhile(pos < str.length()){\n\t\tif (index + len >= str.length() ||!UTF8.isUTF8(str.charAt(pos))) {\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tresult++;\n\t\tpos++;\n\t}\n\t\n\treturn result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  if (index >= str.length() || index < 0) {\n    return 0;\n  }\n  int utf8Size = 0;\n  int idx = index;\n  while (idx < str.length()) {\n    final char ch = str.charAt(idx);\n    if (ch == 0xdf) {\n      utf8Size++;\n      idx++;\n    } else if (ch >= 0x80) {\n      utf8Size++;\n      utf8Size++;\n      idx++;\n    } else if (ch == 0x00) {\n      break;\n    } else {\n      utf8Size++;\n      idx++;\n    }\n  }\n  return utf8Size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint utf8Size = 0;\n\tbyte[] utf8 = new byte[len];\n\tint utf8Index = index;\n\twhile(utf8Index - utf8Size < len){\n\t\tint c = str.charAt(utf8Index - utf8Size);\n\t\t// do not count the first character, which is the UTF-8 null character\n\t\tif(c == '\\0'){\n\t\t\tutf8Index++;\n\t\t\tutf8Size++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c >= 0x80){\n\t\t\tutf8[utf8Size++] = (byte)(c&0xff);\n\t\t}else if(c >= 0x800){\n\t\t\tutf8[utf8Size++] = (byte)(0xc0+(c>> 6));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c& 0x6f));\n\t\t}else if(c >= 0x10000){\n\t\t\tutf8[utf8Size++] = (byte)(0xe0+(c>> 12));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c>> 6));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c& 0x3f));\n\t\t}else if(c >= 0x200000){\n\t\t\tutf8[utf8Size++] = (byte)(0xf0+(c>> 18));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c>> 12));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c>> 6));\n\t\t\tutf8[utf8Size++] = (byte)(0x80+(c& 0x3f));\n\t\t}else{\n\t\t\tutf8Size += 2;\n\t\t\t", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    if(str == null){\n        return 0;\n    }\n    int result=0;\n    for(int i=index;i<index+len;i++){\n        char c=str.charAt(i);\n        if(c>=0x80 || c<=0x8F){\n            result++;\n        }else{\n            result++;\n        }\n    }\n    return result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint result = computeUTF8Size(str,index,len);\n\tif(result==-1)return result;\n\telse return result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    int result = 0;\n    int i = index;\n    if(i < 0){\n        result = 0;\n        i = 0;\n    }else if(i > str.length() - 1){\n        result = 0;\n        i = str.length() - 1;\n    }else{\n        char ch = str.charAt(i);\n        if(ch >= '\\u0000' && ch <= '\\u00FF'){\n            result = 1;\n            i++;\n        }else if(ch >= '\\uD800' && ch <= '\\uDFFF'){\n            result = 2;\n            i++;\n        }else if(ch >= '\\uFFFE' && ch <= '\\uFFFF'){\n            result = 3;\n            i++;\n        }else{\n            result = 4;\n        }\n    }\n    return result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  int result = 0;\n  \n  for(int i = 0; i < len; i++){\n    char ch = str.charAt(index++);\n    if(ch <= 0x7E){\n      result++;\n    }else if(ch <= 0x7FF){\n      result += 2;\n    }else if(ch <= 0xFFFF){\n      result += 3;\n    }else if(ch <= 0x1FFFFF){\n      result += 4;\n    }else if(ch <= 0x1FFFFFF){\n      result += 5;\n    }else if(ch <= 0x1FFFFFFFF){\n      result += 6;\n    }else if(ch <= 0x1FFFFFFFFFFFFF){\n      result += 7;\n    }else if(ch <= 0x1FFFFFFFFFFFFFF){\n      result += 8;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFF){\n      result += 9;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 10;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 11;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 12;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 13;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 14;\n    }else if(ch <= 0x1FFFFFFFFFFFFFFFF){\n      result += 15;\n    }else{\n      result += 16;\n    }\n  }\n  return result;\n}"]}
{"_id": "636767ab1a6d9265ec01867b", "generate_results": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tfinal int len = str.length();\n\tfinal int utflen = len*2;\n\tfinal byte[] buf = new byte[utflen];\n\tint read = 0;\n\tint write = 0;\n\t\n\tfinal int limit = -1;\n\tfinal int pos = 0;\n\ttry{\n\t\twhile(true){\n\t\t\tfinal int limit2 = len - read;\n\t\t\tif(limit2 > limit){\n\t\t\t\tfinal int pos2 = pos + read;\n\t\t\t\tfinal int len2 = limit2 - limit;\n\t\t\t\tSystem.arraycopy(str.toString().getBytes(),read,buf,write,len2);\n\t\t\t\twrite += len2;\n\t\t\t\tread = limit2;\n\t\t\t}else{\n\t\t\t\tfinal int pos2 = pos + read;\n\t\t\t\tfinal int len2 = limit - limit2;\n\t\t\t\tSystem.arraycopy(str.toString().getBytes(),read,buf,write,len2);\n\t\t\t\twrite += len2;\n\t\t\t\tread = limit;\n\t\t\t}\n\t\t\t\n\t\t\tif(read == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}catch(final RuntimeException e){\n\t\tthrow e;\n\t}catch(final Error e){\n\t\tthrow e;\n\t}finally{\n\t\tSystem.arraycopy(buf,0,lb.buf,0,write);\n\t\tlb.write = write;\n\t\tlb.read = read;\n\t\tlb.limit = limit;\n\t}\n\t\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tfinal int len=str.length();\n\tif(len==0){\n\t\treturn lb;\n\t}\n\tfinal int size=lb.size();\n\tfinal LinkedBuffer buf=lb.alloc();\n\tfinal char[] data=new char[size+1];\n\tfinal int n=str.charAt(0);\n\tfor(int i=0;i<n;i++){\n\t\tdata[size+i]=str.charAt(i);\n\t}\n\tdata[size]=0;\n\t\n\tint nleft=0;\n\tint nread=0;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=data[i];\n\t\tif(c!=0){\n\t\t\tif(c=='%'){\n\t\t\t\tnleft=nread;\n\t\t\t\tif(nleft>0){\n\t\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\t\tnread=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfinal int c2=(c=='%')?2:1;\n\t\t\t\tnleft=1;\n\t\t\t\tif(c2==2){\n\t\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\t\tnread=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\tnleft=0;\n\t\t\t\tnread=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c=='%'){\n\t\t\t\tnleft=nread;\n\t\t\t\tif(nleft>0){\n\t\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\t\tnread=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfinal int c2=(c=='%')?2:1;\n\t\t\t\tnleft=1;\n\t\t\t\tif(c2==2){\n\t\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\t\tnread=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf.append(data,0,nleft);\n\t\t\t\tnleft=0;\n\t\t\t\tnread=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(nleft>0){\n\t\t\tbuf.append(data,0,nleft);\n\t\t\tnread=0;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf.append(data,0,nleft);\n\t\tnleft=0;\n\t\tnread=0;\n\t}\n\tif(nread==0){\n\t\treturn buf;\n\t}\n\tfinal int nleft=nread;\n\tbuf.append(data,0,nleft);\n\treturn buf;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(str == null) return lb;\n\tif(str instanceof String) return lb.append((String)str);\n\treturn lb.append(str.toString());\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    if(str == null){\n        return null;\n    }\n    final int len = str.length();\n    final int utfLen = len;\n    final char[] res = new char[len];\n    int resPos = 0;\n    final char[] utf = new char[utfLen];\n\n    for(int i = 0; i < utfLen; i++){\n        final char ch = str.charAt(i);\n        if(ch < 0x80){\n            utf[resPos++] = ch;\n        }else if(ch < 0x800){\n            utf[resPos++] = 0xC0 | (ch >> 6);\n            utf[resPos++] = 0x80 | (ch & 0x3F);\n        }else if(ch < 0xD800){\n            utf[resPos++] = 0xE0 | (ch >> 12);\n            utf[resPos++] = 0x80 | ((ch >> 6) & 0x3F);\n            utf[resPos++] = 0x80 | (ch & 0x3F);\n        }else if(ch < 0xDC00){\n            utf[resPos++] = 0xF0 | (ch >> 18);\n            utf[resPos++] = 0x80 | ((ch >> 12) & 0x3F);\n            utf[resPos++] = 0x80 | ((ch >> 6) & 0x3F);\n            utf[resPos++] = 0x80 | (ch & 0x3F);\n        }else{\n            utf[resPos++] = 0x80 | ((ch >> 18) & 0x3F);\n            utf[resPos++] = 0x80 | ((ch >> 12) & 0x3F);\n            utf[resPos++] = 0x80 | ((ch >> 6) & 0x3F);\n            utf[resPos++] = 0x80 | (ch & 0x3F);\n        }\n    }\n    lb.write(utf);\n    return new LinkedBuffer(lb,resPos);\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(str instanceof String){\n\t\treturn writeUTF8((String)str,session,lb);\n\t}\n\tfinal byte[] buf = str.toString().getBytes(\"UTF-8\");\n\tfinal LinkedBuffer lb2 = new LinkedBuffer(buf);\n\treturn lb2;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(str==null)return null;\n\tfinal int len=str.length();\n\tfinal byte[] out=new byte[len];\n\tint i=0;\n\tint j=0;\n\twhile(i<len){\n\t\tbyte b=0;\n\t\tswitch(str.charAt(i)){\n\t\t\tcase '\\n':\n\t\t\t\tb=0;\n\t\t\t\tout[j++]=b;\n\t\t\tcase '\\r':\n\t\t\t\tb=0;\n\t\t\t\tout[j++]=b;\n\t\t\tdefault:\n\t\t\t\tb=(byte)str.charAt(i);\n\t\t\t\tout[j++]=b;\n\t\t}\n\t\tif(j>=out.length)break;\n\t\ti++;\n\t}\n\tlb.write(out,0,j);\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tint utf8_pos = 0;\n\tif (str!= null){\n\t\tfor (int i = 0; i < str.length(); i++){\n\t\t\tfinal char c = str.charAt(i);\n\t\t\tif (c < 0x80){\n\t\t\t\tlb.write(c);\n\t\t\t} else if (c < 0x800){\n\t\t\t\tlb.write(0xc0 | (c >> 6));\n\t\t\t\tlb.write(0x80 | (c & 0x3f));\n\t\t\t} else if (c < 0x10000){\n\t\t\t\tlb.write(0xe0 | (c >> 12));\n\t\t\t\tlb.write(0x80 | ((c >> 6) & 0x3f));\n\t\t\t\tlb.write(0x80 | (c & 0x3f));\n\t\t\t} else {\n\t\t\t\tlb.write(0xf0 | (c >> 18));\n\t\t\t\tlb.write(0x80 | ((c >> 12) & 0x3f));\n\t\t\t\tlb.write(0x80 | ((c >> 6) & 0x3f));\n\t\t\t\tlb.write(0x80 | (c & 0x3f));\n\t\t\t}\n\t\t\tutf8_pos += 1;\n\t\t}\n\t}\n\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(lb==null){\n\t\treturn null;\n\t}\n\tlb.setLength(0);\n\tfinal int len = str.length();\n\tfinal int limit = lb.length()+1;\n\tfinal int bufferSize = len+1;\n\tchar[] buffer = new char[bufferSize];\n\tstr.getChars(0, len, buffer, 0);\n\tfor(int i=0;i<len;i++){\n\t\tfinal int c = buffer[i];\n\t\tif(c<0x80){\n\t\t\tlb.append(c);\n\t\t}else if(c<0x800){\n\t\t\tlb.append(0xC0+(c>>>6));\n\t\t\tlb.append(0x80+(c&0x3F));\n\t\t}else if(c<0xD800 || c>=0xE000){\n\t\t\tlb.append(0xE0+(c>>>12));\n\t\t\tlb.append(0x80+(c&0x3F));\n\t\t}else if(c<0x10000){\n\t\t\tlb.append(0xF0+(c>>>18));\n\t\t\tlb.append(0x80+(c&0x3F));\n\t\t}else{\n\t\t\tlb.append(0xE0+(c>>>18));\n\t\t\tlb.append(0x80+(c&0x3F));\n\t\t\tlb.append(0x80+(c>>>6));\n\t\t\tlb.append(0x80+(c&0x3F));\n\t\t}\n\t}\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tfinal boolean isUtf8 = isUtf8(str);\n\tfinal int len = str.length();\n\tif(isUtf8){\n\t\tfor(int i = 0;i < len;i++){\n\t\t\tlb.append(str.charAt(i));\n\t\t}\n\t}else{\n\t\tfor(int i = 0;i < len;i++){\n\t\t\tlb.append(str.charAt(i),str.charAt(i+1),str.charAt(i+2));\n\t\t}\n\t}\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    final int length = str.length();\n    for (int i = 0; i < length; ++i) {\n        final byte b = str.charAt(i);\n        if (b == '\\\\') {\n            lb.append('\\\\');\n        }\n        if (b == '\\n') {\n            lb.append('\\\\');\n        }\n        if (b == '\\r') {\n            lb.append('\\\\');\n        }\n        lb.append(b);\n    }\n    return lb;\n}"]}
{"_id": "636767a41a6d9265ec018572", "generate_results": ["public static void skipRawVarint32() throws IOException {\n    long n = readRawVarint64();\n    while ((n & 0x7F) == 0) {\n      n = readRawVarint64();\n    }\n  }", "public long readRawVarint64() throws IOException {\n    if (isFilling) {\n      if (isFirst) {\n        isFirst = false;\n        return readVarint();\n      } else {\n        return readVarint() << 32;\n      }\n    }\n\n    return readVarint() & 0x7F;\n  }", "public long readRawVarint64(boolean bigEndian) throws IOException {\n    if (bigEndian) {\n        return Longs.checkedCast(readRawVarint64());\n    } else {\n        return Longs.checkedCast(readRawVarint32());\n    }\n}", "public long readRawVarint64() throws IOException {\n    if (pos == limit) {\n      return -1;\n    }\n    final int i = in.readInt();\n    pos += 4;\n    return i;\n  }", "public long readRawVarint64() throws IOException {\n      return readRawVarint(64);\n    }", "public long readRawVarint64() throws IOException {\n    long result = readRawVarint64();\n    if (result < 0) {\n      throw new EOFException(\"Invalid varint length: \" + result);\n    }\n    return result;\n  }", "public long readRawVarint64() throws IOException {\n    return readRawVarint64(false);\n  }", "public long readRawVarint64() throws IOException {\n    byte[] b = new byte[8];\n    readRawBytes(b, 0, 8);\n    return b[7] & 0x7F | (b[6] & 0x80) << 7 | (b[5] & 0x80) << 14 | (b[4] & 0x80) << 21 | (b[3] & 0x80) << 28 | (b[2] & 0x80) << 35 | (b[1] & 0x80) << 42 | (b[0] & 0x80) << 49;\n  }", "public long readRawVarint64() throws IOException {\n\tif (pos < limit) {\n\t\tint v = readRawVarint();\n\t\tpos++;\n\t\treturn v;\n\t}\n\tthrow new IOException(\"Read past the end of the stream\");\n}", "public long readRawVarint64() throws IOException {\n\treturn readRawVarint64(true);\n}"]}
{"_id": "636767aa1a6d9265ec01865a", "generate_results": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint i = node.count;\n\tfor(i=0;i<node.count;i++) {\n\t\tout.writeDouble(node.data.getDouble(i));\n\t}\n\treturn i;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint size = 0;\n\tif (node.getSize() >= 0) {\n\t\tsize = node.getSize();\n\t\tout.writeInt(size);\n\t\tout.write(node.getData(), 0, size);\n\t} else {\n\t\tsize = out.writeInt(node.getSize());\n\t\tout.write(node.getData(), 0, node.getSize());\n\t}\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\t// TODO Auto-generated method stub\n\treturn 0;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint size=0;\n\tif(node!=null) {\n\t\tfinal int size1=node.size();\n\t\tsize=size1+1;\n\t\t\n\t\tif(node.getLinkedBuffer()!=null) {\n\t\t\tif(node.getLinkedBuffer().size()!=size1)\n\t\t\t\tthrow new IOException(\"LinkedBuffer size mismatch!\");\n\t\t\t\n\t\t\tfinal List<LinkedBuffer> buffer=node.getLinkedBuffer();\n\t\t\t\n\t\t\tfor(LinkedBuffer buffer1:buffer) {\n\t\t\t\tsize1=size1+1;\n\t\t\t\tsize+=buffer1.size();\n\t\t\t}\n\t\t\t\n\t\t\tout.writeInt(size);\n\t\t\tout.writeInt(size1);\n\t\t\t\n\t\t\tfor(LinkedBuffer buffer1:buffer) {\n\t\t\t\tsize1=size1+1;\n\t\t\t\tsize+=buffer1.size();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\telse {\n\t\t\tout.writeInt(size1);\n\t\t\tsize+=size1;\n\t\t}\n\t}\n\t\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint size=0;\n\tfor(int i=0;i<node.size();i++) {\n\t\tsize+=node.get(i);\n\t}\n\tout.writeInt(size);\n\tfor(int i=0;i<node.size();i++) {\n\t\tout.writeInt(node.get(i));\n\t}\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint bytesWritten=0;\n\tif(node.link.link==null) {\n\t\tbytesWritten=out.writeInt(node.dataLength);\n\t} else {\n\t\tbytesWritten=out.writeInt(node.link.link.dataLength);\n\t\tbytesWritten+=out.write(node.link.link.data,0,node.link.link.dataLength);\n\t}\n\tif(node.link.link!=null) {\n\t\tbytesWritten+=out.writeInt(node.link.link.dataLength);\n\t\tbytesWritten+=out.write(node.link.link.data,0,node.link.link.dataLength);\n\t}\n\treturn bytesWritten;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tif(node.isNull()) {\n\t\tout.writeInt(-1);\n\t} else {\n\t\tout.writeInt(node.getLength());\n\t\tnode.getBytes(out,out.getPosition());\n\t}\n\treturn out.getPosition();\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tout.writeUTF(node.getName());\n\tint bytesWritten = 0;\n\tbytesWritten += write(out, node.getContent());\n\treturn bytesWritten;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\t// Check the node's type.\n\tif(node.getType()!= DataType.LINKED_BUFFER){\n\t\tthrow new IllegalArgumentException(\"Node is not a LinkedBuffer\");\n\t}\n\t// Check the node's content.\n\tfinal byte[] content = node.getContent();\n\t// Write the content to the LinkedBuffer.\n\tout.write(content);\n\treturn content.length;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint oldPos=out.getPosition();\n\tout.writeByte((byte)node.getType());\n\tint length=out.getLength();\n\tout.writeInt(length);\n\tout.write(node.getData(),0,length);\n\treturn oldPos;\n}"]}
{"_id": "636767a31a6d9265ec018552", "generate_results": ["public String readString() throws IOException {\n    if (reader == null) throw new IOException(\"Reader is null\");\n    if (reader.available() == 0) return null;\n    return byteToString(reader.read());\n  }", "public String readString() throws IOException {\n    if (size() == 0) {\n      throw new EOFException();\n    }\n    return readString(size());\n  }", "public String readString() throws IOException {\n    return readUTF();\n  }", "public String readString() throws IOException {\n    return readUTF(readUTFEnd());\n  }", "public String readString() throws IOException {\n    return new String(buffer(), offset + pos, length - pos);\n  }", "public String readString() throws IOException {\n    if (m_data == null) {\n      throw new IOException(\"No data in buffer\");\n    }\n    return new String(m_data, 0, m_data.length - m_pos);\n  }", "public String readString() throws IOException {\n    char[] buf = new char[read()];\n    return new String(buf);\n  }", "public String readString() throws IOException {\n    if (buffer.length() == 0) {\n      return null;\n    }\n    return buffer.toString();\n  }", "public String readString() throws IOException {\n    return get().readLine();\n  }", "public String readString() throws IOException {\n    return readUTF();\n}"]}
{"_id": "636767a21a6d9265ec018517", "generate_results": ["public final byte[] toByteArray(){\n    byte[] result = new byte[size];\n    System.arraycopy(bytes, 0, result, 0, size);\n    return result;\n}", "public final byte[] toByteArray(){\nreturn ByteArray2.toByteArray(buf);\n}", "public final byte[] toByteArray(){\n    return toByteArray(this.buffer);\n}", "public final byte[] toByteArray(){\n    byte[] bytes = new byte[linkedBuffer.size()];\n    \n    for (int i = 0; i < linkedBuffer.size(); i++) {\n        bytes[i] = (byte)linkedBuffer.get(i);\n    }\n    \n    return bytes;\n}", "public final byte[] toByteArray(){\n\tbyte[] b = new byte[m_length];\n\n\tSystem.arraycopy(m_buffer, m_offset, b, 0, m_length);\n\n\tm_offset += m_length;\n\n\treturn b;\n}", "public final byte[] toByteArray(){\n\treturn this.buffer.toByteArray();\n}", "public final byte[] toByteArray(){\n    return this.linkedBuffer.toByteArray();\n}", "public final byte[] toByteArray(){\n\treturn new byte[linkedBuffer.length];\n}", "public final byte[] toByteArray(){\n\treturn bbuf.toByteArray();\n}", "public final byte[] toByteArray(){\n\tbyte[] buffer = new byte[count];\n\tread(buffer);\n\treturn buffer;\n}"]}
{"_id": "636767a41a6d9265ec01857e", "generate_results": ["Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\treturn (a>b)?1:-1;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n    if (a<0) return -1;\n    if (b<0) return 1;\n    return (a>b)? 1 : 0;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n    return (a>b?1:-1);\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\treturn (a>b)?1:-1;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tif(a<b){\n\t\treturn -1;\n\t}\n\telse if(a>b){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tif (a > b) return 1;\n\tif (a < b) return -1;\n\treturn 0;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n    return Long.compare(a,b);\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tint result = (int)(b-a);\n\tif((result==0) || (result==1)){\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tif(a>b){return 1;}\n\tif(a<b){return -1;}\n\treturn 0;\n}", "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\treturn (a > b)? 1 : ((a < b)? -1 : 0);\n}"]}
{"_id": "636767aa1a6d9265ec01864a", "generate_results": ["public byte[] toByteArray(){\n\tbyte[] buffer = new byte[length];\n\tfor(int i = 0; i < length; i++){\n\t\tbuffer[i] = (byte) value[i];\n\t}\n\treturn buffer;\n}", "public byte[] toBytes(){\n    return toByteArray();\n}", "public byte[] toByteArray(){\n\treturn this.bytes;\n}", "public byte[] toByteArray(){\n\n\tbyte[] bytes = new byte[length];\n\t\n\tSystem.arraycopy(arr, offset, bytes, 0, length);\n\t\n\treturn bytes;\n}", "public byte[] toByteArray(){\n\tbyte[] bytes = new byte[this.length];\n\tSystem.arraycopy(this.bytes, 0, bytes, 0, this.length);\n\treturn bytes;\n}", "public byte[] toByteArray(){\n\tbyte[] b = new byte[length()];\n\tSystem.arraycopy(data, 0, b, 0, length());\n\treturn b;\n}", "public byte[] toByteArray(){\n\treturn new byte[count];\n}", "public byte[] toByteArray(){\n  return buf;\n}", "public String toString(){\n\tbyte[] buffer = toByteArray();\n\tString result = \"\";\n\tfor(int i = 0; i < 8; i++){\n\t\tresult = result + ((buffer[i] & 0xFF) << \" \");\n\t}\n\treturn result;\n}", "public byte[] toByteArray(){\n    byte[] array = new byte[message.length];\n    \n    for (int i = 0; i < message.length; i++){\n        array[i] = message[i];\n    }\n    \n    return array;\n}"]}
{"_id": "636767a31a6d9265ec01854f", "generate_results": ["Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif(field.isPacked()) {\n\t\tif(field.isPacked() == false) {\n\t\t\tthrow new IOException(\"The field has not been packed yet\");\n\t\t}\n\t\t\n\t\tfield.unpack();\n\t}\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif(!isPackedField) return;\n\tif(!isPacked) {\n\t\tif(field.length() == 0) {\n\t\t\tthrow new IOException(\"The field is empty. Cannot read it.\");\n\t\t}\n\t\tif(!isReadable) {\n\t\t\tthrow new IOException(\"The field is not readable. Cannot read it.\");\n\t\t}\n\t\tif(!isReadable) {\n\t\t\tisReadable = true;\n\t\t\tif(!isPacked) {\n\t\t\t\tfieldBytes = new byte[field.length()];\n\t\t\t\tSystem.arraycopy(fieldBytes, 0, readFieldBytes, 0, field.length());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfieldBytesLength = field.length();\n\t\t\t\tfieldBytesPosition = 0;\n\t\t\t\treadFieldBytes = new byte[fieldBytesLength];\n\t\t\t\tSystem.arraycopy(fieldBytes, 0, readFieldBytes, 0, fieldBytesLength);\n\t\t\t\tisReadable = true;\n\t\t\t}\n\t\t}\n\t}\n}", "public void readField(byte[] out, int outOffset, int outSize) throws IOException {\n\tif (outOffset < 0) {\n\t\tthrow new IOException(\"illegal offset\");\n\t}\n\tif (outSize < 0) {\n\t\tthrow new IOException(\"illegal size\");\n\t}\n\tint outSize2 = outSize;\n\tcheckIfPackedField();\n\tfReader.readFully(fHeader);\n\tfSize = (int)fHeader[0] + (int)fHeader[1] * 256 + (int)fHeader[2] * 65536 + (int)fHeader[3] * 16777216 + (int)fHeader[4] * 65536 + (int)fHeader[5] * 256 + (int)fHeader[6] * 65536 + (int)fHeader[7] * 256;\n\tfPacked = (fHeader[0] & 0x80)!= 0;\n\tSystem.arraycopy(fHeader, 8, out, outOffset, outSize2);\n\toutOffset += outSize2;\n\tif (outOffset > out.length) {\n\t\tthrow new IOException(\"illegal offset", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif(!this.isPackedField()){\n\t\tthis.readField();\n\t\tthis.setPackedField(true);\n\t}\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif (field.getType().isPrimitive()) {\n\t\treturn;\n\t}\n\tif (field.getType().isArray()) {\n\t\tint length = field.getLength();\n\t\tif (length == 0) {\n\t\t\tthrow new IOException(\"Cannot read an array with empty length\");\n\t\t}\n\t\tif (length > 1) {\n\t\t\tthrow new IOException(\"Cannot read an array with more than one element\");\n\t\t}\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tObject value = field.getValue(i);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IOException(\"Cannot read an array with null values\");\n\t\t\t}\n\t\t\tif (!value.getClass().isArray()) {\n\t\t\t\tthrow new IOException(\"Cannot read an array with a non-array value\");\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (field.getType().isMap()) {\n\t\tMap<String, Object> map = field.getValue(Map.class);\n\t\tif (map == null) {\n\t\t\tthrow new IOException(\"Cannot read a map with null values\");\n\t\t}\n\t\tif (map.isEmpty()) {\n\t\t\tthrow new IOException(\"Cannot read a map with an empty map\");\n\t\t}\n\t\tif (map.size()!= field.getLength()) {\n\t\t\tthrow new IOException(\"Cannot read a map with different keys and values\");\n\t\t}\n\t\treturn;\n\t}\n\tif (field.getType().isCollection()) {\n\t\tCollection<Object> collection = field.getValue(Collection.class);\n\t\tif (collection == null) {\n\t\t\tthrow new IOException(\"Cannot read a collection with null values\");\n\t\t}\n\t\tif (collection.isEmpty()) {\n\t\t\tthrow new IOException(\"Cannot read a collection with an empty collection\");\n\t\t}\n\t\tif (collection.size()!= field.getLength()) {\n\t\t\tthrow new IOException(\"Cannot read a collection with different keys and values\");\n\t\t}\n\t\treturn;\n\t}\n\tif (field.getType().isArray()) {\n\t\tthrow new IOException(\"Cannot read an array with a primitive value\");\n\t}\n\tthrow new IOException(\"Cannot read a primitive value from a field of type: \" + field.getType().getName());\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n    if (field.isPacked()) {\n        checkFieldIsRead();\n        return;\n    }\n    //read the field and set it's value to the internal state\n    field.read(buffer);\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif(field.getType().isPrimitive()) {\n\t\tif(field.isPacked()) {\n\t\t\tif(field.isBinary()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(field.getSize() == 1) {\n\t\t\t\tthis.size = this.field.getSize();\n\t\t\t}\n\t\t}\n\t}\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tint numOfBytesToRead = getNumOfBytesToRead();\n\tif ((numOfBytesToRead!= getNumOfBytesToRead()) || (!isInMemory)) {\n\t\tif (isInMemory) {\n\t\t\tthrow new IOException(\"The packed field is not read yet. Please read it at the end of the process.\");\n\t\t}\n\t\telse {\n\t\t\tthrow new IOException(\"The field is not read yet. Please read it at the end of the process.\");\n\t\t}\n\t}\n}", "public int readNextField(int field) throws IOException {\n\t\n\tif (this.field == -1)\n\t\tthrow new IOException(\"No field is currently selected.\");\n\t\n\tcheckIfPackedField();\n\t\n\treturn this.field++;\n}", "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n    if (field.isPacked()) {\n        readField(field.getFieldData());\n    }\n}"]}
{"_id": "636767a81a6d9265ec0185fc", "generate_results": ["public int readTag() throws IOException {\n    int tag = 0;\n    int shift = 0;\n    while (shift < TAG_TYPE_BITS) {\n        if (input.read() == 'X') {\n            shift++;\n            tag = 0;\n            continue;\n        }\n        if (input.read() == 'X') {\n            shift++;\n            tag = 0;\n            continue;\n        }\n        tag <<= TAG_TYPE_BITS - shift;\n        shift++;\n    }\n    return tag;\n}", "public int readTag() throws IOException {\n\tint tag = 0;\n\tint ch = in.read();\n\tif (ch == '0' && in.read() == 'x') {\n\t\treturn 0;\n\t}\n\tif (ch == '1') {\n\t\ttag = 1;\n\t}\n\tif (ch == '2') {\n\t\ttag = 2;\n\t}\n\tif (ch == '3') {\n\t\ttag = 3;\n\t}\n\tif (ch == '4') {\n\t\ttag = 4;\n\t}\n\tif (ch == '5') {\n\t\ttag = 5;\n\t}\n\tif (ch == '6') {\n\t\ttag = 6;\n\t}\n\tif (ch == '7') {\n\t\ttag = 7;\n\t}\n\tif (ch == '8') {\n\t\ttag = 8;\n\t}\n\tif (ch == '9') {\n\t\ttag = 9;\n\t}\n\t\n\treturn tag;\n\n}", "public int readTag() throws IOException {\n    int result = 0;\n    char ch = in.read();\n    result |= (ch & 0x7f) <<  TAG_TYPE_BITS;\n    if(ch == TAG_TYPE_EOF)\n        return result;\n    else\n        return result | (ch >>> TAG_TYPE_BITS);\n}", "public int readTag() throws IOException {\nif(this.tag == 0) {\nreturn(this.tag);\n} else {\nthrow new IOException(\"Tag is not valid. Only TAG_TYPE_BITS is supported\");\n}\n}", "public int readTag() throws IOException {\n  return readTag(0);\n}", "public int read(byte[] b, int off, int len) throws IOException {\n    int tag = readTag();\n    if (tag == 0)\n      return -1;\n    return tag;\n  }", "public int readTag() throws IOException {\n    int tag = readTag();\n    if (tag == 0)\n        return 0;\n    else\n        return tag;\n}", "public int readTag() throws IOException {\n\tint tag = 0;\n\tint position = 0;\n\tint temp = 0;\n\t//Read the tag\n\tdo {\n\t\tposition = in.read();\n\t\ttemp = 0;\n\t\tif (position == 0)\n\t\t\tthrow new RuntimeException(\"Tag is empty\");\n\t\tfor (int i = 0; i < TAG_TYPE_BITS; i++)\n\t\t\ttemp = in.read();\n\t\ttag = (int) (temp & 0x0F);\n\t\ttag = (tag << TAG_TYPE_BITS) | (tag >> (TAG_TYPE_BITS + TAG_TYPE_BITS));\n\t} while (tag!= 0);\n\n\treturn tag;\n}", "public int read(int numBits) throws IOException {\n    if (numBits == 0) return 0;\n    int tag = readTag();\n    if (tag < 0) throw new EOFException();\n    return tag & TAG_TYPE_BITS;\n}", "public int readTag() throws IOException {\n\tint t=0;\n\tint tag=0;\n\tint i=0;\n\tint j=0;\n\tint len=0;\n\tint last_tag=0;\n\tint count=0;\n\twhile(i<len) {\n\t\ttag=(tag<<TAG_TYPE_BITS)|0;\n\t\ttag=(tag<<TAG_BITS)|0;\n\t\ti++;\n\t\tcount++;\n\t\tif(j==0) {\n\t\t\tif(tag==0) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(\"Tag tag is not zero\");\n\t\t\t}\n\t\t}\n\t\tif(j==1) {\n\t\t\tif(tag==0) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(\"Tag tag is not zero\");\n\t\t\t}\n\t\t}\n\t\tj++;\n\t}\n\tif(count==0) {\n\t\treturn t;\n\t}\n\telse {\n\t\tthrow new IOException(\"Tag tag is not zero\");\n\t}\n}"]}
