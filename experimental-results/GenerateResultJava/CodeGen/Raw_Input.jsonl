{"_id": "6367672d1a6d9265ec017c73", "generate_results": ["public boolean shouldPrintMessage(int timestamp,String message){\n        return false;\n    }", "public boolean shouldPrintMessage(int timestamp,String message){\n\t\n\tif(message == null){\n\t\treturn false;\n\t}\n\t\n\tif(timestamp > 0 && timestamp < 1){\n\t\treturn false;\n\t}\n\t\n\tif(timestamp > 0 && timestamp == 1){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\t\n\tif (this.getLevel() == Message.LEVEL_INFO){\n\t\tif (this.getTimestamp()>timestamp){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tif (this.getLevel() == Message.LEVEL_WARNING || this.getLevel() == Message.LEVEL_ERROR){\n\t\tif (this.getTimestamp()>timestamp){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\treturn (timestamp == 0);\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(timestamp>0 && timestamp<=System.currentTimeMillis()){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\treturn (timestamp > 0 && timestamp <= getLastTimestamp());\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tboolean result = false;\n\tif(timestamp == 0){\n\t\tresult = false;\n\t}else{\n\t\tif(!shouldPrintMessage(timestamp,message)){\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(message==null || message.length()==0){\n\t\treturn false;\n\t}\n\tboolean result=false;\n\tlong lasttime=0;\n\tlong now=System.currentTimeMillis();\n\tif(lasttime!=0){\n\t\tlong diff=now-lasttime;\n\t\tlong diffs=diff*1000;\n\t\tif(diffs>=timestamp){\n\t\t\tresult=true;\n\t\t}\n\t}\n\tif(result){\n\t\tlasttime=now;\n\t\tresult=false;\n\t\t//System.out.println(message);\n\t}\n\treturn result;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(message.startsWith(\"*\") || message.startsWith(\"/\")){\n\t\treturn false;\n\t}\n\tif(!message.startsWith(\"*\") &&!message.startsWith(\"/\")){\n\t\treturn false;\n\t}\n\tint i=message.indexOf(\" \");\n\tif(i<0){\n\t\treturn false;\n\t}\n\tString s=message.substring(0,i);\n\tif(s.contains(\"-\")){\n\t\ts=s.substring(0,s.indexOf(\"-\"));\n\t}\n\tint n=Integer.parseInt(s);\n\tif(n<1){\n\t\treturn false;\n\t}\n\tif(n>timestamp){\n\t\treturn false;\n\t}\n\treturn true;\n}"]}
{"_id": "6367672d1a6d9265ec017c74", "generate_results": ["public boolean remove(int val){\n\tboolean result=false;\n\tfor(int i=0;i<this.size();i++){\n\t\tif((val==this.get(i))){\n\t\t\tresult=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "public boolean remove(int val){\n    if(this.contains(val)){\n        this.remove(val);\n        return true;\n    }\n    return false;\n}", "public boolean remove(int val){\n\treturn this.remove(val);\n}", "public boolean remove(int val){\n\tint i = indexOf(val);\n\tif(i >= 0){\n\t\tremoveAt(i);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\treturn remove(val, val);\n}", "public boolean remove(int val){\n    \n    if(val == 0)\n        return false;\n    \n    if(val > 0)\n        value[val - 1] = 0;\n    \n    count--;\n    \n    return true;\n}", "public boolean remove(int val){\n\tint i=find(val);\n\tif(i>=0){\n\t\tset.remove(i);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public void remove(int val){\n\tset.remove(val);\n}", "public boolean remove(int val){\n\t//\tSystem.out.println(\"Removing value \"+val+\" from set\");\n\tint i;\n\ti=index(val);\n\tif(i>=0){\n\t\tremoveAt(i);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}", "public boolean remove(int val){\n\t\n\tboolean ret = false;\n\t\n\tif(this.contains(val)){\n\t\tthis.remove(val);\n\t\tret = true;\n\t}\n\t\n\treturn ret;\n}"]}
{"_id": "6367672d1a6d9265ec017c78", "generate_results": ["public boolean insert(int val){\n\tif(val >= 0 && val < _set.size()){\n\t\t_set.addElement(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean insert(int val){\n        return set.insert(val);\n    }", "public boolean insert(int val){\n\tif (contains(val)) return false;\t// val already present\n\tset.add(val);\n\treturn true;\n}", "public boolean insert(int val){\n    if (contains(val)) return false;\n    \n    boolean result = false;\n    \n    if (val==0){\n        m_numValues.add(val);\n        result = true;\n    }\n    \n    else if (val==1){\n        m_numValues.add(val);\n        result = true;\n    }\n    \n    else if (val==2){\n        m_numValues.add(val);\n        result = true;\n    }\n    \n    return result;\n}", "public boolean insert(int val){\n\tif(val < 0 || val > this.size()){\n\t\treturn false;\n\t}\n\treturn this.set.add(val);\n}", "public boolean insert(int val){\n\tif(val < 0 || val >= size()) return false;\n\t\n\t// Check if it's already the element\n\tif(val == _val) return true;\n\t\n\t// Insert\n\t_set[size()] = val;\n\t\n\t// Did it make a new element?\n\treturn true;\n}", "public boolean insert(int val){\n\tif(contains(val)) return false;\n\tif(val == 0) return false;\n\t\n\tarr[val] = true;\n\treturn true;\n}", "public boolean insert(int val){\n\tif(val < 0 || val > _set.size()){ return false;}\n\t_set.add(val);\n\treturn true;\n}", "public boolean insert(int val){\n\tif(set.size() <= val) return false;\n\t\n\tset.add(val);\n\treturn true;\n}", "public boolean insert(int val){\n    if (contains(val)) return false;\n    \n    set.add(val);\n    return true;\n}"]}
{"_id": "6367670b1a6d9265ec017a00", "generate_results": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1 == null){\n\t\treturn array2 == null;\n\t}\n\tif(array2 == null){\n\t\treturn array1 == null;\n\t}\n\tint len1 = array1.length;\n\tint len2 = array2.length;\n\tif(len1 == 0){\n\t\treturn len2 == 0;\n\t}\n\tif(len2 == 0){\n\t\treturn len1 == 0;\n\t}\n\treturn len1 == len2;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1 == null){\n\t\treturn array2 == null || array2.length == 0;\n\t}\n\tif(array2 == null){\n\t\treturn array1.length == 0;\n\t}\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\treturn (array1 == null? 0 : array1.length == array2.length)? true : (array1 == null? array2.length == 0 : array1.length == array2.length);\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n    if(array1 == null){\n        return (array2 == null || array2.length == 0);\n    }\n    if(array2 == null){\n        return (array1.length == 0);\n    }\n    return (array1.length == array2.length);\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1==null||array2==null) return true;\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1 == null){\n\t\treturn array2 == null || array2.length == 0;\n\t}\n\telse if(array2 == null){\n\t\treturn array1.length == 0;\n\t}\n\telse{\n\t\tif(array1.length!= array2.length){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0;i < array1.length && i < array2.length;i++){\n\t\t\tif(array1[i]!= array2[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\treturn array1[array1.length - 1] == array2[array2.length - 1];\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\t\n\tif(array1 == null && array2 == null) return true;\n\tif(array1 == null || array2 == null) return false;\n\t\n\tif(array1.length!= array2.length) return false;\n\t\n\tfor(int i = 0; i < array1.length; i++){\n\t\tif(array1[i]!= array2[i]) return false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1==null || array2==null) return true;\n\tif(array1.length==0) return (array2.length==0);\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tfinal int array1Length = array1!=null?array1.length:0;\n\tfinal int array2Length = array2!=null?array2.length:0;\n\tif(array1Length!=array2Length) return false;\n\treturn array1Length==0?array2Length==0:array1Length==array2Length;\n}"]}
{"_id": "636767081a6d9265ec017989", "generate_results": ["public static boolean[] toPrimitive(final Boolean[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\t\n\tfinal boolean[] result = new boolean[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tfinal Boolean element = array[i];\n\t\tresult[i] = (element!= null? Boolean.valueOf(element).booleanValue() : null);\n\t}\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    \n    for (int i=0; i<array.length; i++) {\n        array[i] = null;\n    }\n    return array;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length > 1) {\n\t\t// We have a more complicated case, so must create a customise array\n\t\tboolean[] result = new boolean[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tBoolean boole = array[i];\n\t\t\tresult[i] = (boole == null)? Boolean.FALSE : boole.booleanValue();\n\t\t}\n\t\treturn result;\n\t}\n\t\n\treturn array;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length == 0) return emptyBooleans;\n\t\n\tfinal boolean[] result = new boolean[array.length];\n    for (int i = 0; i < array.length; i++) {\n      final Boolean element = array[i];\n      result[i] = (element!= null? Boolean.valueOf(element).booleanValue() : null);\n    }\n\n    return result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    \n    final boolean[] result = new boolean[array.length];\n    for (int i=array.length; i-->0;) {\n        result[i] = array[i];\n    }\n    return result;\n}", "public static Boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    Boolean[] result = new Boolean[array.length];\n    for (int i=0; i<array.length; i++) {\n        result[i] = array[i];\n    }\n    return result;\n}", "public static Boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n    \n    final Boolean[] result = new Boolean[array.length];\n    for (int i=0; i<array.length; i++) {\n        result[i] = array[i];\n    }\n    \n    return result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    final boolean[] result = new boolean[array.length];\n    for (int i=array.length; i-->0;){\n        result[i] = array[i].booleanValue();\n    }\n    \n    return result;\n}", "public static boolean[] toPrimitive(final Boolean[] array) {\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return emptyArray();\n    }\n    \n    final boolean[] result = new boolean[array.length];\n    for (int i=0; i<array.length; i++) {\n        result[i] = array[i];\n    }\n    \n    return result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n    if (array == null) return null;\n    \n    final boolean[] result = new boolean[array.length];\n    for (int i=0; i<array.length; i++) {\n        result[i] = array[i];\n    }\n    \n    return result;\n}"]}
{"_id": "636766f81a6d9265ec01775c", "generate_results": ["public static String toString(Object obj){\n\tif (obj == null) {\n\t\treturn \"\";\n\t}\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n    return obj == null? EMPTY : obj.toString();\n}", "public static String toString(Object obj){\n    return StringUtils.defaultString(obj);\n}", "public static String toString(Object obj){\n    if (obj == null) {\n        return \"\";\n    }\n    return obj.toString();\n}", "public static String toString(Object obj) {\n    return obj == null? \"null\" : obj.toString();\n}", "public static String toString(Object obj){\n    return obj == null? \"\" : obj.toString();\n}", "public static String toString(Object obj){\n    if(obj == null){\n        return EMPTY_STRING;\n    }\n    return obj.toString();\n}", "public static String toString(Object obj){\n\treturn StringUtils.toString(obj);\n}", "public static String toString(Object obj){\n    return StringUtils.defaultString(obj);\n}", "public static String toString(Object obj){\n  return StringUtils.defaultString(obj);\n}"]}
{"_id": "636766f91a6d9265ec01777f", "generate_results": ["public static boolean toBoolean(Boolean bool){\n    return bool!= null? bool.booleanValue() : false;\n}", "public static boolean toBoolean(Boolean bool){\n  return bool == null? false : bool.booleanValue();\n}", "public static boolean toBoolean(Boolean bool){\n    return bool == null? false : bool.booleanValue();\n}", "public static boolean toBoolean(Boolean bool){\n    return bool!=null?bool:false;\n}", "public static Boolean toBoolean(Boolean bool){\n  return bool!= null? bool : false;\n}", "public static boolean toBoolean(Boolean bool){\n    if (bool==null) return false;\n    return bool;\n}", "public static boolean toBoolean(Boolean bool){\n    return bool == null? false : bool;\n}", "public static boolean toBoolean(Boolean bool){\n    return bool == null? false : bool;\n}", "public static boolean toBoolean(Boolean bool){\n    return bool!= null? bool : false;\n}", "public static Boolean toBoolean(Boolean bool){\n    return bool == null? Boolean.FALSE : bool;\n}"]}
{"_id": "6367670b1a6d9265ec0179ff", "generate_results": ["public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array==null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\tif (array.length==0) {\n\t\treturn array;\n\t}\n\treturn new Byte[array.length];\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\tfinal Byte[] result = new Byte[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null || array.length == 0) return EMPTY_BYTE_ARRAY;\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\t\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\t\n\tif(array == null) return EMPTY_BYTE_ARRAY;\n\tif(array.length == 0) return EMPTY_BYTE_ARRAY;\n\t\n\treturn array;\n\t\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null) return new Byte[0];\n\tif(array.length == 0) return new Byte[0];\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\tif (array.length == 0) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\tfinal int length = array.length;\n\tif (length == 0) {\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\tfinal Byte[] result = new Byte[length];\n\tSystem.arraycopy(array, 0, result, 0, length);\n\treturn result;\n}"]}
{"_id": "6367670a1a6d9265ec0179e8", "generate_results": ["public static Boolean[] nullToEmpty(final Boolean[] array){\n\t if (array == null) return EMPTY_BOOLEAN_ARRAY;\n\t final int length = array.length;\n\t for (int i = 0; i < length; i++) {\n\t\t if (array[i] == null) array[i] = EMPTY_BOOLEAN_ARRAY;\n\t }\n\t return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null) return EMPTY_BOOLEAN_ARRAY;\n\t\n\tfinal int length = array.length;\n\t\n\tif(length == 0) return EMPTY_BOOLEAN_ARRAY;\n\t\n\treturn new Boolean[length];\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif (array==null) return EMPTY_BOOLEANS;\n\tif (array.length==0) return EMPTY_BOOLEANS;\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array) {\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BOOL;\n\t}\n\tif (array.length == 0) {\n\t\treturn array;\n\t}\n\treturn new Boolean[]{array[0]};\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if (array == null) {\n        return EMPTY_BOOLEAN_ARRAY;\n    }\n    final int length = array.length;\n    if (length == 0) {\n        return EMPTY_BOOLEAN_ARRAY;\n    }\n\n    Boolean[] result = new Boolean[length];\n    System.arraycopy(array, 0, result, 0, length);\n    return result;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if (array == null) {\n        return EMPTY_BOOL;\n    }\n    return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n    if (array == null) {\n      return EMPTY_BOOLEANS;\n    }\n    return array;\n  }", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif (array == null) {\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif (array==null) return EMPTY_BOOLEAN_ARRAY;\n\treturn array;\n}"]}
{"_id": "636767031a6d9265ec0178e6", "generate_results": ["public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n\n    final int length = array.length;\n    switch(length){\n        case 0:\n            return null;\n        case 1:\n            return new byte[]{ (byte)array[0] };\n        case 2:\n            return new byte[]{ (byte)(array[0] & 0xFF), (byte)array[1] };\n        case 3:\n            return new byte[]{ (byte)(array[0] & 0xFF), (byte)(array[1] & 0xFF), (byte)array[2] };\n        default:\n            return new byte[][]{\n                    toPrimitive(array[0]),\n                    toPrimitive(array[1]),\n                    toPrimitive(array[2])\n            };\n    }\n}", "public static byte[] toPrimitive(final Byte[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length == 0) return EMPTY_BYTE_ARRAY;\n\t\n\tfinal byte[] result = new byte[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tfinal Byte element = array[i];\n\t\tresult[i] = (element == null)? (byte)NULL_BYTE : element.byteValue();\n\t}\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\tif (array == null) return null;\n\n\tfinal int N = array.length;\n\t\n\tif (N == 0) return null;\n\t\n\tfinal byte[] result = new byte[N];\n\t\n\tfor (int i = 0; i < N; i++) {\n\t\tfinal Byte b = array[i];\n\t\tresult[i] = (b == null)? (byte) 0 : b.byteValue();\n\t}\n\t\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n    \n    final int arrayLen = array.length;\n    if (arrayLen == 0) return null;\n    \n    // Special case: the result is a zero length array, return as is\n    if (arrayLen == 1) return array;\n    \n    final byte[] result = new byte[arrayLen];\n    for (int i=0; i<arrayLen; i++){\n        final Byte b = array[i];\n        result[i] = (b == null)? (byte)0 : b.byteValue();\n    }\n    \n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_BYTE_ARRAY;\n    \n    final byte[] result = new byte[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Byte element = array[i];\n        if (element == null) continue;\n        result[i] = element.byteValue();\n    }\n    \n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n    final byte[] result = new byte[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Byte element = array[i];\n        result[i] = (element == null)? (byte)0 : element.byteValue();\n    }\n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n    final byte[] result = new byte[array.length];\n    for (int i=0; i<array.length; i++) {\n        Byte b = array[i];\n        result[i] = (b == null)? (byte)NULL_BYTE : b.byteValue();\n    }\n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n    \n    final byte[] result = new byte[array.length];\n    for (int i = 0; i < array.length; i++) {\n        Byte b = array[i];\n        result[i] = (b == null? null : b.byteValue());\n    }\n    \n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n    if (array == null) return null;\n    \n    if (array.length == 0) return EMPTY_BYTE_ARRAY;\n\n    final byte[] result = new byte[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Byte", "public static byte[] toPrimitive(final Byte[] array){\n        if (array == null) return null;\n        \n        final int length = array.length;\n        \n        if (length == 0) return EMPTY_BYTE_ARRAY;\n        \n        if (array.length == 1) return new byte[]{ array[0] };\n        \n        final byte[] result = new byte[ length ];\n        \n        for (int i = 0; i < length; i++){\n                result[i] = array[i];\n        }\n        \n        return result;\n    }"]}
{"_id": "636767001a6d9265ec017873", "generate_results": ["public static String reverse(final String str){\n\tif(str == null){\n\t\treturn null;\n\t}\n\tfinal StringBuilder sb = new StringBuilder(str);\n\tsb.reverse();\n\treturn sb.toString();\n}", "public static String reverse(final String str){\n\tif (str == null){\n\t\treturn null;\n\t}\n\treturn new StringBuilder(str).reverse().toString();\n}", "public static String reverse(final String str){\n\tif (str == null) return null;\n\tif (str.length() == 0) return EMPTY;\n\t\n\tStringBuilder sb = new StringBuilder(str);\n\tsb.reverse();\n\treturn sb.toString();\n}", "public static String reverse(final String str){\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    final char[] cs = str.toCharArray();\n    for (int i = cs.length - 1; i >= 0; i--) {\n        final char ch = cs[i];\n        sb.append(Character.toLowerCase(ch));\n        sb.append(ch);\n    }\n    return sb.reverse();\n}", "public static String reverse(final String str){\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tfinal StringBuilder buf = new StringBuilder();\n\tint start = 0;\n\tint end = str.length();\n\twhile(end > 0){\n\t\tbuf.append(str.charAt(end-1));\n\t\tend--;\n\t}\n\treturn buf.reverse().toString();\n}", "public static String reverse(final String str){\n\tif (str == null) {\n\t\treturn null;\n\t}\n\treturn new StringBuilder(str).reverse().toString();\n}", "public static String reverse(final String str){\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    int currentIndex = 0;\n    int length = str.length();\n    for(int i = 0; i < length; i++){\n        char c = str.charAt(i);\n        sb.append(c);\n        \n        if (i < length - 1){\n            sb.append(str.charAt(i + 1));\n        }\n        \n        if (c == '\\n' || c == '\\r'){\n            sb.append(c);\n        }\n        \n        if (currentIndex == 0){\n            currentIndex = i + 1;\n        }\n    }\n    sb.reverse();\n    return sb.toString();\n}", "public static String reverse(final String str){\n    if (str == null){\n        return null;\n    }\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] chars = str.toCharArray();\n    StringBuilder result = new StringBuilder(str.length());\n    for (char c : chars){\n        result.append(c);\n    }\n    return result.reverse();\n}", "public static String reverse(final String str){\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder(str);\n    final char[] chs = sb.toString().toCharArray();\n    final char ch;\n    final int start = 0;\n\n    while (start < chs.length){\n        ch = chs[--start];\n        switch (ch){\n            case '\\t' :\n                sb.reverse();\n                break;\n            case '\\n' :\n                sb.insert(0, 't');\n                sb.insert(sb.length() - 2, 'b');\n                sb.insert(sb.length() - 1, 'a');\n                break;\n            default :\n                sb.insert(0, ch);\n        }\n    }\n    return sb.toString();\n}", "public static String reverse(final String str){\n\tif (str == null)\n\t\treturn null;\n\tfinal int len = str.length();\n\tfinal char[] buf = new char[len];\n\tfinal StringBuilder sb = new StringBuilder(len);\n\tfor (int i = 0; i < len; i++){\n\t\tfinal char ch = str.charAt(i);\n\t\tif (ch == '\\n'){\n\t\t\tsb.append(ch);\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\tbuf[i] = ch;\n\t\t}\n\t}\n\tsb.reverse();\n\treturn new String(buf);\n}"]}
{"_id": "636766ff1a6d9265ec01784b", "generate_results": ["public static boolean isDigits(String str){\n\tif (str == null) return false;\n\tif (str.length() == 0) return false;\n\t\n\tif (str.charAt(0) == '-') return false;\n\t\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tchar ch = str.charAt(i);\n\t\tif (Character.isDigit(ch)) return false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isDigits(String str){\n\t\treturn (isDigits0(str) || isDigits1(str));\n\t}", "public static boolean isDigits(String str){\n    for (int i = 0; i < str.length(); i++){\n        if (Character.isDigit(str.charAt(i)))\n            return false;\n    }\n    return true;\n}", "public static boolean isDigits(String str){\n  if (str == null) return false;\n  if (str.length() == 0) return false;\n\n  for (int i = 0; i < str.length(); i++) {\n    if (Character.isDigit(str.charAt(i)) == false) return false;\n  }\n  return true;\n}", "public static boolean isDigits(String str){\n    if (null == str || str.length() == 0)\n        return false;\n    char[] chars = str.toCharArray();\n    int count = 0;\n    for (int i = 0; i < chars.length; i++) {\n        if (!Character.isDigit(chars[i]))\n            return false;\n        count++;\n    }\n    if (count == chars.length)\n        return true;\n    return false;\n}", "public static boolean isDigits(String str){\n    if (str == null) {\n        return false;\n    }\n    int len = str.length();\n    if (len < 1) {\n        return false;\n    }\n    for (int i = 0; i < len; i++){\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return false;\n        }\n    }\n    return true;\n}", "public static boolean isDigits(String str){\n    if (str == null || str.length() == 0) {\n        return false;\n    }\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        if (!Character.isDigit(str.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}", "public static boolean isDigits(String str){\n\t\n\tif (str == null) return false;\n\t\n\ttry {\n\t\tInteger.parseInt(str);\n\t\treturn true;\n\t}\n\tcatch (NumberFormatException e){\n\t\treturn false;\n\t}\n\t\n}", "public static boolean isDigits(String str){\n\tif(str==null || str.length()==0)\n\t\treturn false;\n\tint len = str.length();\n\tfor(int i=0;i<len;i++){\n\t\tif(Character.isDigit(str.charAt(i))==false)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str) {\n  return isDigits(str, 0);\n}"]}
{"_id": "6367670c1a6d9265ec017a35", "generate_results": ["/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if(str == null) return false;\n    if(suffix == null) return false;\n    if(ignoreCase) return str.endsWith(suffix);\n    else return str.startsWith(suffix);\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n  if (str==null) return false;\n  final int index=str.indexOf(suffix);\n  return (index>=0)?index<str.length()-suffix.length():false;\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str == null){ return false;}\n\tif(suffix == null){ return false;}\n\tfinal int length = str.length();\n\tif(length == 0){ return true;}\n\tif(ignoreCase){\n\t\treturn str.endsWith(suffix);\n\t}\n\telse{\n\t\treturn str.indexOf(suffix,length-suffix.length())!= -1;\n\t}\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if (str == null){\n        return false;\n    }\n    if (suffix == null){\n        return false;\n    }\n    return str.endsWith(suffix);\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if(ignoreCase){\n        return str!= null && str.endsWith(suffix);\n    }\n    else{\n        return str!= null && str.endsWith(suffix);\n    }\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str == null) return false;\n\tif(suffix == null) return false;\n\tif(str.length() == 0) return false;\n\tif(ignoreCase) {\n\t\treturn str.endsWith(suffix);\n\t} else {\n\t\treturn str.endsWith(suffix.toLowerCase());\n\t}\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str == null) {\n\t\treturn false;\n\t}\n\tfinal int len=str.length();\n\tfinal int suffixLen=suffix == null? 0 : suffix.length();\n\t\n\tif(len < suffixLen){\n\t\treturn false;\n\t}\n\t\n\treturn str.endsWith(suffix,ignoreCase);\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    return endsWith(str, suffix, ignoreCase, null, ignoreCase);\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if (str == null) return ignoreCase;\n    int len = str.length();\n    if (suffix == null) return (len >= len - 1);\n    if (ignoreCase) {\n        return str.regionMatches(ignoreCase, 0, suffix, 0, suffix.length());\n    }\n    return str.endsWith(suffix);\n}", "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if (str == null) return false;\n    if (suffix == null) return str.endsWith(null);\n    if (ignoreCase) return str.endsWithIgnoreCase(suffix);\n    return str.endsWith(suffix);\n}"]}
{"_id": "636766f11a6d9265ec017651", "generate_results": ["public static Character[] nullToEmpty(final Character[] array){\n    if (array == null) return EMPTY_CHARACTER_ARRAY;\n    if (array.length == 0) return EMPTY_CHARACTER_ARRAY;\n    final Character[] result = newCharacterArray(array);\n    Arrays.fill(result, (Character) null);\n    return result;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null) {\n\t\treturn EMPTY_CHARACTER_ARRAY;\n\t}\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null){\n\t\treturn EMPTY_CHARACTER_ARRAY;\n\t}\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array==null) return new Character[0];\n\tif (array.length==0) return EMPTY_CHARACTER_ARRAY;\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null) {\n\t\treturn EMPTY_CHARACTER_ARRAY;\n\t}\n\tif (array.length == 0) {\n\t\treturn array;\n\t}\n\treturn new Character[array.length];\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array==null) return EMPTY_CHARACTER_ARRAY;\n\tfinal int length = array.length;\n\tif (length==0) return EMPTY_CHARACTER_ARRAY;\n\t\n\t/**\n\t * @return empty array (of the same length)\n\t */\n\tfinal Character[] result = new Character[length];\n\tSystem.arraycopy(array, 0, result, 0, length);\n\treturn result;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null) return EMPTY_CHARACTER_ARRAY;\n\tif (array.length == 0) return EMPTY_CHARACTER_ARRAY;\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n  if (array == null){\n    return EMPTY_CHARACTER_ARRAY;\n  }\n  return array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null) return EMPTY_CHARACTER_ARRAY;\n\tint i = 0;\n\tif(array.length > 0) return array;\n\treturn new Character[0];\n}", "public static Character[] nullToEmpty(final Character[] array){\n\tif (array == null) {\n\t\treturn EMPTY_CHARACTER_ARRAY;\n\t}\n\tif (array.length == 0) {\n\t\treturn EMPTY_CHARACTER_ARRAY;\n\t}\n\treturn array;\n}"]}
{"_id": "636767021a6d9265ec0178bb", "generate_results": ["public static Double[] nullToEmpty(final Double[] array){\n\tif(array == null) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal int length = array.length;\n\tif(length == 0) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif (array == null) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif (array == null) return EMPTY_DOUBLE_ARRAY;\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif(array==null) return EMPTY_DOUBLE_ARRAY;\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\t if(array == null) return EMPTY_DOUBLE_ARRAY;\n\t else return array;\n  }", "public static Double[] nullToEmpty(final Double[] array){\n\tif (array == null) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif (array.length == 0) {\n\t\treturn new Double[0];\n\t}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n    if (array == null) {\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    return array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\tif (array == null) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif (array.length == 0) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\treturn array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n    if (array == null) {\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    final int length = array.length;\n    if (length == 0) {\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    final Double[] result = new Double[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = array[i];\n    }\n    return result;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\t\n\tif (array == null) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\n\tif (array.length == 0) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\n\treturn array;\n}"]}
{"_id": "636766f01a6d9265ec01762e", "generate_results": ["public static boolean isEmpty(final double[] array){\n    return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n\treturn array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n  return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    if (array!= null){\n        return array.length == 0;\n    } else {\n        return true;\n    }\n}", "public static boolean isEmpty(final double[] array){\n    return array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n    return (array == null) || (array.length == 0);\n}", "public static boolean isEmpty(final double[] array){\n    return (array == null || array.length == 0);\n}"]}
{"_id": "636766f21a6d9265ec017677", "generate_results": ["public static boolean isNotTrue(Boolean bool){\n    if (bool == null) {\n        return true;\n    }\n    return!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n    return!isNotTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n    return!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n  return bool!= null && bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n    return bool!= null && bool.booleanValue()==false;\n}", "public static boolean isNotTrue(Boolean bool){\n    return bool!= null &&!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n    if (bool==null) return true;\n    return!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n    return bool!= null &&!bool.booleanValue();\n}", "public static boolean isNotTrue(Boolean bool){\n\treturn bool!=null?!bool.booleanValue(): true;\n}", "public static boolean isNotTrue(Boolean bool){\n    return bool!= null && bool.booleanValue()==true;\n}"]}
{"_id": "636766ff1a6d9265ec017842", "generate_results": ["public static double[] toPrimitive(final Double[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    final int length = array.length;\n    final boolean isLong = Long.class.equals(array.getClass().getComponentType());\n    final boolean isDouble = Double.class.equals(array.getClass().getComponentType());\n    \n    if (isLong || isDouble){\n        final double[] result = new double[length];\n        for (int i = 0; i < length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n    \n    if (isDouble){\n        final double[] result = new double[length];\n        for (int i = 0; i < length; i++){\n            result[i] = array[i];\n        }\n        return result;\n    }\n    \n    return null;\n}", "public static Double[] toPrimitive(final Double[] array){\n    if (array == null) return null;\n    \n    final int length = array.length;\n    Double[] result = new Double[length];\n    for (int i=0; i<length; i++){\n        result[i] = array[i];\n    }\n    return result;\n}", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) return null;\n    \n    final int length = array.length;\n    final double[] data = new double[ length ];\n    for (int i = 0; i < length; i++) {\n        data[ i ] = array[ i ];\n    }\n    return data;\n}", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) return null;\n    \n    final int size = array.length;\n    \n    switch(size){\n        case 0:\n            return null;\n        case 1:\n            final double value = array[0];\n            return new double[]{ value };\n        default:\n            double[] array2 = new double[size];\n            System.arraycopy(array, 0, array2, 0, size);\n            return array2;\n    }\n}", "public static double[] toPrimitive(final Double[] array){\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\tfinal int length = array.length;\n\t\n\tswitch(length){\n\t\tcase 0:\n\t\t\treturn null;\n\t\t\t\n\t\tcase 1:\n\t\t\treturn new double[]{array[0]};\n\t\t\t\n\t\tdefault:\n\t\t\tdouble[] result = new double[length];\n\t\t\tfor(int i = 0; i < length; i++) {\n\t\t\t\tresult[i] = array[i];\n\t\t\t}\n\t\t\treturn result;\n\t}\n}", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) return null;\n    \n    final int len = array.length;\n    final double[] data = new double[ len ];\n    \n    for ( int i = 0; i < len; i++ ) {\n      final Double d = array[ i ];\n      if ( d == null ) {\n        data[ i ] = null;\n      } else {\n        data[ i ] = Double.doubleToRawLongBits( d );\n      }\n    }\n    \n    return data;\n  }", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    final int length = array.length;\n    final double[] result = new double[length];\n    for (int i=0; i<length; i++){\n        final Double element = array[i];\n        result[i] = (element == null)? Double.valueOf(0) : element;\n    }\n    \n    return result;\n}", "public static double[] toPrimitive(final Double[] array){\n        if (array == null) return null;\n        final int size = array.length;\n        \n        switch (size){\n            case 0:\n                return null;\n            case 1:\n                final double element = array[0];\n                \n                switch (element){\n                    case 0.0:\n                        return new double[] {};\n                    case 1.0:\n                        return new double[] {1};\n                    case -1.0:\n                        return new double[] {-1};\n                    case -2.0:\n                        return new double[] {-2};\n                    case -3.0:\n                        return new double[] {-3};\n                    case Double.POSITIVE_INFINITY:\n                        return new double[] {Double.NEGATIVE_INFINITY};\n                    case Double.NEGATIVE_INFINITY:\n                        return new double[] {Double.POSITIVE_INFINITY};\n                    case Double.NEGATIVE_INFINITY:\n                        return new double[] {-Double.POSITIVE_INFINITY};\n                    default:\n                        return new double[] {};\n                }\n            default:\n                final double[] result = new double[size];\n                for (int i=0; i<size; i++) {\n                    result[i] = array[i];\n                }\n                return result;\n        }\n    }", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) return null;\n    \n    final int length = array.length;\n    final double[] rtn = new double[length];\n    for (int i=0; i<length; i++){\n        rtn[i] = array[i];\n    }\n    \n    return rtn;\n}", "public static double[] toPrimitive(final Double[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    final int length = array.length;\n    final double[] newArray = new double[ length ];\n    for ( int i = 0; i < length; i++ ) {\n        final Double element = array[ i ];\n        if (element == null) {\n            newArray[ i ] = null;\n        } else {\n            newArray[ i ] = Double.valueOf( element );\n        }\n    }\n    return newArray;\n}"]}
{"_id": "6367670a1a6d9265ec0179cf", "generate_results": ["public static char toChar(final Character ch,final char defaultValue){\n  if(ch==null){\n    return defaultValue;\n  }\n  else{\n    return ch.charValue();\n  }\n}", "public static char toChar(final Character ch,final char defaultValue){\n    if (ch == null) {\n        return defaultValue;\n    }\n    return ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch==null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n  if (ch == null){\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch == null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif (ch == null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\treturn toChar(ch, defaultValue.toChar());\n}", "public static char toChar(final Character ch,final char defaultValue){\n\tif (ch == null) {\n\t\treturn defaultValue;\n\t} else {\n\t\treturn ch.charValue();\n\t}\n}", "public static char toChar(final Character ch,final char defaultValue){\n  if (null == ch){\n    return defaultValue;\n  }\n  return ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n  if(ch == null){\n    return defaultValue;\n  }\n  return ch.charValue();\n}"]}
{"_id": "636767081a6d9265ec0179a2", "generate_results": ["/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}", "/** \n * <p>Utility method for  {@link #createNumber(String)}"]}
{"_id": "636766f21a6d9265ec01767d", "generate_results": ["public static String toString(Object object){\n\t\n\tif(object == null){\n\t\treturn null;\n\t}\n\t\n\tif(object instanceof String){\n\t\treturn (String)object;\n\t}else{\n\t\treturn object.toString();\n\t}\n}", "public static String toString(Object object){\n\tif (object == null) {\n\t\treturn \"null\";\n\t}\n\treturn object.toString();\n}", "public static String toString(Object object){\n\tif(object == null){\n\t\treturn null;\n\t}\n\tif(object instanceof String){\n\t\treturn (String)object;\n\t}\n\treturn object.toString();\n}", "public static String toString(Object object){\n  if (object == null) return null;\n  return object.toString();\n}", "public static String toString(Object object){\n\tif(object ==null) return \"\";\n\tif(object instanceof String) return (String)object;\n\treturn object.toString();\n}", "public static String toString(Object object){\n\tif(object == null)\n\t\treturn null;\n\tif(object instanceof String)\n\t\treturn (String) object;\n\telse\n\t\treturn object.toString();\n}", "public static String toString(Object object){\n\tif(object == null){\n\t\treturn \"\";\n\t}\n\telse{\n\t\treturn object.toString();\n\t}\n}", "public static String toString(Object object){\n\tif(object == null){\n\t\treturn null;\n\t}\n\t\n\treturn object.toString();\n}", "public static String toString(Object object){\n\tif(object == null){\n\t\treturn \"\";\n\t}\n\treturn object.toString();\n}", "public static String toString(Object object){\n    if(object == null){\n        return null;\n    }\n    if(object instanceof String){\n        return (String)object;\n    }\n    return null;\n}"]}
{"_id": "6367670c1a6d9265ec017a2a", "generate_results": ["public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] result = new int[array.length];\n    for (int i=0; i<array.length; i++){\n        result[i] = array[i];\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] newArray = new int[array.length];\n    for (int i=0; i<array.length; i++){\n        newArray[i] = array[i];\n    }\n    return newArray;\n}", "public static int[] toPrimitive(final Integer[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\t\n\tint[] result = new int[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tObject o = array[i];\n\t\tif(o==null){\n\t\t\tresult[i] = 0;\n\t\t}\n\t\telse if(o instanceof Integer){\n\t\t\tresult[i] = ((Integer)o).intValue();\n\t\t}\n\t\telse if(o instanceof Short){\n\t\t\tresult[i] = ((Short)o).intValue();\n\t\t}\n\t\telse if(o instanceof Byte){\n\t\t\tresult[i] = ((Byte)o).intValue();\n\t\t}\n\t\telse if(o instanceof Long){\n\t\t\tresult[i] = ((Long)o).intValue();\n\t\t}\n\t\telse if(o instanceof Double){\n\t\t\tresult[i] = ((Double)o).intValue();\n\t\t}\n\t\telse if(o instanceof Float){\n\t\t\tresult[i] = ((Float)o).intValue();\n\t\t}\n\t\telse if(o instanceof BigDecimal){\n\t\t\tBigDecimal bd = (BigDecimal)o;\n\t\t\tresult[i] = bd.intValue();\n\t\t}\n\t\telse if(o instanceof BigInteger){\n\t\t\tBigInteger bi = (BigInteger)o;\n\t\t\tresult[i] = bi.intValue();\n\t\t}\n\t\telse if(o instanceof String){\n\t\t\tString s = (String)o;\n\t\t\tint len = s.length();\n\t\t\tbyte[] bytes = new byte[len];\n\t\t\tfor(int j=0; j<len; j++){\n\t\t\t\tbytes[j] = (byte)s.charAt(j);\n\t\t\t}\n\t\t\tresult[i] = bytes;\n\t\t}\n\t\telse if(o instanceof Object[]){\n\t\t\tObject[] a = (Object[])o;\n\t\t\tint len = a.length;\n\t\t\tif(len == 0){\n\t\t\t\tresult[i] = 0;\n\t\t\t}\n\t\t\telse if(len == 1){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t}\n\t\t\telse if(len == 2){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t\tresult[i+1] = toPrimitive(a[1]);\n\t\t\t}\n\t\t\telse if(len == 3){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t\tresult[i+1] = toPrimitive(a[1]);\n\t\t\t\tresult[i+2] = toPrimitive(a[2]);\n\t\t\t}\n\t\t\telse if(len == 4){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t\tresult[i+1] = toPrimitive(a[1]);\n\t\t\t\tresult[i+2] = toPrimitive(a[2]);\n\t\t\t\tresult[i+3] = toPrimitive(a[3]);\n\t\t\t}\n\t\t\telse if(len == 5){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t\tresult[i+1] = toPrimitive(a[1]);\n\t\t\t\tresult[i+2] = toPrimitive(a[2]);\n\t\t\t\tresult[i+3] = toPrimitive(a[3]);\n\t\t\t\tresult[i+4] = toPrimitive(a[4]);\n\t\t\t}\n\t\t\telse if(len == 6){\n\t\t\t\tresult[i] = toPrimitive(a[0]);\n\t\t\t\tresult[i+1] = toPrimitive(a[1]);\n\t\t\t\tresult[i+2] = toPrimitive(a[2]);\n\t\t\t\tresult[i+3] = toPrimitive(a[3]);\n\t\t\t\tresult[i+4] = toPrimitive(a[4]);\n\t\t\t\tresult[i+5] = toPrimitive(a[5]);\n\t\t\t}\n\t\t\telse if", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] result = new int[array.length];\n    for (int i=0; i<array.length; i++){\n        final Integer element = array[i];\n        if (element == null) result[i] = 0;\n        else result[i] = element.intValue();\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int count = array.length;\n    int[] result = new int[count];\n    \n    for (int i = 0; i < count; i++) {\n        result[i] = array[i];\n    }\n    \n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] newArray = new int[array.length];\n    for (int i=0; i<array.length; i++){\n        newArray[i] = array[i];\n    }\n    return newArray;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_INT_ARRAY;\n    \n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer element = array[i];\n        result[i] = (element == null)? 0 : element.intValue();\n    }\n    \n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] result = new int[array.length];\n    for (int i=0; i<array.length; i++){\n        //check array\n        if (array[i] == null) throw new NullPointerException(\"PrimitiveArrayToPrimitive: no input array\");\n        \n        //check range\n        if (array[i] < 0) throw new IllegalArgumentException(\"PrimitiveArrayToPrimitive: negative index\");\n        \n        //check content\n        if (array[i] > Integer.MAX_VALUE) throw new IllegalArgumentException(\"PrimitiveArrayToPrimitive: array element is too large\");\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = array[i];\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n    if (array == null) return null;\n    int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = array[i];\n    }\n    return result;\n}"]}
{"_id": "636766fa1a6d9265ec01779d", "generate_results": ["public static boolean isAsciiControl(final char ch){\n    return (ch>=65 && ch<=90) || ch==127;\n}", "public static boolean isAsciiControl(final char ch){\n  if(ch == '\\n'){\n    return false;\n  }\n  if(ch < 32 || ch > 127){\n    return false;\n  }\n  return true;\n}", "public static boolean isAsciiControl(final char ch){\n  return (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '-');\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch <= 0x7F) || ((ch >= 0xFF) && (ch <= 0x7F + 32));\n}", "public static boolean isAsciiControl(final char ch){\n  return ch >='' && ch <= 127;\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch <= 127);\n}", "public static boolean isAsciiControl(final char ch){\n\treturn ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '-' || ch == '+' || ch == '\\\\' || ch == 0;\n}", "public static boolean isAsciiControl(final char ch){\n  if(ch=='a') return true;\n  return ch<32 || ch>127;\n}", "public static boolean isAsciiControl(final char ch){\n  return ch <= 127;\n}", "public static boolean isAsciiControl(final char ch){\n\treturn (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == 0x00;\n}"]}
{"_id": "636766fa1a6d9265ec017796", "generate_results": ["public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n\n    final Boolean[] result = new Boolean[array.length];\n\n    for (int i=0; i<array.length; i++){\n        result[i] = Boolean.valueOf(array[i]);\n    }\n\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n    final Boolean[] result = new Boolean[array.length];\n    for (int i=0; i<array.length; i++){\n        result[i] = array[i]? Boolean.TRUE : Boolean.FALSE;\n    }\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n\n    final Boolean[] result = new Boolean[array.length];\n\n    for (int i=0; i<array.length; i++){\n        result[i] = array[i]? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\t\n\tBoolean[] result = new Boolean[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = Boolean.valueOf(array[i]);\n\t}\n\treturn result;\t\n}", "public static Boolean toObject(final boolean[] array){\n    if (array == null) return null;\n\n    Boolean result = null;\n\n    if (array.length > 0) {\n        result = Boolean.valueOf(array[0]);\n    }\n\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n    \n    final Boolean[] result = new Boolean[array.length];\n    \n    for (int i=0; i<array.length; i++){\n        result[i] = Boolean.valueOf(array[i]);\n    }\n    \n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    Boolean[] resultArray = null;\n    \n    if (array.length > 0){\n        resultArray = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++){\n            resultArray[i] = new Boolean(array[i]);\n        }\n    }\n    \n    return resultArray;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n    if (array.length == 0) return (Boolean[]) null;\n    \n    Boolean[] result = new Boolean[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = new Boolean(array[i]);\n    }\n    return result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length == 0) return new Boolean[0];\n\n\tBoolean[] result = new Boolean[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i];\n\t}\n\t\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n    final Boolean[] result = new Boolean[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = Boolean.valueOf(array[i]);"]}
{"_id": "6367670a1a6d9265ec0179f1", "generate_results": ["public static Short[] toObject(final short[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_SHORT_ARRAY;\n    final Short[] result = new Short[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = new Short(array[i]);\n    }\n    return result;\n}", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length == 0) return null;\n\t\n\treturn new Short[array.length];\n}", "public static Double[] toObject(final short[] array){\n\t\n\tif (array == null) return null;\n\t\n\tDouble[] result = null;\n\t\n\t// No NULL checks or casting...\n\t// Allocate the result, copy the array into it.\n\t// The original array is not changed.\n\tresult = new Double[array.length];\n\tSystem.arraycopy(array, 0, result, 0, array.length);\n\t\n\treturn result;\n\t\n}", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return (Short[])null;\n\t\n\tshort[] newArray = new short[array.length];\n\t\n\tfor (int i = 0; i < array.length; i++) {\n\t\tnewArray[i] = array[i];\n\t}\n\t\n\treturn newArray;\n}", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\n\tfinal Short[] vector = new Short[array.length];\n\tfor (int i = 0; i < array.length; i++) vector[i] = new Short(array[i]);\n\treturn vector;\n}", "public static Short[] toObject(final short[] array){\n    if (array == null) return null;\n    \n    if (array.length == 0) return null;\n    \n    Short[] result = new Short[array.length];\n    for (int i = 0; i < array.length; i++){\n        result[i] = new Short(array[i]);\n    }\n    return result;\n}", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_SHORT_ARRAY;\n\treturn array;\n}", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_SHORT_ARRAY;\n\t\n\tfinal Short[] result = new Short[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = Short.value", "public static Short[] toObject(final short[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return null;\n\t\n\tfinal Short[] result = new Short[array.length];\n\tfor (int i=0; i<array.length; i++) result[i] = new Short(array[i]);\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\t\n\tif (array == null) return null;\n\t\n\tShort[] result = null;\n\t\n\tif (array.length > 0){\n\t\t\n\t\tresult = new Short[array.length];\n\t\t\n\t\tfor (int i = 0; i < array.length; i++){\n\t\t\t\n\t\t\tresult[i] = new Short(array[i]);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn result;\n\t\n}"]}
{"_id": "636766fe1a6d9265ec017838", "generate_results": ["public static char[] toPrimitive(final Character[] array){\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_CHAR_ARRAY;\n    }\n    final char[] result = new char[array.length];\n    for (int i=0; i<array.length; i++) {\n        final char value = array[i];\n        result[i] = (value < 256)? value : (value > 255)? 255 : (value < 10)? 10 : 16;\n    }\n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) return null;\n    \n    if (array.length == 0) return EMPTY_CHAR;\n    \n    final char[] result = new char[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Character element = array[i];\n        result[i] = element!= null? (char) element.charValue() : 0;\n    }\n    \n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_CHAR_ARRAY;\n    }\n    final char[] result = new char[array.length];\n    for (int i=0; i<array.length; i++) {\n        final Character element = array[i];\n        result[i] = (element == null)? null : element.charValue();\n    }\n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n\tif (array == null) return null;\n\t\n\tchar[] arrayCopy = new char[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tarrayCopy[i] = array[i];\n\t}\n\treturn arrayCopy;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) return null;\n    \n    final char[] arrayCopy = new char[array.length];\n    for (int i=0; i<array.length; i++) {\n        arrayCopy[i] = array[i];\n    }\n    return arrayCopy;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) return null;\n    \n    final char[] result = new char[array.length];\n    for (int i=0; i<array.length; i++) {\n        final Character c = array[i];\n        result[i] = (c == null)? null : c.charValue();\n    }\n    \n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_CHAR_ARRAY;\n    }\n    final char[] result = new char[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = array[i];\n    }\n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n    if (array == null) return null;\n    if (array.length == 0) return EMPTY_CHAR_ARRAY;\n    \n    final char[] result = new char[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Character element = array[i];\n        result[i] = (element == null? EMPTY_CHAR : element.charValue());\n    }\n    return result;\n}", "public static char[] toPrimitive(final Character[] array){\n\tif (array == null) return null;\n\t\n\tif (array.length == 0) return new char[0];\n\t\n\tfinal char[] result = new char[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tfinal Character element = array[i];\n\t\tresult[i] = (element == null)? null : element.charValue();\n\t}\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\tif (array.length == 0) {\n\t\treturn EMPTY_CHAR_ARRAY;\n\t}\n\n\tfinal char[] data = new char[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tfinal Character element = array[i];\n\t\tif (element == null) {\n\t\t\tdata[i] = null;\n\t\t} else {\n\t\t\tdata[i] = element.charValue();\n\t\t}\n\t}\n\treturn data;\n}"]}
{"_id": "636767041a6d9265ec01790f", "generate_results": ["public static Integer[] toObject(final int[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0) {\n\t\treturn null;\n\t}\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n    if (array == null) return null;\n    if (array.length == 0) return null;\n    \n    Integer[] result = new Integer[array.length];\n    for (int i = 0; i < array.length; i++){\n        result[i] = Integer.valueOf(array[i]);\n    }\n    \n    return result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return null;\n\treturn toObject(array[0]);\n}", "public static Integer[] toObject(final int[] array){\n    if (array == null) return null;\n    \n    Integer[] result = new Integer[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = new Integer(array[i]);\n    }\n    return result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return (Integer[])null;\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor (int i = 0; i < array.length; i++)\n\t\tresult[i] = Integer.valueOf(array[i]);\n\t\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\t\n\tInteger[] result = new Integer[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return null;\n\t\n\tfinal Integer[] result = new Integer[array.length];\n\t\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\t\n\treturn result;\n}"]}
{"_id": "636766fa1a6d9265ec0177a4", "generate_results": ["public static Double[] toObject(final double[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_DOUBLE_ARRAY; //special case\n\tfinal Double[] result = new Double[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = Double.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\t\n\tif (array == null) return null;\n\t\n\tfinal Double[] result = new Double[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n    if (array == null) return null;\n    \n    Double[] result = new Double[array.length];\n    for (int i=0; i<array.length; i++){\n        result[i] = new Double(array[i]);\n    }\n    return result;\n}", "public static Double[] toObject(final double[] array){\n\tif (array == null) return null;\n\tif (array.length == 0) return EMPTY_DOUBLE_ARRAY;\n\t\n\tfinal Double[] result = new Double[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = new Double(array[i]);\n\t}\n\t\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\tif(array == null) return null;\n\t\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n    if (array == null) return null;\n    final int length = array.length;\n    if (length == 0) return new Double[0];\n    \n    final Double[] result = new Double[length];\n    for (int i = 0; i < length; i++){\n        result[i] = new Double(array[i]);\n    }\n    return result;\n}", "public static Double[] toObject(final double[] array){\n    if (array == null) return null;\n    final Double[] result = new Double[array.length];\n    for (int i=0; i<array.length; i++){\n        result[i] = Double.valueOf(array[i]);\n    }\n    return result;\n}", "public static Double[] toObject(final double[] array){\n\tif (array == null) return null;\n\treturn toObject(array.length, array);\n}", "public static Double[] toObject(final double[] array){\n    if (array == null) return null;\n    final Double[] result = new Double[array.length];\n    for (int i = 0; i < array.length; i++) {\n        result[i] = new Double(array[i]);\n    }\n    return result;\n}", "public static Double[] toObject(final double[] array){\n\tif(array == null){\n\t\treturn null;\n\t}\n\t\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}"]}
{"_id": "636767151a6d9265ec017b6b", "generate_results": ["/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str == null){\n\t\treturn false;\n\t}\n\tif(prefix == null){\n\t\treturn str.startsWith(null);\n\t}\n\treturn str.startsWith(prefix) && ignoreCase?\n\t\tstr.toLowerCase().startsWith(prefix.toLowerCase()) : str.startsWith(prefix);\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif (str==null || str.length()<1) return false;\n\tif (prefix==null) prefix=\"\";\n\treturn str.startsWith(prefix);\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif (ignoreCase){\n\t\tif (prefix == null || prefix.length() == 0) return (str!= null && str.startsWith(null));\n\t\tif (prefix.length() == 0) return (str!= null && str.startsWith(null));\n\t\treturn str.startsWith(prefix);\n\t}\n\telse{\n\t\treturn str.startsWith(prefix);\n\t}\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str == null){\n\t\treturn false;\n\t}\n\n\tif(prefix == null){\n\t\treturn str.startsWith(null);\n\t}\n\n\tif(ignoreCase){\n\t\treturn str.startsWith(prefix);\n\t}\n\telse{\n\t\treturn str.startsWith(prefix);\n\t}\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n    if (ignoreCase){\n        return (str.toLowerCase().startsWith(prefix.toLowerCase()));\n    }\n    return (str.toLowerCase().startsWith(prefix));\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n  if(str==null) return false;\n  return prefix==null || str.startsWith(prefix);\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\t\n\tif(str == null) return false;\n\t\n\tfinal int start = str.toLowerCase().indexOf(prefix.toLowerCase());\n\treturn (start >= 0)? (start == 0) : ignoreCase;\n\t\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n    if (str == null) {\n        return false;\n    }\n    if (prefix == null || prefix.length() == 0) {\n        return true;\n    }\n    if (ignoreCase) {\n        return str.startsWith(prefix);\n    } else {\n        return str.startsWith(prefix);\n    }\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n    if(str == null){\n        return false;\n    }\n    if(str.startsWith(prefix)){\n        return true;\n    }\n    if(ignoreCase){\n        return str.startsWithIgnoreCase(prefix);\n    }\n    return str.startsWith(prefix);\n}", "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n\nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\treturn (str == null)? prefix == null :\n\t\tstr.startsWith(prefix) && (ignoreCase? str.toLowerCase().startsWith(prefix) : str.startsWith(prefix));\n}"]}
{"_id": "636766fe1a6d9265ec01781c", "generate_results": ["public static Character toCharacterObject(final char ch){\n\tif (ch =='') return ch;\n\tif (ch >= 'a' && ch <= 'z') return ch;\n\tif (ch >= 'A' && ch <= 'Z') return ch;\n\treturn null;\n}", "public static Character toCharacterObject(final char ch){\n\tif(ch =='' || ch == '\\t' || ch == '\\n' || ch == '\\r' || ch == '\\f'){\n\t\treturn ch;\n\t}\n\t\n\tif(ch == '\\''){\n\t\treturn new Character(ch);\n\t}\n\t\n\tif(ch == '('){\n\t\treturn new Character(ch);\n\t}\n\t\n\tif(ch <= '9' || ch >= 'A' + 10){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= 'Z' || ch >= 'a' + 10){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= 'z' || ch >= 'A' + 10){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\tif(ch <= '\\''){\n\t\tfinal Character c = Character.getInstance(ch);\n\t\tif(c!= null){\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\treturn null;\n}", "public static Character toCharacterObject(final char ch){\n    if (ch <= 0x7f){\n        return new Character(ch);\n    }\n    if (ch <= 0x7ff){\n        return new Character((char) ch);\n    }\n    return new Character((char) (ch - 0x10000));\n}", "public static Character toCharacterObject(final char ch){\n  if (Character.isDigit(ch)){\n    return ((Character) new Character(ch));\n  } else {\n    return ((Character) Character.valueOf(ch));\n  }\n}", "public static Character toCharacterObject(final char ch){\n\tif(ch>=0x10000){\n\t\treturn new Character((char)ch);\n\t}\n\treturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\tif(ch<0x00FF){\n\t\treturn new Character(ch);\n\t}\n\treturn Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n    if (ch < 0x20 ) {\n        return ch;\n    }\n    return new Character(ch);\n}", "public static Character toCharacterObject(final char ch) {\n\treturn toCharacterObject(ch, 0, 1);\n}", "public static Character toCharacterObject(final char ch){\n    final Character character = cache.get(ch);\n    if (character == null){\n        character = new Character(ch);\n        cache.put(ch, character);\n    }\n    return character;\n}", "public static Character toCharacterObject(final char ch){\n    if(ch ==''){\n        return new Character(' ');\n    }else if(ch == '\\t'){\n        return new Character('\\t');\n    }else if(ch == '\\n'){\n        return new Character('\\n');\n    }else if(ch == '\\r'){\n        return new Character('\\r');\n    }else if(ch == '\\b'){\n        return new Character('\\b');\n    }else if(ch == '\\f'){\n        return new Character('\\f');\n    }else if(ch == '\\v'){\n        return new Character('\\v');\n    }else if(ch == '\\0'){\n        return new Character('\\0');\n    }else{\n        throw new IllegalArgumentException(\"Unknown character: '\" +"]}
{"_id": "636766fb1a6d9265ec0177c1", "generate_results": ["public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 97 && ch <= 90);\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n  return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '-' || ch == '\\n';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n  return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 65 && ch <= 90);\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n    return (ch >= 65 && ch <= 90) || ch == '-';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n  return ch >= 'A' && ch <= 'Z';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 65 && ch <= 90);\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 65 && ch <= 90);\n}"]}
{"_id": "6367670a1a6d9265ec0179d9", "generate_results": ["public static int length(final String str){\n    return str==null? 0 : str.length();\n}", "public static int length(final String str){\n  if (str == null) return 0;\n  return str.length();\n}", "public static int length(final String str){\n\tif (str == null) return 0;\n\treturn str.length();\n}", "public static int length(final String str){\n\tif (str == null) return 0;\n\treturn str.length();\n}", "public static int length(final String str){\n\treturn str == null? 0 : str.length();\n}", "public static int length(final String str){\n  return str == null? 0 : str.length();\n}", "public static int length(final String str){\n\tif (str == null) return 0;\n\treturn str.length();\n}", "public static int length(final String str){\n\tif (str == null) {\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "public static int length(final String str){\n    if(str == null){\n        return 0;\n    }\n    return str.length();\n}", "public static int length(final String str){\n\tif (str == null) return 0;\n\treturn str.length();\n}"]}
{"_id": "636766f81a6d9265ec017748", "generate_results": ["public static String base64Decode(final String s){\n\tif (s == null) return null;\n\t\n\t//Base64 is a base64-encoded string, so don't need to decode it\n\treturn s.replaceAll(\"=\", \"\");\n}", "public static String base64Decode(final String s){\n    // TODO: Base64 decoding is not supported yet.\n    //throw new RuntimeException(\"Base64 decoding not supported yet.\");\n    \n    // The following code is the same as the previous one.\n    \n    final int LEN = s.length();\n    final StringBuilder sb = new StringBuilder(LEN);\n    final int OUT_LEN = Math.min(LEN, sb.length()+16);\n    \n    final char[] dst = sb.toString().toCharArray();\n    \n    final char[] src = s.toCharArray();\n    \n    for(int i=0; i<LEN; i++){\n        final int b = src[i];\n        final int d = (b & 0x7f);\n        if(d > 127){\n            final byte[] by = new byte[d];\n            for(int j=0; j<d; j++){\n                by[j] = (byte)b;\n            }\n            \n            // We get the output length.\n            final int len = (BYTE_SIZE*d+7)>>3;\n            \n            // The output is the same as the input.\n            final int outLen = Math.min(len, OUT_LEN);\n            System.arraycopy(by, 0, dst, i, outLen);\n            i += outLen;\n            \n            // The output is not null.\n            return sb.toString();\n        }\n        \n        // The next code is the same as the previous one.\n        \n        dst[i] = (byte)b;\n    }\n    \n    // The output is null.\n    return sb.toString();\n}", "public static String base64Decode(final String s){\n    // first decode\n    final StringBuilder sb = new StringBuilder();\n    final byte[] bytes = Base64.getDecoder().decode(s);\n    \n    // add the first byte\n    sb.append((char) bytes[0]);\n    \n    // add all the remaining bytes\n    for (int i = 1; i < bytes.length; i++){\n        sb.append((char) bytes[i]);\n    }\n    \n    return sb.toString();\n}", "public static String base64Decode(final String s){\n\ttry {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tfinal Base64 b64 = new Base64();\n\t\tb64.decode(s, sb);\n\t\treturn sb.toString();\n\t} catch (final Exception e) {\n\t\treturn null;\n\t}\n}", "public static String base64Decode(final String s){\n    \n    if (s == null){\n        return null;\n    }\n    \n    final int len = s.length();\n    \n    final byte[] out = new byte[len*4/3];\n    \n    for (int i=0; i<len; i++){\n        \n        final int b = s.charAt(i);\n        \n        final int r = b & 0x3F;\n        \n        out[i*4] = (byte)r;\n        \n        final int g = (b >> 6) & 0x3F;\n        \n        out[i*4+1] = (byte)g;\n        \n        final int g2 = (b >> 12) & 0x3F;\n        \n        out[i*4+2] = (byte)g2;\n        \n        final int g3 = (b >> 18) & 0x3F;\n        \n        out[i*4+3] = (byte)g3;\n        \n    }\n    \n    return new String(out);\n    \n}", "public static byte[] base64Decode(final String s){\n    if(s == null || s.length() == 0) return null;\n    try{\n        byte[] data = Base64.getDecoder().decode(s);\n        return data;\n    }catch(Exception e){\n        return null;\n    }\n}", "public static String base64Decode(final String s){\n\t\n\t// The string is encoded as Base64 \n\t// The string is converted to string by Base64.  \n\t// The base64 string is returned as a string.  \n\t\n\t/*\n\t * The base64 string is the encoded string\n\t */\n\t\n\t// Create a byte array\n\tbyte[] b = new byte[s.length()];\n\t\n\t// Create a byte array\n\tbyte[] c = new byte[b.length];\n\t\n\t// Create a byte array\n\tbyte[] d = new byte[b.length];\n\t\n\t// Initialize the byte array with 0x00 \n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<b.length; i++){\n\t\tb[i] = (byte)Base64.getDecoder().decode(s.substring(i*2,i*2+2));\n\t}\n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<b.length; i++){\n\t\td[i] = (byte)Base64.getDecoder().decode(b[i]);\n\t}\n\t\n\t// Create a new byte array\n\t\n\t// Create a new byte array\n\tbyte[] e = new byte[d.length];\n\t\n\t// Initialize the byte array with 0x00\n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<d.length; i++){\n\t\te[i] = (byte)Base64.getDecoder().decode(d[i]);\n\t}\n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<d.length; i++){\n\t\tc[i] = (byte)Base64.getDecoder().decode(d[i]);\n\t}\n\t\n\t// Create a new byte array\n\t\n\t// Create a new byte array\n\tbyte[] f = new byte[c.length];\n\t\n\t// Initialize the byte array with 0x00\n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<c.length; i++){\n\t\tf[i] = (byte)Base64.getDecoder().decode(c[i]);\n\t}\n\t\n\t// Create a new byte array\n\tbyte[] g = new byte[f.length];\n\t\n\t// Initialize the byte array with 0x00\n\t\n\t// Decode the Base64 string\n\tfor(int i=0; i<f.length; i++){\n\t\tg[i] = (byte)Base64.getDecoder().decode(f[i]);\n\t}\n\t\n\t// Create a new string\n\t\n\t// Return the decoded string\n\treturn new String(g);\n}", "public static String base64Decode(final String s) {\n   byte[] bytes = null;\n   try {\n      bytes = Base64.decodeBase64(s);\n   }\n   catch(final Exception e) {\n      return null;\n   }\n   return new String(bytes);\n}", "public static String base64Decode(final String s){\n\t\n\tint i = 0;\n\t\n\tint l = s.length();\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tfor(; i < l; i++){\n\t\t\n\t\tint c = s.charAt(i);\n\t\t\n\t\tif(c == '\\n'){\n\t\t\t\n\t\t\tsb.append('\\r');\n\t\t\tsb.append(chr(0));\n\t\t\t\n\t\t}else if(c == '\\r' || c == '\\n' || c =='' || c == '=' || c == '+' || c == '/' || c == '=' || c == '!' || c == '=' || c == '?' || c == '@' || c == '#'){\n\t\t\t\n\t\t\tsb.append(chr(0));\n\t\t\t\n\t\t}else if(c >= 'A' && c <= 'Z'){\n\t\t\t\n\t\t\tsb.append(c);\n\t\t\t\n\t\t}else if(c >= 'a' && c <= 'z'){\n\t\t\t\n\t\t\tsb.append(c);\n\t\t\t\n\t\t}else if(c >= '0' && c <= '9'){\n\t\t\t\n\t\t\tsb.append(c);\n\t\t\t\n\t\t}else if(c == '+'){\n\t\t\t\n\t\t\tsb.append(\"-\");\n\t\t\t\n\t\t}else if(c == '/'){\n\t\t\t\n\t\t\tsb.append(\"_\");\n\t\t\t\n\t\t}else if(c == '='){\n\t\t\t\n\t\t\tsb.append(\"_\");\n\t\t\t\n\t\t}else if(c == '_'){\n\t\t\t\n\t\t\tsb.append(\"-_\");\n\t\t\t\n\t\t}else if(c == '@'){\n\t\t\t\n\t\t\tsb.append(\"_-_\");\n\t\t\t\n\t\t}else if(c == '#'){\n\t\t\t\n\t\t\tsb.append(\"_-_\");\n\t\t\t\n\t\t}else if(c == '?'){\n\t\t\t\n\t\t\tsb.append(\"_-_\");\n\t\t\t\n\t\t}else if(c == '='){\n\t\t\t\n\t\t\tsb.append(\"_-_\");\n\t\t\t\n\t\t}else if(c == '`'){\n\t\t\t\n\t\t\tsb.append(\"_-_\");\n\t\t\t\n\t\t}else if(c == '{'){\n\t\t\t\n\t\t\tsb.append(chr(0));\n\t\t\t\n\t\t}else if(c == '}'){\n\t\t\t\n\t\t\tsb.append(chr(0));\n\t\t\t\n\t\t}else{\n\t\t\t\n\t\t\tsb.append(chr(0));\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n\t\n}", "public static String base64Decode(final String s){ \n   \n  if(s==null || s.length()==0)\n    return s;\n  \n  if(s.length()%4!=0)\n    return null;\n  \n  final StringBuilder sb = new StringBuilder(s.length()/4);\n  \n  int b=0;\n  for(int i=0;i<s.length();i+=4){\n    final int r = s.charAt(i) - 'A';\n    final int g = s.charAt(i+1) - 'A';\n    final int b = s.charAt(i+2) - 'A';\n    \n    sb.append((char)((r << 2) & 0x3c00));\n    sb.append((char)(((r & 3) << 4) & 0x300));\n    sb.append((char)(((r & 0) << 6) & 0x3e0));\n    sb.append((char)(b & 0x3f));\n    \n    b = g;\n    g = r;\n    r = 0;\n  }\n  \n  return sb.toString();\n}"]}
{"_id": "636766f11a6d9265ec017663", "generate_results": ["public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null && array2!=null) return false;\n\tif(array1==null && array2==null) return true;\n\tif(array1==null || array2==null) return array1==array2;\n\tif(array1.length!=array2.length) return false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null || array2==null) return  array1==null && array2==null;\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    return isSameLength(array1,array2,0);\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n        if (array1 == null) {\n                return (array2 == null || array2.length == 0);\n        }\n        if (array2 == null) {\n                return (array1.length == 0);\n        }\n        if (array1.length!= array2.length){\n                return false;\n        }\n        for (int i = 0; i < array1.length; i++){\n                if (array1[i]!= array2[i]){\n                        return false;\n                }\n        }\n        return true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\t\n\tif(array1 == null) return array2 == null;\n\tif(array2 == null) return array1 == null;\n\t\n\tif(array1.length!= array2.length) return false;\n\t\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(Double.compare(array1[i],array2[i])!= 0) return false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    return (array1 == null)? (array2 == null) : (array1.length == array2.length);\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n        if (array1 == null || array2 == null)\n        return (array1 == null && array2!= null) || (array1!= null && array2 == null);\n\n        if (array1.length == array2.length)\n        return true;\n\n        return false;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null)\n\t\treturn array2==null || array1.length==0;\n\tif(array2==null)\n\t\treturn array1.length==0;\n\tif(array1.length!=array2.length)\n\t\treturn false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n\n\t\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1==null) return array2==null;\n\t\n\tif(array1.length!=array2.length)\n\t\treturn false;\n\t\t\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!=array2[i])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n    if(array1 == null || array2 == null) return array1 == array2;\n    if(array1.length!= array2.length) return false;\n    for(int i=0;i<array1.length;i++){\n        if(array1[i]!= array2[i]) return false;\n    }\n    return true;\n}"]}
{"_id": "636766f31a6d9265ec01768f", "generate_results": ["public static char[] clone(final char[] array){\n\t\n  if (array == null) {\n    return null;\n  }\n  \n  return (char[]) cloneObject(array);\n}", "public static char[] clone(final char[] array){\n    if (array == null) {\n        return null;\n    }\n    if (array.length == 0) {\n        return EMPTY_CHAR_ARRAY;\n    }\n    final char[] result = new char[array.length];\n    System.arraycopy(array, 0, result, 0, array.length);\n    return result;\n}", "public static char[] clone(final char[] array){\n\t\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\tif (array.length == 0) {\n\t\treturn EMPTY_CHAR_ARRAY;\n\t}\n\t\n\tfinal char[] result = new char[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static char[] clone(final char[] array){\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\treturn (char[]) array.clone();\n}", "public static char[] clone(final char[] array){\n\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\ttry {\n\t\treturn (char[]) array.clone();\n\t} catch (final CloneNot", "public static char[] clone(final char[] array){\n\tif (array == null) {\n\t\treturn null;\n\t}\n\t\n\t// Find the correct size, preallocation for size of char[]\n\tfinal int newSize = ((array.length * 4) / 3) + 1;\n\tchar[] result = null;\n\tif (newSize == 0) {\n\t\treturn result;\n\t}\n\n\t// Copy the contents of the array\n\tresult = new char[newSize];\n\tSystem.arraycopy(array, 0, result, 0, array.length);\n\t\n\treturn result;\n}", "public static char[] clone(final char[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    return (char[]) array.clone();\n}", "public static char[] clone(final char[] array){\n\tif (array==null){\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn (char[]) array.clone();\n\t} catch(CloneNotSupportedException e){\n\t\t// should not happen\n\t\treturn null;\n\t}\n}", "public static char[] clone(final char[] array){\n\t// TODO: Isn't this the same as clone(final int[] array)?\n\tif (array == null) {\n\t\treturn null;\n\t}\n\tchar[] result = new char[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static char[] clone(final char[] array){\n    if (array == null) {\n        return null;\n    }\n    \n    /* We can only clone primitive arrays */\n    if (array.getClass().isArray()){\n        int i = 0;\n        int len = array.length;\n        \n        while (len > i){\n            if (array[i] == null) {\n                array[i] = null;\n                i++;\n            } else {\n                array[i] = array[len - 1];\n            }\n            len--;\n        }\n        \n        return array;\n    }\n    \n    return null;\n}"]}
{"_id": "636766fb1a6d9265ec0177c3", "generate_results": ["public static boolean isAscii(final char ch){\n    return (ch > 127);\n}", "public static boolean isAscii(final char ch){\n    return (ch >= '\\u0000' && ch <= '\\u007F');\n}", "public static boolean isAscii(final char ch){\n    return ch >='' && ch <= '~';\n}", "public static boolean isAscii(final char ch){\n    return 0x00 <= ch && ch <= 0x7F;\n}", "public static boolean isAscii(final char ch){\n\treturn (ch < 128);\n}", "public static boolean isAscii(final char ch){\n    return ch > 127;\n}", "public static boolean isAscii(final char ch){\n    return (ch >= 65 && ch <= 90);\n}", "public static boolean isAscii(final char ch){\n\treturn (ch>=128);\n}", "public static boolean isAscii(final char ch){\n\treturn ch >= 0x80 && ch < 0x100;\n}", "public static boolean isAscii(final char ch){\n\tif(ch < 128)\n\t\treturn true;\n\treturn false;\n}"]}
{"_id": "6367670b1a6d9265ec017a05", "generate_results": ["public static String toString(final char ch){\n    if (ch < 0x0020 || ch > 0x007f) return \"\"; // allow ASCII\n    if (ch == '\\r') return \"\"; // allow carriage return\n    if (ch == '\\n') return \"\"; // allow newline\n    if (ch == '\\t') return \"\"; // allow tabulation\n    return new String(new char[]{ch});\n}", "public static String toString(final char ch){\n    if(ch == 0){\n        return \"\";\n    }\n    return new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\n\tif (ch == 0) {\n\t\treturn \"\";\n\t} else {\n\t\tif (ch < 128){\n\t\t\treturn Character.toString(ch);\n\t\t} else {\n\t\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\tsb.append(ch);\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n}", "public static String toString(final char ch){\n  if (ch < 0x80) {\n    return String.valueOf(ch);\n  }\n  if (ch < 0x800) {\n    return String.valueOf((char)(ch & 0x7f | 0x80));\n  }\n  if (ch < 0x10000) {\n    return String.valueOf((char)(ch & 0x3f | 0x80 | 0x200));\n  }\n  return String.valueOf(ch);\n}", "public static String toString(final char ch){\n\treturn toString(ch, true);\n}", "public static String toString(final char ch){\n    if(ch==' '){\n        return \" \";\n    }else if(ch=='A'){\n        return \"A\";\n    }else{\n        return \"\";\n    }\n}", "public static String toString(final char ch){\n   return new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\t// if it is ASCII 0-9, return it\n\tif(ch >= 48 && ch <= 57){\n\t\treturn \"\";\n\t}\n\tif(ch < 0x80){\n\t\treturn String.valueOf(ch);\n\t}\n\n\t// if it is a printable ASCII character, just return that\n\tif(Character.isDefined(ch)){\n\t\treturn String.valueOf(ch);\n\t}\n\n\t// if it is a printable ASCII character but the charset is not supported, just return that\n\tif(ch >= 0x80 && ch <= 0x9F){\n\t\treturn String.valueOf(ch);\n\t}\n\n\t// if it is a printable ASCII character but the charset is not supported, just return that\n\tif(ch >= 0xA0 && ch <= 0xFF){\n\t\treturn String.valueOf(ch);\n\t}\n\n\t// if it is not a printable ASCII character but the charset is not supported, return an empty String\n\treturn \"\";\n}", "public static String toString(final char ch){\n  if(ch==null){\n    return null;\n  }\n  if(ch=='\\t'){\n    return \"\\t\";\n  }\n  if(ch=='\\n'){\n    return \"\\n\";\n  }\n  if(ch=='\\r'){\n    return \"\\r\";\n  }\n  if(ch=='\\b'){\n    return \"\\b\";\n  }\n  if(ch=='\\f'){\n    return \"\\f\";\n  }\n  if(ch=='\\v'){\n    return \"\\v\";\n  }\n  if(ch=='\\a'){\n    return \"\\a\";\n  }\n  if(ch=='\\f'){\n    return \"\\f\";\n  }\n  if(ch=='\\v'){\n    return \"\\v\";\n  }\n  if(ch=='\\b'){\n    return \"\\b\";\n  }\n  if(ch=='\\f'){\n    return \"\\f\";\n  }\n  if(ch=='\\n'){\n    return \"\\n\";\n  }\n  if(ch=='\\r'){\n    return \"\\r\";\n  }\n  if(ch=='\\v'){\n    return \"\\v\";\n  }\n  if(ch=='\\x0b'){\n    return \"\\x0b\";\n  }\n  if(ch=='\\x0f'){\n    return \"\\x0f\";\n  }\n  if(ch=='\\x1b'){\n    return \"\\x1b\";\n  }\n  if(ch=='\\x1f'){\n    return \"\\x1f\";\n  }\n  if(ch=='\\x2a'){\n    return \"\\x2a\";\n  }\n  if(ch=='\\x2f'){\n    return \"\\x2f\";\n  }\n  return \"\";\n}", "public static String toString(final char ch){\n\treturn toString(ch);\n}"]}
{"_id": "636767191a6d9265ec017c0f", "generate_results": ["/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n    \n    if(size > this.size){\n        this.size = size;\n    }\n    else if(this.size > 0){\n        this.size += size;\n    }\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tif (size > data.length - 1) this.data = Arrays.copyOf(this.data, size+1);\n\telse this.data = Arrays.copyOf(this.data, size);\n}", "public void enlarge(final int size){\n\tenlarge(size);\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tif( size > maxSize ){\n\t\tmaxSize = size+1;\n\t}\n\tbyteVector = new byte[maxSize];\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyteCount = byteCount + size;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyteVector.ensureCapacity(byteVector.size() + size);\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tthis.size += size;\n\tthis.buffer = new byte[size];\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tif (size > maxBufferSize) {\n\t\tmaxBufferSize = size;\n\t}\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tthis.size = size;\n\tthis.capacity = capacity << 1;\n\tthis.data = new byte[this.capacity];\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tfinal int oldCapacity = arrayCapacity;\n\tif(oldCapacity == 0) return;\n\tfinal int newCapacity = oldCapacity * 2;\n\tif(newCapacity <= 0) return;\n\tfinal byte [] newArray = new byte[newCapacity];\n\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\tarray = newArray;\n\tarrayCapacity = newCapacity;\n}"]}
{"_id": "636766ef1a6d9265ec01761a", "generate_results": ["/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tif(findType(value)!= -1){\n\t\treturn -1;\n\t}\n\t//System.out.println(\"addType: \"+value+\" to \"+this.getClass().getName());\n\tint i = 0;\n\twhile(true){\n\t\tif(findType(value) == -1)\n\t\t\tbreak;\n\t\ti++;\n\t\tvalue = value.substring(i);\n\t}\n\ttypeTable[i] = newType(value);\n\treturn i;\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n    if(table.containsKey(value)){\n        return -1;\n    }\n    table.put(value, new Type(value));\n    \n    //System.out.println(\"Adding type \" + value + \" to class \" + getInternalClassName());\n    \n    return table.size() - 1;\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tif(value == null)\n\t\treturn -1;\n\treturn addType(value.substring(0, value.length() - 1));\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tif(typeTab==null){\n\t\ttypeTab=new TypeTab();\n\t\treturn typeTab.getType(value);\n\t}\n\telse\n\t\treturn typeTab.getType(value);\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tif(!containsType(value)){\n\t\treturn addType(new Symbol(value));\n\t}\n\treturn -1;\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\treturn addType(value, null, null);\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tif(!typeTable.containsKey(value)){\n\t\ttypeTable.put(value, new Integer(typeTable.size()));\n\t}\n\treturn typeTable.get(value).intValue();\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n    if(m_types.containsKey(value))\n        return m_types.get(value);\n    else{\n        m_types.put(value, new Type(value));\n        return m_types.get(value).m_index;\n    }\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n    return addType(this.typeTable.lookup(value));\n}", "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n\nint addType(final String value){\n\tint i = typeTable.get(value);\n\tif(i < 0){\n\t\ttypeTable.put(value, i);\n\t\treturn i;\n\t}\n\treturn -1;\n}"]}
{"_id": "636766f81a6d9265ec01775b", "generate_results": ["public long readLong(final int offset){\n  // read value in long order\n  return readInt(offset) & 0x7F_FFFF_FFFF_FFFFL;\n}", "public long readLong(final int offset){\n  // read and discard the endianness flag, byte order mark, and class size\n  // this is important for some formats as we don't want to accidentally read something not a header\n  final byte[] b = this.b;\n  b[offset] = (byte) (b[offset] + 1);\n  this.b = b;\n\n  // read in the value's sign, byte order mark, and class size\n  final int i = this.i;\n  b[offset + 1] = (byte) (b[offset + 1] + 1);\n  this.i = b[offset + 1];\n\n  // read and discard the remaining unsigned integer part\n  final int j = this.j;\n  final int k = this.j;\n  this.j = this.j + 4;\n\n  // if the integer is negative, we need to make it positive before casting it to a long\n  if (b[offset + 2] < 0){\n    b[offset + 2] = (byte) (b[offset + 2] + 256);\n    this.i++;\n  }\n  \n  // read in the integer part\n  this.j = this.j + 4;\n\n  // if the integer is zero, we need to make it positive before casting it to a long\n  if (b[offset + 3] == 0){\n    b[offset + 3] = (byte) (b[offset + 3] + 256);\n    this.i++;\n  }\n\n  // read the (two) final, sign-mapped bytes\n  b[offset + 4] = (byte) (b[offset + 4] + b[offset + 3] + 1);\n\n  // return the actual length of the integer\n  return ((b[offset + 2] & 0xFF) << 56) | ((b[offset + 3] & 0xFF) << 48) | ((b[offset + 4] & 0xFF) << 40) | ((b[offset + 5] & 0xFF) << 32) | ((b[offset + 6] & 0xFF) << 24) | ((b[offset + 7] & 0xFF) << 16) | ((b[offset + 8] & 0xFF) << 8) | ((b[offset + 9] & 0xFF) << 0);\n}", "public long readLong(final int offset) {\n  return (readLong >>> 0) & 0xFFFF_FFFF_FFFF_FFL;\n}", "public long readLong(final int offset){\n\t\n\treturn classFile.readLong(offset);\n}", "public long readLong(final int offset){\n\t\n\treturn (long) ((buffer[offset] & 0xFF) | ((buffer[offset + 1] & 0xFF) << 8) | ((buffer[offset + 2] & 0xFF) << 16) | ((buffer[offset + 3] & 0xFF) << 24));\n\n}", "public long readLong(final int offset){\n  return readInt(offset) & 0x7F_FFFF_FFFF_FFFFL;\n}", "public long readLong(final int offset){\n\t\n\treturn this.data[offset];\n\t\n}", "public long readLong(final int offset) {\n        return readLong(offset) & 0xFFFF_FFFFL;\n    }", "public long readLong(final int offset){\n\t// read value in uncompensated encoding\n\treturn unsafe.getInt(buffer, offset);\n}", "public long readLong(final int offset){\n  // reads an unsigned short value in this ClassWriter\n  final int tag = read();\n  // skips 0 - 4 bytes - the value in the range of 0 to 255\n  offset += readUnsignedShort(offset);\n  switch(tag){\n   case ClassReader.FIELD:\n    return readUTF8(offset + 2, maxStringLength - 2);\n   case ClassReader.METHOD:\n    return readUTF8(offset + 3, maxStringLength - 3);\n   case ClassReader.CLASS:\n    return readInt(offset + 5);\n   case ClassReader.INTERFACE:\n    return readInt(offset + 8);\n   case ClassReader.ENUM:\n    return readInt(offset + 5);\n   case ClassReader.STR:\n    return readUTF8(offset + 2, maxStringLength - 2);\n   case ClassReader.LONG:\n    return readLong(offset + 8);\n   case ClassReader.DOUBLE:\n    return Double.longBitsToDouble(readLong(offset));\n   default:\n    throw new IllegalArgumentException(\n      \"Reference error, type tag is neither FIELD, METHOD, or CLASS, expected one of \" \n      + \"{0}.\");\n  }\n }"]}
{"_id": "6367671a1a6d9265ec017c15", "generate_results": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\tthrow new NullPointerException(\"byteArrayValue must not be null\");\n\t}\n\tfinal int byteLengthUnsigned = byteLength + byteOffset;\n\tif(byteLengthUnsigned > byteArrayValue.length){\n\t\tfinal int newLength = byteArrayValue.length * 2;\n\t\tif(newLength < 0){\n\t\t\tthrow new IllegalArgumentException(\"The length \"+byteLength+\" is not a multiple of 2\");\n\t\t}\n\t\tbyteArrayValue = Arrays.copyOf(byteArrayValue, newLength);\n\t}\n\t\n\tfinal int byteArrayLength = byteArrayValue.length;\n\tfinal int byteOffsetUnsigned = byteOffset + byteLengthUnsigned;\n\t\n\tif(byteArrayLength > byteArrayValue.length - byteOffset){\n\t\tthrow new IllegalArgumentException(\"The length \"+byteOffset+\" is greater than the length \"+byteArrayValue.length+\" \"+byteArrayValue.length-byteOffset);\n\t}\n\t\n\t// Enlarge the byte vector.\n\tfinal int newLength = byteArrayLength + byteOffsetUnsigned;\n\tif(newLength > maxLength){\n\t\tfinal byte[] newByteArray = new byte[newLength];\n\t\tSystem.arraycopy(byteArrayValue, byteOffset, newByteArray, 0, byteOffsetUnsigned);\n\t\tbyteArrayValue = newByteArray;\n\t\tmaxLength = newLength;\n\t}\n\t\n\t// Append the bytes in the array.\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteArrayValue, byteOffsetUnsigned, byteLengthUnsigned);\n\t\n\treturn this;\n}", "public final ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\tthis.byteLength=byteLength;\n\t\tthis.byteArrayValue=null;\n\t\treturn this;\n\t}\n\tif(byteLength == this.byteLength){\n\t\tif(byteArrayValue.length == 0){\n\t\t\tthis.byteArrayValue=null;\n\t\t\treturn this;\n\t\t}\n\t\tthis.byteArrayValue=byteArrayValue.clone();\n\t\treturn this;\n\t}\n\tbyteVector.enlarge(byteLength);\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteVector.data, byteOffset, byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteLength == 0){\n\t\treturn this;\n\t}\n\t\n\tif(byteLength > this.length - byteOffset){\n\t\tthis.length = byteOffset + byteLength;\n\t\tthis.data = new byte[this.length];\n\t\tSystem.arraycopy(this.data, byteOffset, this.data, 0, this.length);\n\t} else {\n\t\tthis.data = new byte[byteLength];\n\t\tSystem.arraycopy(byteArrayValue, byteOffset, this.data, 0, byteLength);\n\t}\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteOffset + byteLength > byteArrayValue.length){\n        enlarge(byteArrayValue.length - byteOffset);\n    }\n    System.arraycopy(byteArrayValue, byteOffset, this.data, this.position, byteLength);\n    this.position += byteLength;\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    ensureSize(byteLength);\n    byteArrayValue[byteOffset] = (byte)byteLength;\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue!= null){\n\t\tif(byteLength > 0){\n\t\t\tint byteLength2 = byteLength;\n\t\t\tif(byteLength2 < byteOffset){\n\t\t\t\tbyteLength2 = byteOffset;\n\t\t\t}\n\t\t\tbyteLength = byteLength2;\n\t\t\tbyteArrayValue = Arrays.copyOfRange(byteArrayValue, byteOffset, byteOffset+byteLength);\n\t\t}\n\t\telse{\n\t\t\tbyteLength = byteOffset;\n\t\t\tbyteArrayValue = Arrays.copyOfRange(byteArrayValue, byteOffset, byteOffset+byteLength);\n\t\t}\n\t}\n\t\n\tif(byteArrayValue!= null){\n\t\tbyteArrayValueLength = byteArrayValue.length;\n\t\tbyteArrayValueOffset = 0;\n\t}\n\telse{\n\t\tbyteArrayValueLength = 0;\n\t\tbyteArrayValueOffset = 0;\n\t}\n\t\n\tthis.byteArrayValue = byteArrayValue;\n\tthis.byteArrayValueLength = byteArrayValueLength;\n\tthis.byteArrayValueOffset = byteArrayValueOffset;\n\t\n\tthis.byteCount = byteLength;\n\t\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\treturn putByteArray(byteArrayValue,byteOffset,byteLength,(byteLength * 2));\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteArrayValue==null){\n        byteArrayValue=new byte[byteLength];\n    }\n    byteLength=byteLength>byteArrayValue.length?byteArrayValue.length:byteLength;\n    if(byteLength>0){\n        byteArrayValue=byteArrayValue.clone();\n        byteOffset=byteOffset>byteArrayValue.length?byteArrayValue.length:byteOffset;\n        byteLength=byteLength-byteOffset;\n    }\n\n    byte[] byteArray=byteArrayValue.clone();\n    byteVector.reset(byteArray,byteOffset,byteLength);\n    byteVector.size=byteLength;\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\t//if (byteArrayValue == null) throw new IllegalArgumentException(\"byteArrayValue must not be null\");\n\tif (byteLength == 0) return this;\n\tif (byteLength > byteOffset + byteArrayValue.length) throw new IndexOutOfBoundsException(\"byteLength: \" + byteLength + \" > byteOffset + byteArrayValue.length: \" + byteOffset + \" + \" + byteArrayValue.length);\n\tfinal byte[] temp = ensureCapacity(byteLength);\n\tSystem.arraycopy(byteArrayValue, byteOffset, temp, 0, byteLength);\n\tthis.data = temp;\n\tthis.length = byteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\tthis.byteLength = 0;\n\t\treturn this;\n\t}\n\tif(byteLength == 0){\n\t\tthis.byteLength = 1;\n\t}else if(byteLength < 0){\n\t\tthis.byteLength = byteLength & 0xFFFFFF;\n\t}else{\n\t\tthis.byteLength += byteLength;\n\t}\n\tif(this.byteLength > this.byteCapacity){\n\t\tbyteCapacity = this.byteLength;\n\t}\n\tif(byteOffset > this.byteLength - byteLength){\n\t\tbyteLength += byteOffset - this.byteLength;\n\t}\n\tSystem.arraycopy(byteArrayValue, byteOffset, this.byte, this.byteOffset, byteLength);\n\treturn this;\n}"]}
{"_id": "636767021a6d9265ec0178b2", "generate_results": ["/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tif(descriptor.equals(\"void\")){\n\t\tthrow new IllegalArgumentException(\"void\");\n\t}\n\t\n\tfinal int len = stack.size();\n\tif(len == 0) return;\n\t\n\tfinal int argOffset = descriptor.indexOf(\"(\");\n\tfinal int argEnd = descriptor.indexOf(\")\");\n\t\n\tfinal int argStart = Math.max(0, argOffset);\n\tfinal int argEnd = Math.min(argEnd, argStart);\n\t\n\tfor(int i = argStart; i < argEnd; i++){\n\t\tfinal String arg = descriptor.substring(argStart, i);\n\t\tfinal int argLength = arg.length();\n\t\t\n\t\tif(arg.equals(\"void\")){\n\t\t\targs.push(null);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(argLength == 0) continue;\n\t\t\n\t\tif(arg.charAt(0) == '*'){\n\t\t\targs.push(arg.substring(1));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\targs.push(arg);\n\t}\n\t\n\tfinal int returnTypeOffset = descriptor.indexOf(\"(\");\n\tfinal int returnTypeEnd = descriptor.indexOf(\")\");\n\t\n\tfinal int returnTypeStart = Math.max(0, returnTypeOffset);\n\tfinal int returnTypeEnd = Math.min(returnTypeEnd, returnTypeStart);\n\t\n\tfinal String returnType = descriptor.substring(returnTypeStart, returnTypeEnd);\n\t\n\tif(returnType.equals(\"void\")){\n\t\tthrow new IllegalArgumentException(\"void\");\n\t}\n\t\n\t\n\tfinal int paramOffset = descriptor.indexOf(\"(\");\n\tfinal int paramEnd = descriptor.indexOf(\")\");\n\t\n\tfinal int paramStart = Math.max(0, paramOffset);\n\tfinal int paramEnd = Math.min(paramEnd, paramStart);\n\t\n\tfor(int i = paramStart; i < paramEnd; i++){\n\t\tfinal String param = descriptor.substring(paramStart, i);\n\t\tfinal int paramLength = param.length();\n\t\t\n\t\tif(param.equals(\"void\")){\n\t\t\targs.push(null);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(paramLength == 0) continue;\n\t\t\n\t\tif(param.charAt(0) == '*'){\n\t\t\targs.push(param.substring(1));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\targs.push(param);\n\t}\n\t\n\t\n\tif(descriptor.charAt(0) == ')'){\n\t\targs.pop();\n\t}\n\t\n\t\n\tif(descriptor.charAt(descriptor.length() - 1) == ')'){\n\t\targs.pop();\n\t}\n\t\n\tif(args.size() == 0){\n\t\tthrow new IllegalArgumentException(\"method descriptor must not start with the '(' character\");\n\t}\n\t\n\t\n\tif(returnTypeOffset == 0 && returnTypeEnd == 0){\n\t\tthrow new IllegalArgumentException(\"method descriptor must not contain the '()' character\");\n\t}\n\t\n\t\n\tif(returnTypeOffset!= 0 && returnTypeEnd == 0){\n\t\tthrow new IllegalArgumentException(\"method descriptor must not contain the '()' character\");\n\t}\n\t\n\t\n\tif(returnTypeEnd!= 0 && returnTypeOffset!= 0){\n\t\tthrow new IllegalArgumentException(\"method descriptor must not contain the '()' character\");\n\t}\n\t\n\t\n\t\n\tif(returnTypeStart!= 0 && returnTypeEnd == 0){\n\t\tthrow new IllegalArgumentException(\"return type descriptor must not start with the '()' character\");\n\t}\n\t\n\t\n\tif(returnTypeEnd!= 0 && returnTypeStart == 0){\n\t\tthrow new IllegalArgumentException(\"return type descriptor must not start with the '()' character\");\n\t}\n\t\n\t\n\t\n\tif(returnTypeEnd!= 0 && returnTypeEnd == returnTypeStart){\n\t\tthrow new IllegalArgumentException(\"return type descriptor must not end with the '()' character\");\n\t}\n\t\n\t\n\tif(returnType", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    Frame frame = pop();\n    if(frame.isAbstract()){\n        throw new IllegalStateException(\"Abstract type encountered: \"+descriptor);\n    }\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tif (DEBUG) System.out.println(this.getDescriptor() + \": Pops \" + descriptor + \" from the output frame stack\");\n\t\n\tthis.currentFrame = this.stack.pop();\n\tthis.currentFrame.setArgumentTypes(this.stack.pop());\n\tthis.stack.pop();\n\t\n\tif (DEBUG) System.out.println(this.getDescriptor() + \": Output frame stack is \" + this.stack.size());\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if(descriptor.equals(\"java.lang.Object\")){\n        return;\n    }\n    \n    final ReferenceType[] arguments = descriptor.equals(\"java.lang.Object\")? new ReferenceType[]{} : new ReferenceType[]{};\n    \n    final TypeDescriptor descriptor1 = new TypeDescriptor(this, arguments);\n    final TypeDescriptor descriptor2 = new TypeDescriptor(this, arguments);\n    \n    //System.out.println(\"POPING \"+descriptor1+\" \"+descriptor2);\n    \n    int count = 0;\n    \n    while(count<descriptor1.getArgumentCount() && count<descriptor2.getArgumentCount()){\n        \n        if(descriptor1.isAbstract() && descriptor2.isAbstract()){\n            \n            //System.out.println(\"CALLING \"+descriptor1.getClassName()+\" \"+descriptor2.getClassName());\n            \n            // This is a call to a non-abstract method.\n            // We have to go through the stack and find the method that matches the class\n            // and call it.\n            \n            //System.out.println(\"FOUND \"+descriptor1.getClassName()+\" \"+descriptor2.getClassName());\n            \n            final ReferenceType[] arguments1 = descriptor1.getArgumentTypes();\n            final ReferenceType[] arguments2 = descriptor2.getArgumentTypes();\n            \n            final TypeDescriptor superType = descriptor1.getSuperclass();\n            final TypeDescriptor superType1 = descriptor1.getSuperclass();\n            final TypeDescriptor superType2 = descriptor2.getSuperclass();\n            \n            \n            //System.out.println(\"SUPER \"+superType1+\" \"+superType2);\n            \n            final String thisClass = descriptor1.getClassName();\n            final String thisSuperClass = superType1.getClassName();\n            final String thisSuperClass1 = superType1.getSuperclass().getClassName();\n            final String thisSuperClass2 = superType2.getClassName();\n            \n            final int thisArgumentCount = arguments1.length;\n            \n            final int thisArgumentCount1 = arguments1.length;\n            \n            final int thisArgumentCount2 = arguments2.length;\n            \n            final int thisArgumentCount3 = arguments2.length;\n            \n            final int thisArgumentCount4 = arguments1.length;\n            \n            \n            //System.out.println(\"THIS \"+thisClass+\" \"+thisSuperClass+\" \"+thisSuperClass1+\" \"+thisSuperClass2+\" \"+thisArgumentCount1+\" \"+thisArgumentCount2+\" \"+thisArgumentCount3+\" \"+thisArgumentCount4);\n            \n            \n            // We must find the method that matches the class and call it.\n            \n            //System.out.println(\"FOUND \"+thisClass+\" \"+thisSuperClass+\" \"+thisSuperClass1+\" \"+thisSuperClass2+\" \"+thisArgumentCount1+\" \"+thisArgumentCount2+\" \"+thisArgumentCount3+\" \"+thisArgumentCount4);\n            \n            final MethodDescriptor descriptor1Method = new MethodDescriptor(thisClass, superType1.getClassName(), superType1.getSuperclass().getClassName(), superType1.getBaseName(), superType2.getClassName(), superType2.getSuperclass().getClassName(), superType2.getBaseName(), superType2.getBaseName(), superType2.getBaseName(), superType2.getBaseName(), thisClass, thisArgumentCount1, thisArgumentCount2, thisArgumentCount3, thisArgumentCount4, thisArgumentCount1, thisArgumentCount2, thisArgumentCount3, thisArgumentCount4, thisArgumentCount1, thisArgumentCount2, thisArgumentCount3, thisArgumentCount4);\n            \n            //System.out.println(\"FOUND \"+thisClass+\" \"+thisSuperClass+\" \"+thisSuperClass1+\" \"+thisSuperClass2+\" \"+thisArgumentCount1+\" \"+thisArgumentCount2+\" \"+thisArgument", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    final int numArgs = descriptor.length() - 1;\n    final int numParams = numArgs;\n    final int numLocals = numParams + numArgs;\n\n    if(!isValidType(descriptor))\n        return;\n\n    final int index = getIndex(descriptor);\n    if(index < 0){\n        System.err.println(\"Invalid type descriptor\");\n        return;\n    }\n\n    final int paramIndex = index + numParams;\n    final int localIndex = index + numLocals;\n    final int stackSize = frame.getStackSize();\n\n    final ArrayList<Type> argTypes = new ArrayList<Type>(numArgs);\n    final ArrayList<Type> paramTypes = new ArrayList<Type>(numParams);\n\n    for(int i = numArgs; i >= 0; i--){\n        argTypes.add(getType(descriptor, i));\n    }\n\n    for(int i = numArgs; i >= 0; i--){\n        paramTypes.add(getType(descriptor, i + numParams));\n    }\n\n    frame.setType(paramIndex, paramTypes.remove(paramIndex));\n    frame.setReturnType(localIndex, argTypes.remove(localIndex));\n    frame.setStackSize(stackSize - numArgs);\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if (descriptor == null){\n        return;\n    }\n    \n    final String desc = descriptor.toString();\n    \n    //System.out.println(\"Descriptor: \" + desc);\n    \n    if (desc.equals(\"java.lang.Object\")){\n        return;\n    }\n    \n    //System.out.println(\"Descriptor to pop: \" + desc);\n    \n    if (desc.equals(\"java.util.List\")){\n        popList();\n        return;\n    }\n    \n    if (desc.equals(\"java.util.Vector\")){\n        popVector();\n        return;\n    }\n    \n    //System.out.println(\"Descriptor to pop: \" + desc);\n    \n    if (desc.equals(\"java.lang.Comparable\")){\n        popComparable();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Boolean\")){\n        popBoolean();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.String\")){\n        popString();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Number\")){\n        popNumber();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Character\")){\n        popCharacter();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Double\")){\n        popDouble();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Float\")){\n        popFloat();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Byte\")){\n        popByte();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Short\")){\n        popShort();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Integer\")){\n        popInteger();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Long\")){\n        popLong();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.Void\")){\n        popVoid();\n        return;\n    }\n    \n    //System.out.println(\"Descriptor to pop: \" + desc);\n    \n    if (desc.equals(\"java.lang.Class\")){\n        popClass();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.StringBuilder\")){\n        popStringBuilder();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.StringBuffer\")){\n        popStringBuffer();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.BooleanArray\")){\n        popBooleanArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.IntegerArray\")){\n        popIntegerArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.LongArray\")){\n        popLongArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.FloatArray\")){\n        popFloatArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.DoubleArray\")){\n        popDoubleArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.CharacterArray\")){\n        popCharacterArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.ShortArray\")){\n        popShortArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.ByteArray\")){\n        popByteArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.IntegerArray\")){\n        popIntegerArray();\n        return;\n    }\n    \n    if (desc.equals(\"java.lang.LongArray\")){\n        popLong", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tif(!descriptor.startsWith(\"L\")){\n\t\tsuper.push(descriptor);\n\t\treturn;\n\t}\n\t\n\tint start = descriptor.indexOf('[');\n\tint end = descriptor.indexOf(';');\n\t\n\tif(start == -1){\n\t\tString msg = \"Missing argument types for \" + descriptor;\n\t\tthrow new IllegalStateException(msg);\n\t}\n\t\n\tString type = descriptor.substring(start + 1, end);\n\t\n\tif(!type.equals(\"L\")){\n\t\tString msg = \"Unknown types for \" + descriptor;\n\t\tthrow new IllegalStateException(msg);\n\t}\n\t\n\tint argCount = 0;\n\t\n\tint endIndex = 0;\n\twhile(endIndex < end){\n\t\tendIndex = descriptor.indexOf('[', endIndex);\n\t\tif(endIndex == -1){\n\t\t\tendIndex = descriptor.length();\n\t\t}\n\t\t\n\t\tif(endIndex == start){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tString arg = descriptor.substring(endIndex + 1, endIndex);\n\t\tendIndex += 1;\n\t\t\n\t\tif(arg.startsWith(\"L\")){\n\t\t\tString argType = arg.substring(1);\n\t\t\tif(!argType.equals(\"L\")){\n\t\t\t\tString msg = \"Unknown argument types for \" + descriptor;\n\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t}\n\t\t\t\n\t\t\targCount++;\n\t\t\t\n\t\t\tint startIndex = 0;\n\t\t\twhile(startIndex < start){\n\t\t\t\tstartIndex = descriptor.indexOf('[', startIndex);\n\t\t\t\tif(startIndex == -1){\n\t\t\t\t\tstartIndex = descriptor.length();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(startIndex == endIndex){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString argType = descriptor.substring(startIndex + 1, startIndex);\n\t\t\t\tstartIndex += 1;\n\t\t\t\t\n\t\t\t\tif(!argType.equals(\"L\")){\n\t\t\t\t\tString msg = \"Unknown argument types for \" + descriptor;\n\t\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\targCount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(argCount == 0) {\n\t\tsuper.pop();\n\t}\n\telse{\n\t\tsuper.push(descriptor.substring(start, end));\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if(descriptor.startsWith(\"[\")){\n        pop(descriptor.substring(1, descriptor.length() - 1));\n    }else if(descriptor.startsWith(\"L\")){\n        pop(descriptor.substring(1));\n    }else if(descriptor.startsWith(\"(\")){\n        descriptor = descriptor.substring(1);\n    }else if(descriptor.startsWith(\"#\")){\n        descriptor = descriptor.substring(1);\n    }else{\n        throw new IllegalArgumentException(\"Not a method or class descriptor: \" + descriptor);\n    }\n    \n    int lastIndex = descriptor.lastIndexOf(';');\n    \n    if(lastIndex < 0){\n        throw new IllegalArgumentException(\"Not a method or class descriptor: \" + descriptor);\n    }\n    \n    String paramType = descriptor.substring(0, lastIndex);\n    String paramName = descriptor.substring(lastIndex + 1);\n    \n    ClassType classType = (ClassType)Type.getType(paramType);\n    ClassType[] parameters = classType.getParameters();\n    \n    for(int i = 0; i < parameters.length; i++){\n        String paramName2 = parameters[i].getName();\n        if(paramName2.equals(paramName)){\n            throw new IllegalArgumentException(descriptor + \" is not a parameter\");\n        }\n    }\n    \n    Type returnType = (Type)Type.getType(paramType);\n    \n    if(returnType.isArray()){\n        Type returnType2 = returnType.getComponentType();\n        Type[] args = new Type[returnType2.getDimensions()];\n        \n        int index = 0;\n        while(true){\n            String nextParam = descriptor.substring(index, descriptor.length() - 1);\n            \n            if(nextParam.equals(\"[\") || nextParam.equals(\"L\")){\n                break;\n            }else{\n                args[index++] = (Type)Type.getType(nextParam);\n            }\n        }\n        \n        if(index < args.length){\n            returnType = returnType.getComponentType();\n            returnType2 = returnType.getComponentType();\n            \n            for(int i = 0; i < args.length; i++){\n                returnType.addExceptions(args[i]);\n                returnType2.addExceptions(args[i]);\n            }\n        }\n    }\n    \n    if(descriptor.startsWith(\"<\")){\n        descriptor = descriptor.substring(1);\n    }else if(descriptor.startsWith(\">\")){\n        descriptor = descriptor.substring(1);\n    }else{\n        throw new IllegalArgumentException(\"Not a method or class descriptor: \" + descriptor);\n    }\n    \n    String type = descriptor;\n    \n    String current = descriptor.substring(0, descriptor.length() - 1);\n    \n    if(current.endsWith(\";\")){\n        current = current.substring(0, current.length() - 1);\n    }\n    \n    MethodType methodType = (MethodType)Type.getType(current);\n    \n    ClassType[] params = methodType.getParameters();\n    \n    for(int i = 0; i < params.length; i++){\n        String paramName2 = params[i].getName();\n        if(paramName2.equals(paramName)){\n            throw new IllegalArgumentException(descriptor + \" is not a parameter\");\n        }\n    }\n    \n    returnType = returnType.getReturnType();\n    \n    if(returnType.isArray()){\n        Type returnType2 = returnType.getComponentType();\n        Type[] args = new Type[returnType2.getDimensions()];\n        \n        int index = 0;\n        while(true){\n            String nextParam = descriptor.substring(index, descriptor.length() - 1);\n            \n            if(nextParam.equals(\"[\") || nextParam.equ", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tif (descriptor.equals(Descriptor.CLASS_TYPE)){\n\t\twhile (true){\n\t\t\tClass c = pop();\n\t\t\tif (c == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tClassOutline.unregister(c);\n\t\t}\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if(descriptor.startsWith(\"[\")){\n        final int index = descriptor.indexOf(']');\n        final String type = descriptor.substring(1,index);\n        final boolean isType = type.equals(\"Ljava.lang.Class;\")){\n            if(index!=-1)\n                classStacks.pop();\n        }\n    }\n}"]}
{"_id": "636766fa1a6d9265ec0177a9", "generate_results": ["/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tif (initializedTypes.add(abstractType))\n\t\treturn;\n\t\n\t// We have seen an abstract type that is not in the list of types on which a constructor is invoked.\n\t// We have to throw an exception.\n\t\n\t// We know that the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception.\n\t\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t\n\t// if (abstractTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t// We can't throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t\n\t// We can't throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t\n\t// We can't throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n\t\n\t\n\t// We can't throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t// We can throw an exception if the constructor is not in the list of types on which a constructor is invoked.\n\t\n\t// if (initializedTypes.contains(abstractType))\n\t// \tthrow new SemanticException(\"Abstract type '\" + abstractType + \"' is already in the list of types on which a constructor is invoked.\");\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tinitializedTypes.add(abstractType);\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tif(!isInitializedType(abstractType)){\n\t\tinitializedTypes.add(abstractType);\n\t}\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n    if(initializedTypes.contains(abstractType)){\n        return;\n    }\n    initializedTypes.add(abstractType);\n    if(!visited.contains(abstractType)){\n        visited.add(abstractType);\n    }\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n  if (initializedTypes.contains(abstractType)) {\n    return;\n  }\n  initializedTypes.add(abstractType);\n  if (initializedTypes.size() > maxInitializedTypes) {\n    maxInitializedTypes = initializedTypes.size();\n  }\n  for (int i = 0; i < maxInitializedTypes; i++){\n    if (initializedTypes.get(i) == abstractType) {\n      initializedTypes.set(i,abstractType);\n      return;\n    }\n  }\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tif(initializedTypes.contains(abstractType)){\n\t\treturn;\n\t}\n\tinitializedTypes.add(abstractType);\n\t\n\tint[] constructorArgs = new int[constructorArgsForType(abstractType)];\n\tconstructorArgsForType(abstractType).clone();\n\t\n\tfor(int i = 0; i < constructorArgs.length; i++)\n\t{\n\t\tconstructorArgs[i] = constructorArgs[i].add(argTypes[i]);\n\t}\n\t\n\targTypes.add(abstractType);\n\targTypes.add(constructorArgs);\n\t\n\tint index = 0;\n\tfor(int i = 0; i < constructorArgs.length; i++)\n\t{\n\t\tif(constructorArgs[i] == null)\n\t\t{\n\t\t\tconstructorArgs[i] = index;\n\t\t\tindex++;\n\t\t}\n\t}\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tif(initializedTypes.get(abstractType) == null){\n\t\tinitializedTypes.put(abstractType, new ArrayList<Integer>());\n\t}\n\tinitializedTypes.get(abstractType).add(abstractType);\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\taddType(new AbstractType(abstractType));\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n\tif(!initializedTypes.contains(abstractType)) {\n\t\tinitializedTypes.add(abstractType);\n\t}\n}", "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n\nprivate void addInitializedType(final int abstractType){\n  if (initializedTypes.get(abstractType) == null)\n    initializedTypes.put(abstractType, new ArrayList<Integer>());\n}"]}
{"_id": "6367670a1a6d9265ec0179dc", "generate_results": ["/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}", "/** \n * Puts some abstract types of  {@link #currentFrame}"]}
{"_id": "636766f21a6d9265ec017667", "generate_results": ["public short readShort(final int offset){\n  // Read and discard the tag byte\n  final byte b0 = in.readByte(offset + 2);\n  offset += 3;\n\n  // Read and discard the class_index\n  final int class_index = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the name_index\n  final int name_index = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the super_class_index\n  final int super_class_index = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the interfaces_count\n  final int interfaces_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the fields_count\n  final int fields_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the methods_count\n  final int methods_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the inner_classes_count\n  final int inner_classes_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the attributes_count\n  final int attributes_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the inner_classes_count\n  final int inner_classes_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the inner_interfaces_count\n  final int inner_interfaces_count = readUnsignedShort(offset);\n  offset += 2;\n\n  // Read and discard the serial_version_uid\n  final int serial_version_uid = readInt(offset);\n  offset += 4;\n\n  // Read and discard the inner_serial_version_uid\n  final int inner_serial_version_uid = readInt(offset);\n  offset += 4;\n\n  // Read and discard the class_index\n  final int class_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the name_index\n  final int name_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the super_class_index\n  final int super_class_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the interfaces_count\n  final int interfaces_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the fields_count\n  final int fields_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the methods_count\n  final int methods_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the inner_classes_count\n  final int inner_classes_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the attributes_count\n  final int attributes_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the inner_classes_count\n  final int inner_classes_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the inner_interfaces_count\n  final int inner_interfaces_count = readInt(offset);\n  offset += 4;\n\n  // Read and discard the serial_version_uid\n  final int serial_version_uid = readInt(offset);\n  offset += 4;\n\n  // Read and discard the inner_serial_version_uid\n  final int inner_serial_version_uid = readInt(offset);\n  offset += 4;\n\n  // Read and discard the class_index\n  final int class_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the name_index\n  final int name_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the super_class_index\n  final int super_class_index = readInt(offset);\n  offset += 4;\n\n  // Read and discard the interfaces_count\n  final int interfaces_count = readInt(offset);\n  offset += 4;\n\n  // Read", "public short readShort(final int offset){\n  return super.readShort(offset);\n}", "public short readShort(final int offset){\n\t\n\tshort value = this.data[offset];\n\tvalue = ((value & 0xffff) << 8) | (this.data[offset + 1] & 0xff);\n\treturn value;\n}", "public short readShort(final int offset){\n\treturn (short) classFile.readShort(offset);\n}", "public short readShort(final int offset){\n\treturn this.readShort();\n}", "public short readShort(final int offset){\n\treturn this.data[offset];\n}", "public short readShort(final int offset){\n\tbyte[] b = this.b;\n\tb[offset] = (byte) (b[offset] & 0x00FF);\n\tb[offset + 1] = (byte) ((b[offset + 1] & 0xFF00) >> 8);\n\treturn (short) ((b[offset + 2] & 0xFF) << 8 | (b[offset + 3] & 0xFF));\n}", "public short readShort(final int offset){\n\treturn (short) ((readInt(offset) & 0xffff) << 8);\n}", "public short readShort(final int offset){\n\tthis.bytes[offset] = (byte)((short) (((this.bytes[offset] & 0xFF) << 8) | (this.bytes[offset + 1] & 0xFF)));\n\treturn (short) (((this.bytes[offset] & 0xFF) << 8) | (this.bytes[offset + 2] & 0xFF));\n}", "public short readShort(final int offset){\n  // reads a signed short value in this ClassReader.\n  // returns a short value.\n  final int i = classReader.readUnsignedShort(offset);\n  return (short)(i & 0xFFFF);\n}"]}
{"_id": "636766ff1a6d9265ec017853", "generate_results": ["/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if (labels[bytecodeOffset]!=null) return labels[bytecodeOffset];\n  if (labels==null || labels.length<=bytecodeOffset) return new Label(0);\n  return labels[bytecodeOffset]=new Label();\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif (labels==null) return null;\n\tif (labels[bytecodeOffset]!=null) return labels[bytecodeOffset];\n\tfinal Label label = new Label();\n\tlabels[bytecodeOffset]=label;\n\treturn label;\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset] = new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif( labels[bytecodeOffset] == null ){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tfinal int label = readInt();\n\tif(labels[bytecodeOffset]!= null)\n\t\treturn labels[bytecodeOffset];\n\tlabels[bytecodeOffset] = new Label();\n\tlabels[bytecodeOffset].put(label);\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif(labels[bytecodeOffset]==null) labels[bytecodeOffset] = new Label();\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if(labels[bytecodeOffset]==null) {\n    labels[bytecodeOffset]=new Label();\n  }\n  return labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tif(labels[bytecodeOffset]!=null) return labels[bytecodeOffset];\n\tlabels[bytecodeOffset]=new Label();\n\treturn labels[bytecodeOffset];\n}", "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\tLabel label = labels[bytecodeOffset];\n\tif (label == null) {\n\t\tif (labels == labels) label = new Label();\n\t\tlabels[bytecodeOffset] = label;\n\t}\n\treturn label;\n}"]}
{"_id": "636766fe1a6d9265ec01782a", "generate_results": ["/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}", "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}"]}
{"_id": "636766f81a6d9265ec017758", "generate_results": ["public int hashCode(){ return super.hashCode(); }", "public int hashCode(){\n\treturn _hash;\n}", "public int hashCode(){ return super.hashCode(); }", "public int hashCode(){\n    return super.hashCode();\n}", "public boolean equals(Object t){\n\tif(t instanceof Type){\n\t\tType t2 = (Type)t;\n\t\treturn (hashCode == t2.hashCode());\n\t}\n\treturn false;\n}", "public int hashCode(){\n    return this.cls == null? 0 : this.cls.hashCode()\n        ^ this.type.hashCode();\n}", "public int hashCode(){\n\tint h=0;\n\th=h*31+m_type.hashCode();\n\th=h*31+m_name.hashCode();\n\treturn h;\n}", "public int hashCode(){ return hash; }", "public int hashCode(){ return Integer.hashCode(this.id); }", "public String toString(){\n\treturn (this.getClass() + this.getDeclaringClass().toString() + this.hashCode());\n}"]}
{"_id": "636766fe1a6d9265ec017823", "generate_results": ["/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = nameAndTypeIndex(name,descriptor);\n\tif(index==-1) {\n\t\tindex = constantPool.length();\n\t\taddConstant(new ConstantNameAndType_info(index,name,descriptor));\n\t}\n\treturn index;\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n    Symbol c = new Symbol(name, descriptor);\n    c.access = CONSTANT_NameAndType;\n    c.addConstant();\n    c.constant_pool.size++;\n    return c;\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tSymbol sym = new Symbol(name,descriptor);\n\tif(pool.put(sym) == null){\n\t\tpool.put(sym,sym);\n\t\treturn sym;\n\t} else {\n\t\treturn sym;\n\t}\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(!_constantNameAndType.containsKey(name)){\n\t\t_constantNameAndType.put(name,new Integer(newConstantPoolItem()));\n\t}\n\tInteger constantNameAndType = (Integer)_constantNameAndType.get(name);\n\tif(constantNameAndType.intValue() == newConstantPoolItem()){\n\t\treturn newConstantPoolItem();\n\t}\n\treturn constantNameAndType;\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\t\n\tif (pool.contains(name) || pool.contains(descriptor)) return pool.addConstant(name, descriptor);\n\t\n\tpool.addConstant(name, descriptor);\n\treturn pool.getConstant(name, descriptor);\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(!hasConstantNameAndType(name,descriptor)){\n\t\taddConstant(name, descriptor);\n\t}\n\treturn getConstant(name,descriptor);\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(name.equals(\"<init>\")){\n\t\treturn new Symbol(CONSTANT_Class_info,descriptor);\n\t}\n\telse if(name.equals(\"<clinit>\")){\n\t\treturn new Symbol(CONSTANT_Class_info,descriptor);\n\t}\n\telse if(name.equals(\"<init>\")){\n\t\treturn new Symbol(CONSTANT_Class_info,descriptor);\n\t}\n\telse if(name.equals(\"<clinit>\")){\n\t\treturn new Symbol(CONSTANT_Class_info,descriptor);\n\t}\n\telse if(name.equals(\"<invoke>\")){\n\t\treturn new Symbol(CONSTANT_MethodType_info,descriptor);\n\t}\n\telse if(name.equals(\"<invoke>\")){\n\t\treturn new Symbol(CONSTANT_MethodType_info,descriptor);\n\t}\n\telse if(name.equals(\"<invoke>\")){\n\t\treturn new Symbol(CONSTANT_MethodType_info,descriptor);\n\t}\n\telse if(name.equals(\"<invoke>\")){\n\t\treturn new Symbol(CONSTANT_MethodType_info,descriptor);\n\t}\n\tif(constantPool.contains(name)){\n\t\treturn new Symbol(constantPool.getNameAndType(name),descriptor);\n\t}\n\telse{\n\t\treturn new Symbol(CONSTANT_NameAndType_info,descriptor);\n\t}\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(constantPool[index]==null) {\n\t\tconstantPool[index] = new Symbol(0, name, descriptor);\n\t\treturn index;\n\t}\n\telse {\n\t\treturn addConstantNameAndType(index,name,descriptor);\n\t}\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(!isConstantName(name)){\n\t\treturn addConstant(name, descriptor);\n\t}\n\treturn addConstant(name, descriptor, Symbol.CONSTANT_NameAndType);\n}", "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n\nint addConstantNameAndType(final String name,final String descriptor){\n\tif(constantPool.contains(name, descriptor)) return constantPool.get(name, descriptor);\n\treturn constantPool.add(name, descriptor);\n}"]}
{"_id": "636767131a6d9265ec017b23", "generate_results": ["/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\tif(lineNumber < 0){\n\t\tthrow new IllegalArgumentException(\"lineNumber must be strictly positive\");\n\t}\n\tsynchronized(this){\n\t\tif(lines.size() < lineNumber + 1){\n\t\t\tlines.add(lineNumber, null);\n\t\t}\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n   if (lineNumber < 0) {\n      throw new IllegalArgumentException(\"lineNumber must be strictly positive\");\n   }\n   sourceLines.add(lineNumber);\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\tfinal int index = lineNumberIndex(lineNumber);\n\tif(index < 0)\n\t\tthrow new IllegalArgumentException(\"lineNumber must be strictly positive\");\n\tif(index >= lineNumberCount)\n\t\tthrow new IllegalArgumentException(\"lineNumber must be strictly positive\");\n\tif(lineNumbers[index] == null){\n\t\tlineNumbers[index] = lineNumber;\n\t\tlineNumberIndex = index;\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\tfinal String source = getSource();\n\tfinal String prefix = \"Line \";\n\tfinal int index = source.lastIndexOf(prefix);\n\tif (index!= -1) {\n\t\tfinal String lineNumberStr = Integer.toString(lineNumber);\n\t\tfinal String lineNumberPrefix = prefix + lineNumberStr;\n\t\tthis.addSourceLine(lineNumberPrefix + lineNumberStr);\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\t// add to the end of the list\n\tif (currentLineNumberList.size() < lastLineNumber) {\n\t\tcurrentLineNumberList.add(lineNumber);\n\t}\n\t// if the line number is greater than the last one, we need to replace it\n\telse if (lineNumber > lastLineNumber) {\n\t\t// we're replacing the last one, so we need to remove the old one from the list\n\t\tcurrentLineNumberList.remove(lastLineNumber);\n\t\t// we need to add the new one to the end of the list\n\t\tcurrentLineNumberList.add(lineNumber);\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\tif(lineNumber < 0){\n\t\tthrow new IllegalArgumentException(\"lineNumber must be >= 0.\");\n\t}\n\tif(lineNumber == 0){\n\t\tthrow new IllegalArgumentException(\"lineNumber must be > 0.\");\n\t}\n\tif(sourceLineNumbers.size() < lineNumber){\n\t\tsourceLineNumbers.add(lineNumber);\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n    lineNumbers.add(lineNumber);\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\t// ensure that the line number is not already in the list of line numbers\n\t// (if the line number is already in the list, it will be overwritten by the new line number)\n\tsynchronized(lineNumbers){\n\t\tif(!lineNumbers.contains(lineNumber)){\n\t\t\tlineNumbers.add(lineNumber);\n\t\t}\n\t}\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n    final int lineNumberIndex = lineNumberIndex(lineNumber);\n    if(lineNumberIndex == -1){\n        throw new Error(\"line number out of range\");\n    }\n    \n    if(lineNumber > lineNumberIndex){\n        throw new Error(\"line number out of range\");\n    }\n    \n    if(lineNumber < 0){\n        throw new Error(\"line number out of range\");\n    }\n    \n    // Add the line number to the list\n    lineNumbers.add(lineNumberIndex);\n    \n    // Add the line number index to the list\n    lineNumbersIndexes.add(lineNumberIndex);\n}", "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n\nfinal void addLineNumber(final int lineNumber){\n\tif (lineNumber < 0)\n\t\tthrow new IllegalArgumentException(\"lineNumber parameter must be strictly positive\");\n\tif (lineNumbers.length == lineNumber + 1)\n\t\tthrow new IllegalArgumentException(\"lineNumber parameter must be greater than 0\");\n\tlineNumbers[lineNumber] = lineNumber;\n}"]}
{"_id": "636766f11a6d9265ec017658", "generate_results": ["public static int indexOfLastSeparator(String filename){\n\tint i;\n\tif(filename==null) return -1;\n\tfor(i=filename.length()-1;i>=0;i--) {\n\t\tif(filename.charAt(i)==File.separatorChar) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "public static int indexOfLastSeparator(String filename){\n\tif (filename == null)\n\t\treturn -1;\n\t\n\tint lastIndex = filename.length() - 1;\n\tfor (;;) {\n\t\tchar c = filename.charAt(lastIndex);\n\t\tif (c == '\\\\')\n\t\t\tlastIndex--;\n\t\telse\n\t\t\treturn lastIndex;\n\t}\n}", "public static int indexOfLastSeparator(String filename){\n\tif (filename == null)\n\t\treturn -1;\n\tint index = indexOfLastSeparator(filename.toCharArray(), 0, filename.length());\n\treturn index == -1? indexOfLastSeparator(filename.toCharArray(), filename.length(), 0) : index;\n}", "public static int indexOfLastSeparator(String filename){\n\tint length = 0;\n\tint index = indexOfLastSeparator(filename,0,filename.length());\n\tif(index == -1){\n\t\treturn index;\n\t}\n\t\n\twhile(index < length){\n\t\tif(filename.charAt(index) == '\\\\' || filename.charAt(index) == '/'){\n\t\t\t// we're at the end of the path\n\t\t\treturn index;\n\t\t}\n\t\tlength++;\n\t\tindex++;\n\t}\n\t\n\treturn -1;\n}", "public static int indexOfLastSeparator(String filename){\n\tif(filename==null) return -1;\n\tint length = filename.length();\n\tint lastSep = -1;\n\tfor(int i = 0; i < length; i++){\n\t\tchar ch = filename.charAt(i);\n\t\tif(ch == '/' || ch == '\\\\'){\n\t\t\tlastSep = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lastSep;\n}", "public static int indexOfLastSeparator(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\tint max = filename.length();\n\tint index = max;\n\tint ch = 0;\n\tdo{\n\t\tch = filename.charAt(index);\n\t\tif(ch == '\\\\' || ch == '/'){\n\t\t\treturn index;\n\t\t}\n\t\tindex++;\n\t} while (index < max){\n\t\tif(ch == '.'){\n\t\t\tif(index == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tch = filename.charAt(index);\n\t\t\tindex++;\n\t\t\tif(ch == '.' && index < max){\n\t\t\t\tif(filename.charAt(index) == '.'){\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(ch == '/' && index > 0 && filename.charAt(index - 1) == '/' && filename.charAt(index) == '/'){\n\t\t\treturn index;\n\t\t}\n\t\tif(ch == '/' && index > 0 && filename.charAt(index - 1) == '\\\\'){\n\t\t\treturn index;\n\t\t}\n\t\tindex++;\n\t}\n\treturn index;\n}", "public static int indexOfLastSeparator(String filename){\n\tif (filename == null)\n\t\treturn -1;\n\tint index = indexOfLastSeparator(filename, filename.length());\n\tif (index == 0)\n\t\treturn -1;\n\treturn index;\n}", "public static int indexOfLastSeparator(String filename){\n\tif(filename == null) return -1;\n\tint lastSep = indexOfLastSeparator(filename.charAt(0));\n\tif(lastSep == -1) return -1;\n\treturn indexOfLastSeparator(filename.substring(1));\n}", "public static int indexOfLastSeparator(String filename){\n\tif(filename == null) return -1;\n\tint length = filename.length();\n\tint lastSeparator = -1;\n\tfor(int i = 0; i < length; i++){\n\t\tlastSeparator = i;\n\t\tif(filename.charAt(i) == PATH_SEPARATOR){\n\t\t\tif(i > 0 && filename.charAt(i - 1) == PATH_SEPARATOR){\n\t\t\t\treturn i - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn lastSeparator;\n}", "public static int indexOfLastSeparator(String filename){\n\tif(filename == null) return -1;\n\tint index = filename.lastIndexOf(separatorChar);\n\t//the last directory separator is returned\n\treturn index;\n}"]}
{"_id": "636766fe1a6d9265ec017833", "generate_results": ["public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file == null) {\n\t\tthrow new NullPointerException(\"file must not be null\");\n\t}\n\tif (file.isDirectory()) {\n\t\tif (file.listFiles().length > 0) {\n\t\t\tfor (File f : file.listFiles()) {\n\t\t\t\tforceDeleteOnExit(f);\n\t\t\t}\n\t\t}\n\t}\n\tif (file.delete()) {\n\t\tSystem.out.println(\"Deleted \" + file);\n\t} else {\n\t\tthrow new IOException(\"Unable to delete \" + file);\n\t}\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file!= null) {\n\t\tif (file.isFile()) {\n\t\t\tfile.delete();\n\t\t}\n\t}\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file == null) {\n        throw new NullPointerException(\"File must not be null\");\n    }\n    FileUtils.deleteQuietly(file);\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file == null)\n        throw new NullPointerException(\"file must not be null\");\n    if (!file.isDirectory())\n        throw new IOException(\"File must be a directory, not \"+file.getAbsolutePath());\n    File[] files = file.listFiles();\n    if (files == null)\n        return;\n    for (int i = 0; i < files.length; i++) {\n        if (files[i].isDirectory()) {\n            forceDeleteOnExit(files[i]);\n            files[i] = null;\n        }\n    }\n    file.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file == null)\n        throw new NullPointerException(\"File must not be null\");\n    if (file.isDirectory())\n        forceDeleteOnExit(file.getAbsoluteFile());\n    else if (file.isFile())\n        file.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isFile()) {\n    forceDelete(file);\n  } else if (file.isDirectory()) {\n    for (File childFile : file.listFiles()) {\n      forceDelete(childFile);\n    }\n  }\n}", "public static void forceDeleteOnExit(File file) {\n\tif (file == null) {\n\t\tthrow new NullPointerException(\"file must not be null\");\n\t}\n\n\tif (file.isDirectory()) {\n\t\tforceDeleteOnExit(file);\n\t}\n\n\tfile.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\tif (file == null) {\n\t\tthrow new NullPointerException(\"File must not be null\");\n\t}\n\tif (!file.isDirectory()) {\n\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"File must be a directory: \" + file.getAbsolutePath());\n\t}\n\tif (file.isDirectory()) {\n\t\tFile[] files = file.listFiles();\n\t\tfor (File f : files) {\n\t\t\tforceDeleteOnExit(f);\n\t\t}\n\t}\n\tfile.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file == null) {\n        throw new NullPointerException(\"File must not be null\");\n    }\n    if (!file.exists()) {\n        return;\n    }\n    if (file.isDirectory()) {\n        File[] files = file.listFiles();\n        if (files == null) {\n            throw new IOException(\"Unable to list the files in the directory given\");\n        }\n        for (File f : files) {\n            forceDeleteOnExit(f);\n        }\n    }\n    file.delete();\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file == null) {\n        throw new NullPointerException(\"File must not be null\");\n    }\n\n    if (!file.isDirectory()) {\n        throw new IOException(\"File must be a directory\");\n    }\n\n    if (file.exists() && file.isFile()) {\n        forceDeleteOnExit(file.getParentFile());\n    }\n    file.delete();\n}"]}
{"_id": "636767061a6d9265ec01794a", "generate_results": ["public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\tif (filename.indexOf('.') >= 0) {\n\t\treturn indexOfLastSeparator(filename);\n\t}\n\tint lastDot = indexOfLastSeparator(filename, '.');\n\tif (lastDot < 0) {\n\t\treturn -1;\n\t}\n\tint length = filename.length();\n\tif (lastDot == length - 1) {\n\t\treturn indexOfLastSeparator(filename, '/');\n\t}\n\tif (lastDot == length - 2) {\n\t\treturn indexOfLastSeparator(filename, '/');\n\t}\n\treturn lastDot;\n}", "public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\tfor (int i = 0; i < filename.length(); i++) {\n\t\tif (filename.charAt(i) == '.') {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\tint index = indexOfLastSeparator(filename);\n\tif (index == -1) {\n\t\treturn index;\n\t}\n\tint start = index;\n\tint startIndex = index;\n\tif (indexOfLastSeparator(filename.substring(0, index))!= -1) {\n\t\tdo {\n\t\t\tindex++;\n\t\t} while (index < filename.length() && filename.charAt(index) == PATH_SEPARATOR_CHAR);\n\t\tstart = index;\n\t\tstartIndex = index;\n\t}\n\tif (indexOfLastSeparator(filename.substring(start, index))!= -1) {\n\t\tdo {\n\t\t\tindex++;\n\t\t} while (index < filename.length() && filename.charAt(index)!= PATH_SEPARATOR_CHAR);\n\t\tstart = index;\n\t\tstartIndex = index;\n\t}\n\treturn startIndex;\n}", "public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\treturn indexOfLastSeparator(filename, File.separatorChar);\n}", "public static int indexOfExtension(String filename){\n\treturn indexOfLastSeparator(filename, EXTENSION_SEPARATOR);\n}", "public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\tint index = indexOfExtension(filename.getBytes());\n\tif (index == -1) {\n\t\treturn index;\n\t}\n\treturn indexOfLastSeparator(filename.getBytes(), index);\n}", "public static int indexOfExtension(String filename){\n\tif (filename == null) {\n\t\treturn -1;\n\t}\n\treturn indexOfExtension(filename, INDEX_SEPARATOR);\n}", "public static int indexOfExtension(String filename){\n\t\treturn indexOfExtension(filename, '.');\n\t}", "public static int indexOfExtension(String filename){\n\tif (filename==null) {\n\t\tfilename=System.getProperty(\"file.separator\");\n\t}\n\tint index=indexOfLastSeparator(filename);\n\tif (index>=0) {\n\t\tindex++;\n\t}\n\treturn index;\n}", "public static int indexOfExtension(String filename){\n\t\n\tint index = indexOfLastSeparator(filename);\n\tif (index > -1) {\n\t\treturn index;\n\t}\n\t\n\tint lastIndex = filename.lastIndexOf('.');\n\tif (lastIndex == -1) {\n\t\treturn -1;\n\t}\n\t\n\treturn indexOfLastSeparator(filename.substring(lastIndex+1));\n}"]}
{"_id": "6367670b1a6d9265ec0179fe", "generate_results": ["public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n    if (b.length == 0) {\n        return;\n    }\n    write(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n\tint n = b.length;\n\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\n\tif (n > buf.length) {\n\t\tthrow new IOException(\"buf.length is too small\");\n\t}\n\n\tbuf.setLength(buf.length() + n);\n\n\tSystem.arraycopy(b, 0, buf.array(), buf.offset, n);\n}", "public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(byte b[]) throws IOException {\n\twrite(b, 0, b.length);\n}"]}
{"_id": "636766f91a6d9265ec01776e", "generate_results": ["public void write(final byte b[],final int off,final int len) throws IOException {\n\tout.write(b, off, len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif(len <= 0) {\n\t\treturn;\n\t}\n\tif(off < 0) {\n\t\tthrow new IndexOutOfBoundsException(\"off can not be negative\");\n\t}\n\tif(len > b.length - off) {\n\t\tthrow new IndexOutOfBoundsException(\"len can not be greater than b.length - off\");\n\t}\n\tfor(int i = off; i < off + len; i++) {\n\t\twrite(b[i]);\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tsuper.write(b,off,len);\n\tif (pos + len > buf.length) {\n\t\twrite(b,0,buf.length-pos);\n\t\tpos = 0;\n\t}\n\tbuf.setLength(buf.length()+len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tfinal int pos=off;\n\tfor (int i=0;i<len;i++) {\n\t\twrite(b[off++]);\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tcheck(len);\n\tif (b == null) {\n\t\tthrow new NullPointerException();\n\t}\n\tif (off < 0) {\n\t\tthrow new IndexOutOfBoundsException();\n\t}\n\tif (off + len > b.length) {\n\t\tthrow new IndexOutOfBoundsException();\n\t}\n\tfor (int i = off; i < off + len; i++) {\n\t\tbuf[i] = b[i];\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif (b == null) {\n\t\tthrow new NullPointerException();\n\t} else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length)) {\n\t\tthrow new IndexOutOfBoundsException();\n\t} else if (len == 0) {\n\t\treturn;\n\t}\n\tif (off == 0) {\n\t\tthis.b = b;\n\t} else {\n\t\tthis.b = Arrays.copyOfRange(b, off, off + len);\n\t}\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif (b == null) return;\n\tif (off < 0) throw new IndexOutOfBoundsException(\"off = \"+off+\", len = \"+len);\n\tif (len < 0) throw new IndexOutOfBoundsException(\"len = \"+len+\", off = \"+off);\n\tif (off + len > b.length) throw new IndexOutOfBoundsException(\"off = \"+off+\", len = \"+len+\", b.length = \"+b.length);\n\tif (off + len == b.length) {\n\t\tSystem.arraycopy(b, off, buf, 0, len);\n\t\treturn;\n\t}\n\tfinal int n = len;\n\tfinal int n2 = b.length - off;\n\tfinal int n3 = n2 - n;\n\tif (n3 <= 0) {\n\t\tSystem.arraycopy(b, off, buf, 0, n);\n\t\treturn;\n\t}\n\tSystem.arraycopy(b, off, buf, 0, n);\n\tSystem.arraycopy(b, off, buf, len, n2);\n\tSystem.arraycopy(b, off, buf, len + n2, n3);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n    checkBounds(off,len);\n    super.write(b,off,len);\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n    if (len <= 0) {\n        return;\n    }\n    if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length)) {\n        throw new IndexOutOfBoundsException();\n    }\n    final int n = len;\n    final int pos = off;\n    while (n > 0) {\n        b[pos] = (byte) (b[pos] + this.count);\n        this.count = count;\n        this.count = count >>> 8;\n        pos++;\n        n--;\n    }\n}", "public void write(final byte b[],final int off,final int len) throws IOException {\n    write(b,off,len,null);\n}"]}
{"_id": "6367670a1a6d9265ec0179d8", "generate_results": ["public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    outputStream.write(b);\n}", "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n\t//System.out.println(\"write\");\n\t//System.out.println(new String(b));\n\t//System.out.println(\"write size: \"+b.length);\n\t//System.out.println(b.length);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System.out.println(\"write size: \"+b.length>0);\n\t//System", "public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n\twrite(b, 0, b.length);\n}", "public void write(final byte[] b) throws IOException {\n    out.write(b);\n}", "public void write(final byte[] b) throws IOException {\n     super.write(b);\n}"]}
{"_id": "636767001a6d9265ec01787e", "generate_results": ["public void set(StringBuilder str,int len,boolean caseInsensitive){\n    this.str = str.toString();\n    this.len = len;\n    this.caseInsensitive=caseInsensitive;\n}", "public String toString(){\n\treturn string;\n}", "public String toString(){\n\treturn \"\";\n}", "public String toString(){\n\treturn \"\";\n}", "public String toString(){\n\treturn this.toString(false);\n}", "public String toString(){\n    return str();\n}", "public String toString(){\n    return \"StringBuilder\";\n}", "public String toString(){\n\treturn str;\n}", "public String toString(){\n\treturn str;\n}", "public String toString(){\n    return string;\n}"]}
{"_id": "636767001a6d9265ec01787f", "generate_results": ["/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n    buffer.append(fieldName);\n    buffer.append(\"=\");\n    buffer.append(Arrays.toString(array));\n\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tint length = array.length;\n\tif (length > 0){\n\t\tbuffer.append(fieldName).append('[');\n\t\tfor (int i = 0; i < length; i++){\n\t\t\tbuffer.append(array[i]).append(\", \");\n\t\t}\n\t\tbuffer.append(']');\n\t}\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(\"[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]+\", \");\n\t}\n\tbuffer.append(\"]\");\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n    if (array==null)\n        return;\n    buffer.append(fieldName);\n    buffer.append(\"[ \");\n    for (int i=0;i<array.length;i++) {\n        if (i!=0)\n            buffer.append(\", \");\n        buffer.append(array[i]);\n    }\n    buffer.append(\" ]\");\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n    if(array.length > 0){\n        buffer.append(\"[\");\n        int n = array.length;\n        for(int i = 0;i < n;i++){\n            if(i > 0) buffer.append(\", \");\n            buffer.append(array[i]);\n        }\n        buffer.append(\"]\");\n    }else{\n        buffer.append(\"null\");\n    }\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n    if (array == null) {\n        return;\n    }\n    buffer.append(fieldName).append(\" : \");\n    for (int i = 0; i < array.length; i++){\n        if (i > 0) {\n            buffer.append(\", \");\n        }\n        String s = Integer.toString(array[i]);\n        buffer.append(s);\n    }\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n    buffer.append(fieldName);\n    for(int i=0;i<array.length;i++){\n        buffer.append(array[i]);\n    }\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n    buffer.append(fieldName);\n    buffer.append(\"[\");\n    for(int i=0;i<array.length;i++){\n        if(i>0){\n            buffer.append(\",\");\n        }\n        buffer.append(array[i]);\n    }\n    buffer.append(\"]\");\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\t\n\tbuffer.append(\"(\");\n\tbuffer.append(fieldName);\n\tbuffer.append(\", \");\n\tbuffer.append(Arrays.toString(array));\n\tbuffer.append(\")\");\n\n}", "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tbuffer.append(fieldName);\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\", \");\n\t\t}\n\t}\n}"]}
{"_id": "636766f71a6d9265ec017730", "generate_results": ["/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}", "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])}"]}
{"_id": "636767041a6d9265ec017911", "generate_results": ["/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n    if (!(value instanceof Object)){\n        return;\n    }\n    \n    Object[] args = new Object[2];\n    args[0] = value;\n    args[1] = value;\n    \n    \n    reflections.put(value.getClass().getName(), value);\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n  if(!registered){\n    registered = true;\n    registerReflection(value);\n  }else{\n    throw new Error(\"Already registered\");\n  }\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n    if(value == null){\n        return;\n    }\n\n    // Check if the object is already registered.\n    if(registered.contains(value)){\n        return;\n    }\n\n    // Register the object.\n    registered.add(value);\n\n    // Register the method.\n    if(value instanceof Constructor){\n        Class cls = ((Constructor)value).getDeclaringClass();\n        try{\n            cls.getDeclaredMethod(\"registerConstructor\",\n                    Class.forName(\"java.lang.reflect.Constructor\"));\n        }catch(Exception e){\n            // Ignore.\n        }\n    }else if(value instanceof Method){\n        Class cls = ((Method)value).getDeclaringClass();\n        try{\n            cls.getDeclaredMethod(\"registerMethod\",\n                    Class.forName(\"java.lang.reflect.Method\"));\n        }catch(Exception e){\n            // Ignore.\n        }\n    }\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif(value!= null)\n\t\tclasses.register(value);\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif( object_map.get(value)!= null ){\n\t\tthrow new RuntimeException(\"Object already registered: \" + value);\n\t}\n\tobject_map.put(value, value);\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n  if (value instanceof Class){\n    register((Class)value);\n  } else if (value instanceof String){\n    register(value.toString());\n  } else {\n    throw new RuntimeException(\"Unable to register object \" + value.getClass() + \".\");\n  }\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif(value==null) return;\n\tif(!(value instanceof Object)){\n\t\tthrow new IllegalArgumentException(\"The passed object is not an instance of Object\");\n\t}\n\t\n\tif(!(value instanceof java.lang.reflect.Field)){\n\t\tthrow new IllegalArgumentException(\"The passed object is not a Field\");\n\t}\n\t\n\tjava.lang.reflect.Field field=(java.lang.reflect.Field)value;\n\tfield.setAccessible(true);\n\t\n\tif(!field.isAccessible()) field.setAccessible(true);\n\t\n\tObject fieldValue=get(field);\n\t\n\tif(fieldValue==null) fieldValue=value;\n\t\n\tfield.set(value, fieldValue);\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif(!value){\n\t\tthrow new IllegalArgumentException(\"Registering null\");\n\t}\n\n\t// register the object\n\tObject[] array = new Object[1];\n\tarray[0] = value;\n\tClass<?> cls = value.getClass();\n\ttry{\n\t\tClassLoader classLoader = cls.getClassLoader();\n\t\tif(classLoader!= null){\n\t\t\tClass<?> cls2 = classLoader.loadClass(cls.getName());\n\t\t\tif(!cls2.isAssignableFrom(array[0].getClass())){\n\t\t\t\tthrow new IllegalArgumentException(\"Unable register \" + value + \" as \" + cls);\n\t\t\t}\n\t\t\tcls2.getConstructors();\t// get the constructor for the class\n\t\t\tConstructor<?>[] ctors = cls2.getDeclaredConstructors();\n\t\t\tfor(Constructor<?> c: ctors){\n\t\t\t\ttry{\n\t\t\t\t\tregister(c.newInstance(array));\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\tthrow new IllegalArgumentException(\"Error creating constructor \" + c, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\tthrow new IllegalArgumentException(\"Error registering \" + value, e);\n\t}\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif (registry.containsKey(value)) return; // already registered\n\tregistry.put(value,value);\n}", "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n\nstatic void register(Object value){\n\tif(value == null){\n\t\treturn;\n\t}\n\tif(!(value instanceof Object[])){\n\t\treturn;\n\t}\n\tObject[] objects = (Object[])value;\n\tfor(int i=0;i<objects.length;i++){\n\t\tregister(objects[i]);\n\t}\n}"]}
{"_id": "636766fe1a6d9265ec017821", "generate_results": ["/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n  buffer.append(fieldName);\n  buffer.append(\"=\");\n  buffer.append(array);\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(getDetail(fieldName,array));\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(\"\\n\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(fieldName+\": \");\n\t\tbuffer.append(array[i]);\n\t\tbuffer.append(\"\\n\");\n\t}\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName + \": \");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\", \");\n\t\t}\n\t}\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(array);\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tif (array == null) {\n\t\tbuffer.append(\"null\");\n\t} else {\n\t\tbuffer.append(\"[\");\n\t\tfor (int i=0;i<array.length;i++) {\n\t\t\tif (i>0) {\n\t\t\t\tbuffer.append(\", \");\n\t\t\t}\n\t\t\tbuffer.append(new Integer(array[i]));\n\t\t}\n\t\tbuffer.append(\"]\");\n\t}\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(\"[\");\n\tbuffer.append(fieldName);\n\tbuffer.append(\" = \");\n\tbuffer.append(Arrays.toString(array));\n\tbuffer.append(\"]\");\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n  buffer.append(array[0]);\n  for (int i=1; i<array.length; i++)\n    buffer.append(FIELD_SEPARATOR);\n    \n  buffer.append(array[array.length -1]);\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tbuffer.append(\"=\");\n\tbuffer.append(array);\n\tbuffer.append(\"\\n\");\n}", "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tbuffer.append(fieldName);\n\tfor (int i = 0 ; i < array.length ; i++ ) {\n\t\tbuffer.append(array[i]);\n\t}\n}"]}
{"_id": "636766fc1a6d9265ec0177ef", "generate_results": ["/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}", "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])}"]}
{"_id": "636766f11a6d9265ec017641", "generate_results": ["public synchronized int available() throws IOException {\n    return is.available();\n}", "public int available() throws IOException {\n  return in.available();\n}", "public int available() throws IOException {\n    return super.available();\n}", "public int available() throws IOException {\n  int n = in.available();\n  if (n == 0) return 0;\n  return n;\n}", "public int available() throws IOException {\n\treturn -1;\n}", "public int available() throws IOException {\n    if (position == positionLimit) {\n\treturn -1;\n    }\n    return 1;\n}", "public int available() throws IOException {\n    return ((InputStream)getStream()).available();\n}", "public int available()", "public synchronized int available() throws IOException {\n    return _in.available();\n}", "public int available() throws IOException {\n\tif (this.isClosed()) throw new IOException(\"InputStream is closed\");\n\treturn this.in.available();\n}"]}
{"_id": "636766f01a6d9265ec017639", "generate_results": ["public static <T>List<T> asList(T[] a){\n    return Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tif (a == null) return null;\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tif (a == null) return null;\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tList<T> l = new ArrayList<T>();\n\tfor(int i=0; i<a.length; i++){\n\t\tl.add(a[i]);\n\t}\n\treturn l;\n}", "public static <T>List<T> asList(T[] a){\n\tif( a == null ) return new ArrayList<T>(a);\n\treturn (List<T>)new ArrayList<T>(a);\n}", "public static <T> List<T> asList(T[] a){\n\treturn asList(a, 0, a.length);\n}", "public static <T>List<T> asList(T[] a){\n    return asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\tif (a == null) return emptyList();\n\treturn new ArrayList(Arrays.asList(a));\n}"]}
{"_id": "636766f91a6d9265ec01777d", "generate_results": ["public static byte convertHexDigit(byte b){\n    return (byte) (convertHexDigit(b) << 4);\n}", "public static byte convertHexDigit(byte b){\n\tif(b == '0' || b == '1' || b == '2' || b == '3' || b == '4' || b == '5' || b == '6' || b == '7' || b == '8' || b == '9'){\n\t\treturn b;\n\t}\n\tif(b >= 'a' && b <= 'f'){\n\t\treturn (byte)(b - 'a' + 10);\n\t}\n\tif(b >= 'A' && b <= 'F'){\n\t\treturn (byte)(b - 'A' + 10);\n\t}\n\tthrow new IllegalArgumentException(\"Unable to convert character 0-16 to byte\");\n}", "public static byte convertHexDigit(byte b){\n\tif (b >= '0' && b <= '9')\n\t\treturn b - '0';\n\tif (b >= 'A' && b <= 'F')\n\t\treturn b - 'A' + 10;\n\treturn b;\n}", "public static byte convertHexDigit(byte b){\n  return ((b & 0xF0) >> 4);\n}", "public static byte convertHexDigit(byte b){\n\treturn (byte) ((b >= '0')? b - '0' : b - 'A' + 10);\n}", "public static byte convertHexDigit(byte b){\n\n    if (b >= '0' && b <= '9')\n        return b - '0';\n    else if (b >= 'a' && b <= 'f')\n        return b - 'a' + 10;\n    else\n        return b - 'A' + 10;\n}", "public static byte convertHexDigit(byte b){\n    return (byte)(((b & 0xF0) >> 4) * 16 + (b & 0x0F));\n}", "public static byte convertHexDigit(byte b){\n    if(b < 0x10)\n        return (byte)(((b) << 4) | (b & 0x0f));\n    else if(b < 0x100)\n        return (byte)(((b) << 4) | (b & 0x0f) | (b & 0xf0) >> 4);\n    else if(b < 0x10000){\n        return (byte)(((b) << 4) | (b & 0x0f) | (b & 0xf0) >> 4 | (b & 0x0f) << 4);\n    }\n    else if(b < 0x1000000){\n        return (byte)(((b) << 4) | (b & 0x0f) | (b & 0xf0) >> 4 | (b & 0xf) << 4 | (b & 0x0f) << 6);\n    }\n    else if(b < 0x100000000){\n        return (byte)(((b) << 4) | (b & 0x0f) | (b & 0xf0) >> 4 | (b & 0xf) << 4 | (b & 0x0f) << 6 | (b & 0xf) << 8);\n    }\n    else{\n        return (byte)(((b) << 4) | (b & 0x0f) | (b & 0xf0) >> 4 | (b & 0xf) << 4 | (b & 0x0f) << 6 | (b & 0xf) << 8 | (b & 0xf) << 10);\n    }\n}", "public static byte convertHexDigit(byte b){\n\tint bb = b & 0xF;\n\treturn (byte) (bb < 10? ('0' + bb) : ('A' + (bb - 10)));\n}", "public static byte convertHexDigit(byte b){\n\t\n\treturn (byte)(b & 0x0f);\n}"]}
{"_id": "6367670a1a6d9265ec0179e7", "generate_results": ["public Converter lookup(final Class<?> clazz){\n    return (Converter)lookup.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn (Converter) lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn registered.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n\tConverter result = (Converter)registeredConverters.get(clazz);\n\treturn result;\n}", "public Converter lookup(final Class<?> clazz){\n\treturn Converter.lookup(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn lookup(clazz, null);\n}", "public Converter lookup(final Class<?> clazz){\n\treturn ConverterLookup.getInstance().lookup(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n    Converter converter = null;\n    \n    // First, try the cache\n    converter = converterCache.get(clazz);\n    \n    // Second, try the registry\n    if(converter == null){\n        converter = lookupByClass(clazz);\n    }\n    \n    // Third, return the first one\n    return converter;\n}"]}
{"_id": "6367670b1a6d9265ec0179f2", "generate_results": ["public boolean containsKey(final Object key){\n  return key instanceof Integer && ((Integer)key).intValue()==((Integer)this.key).intValue();\n}", "public boolean containsKey(final Object key){return map.containsKey(key);}", "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n}", "public boolean containsKey(final Object key){\n    return entrySet().contains(new AbstractMapEntry<Object, Boolean>() {\n        public Object getKey(){ return key; }\n        public Boolean getValue(){ return null; }\n    });\n}", "public boolean containsKey(final Object key){\n  return super.containsKey(key);\n}", "public boolean containsKey(final Object key){\n\treturn map.containsKey(key);\n}", "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n}", "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n}", "public boolean containsKey(final Object key){\n\tfinal Object[] k = keyToArray(key);\n\treturn containsKey(k);\n}", "public boolean containsKey(final Object key){\n\treturn super.containsKey(key);\n}"]}
{"_id": "636767041a6d9265ec0178f8", "generate_results": ["/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tString[] dst = new String[src.length];\n\tfor(int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor (int i = 0; i < src.length; i++) {\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor(int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\t\n\tfor(int i = 0 ; i < src.length ; i++){\n\t\tif(!src[i].equals(src[i].toLowerCase())){\n\t\t\tdst[i] = src[i];\n\t\t}\n\t}\n\t\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tString[] dst=new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\tdst[i]=src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\t\n\tfor(int i=0;i<src.length;i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\t\n\treturn dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n    final String[] dst = new String[src.length];\n    for (int i = 0; i < src.length; i++){\n        dst[i] = src[i].toLowerCase();\n    }\n    return dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfor (final String element : src) {\n\t\tif (!Character.isLowerCase(element.charAt(0))) {\n\t\t\tthrow new IllegalArgumentException(\"The string array to copy is not correctly upper-case\");\n\t\t}\n\t}\n\treturn src;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n    final String[] dst = new String[src.length];\n    for (int i = 0; i < src.length; i++) {\n        dst[i] = src[i].toLowerCase();\n    }\n    return dst;\n}", "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dst = new String[src.length];\n\tfor(int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}"]}
{"_id": "636767021a6d9265ec0178bf", "generate_results": ["/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) return null;\n\tCharacter result = null;\n\tif (type == Character.class) {\n\t\tresult = (Character)value;\n\t} else if (type == String.class) {\n\t\tif (value instanceof String) {\n\t\t\tresult = new String((String)value);\n\t\t} else if (value instanceof StringBuffer) {\n\t\t\tresult = String.valueOf(((StringBuffer)value).toString());\n\t\t} else if (value instanceof StringBuilder) {\n\t\t\tresult = String.valueOf(((StringBuilder)value).toString());\n\t\t} else {\n\t\t\tresult = value.toString();\n\t\t}\n\t} else if (type == Character.TYPE) {\n\t\tresult = new Character((Character)value);\n\t} else if (type == Boolean.TYPE) {\n\t\tresult = (value instanceof Boolean)?new Boolean((Boolean)value):Boolean.FALSE;\n\t} else if (type == Byte.TYPE) {\n\t\tresult = (value instanceof Byte)?new Byte((Byte)value):new Byte((byte)value);\n\t} else if (type == Short.TYPE) {\n\t\tresult = (value instanceof Short)?new Short((Short)value):new Short((short)value);\n\t} else if (type == Integer.TYPE) {\n\t\tresult = (value instanceof Integer)?new Integer((Integer)value):new Integer((int)value);\n\t} else if (type == Long.TYPE) {\n\t\tresult = (value instanceof Long)?new Long((Long)value):new Long((long)value);\n\t} else if (type == Float.TYPE) {\n\t\tresult = (value instanceof Float)?new Float((Float)value):new Float((float)value);\n\t} else if (type == Double.TYPE) {\n\t\tresult = (value instanceof Double)?new Double((Double)value):new Double((double)value);\n\t} else if (type == BigInteger.class) {\n\t\tresult = new BigInteger((BigInteger)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDecimal.class) {\n\t\tresult = new BigDecimal((BigDecimal)value);\n\t} else if (type == BigDec", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value.getClass()!= type) {\n\t\tthrow new IllegalArgumentException(\"the value must be of type \" + type);\n\t}\n\tCharacter result = null;\n\tif (value instanceof Character) {\n\t\tresult = (Character) value;\n\t} else {\n\t\tresult = Character.valueOf(value.toString().charAt(0));\n\t}\n\treturn result;\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof Character) {\n\t\treturn value;\n\t} else if (value instanceof Boolean) {\n\t\treturn ((Boolean)value).booleanValue()? '\\u001B' : '\\u001B';\n\t} else {\n\t\treturn '\\u001B';\n\t}\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n    return value.toString();\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (type == null) throw new IllegalArgumentException(\"type must not be null\");\n\tif (value == null) throw new IllegalArgumentException(\"value must not be null\");\n\tif (value instanceof Character) return value;\n\tif (value instanceof Byte) return ((Byte)value).byteValue();\n\tif (value instanceof Short) return ((Short)value).shortValue();\n\tif (value instanceof Integer) return ((Integer)value).intValue();\n\tif (value instanceof Long) return ((Long)value).longValue();\n\tif (value instanceof Float) return ((Float)value).floatValue();\n\tif (value instanceof Double) return ((Double)value).doubleValue();\n\tif (value instanceof BigInteger) return ((BigInteger)value).longValue();\n\tif (value instanceof BigDecimal) return ((BigDecimal)value).longValue();\n\tif (value instanceof String) return value.toString();\n\tif (value instanceof Calendar) return ((Calendar)value).getTime();\n\tif (value instanceof boolean[]) return new char[](((boolean[])value)[0]);\n\tif (value instanceof byte[]) return new char[](((byte[])value)[0]);\n\tif (value instanceof char[]) return new char[](((char[])value)[0]);\n\tif (value instanceof double[]) return new char[](((double[])value)[0]);\n\tif (value instanceof float[]) return new char[](((float[])value)[0]);\n\tif (value instanceof int[]) return new char[](((int[])value)[0]);\n\tif (value instanceof long[]) return new char[](((long[])value)[0]);\n\tif (value instanceof short[]) return new char[](((short[])value)[0]);\n\tthrow new IllegalArgumentException(\"Conversion of value \" + value + \" of type \" + type.getName() + \" cannot be performed\");\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif ( value==null) {\n\t\treturn null;\n\t}\n\tif ( value instanceof Character) {\n\t\treturn value;\n\t}\n\n\tthrow new Exception(\"Unknown type: \"+value.getClass().getName()+\" for \"+value);\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (Character.class.equals(type)) return value.toString();\n\tif (Integer.class.equals(type)) return value.toString();\n\tif (Long.class.equals(type)) return value.toString();\n\tif (Double.class.equals(type)) return value.toString();\n\tif (Float.class.equals(type)) return value.toString();\n\treturn value.toString();\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\treturn value.toString().charAt(0);\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\treturn value;\n}", "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n    if (value instanceof String) {\n        return value;\n    } else if (value instanceof Character) {\n        return value;\n    } else if (value instanceof Number) {\n        return value;\n    } else if (value instanceof Boolean) {\n        return value;\n    } else if (value instanceof Date) {\n        return value;\n    } else if (value instanceof Calendar) {\n        return value;\n    } else {\n        throw new IllegalArgumentException(\"Unknown data type: \" + value.getClass().getName());\n    }\n}"]}
{"_id": "636766f11a6d9265ec01764f", "generate_results": ["public Collection<Object> values(){\n    return this.values;\n}", "public Collection<Object> values(){\n\treturn Collections.unmodifiableCollection(this.values.values());\n}", "public Collection values(){\n\treturn Collections.unmodifiableCollection(this.values);\n}", "public Collection<Object> values(){ return Collections.emptyList(); }", "public Collection<Object> values(){\n\treturn values;\n}", "public Collection<Object> values(){\n    return new HashSet<Object>();\n}", "public Collection<Object> values(){\n\treturn new HashSet<Object>(beanMap.values());\n}", "public Map<Object,Object> setHashMap(Collection<Object> set,Set<Object> set){\n\tthis.hashMap = set;\n\tthis.set = set;\n\treturn this;\n}", "public Collection<Object> values(){\n\treturn (Collection<Object>) values;\n}", "public Collection<Object> values(){\n\treturn new ArrayList<Object>();\n}"]}
{"_id": "636767071a6d9265ec017962", "generate_results": ["public void putAllWriteable(BeanMap map){\n    for(Map.Entry entry : map.entrySet()){\n        putWriteable(entry.getKey(), entry.getValue());\n    }\n}", "public void putAllWriteable(BeanMap map){\n    map.putAll(this);\n}", "public void putAllWriteable(BeanMap map){\n\t\n\tfor(Map.Entry<String, Object> entry: map.entrySet()){\n\t\tif(entry.getValue() instanceof Map)\n\t\t\tputAllWriteable((Map) entry.getValue());\n\t\telse\n\t\t\tputWriteable(entry.getKey(), entry.getValue());\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tfor(Map.Entry entry : map.entrySet()){\n\t\tputWriteable(entry.getKey(), entry.getValue());\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tmap.putAll(this);\n}", "public void putAllWriteable(BeanMap map){\n\tmap.putAll(this);\n}", "public void putAllWriteable(BeanMap map){\n\tfor (BeanProperty property : map.getPropertyNames()) {\n\t\tif (property.isWritable()) {\n\t\t\tthis.put(property.getName(), map.get(property.getName()));\n\t\t}\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tfor(Map.Entry<String, Object> entry : map.entrySet()){\n\t\tif(entry.getValue() instanceof Writable){\n\t\t\tputWriteable(entry.getKey(), (Writable) entry.getValue());\n\t\t}else{\n\t\t\tputWriteable(entry.getKey(), entry.getValue());\n\t\t}\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\tfor (BeanMap.Property property : map.getProperties()) {\n\t\tputWriteableProperty(property.getName(), property.getType(), property.getReadOnly(), property.getWriteOnly());\n\t}\n}", "public void putAllWriteable(BeanMap map){\n    for(Property p: map.getProperties()){\n        if(!p.getWriteable()){\n            p.setWriteable(true);\n            p.setWriteableProperty(true);\n        }\n    }\n}"]}
{"_id": "636767031a6d9265ec0178dd", "generate_results": ["public long contentLength(){\n    return (this.length);\n}", "public long contentLength(){\n\treturn _contentLength;\n}", "public long contentLength(){\n    return contentLength;\n}", "public long contentLength(){\n    return _contentLength;\n}", "public long contentLength(){\n  return contentLength;\n}", "public long contentLength(){\n  return (this.length);\n}", "public long contentLength(){\n    return _contentLength;\n}", "public long contentLength(){\n    return this.contentLength;\n}", "public long contentLength(){\n    return contentLength;\n}", "public long contentLength(){return http.contentLength;}"]}
{"_id": "636767121a6d9265ec017b0a", "generate_results": ["/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\t\n\tint start=0;\n\tint end1=0;\n\tint end2=0;\n\t\n\tif(headerPart.length()>0){\n\t\tend1=headerPart.indexOf(\"\\r\\n\");\n\t\t\n\t\tif(end1>0){\n\t\t\tend2=headerPart.indexOf(\"\\n\",end1);\n\t\t\t\n\t\t\tif (end2>0 && end2<end1){\n\t\t\t\tend=end2+1;\n\t\t\t}else{\n\t\t\t\tend=end1+1;\n\t\t\t}\n\t\t}else{\n\t\t\tend=end1+1;\n\t\t}\n\t}\n\t\n\treturn end;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n    while(end> 0 && headerPart.charAt(end-1) == '\\r' && headerPart.charAt(end-2) == '\\n')\n        end--;\n    return end;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\t\n\tif(end<0){\n\t\tend=headerPart.length();\n\t}\n\t\n\tint i = end;\n\t\n\tif(end>1){\n\t\twhile(i>=1 && (headerPart.charAt(i-1)=='\\r') && (headerPart.charAt(i-2)=='\\n')){\n\t\t\ti--;\n\t\t}\n\t\tif(i>end){\n\t\t\ti=end;\n\t\t}\n\t}\n\t\n\treturn i;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\tint result = end;\n\tint index = end;\n\t\n\t// First of all, check for a line ending with \\r\\n\n\tif(headerPart.length()>1 && headerPart.charAt(0)=='\\r' && headerPart.charAt(1)=='\\n'){\n\t\tresult = end;\n\t}\n\t\n\t// Then, if we have a \\r\\n and no other \\r\\n is found, skip it\n\tif(headerPart.length()>1 && headerPart.charAt(0)=='\\r' && headerPart.charAt(1)!='\\r'){\n\t\tindex = end;\n\t\tif(index>end){\n\t\t\tresult = end;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\t\n\tStringBuffer line = new StringBuffer();\n\t\n\tline.append(headerPart);\n\t\n\tfor(int i=0; i<end; i++){\n\t\tif (line.charAt(i) == '\\n'){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn i + 1;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\t\n\tif(headerPart.length()>0){\n\t\tif(headerPart.charAt(headerPart.length()-1)=='\\r'){\n\t\t\treturn end;\n\t\t}\n\t}\n\t\n\treturn end;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\tint result = end;\n\tint i=0;\n\twhile(i<headerPart.length()){\n\t\tif(headerPart.charAt(i)=='\\r'){\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif(i==headerPart.length()){\n\t\treturn result;\n\t}\n\t//This is the end of line, so parse it and return the index of the \\r\\n sequence\n\tint endOfLine = i;\n\twhile(i<headerPart.length()){\n\t\tif(headerPart.charAt(i)=='\\r'){\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif(i==headerPart.length()){\n\t\treturn result;\n\t}\n\treturn endOfLine;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\tint pos = 0;\n\twhile (pos < end){\n\t\tif (headerPart.charAt(pos) == '\\r'){\n\t\t\tint endPos = pos;\n\t\t\twhile (endPos < headerPart.length()){\n\t\t\t\tif (headerPart.charAt(endPos) == '\\n'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tendPos++;\n\t\t\t}\n\t\t\tif (endPos < headerPart.length()){\n\t\t\t\treturn endPos;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthrow new RuntimeException(\"Error: header has more than one \\r\\n character\");\n\t\t\t}\n\t\t}\n\t\tpos++;\n\t}\n\treturn -1;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n\tint start = end;\n\tint pos = 0;\n\tint len = 0;\n\twhile(pos < headerPart.length()){\n\t\tif(headerPart.charAt(pos) == '\\r'){\n\t\t\tif(pos < end){\n\t\t\t\tlen = end - pos;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpos++;\n\t}\n\tif(len > 0){\n\t\treturn start + len;\n\t}\n\treturn -1;\n}", "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n\nprivate int parseEndOfLine(String headerPart,int end){\n    int index=end;\n    for (int i=end-1;i>end+1;i--){\n        if (headerPart.charAt(i)=='\\r'){\n            index=i;\n            break;\n        }\n    }\n    return index;\n}"]}
{"_id": "636766ff1a6d9265ec017851", "generate_results": ["/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n    return (value & byteMask) == value? pos : -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\tint pos1 = 0;\n\tfor(int i=pos;i<pos1;i++){\n\t\tif(buffer[i]==value){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\tint result=-1;\n\tint pos1=pos;\n\tfor(int i=0;i<size();i++){\n\t\tif(buffer[i]==value){\n\t\t\tif(pos1==i){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif(pos1==0){\n\t\t\t\tresult=i;\n\t\t\t}\n\t\t}\n\t\tpos1--;\n\t}\n\treturn result;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\n  int i = pos;\n  while (i < buffer.length) {\n    if ((buffer[i] == value) && (i < buffer.length - 1)) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\treturn findByte(value,pos,0);\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\tint i=0;\n\tdo{\n\t\ti++;\n\t}while(i<pos && (buffer[i]==value||buffer[i]==0));\n\treturn i;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\t\n\tif(buffer[pos]==value){\n\t\treturn pos;\n\t}\n\tif(buffer[pos]!=value){\n\t\treturn -1;\n\t}\n\t\n\tfor(int i=pos+1;i<buffer.length;i++){\n\t\tif(buffer[i]==value){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\t\n\tif(pos<0){\n\t\tthrow new IndexOutOfBoundsException(\"position must be >= 0\");\n\t}\n\t\n\tint valuePos = 0;\n\tfor(int i=pos-1;i>=0;i--){\n\t\tif(buffer[i]==value){\n\t\t\treturn i;\n\t\t}\n\t\tvaluePos++;\n\t}\n\treturn -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n\tbyte byteValue=(byte)value;\n\tint bytePos=(int)pos;\n\t//System.out.println(byteValue+\" \"+bytePos);\n\twhile(bytePos>=0){\n\t\tif(buffer[bytePos]==byteValue){\n\t\t\treturn bytePos;\n\t\t}\n\t\tbytePos--;\n\t}\n\treturn -1;\n}", "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n\nprotected int findByte(byte value,int pos){\n    return buffer[pos+1]&0xff;\n}"]}
{"_id": "636766f81a6d9265ec01774b", "generate_results": ["public byte readByte() throws IOException {\n  byte result = buffer.readByte();\n  if (result == (byte)EOF) {\n    throw new EOFException();\n  }\n  return result;\n}", "public byte readByte() throws IOException {\n    if (buffer == null) {\n        throw new IOException(\"No more data available\");\n    }\n    return buffer[bufferPos++];\n}", "public byte readByte() throws IOException {\n    if (bufferPos == buffer.length) {\n        fillBuffer();\n    }\n    return buffer[bufferPos++];\n}", "public void readBytes(byte[] buffer, int bufferPos) throws IOException {\n    int i;\n    for (i = 0; i < 16; i++) {\n        buffer[bufferPos] = readByte();\n        bufferPos++;\n    }\n}", "public byte readByte() throws IOException {\n  if (position >= buffer.length) {\n    fill();\n  }\n  return buffer[position++];\n}", "public byte readByte() throws IOException {\n    return readByte(buffer);\n}", "public char readChar() throws IOException {\n  int nextByte = readByte();\n  if (nextByte == -1) {\n    return '\\0';\n  }\n  int result = (nextByte & 0xFF);\n  nextByte = readByte();\n  if (nextByte == -1) {\n    return '\\0';\n  }\n  result |= (nextByte & 0xFF) << 8;\n  nextByte = readByte();\n  if (nextByte == -1) {\n    return '\\0';\n  }\n  result |= (nextByte & 0xFF) << 16;\n  nextByte =", "public byte readByte() throws IOException {\n    byte b = in.readByte();\n    if (read!= 0) {\n\tif (b == read) {\n\t    in.unreadByte();\n\t} else {\n\t    throw new EOFException(\"InputStream closed\");\n\t}\n    }\n    return b;\n}", "public byte readByte() throws IOException {\n\tint b = buffer.read();\n\tif (b < 0)\n\t\tthrow new EOFException();\n\treturn (byte) b;\n}", "public byte readByte() throws IOException {\n\tif (buffer == null) {\n\t\tthrow new IOException(\"No data available.\");\n\t}\n\tbyte theByte = buffer[pos++];\n\tif (pos >= bufLength) {\n\t\tfillBuffer();\n\t}\n\treturn theByte;\n}"]}
{"_id": "636766fa1a6d9265ec01779c", "generate_results": ["/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n    StringBuilder token = new StringBuilder();\n    char current = terminators[0];\n    for(int i = 1; i < terminators.length; i++){\n        char next = terminators[i];\n        if(current == '*' && next == '/'){\n            token.append(current);\n            current = terminators[i+1];\n        }else if(current == '/' && next == '/'){\n            token.append(current);\n            current = terminators[i+2];\n        }else if(current == '*' && next == '*'){\n            token.append(current);\n            current = terminators[i+3];\n        }else if(current == '/' && next == '*'){\n            token.append(current);\n            current = terminators[i+4];\n        }else if(current == '*' && next == '*'){\n            token.append(current);\n            current = terminators[i+5];\n        }else if(current == '/' && next == '*'){\n            token.append(current);\n            current = terminators[i+6];\n        }\n        else if(current == '/'){\n            token.append(current);\n            current = next;\n        }\n    }\n    return token.toString();\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n    int start=0;\n    int end=0;\n    for(int i=0;i<terminators.length;i++){\n        if(terminators[i]=='\\''){\n            end=i;\n            break;\n        }\n        if(terminators[i]=='\\\"'){\n            start=i;\n            break;\n        }\n    }\n    return new String(terminators,start,end-start);\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\tString result = null;\n\tfor(int i = 0; i < terminators.length; i++){\n\t\tif(terminators[i] == '\"' || terminators[i] == '\\''){\n\t\t\treturn result;\n\t\t}\n\t\tif(terminators[i] == ';' || terminators[i] == ','){\n\t\t\tresult = result.concat(terminators[i]);\n\t\t}\n\t}\n\treturn result;\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n    StringBuilder b = new StringBuilder();\n    \n    for(int i = 0; i < terminators.length; i++){\n        char c = terminators[i];\n        \n        if(c == '\"'){\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '\\''){\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '{'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '}'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == ';'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == ':'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == ':'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '='){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '!'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '!'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '%'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        }\n        \n        if(c == '%'){\n            b.append(c);\n            if(i < terminators.length - 1){\n                b.append(terminators[i + 1]);\n            }\n            else{\n                b.append(terminators[i]);\n            }\n            return b.toString();\n        ", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\tString token = \"\";\n\tboolean first = true;\n\t\n\tfor(int i=0; i<terminators.length; i++){\n\t\tchar c = terminators[i];\n\t\t\n\t\tif(first){\n\t\t\ttoken = token + c;\n\t\t\tfirst = false;\n\t\t}else{\n\t\t\tif(c == '\\''){\n\t\t\t\ttoken = token + c;\n\t\t\t}else if(c == '\"'){\n\t\t\t\ttoken = token + c;\n\t\t\t}else if(c == ','){\n\t\t\t\ttoken = token + c;\n\t\t\t}else if(c == ';'){\n\t\t\t\ttoken = token + c;\n\t\t\t}else if(c == '('){\n\t\t\t\ttoken = token + c;\n\t\t\t}else if(c == ')'){\n\t\t\t\ttoken = token + c;\n\t\t\t}else{\n\t\t\t\ttoken = token + c;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn token;\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n    StringBuilder token = new StringBuilder();\n    for(char terminator: terminators){\n        if(terminator == '('){\n            token.append('(');\n        }\n        else if(terminator == ')'){\n            token.append(')');\n        }\n        else if(terminator == ','){\n            token.append(',');\n        }\n        else if(terminator == ';'){\n            token.append(';');\n        }\n        else if(terminator ==''){\n            token.append(' ');\n        }\n        else if(terminator == '\\'' && (token.length() > 0)){\n            token.append('\\'');\n        }\n        else{\n            token.append(terminator);\n        }\n    }\n    return token.toString();\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\tif(terminators == null || terminators.length == 0)\n\t\treturn null;\n\tStringBuilder result = new StringBuilder();\n\tfor(int i = 0; i < terminators.length; i++)\n\t\tresult.append(terminators[i]);\n\treturn result.toString();\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\t\n\tString token = \"\";\n\tchar[] chars = new char[terminators.length];\n\t\n\tfor(int i = 0; i < terminators.length; i++){\n\t\tchars[i] = terminators[i];\n\t}\n\t\n\ttoken = new String(chars);\n\t\n\treturn token;\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\tString token = \"\";\n\t\n\tfor(int i=0; i < terminators.length; i++){\n\t\tif(terminators[i] == '\\''){\n\t\t\ttoken = token.replace(\"'\", \"\");\n\t\t}\n\t\telse if(terminators[i] == '\\\"' || terminators[i] == '\\\\'){\n\t\t\ttoken = token.replace(terminators[i], \"\");\n\t\t}\n\t\telse{\n\t\t\ttoken += terminators[i];\n\t\t}\n\t}\n\t\n\treturn token;\n}", "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n\nprivate String parseToken(final char[] terminators){\n\tint index = 0;\n\tString token = null;\n\twhile (index < terminators.length){\n\t\tif (terminators[index] == ';'){\n\t\t\ttoken = token + terminators[index];\n\t\t\tindex++;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\treturn token;\n}"]}
{"_id": "636766fd1a6d9265ec017814", "generate_results": ["public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n    for (int i =0;i < count;i++){\n        if (a[i]!= b[i]) return false;\n    }\n    return true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif (a.length<count) return false;\n\tif (b.length<count) return false;\n\tfor (int i=0;i<count;i++){\n\t\tif (a[i]!=b[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif (a == null || b == null || a.length!= b.length) return false;\n\t\n\tfor (int i=0; i<count; i++){\n\t\tif (a[i]!= b[i]) return false;\n\t}\n\t\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a==null||b==null||a.length<count){\n\t\treturn false;\n\t}\n\t\n\tfor(int i = 0;i<count;i++){\n\t\tif(a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(count < 1) return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a.length!= b.length) return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!= b[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a==null){\n\t\treturn (b==null);\n\t}\n\tif(b==null){\n\t\treturn (a==null);\n\t}\n\tif(a.length<count){\n\t\treturn false;\n\t}\n\tif(b.length<count){\n\t\treturn false;\n\t}\n\tif(a.length==count){\n\t\tfor(int i=0;i<count;i++){\n\t\t\tif(a[i]!=b[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n    if(a==null || b==null || a.length!=b.length || a.length<=0 || b.length<=0){\n        return false;\n    }\n    for(int i=0;i<count;i++){\n        if(a[i]!=b[i]){\n            return false;\n        }\n    }\n    return true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif (a.length!=b.length){\n\t\treturn false;\n\t}\n\tfor (int i=0;i<count;i++){\n\t\tif (a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n    if(a.length!=b.length){\n        return false;\n    }\n    for(int i=0;i<count;i++){\n        if(a[i]!=b[i]){\n            return false;\n        }\n    }\n    return true;\n}"]}
{"_id": "636766f61a6d9265ec017701", "generate_results": ["public static int lastIndexOf(String str,String searchStr){\n    return str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif(searchStr==null){\n\t\treturn str.lastIndexOf(str);\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif (str == null || searchStr == null) return -1;\n\tint pos = str.lastIndexOf(searchStr);\n\treturn pos;\n}", "public static int lastIndexOf(String str,String searchStr){\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif(str==null) return -1;\n\tint index=str.lastIndexOf(searchStr);\n\treturn index;\n}", "public static int lastIndexOf(String str,String searchStr){\n    return StringUtils.lastIndexOf(str,searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\tif (str == null || searchStr == null) {\n\t\treturn -1;\n\t}\n\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\t\n\tif(searchStr==null) return -1;\n\t\n\tint index=str.lastIndexOf(searchStr);\n\t\n\treturn index;\n}", "public static int lastIndexOf(String str,String searchStr){\n\t\n\tif(str == null || searchStr == null)\n\t\treturn -1;\n\t\n\tif(str.length() == 0)\n\t\treturn -1;\n\t\n\tint i = str.lastIndexOf(searchStr);\n\tif(i == -1)\n\t\treturn -1;\n\telse\n\t\treturn i;\n\t\t\n}"]}
{"_id": "636766ff1a6d9265ec01783b", "generate_results": ["public static String sub(String str,int start,int end){ \n\tif(end-start<=0) return \"\";\n\telse if(start>=end) return \"\";\n\t\n\tString s1=str.substring(start,end);\n\treturn s1;\n}", "public static String sub(String str,int start,int end){\n\tif(str==null) return null;\n\tif(start<0) start=0;\n\tif(end<0) end=0;\n\tint len=str.length();\n\tif(start>end) return null;\n\tif(start==end) return str;\n\tif(end==len) return str;\n\tint mid=Math.min(start,end);\n\tif(mid<len) return str.substring(start,mid);\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n    \n    // The characters in the string are already checked for exceptions\n    \n    int i=start;\n    int j=end;\n    \n    while(i<=j){\n        if (str.charAt(i)!=str.charAt(j)){\n            return str.substring(start,i);\n        }\n        i++;\n        j--;\n    }\n    \n    return \"\";\n}", "public static String sub(String str,int start,int end){\n\t\n\tif(start<0){\n\t\tstart=0;\n\t}\n\tif(end<0){\n\t\tend=0;\n\t}\n\tif(end<start){\n\t\tend=start;\n\t}\n\t\n\tif(start>end){\n\t\tthrow new IndexOutOfBoundsException(\"start=\"+start+\" end=\"+end);\n\t}\n\t\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\tif(str == null || str.length() == 0){\n\t\treturn", "public static String sub(String str,int start,int end){\n\tif (str == null){\n\t\treturn null;\n\t}\n\tif (start < 0 || end < 0 || end > str.length()){\n\t\tthrow new IllegalArgumentException(\"start<0 || end<0 || end>str.length()\");\n\t}\n\tint mid = end;\n\twhile (mid >= start){\n\t\tif (str.charAt(mid) == str.charAt(start)){\n\t\t\tbreak;\n\t\t}\n\t\tmid--;\n\t}\n\treturn str.substring(start,mid);\n}", "public static String sub(String str,int start,int end){\n    if (end==start) return null;\n    if (end<0) end=str.length()+end;\n    \n    if (start>=0 && start<end) return str.substring(start,end);\n    else return null;\n}", "public static String sub(String str,int start,int end){\n\tif(end<=start){\n\t  return \"\";\n\t}\n\t\n\tint i=start;\n\tint j=end;\n\t\n\tif(i<j){\n\t  i=i+1;\n\t  j=end;\n\t}\n\t\n\tif(i>=j){\n\t  i=j-1;\n\t  j=start;\n\t}\n\t\n\tif(i>=0 && j>=0 && i<str.length() && j<=str.length()){\n\t  return str.substring(i,j);\n\t}else{\n\t  return \"\";\n\t}\n}", "public static String sub(String str,int start,int end){\n\t\n\tif(start>end){\n\t\tthrow new java.lang.Exception(\"start > end\");", "public static String sub(String str,int start,int end){ \n\tint end_pos=start;\n\tif(end>str.length()){ \n\t\tend=str.length(); \n\t}\n\twhile(end_pos<end){ \n\t\tif(str.charAt(end_pos)!=str.charAt(end_pos-1)){ \n\t\t\tend_pos++; \n\t\t\tbreak; \n\t\t} \n\t\tend_pos++; \n\t}\n\treturn str.substring(start,end_pos);\n}"]}
{"_id": "6367670b1a6d9265ec017a0f", "generate_results": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tif(str==null){\n\t\treturn false;\n\t}\n\tfor(String s:searchStrArray){\n\t\tif(!str.contains(s)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tint searchStrLen = searchStrArray.size();\n\tfor (int i = 0; i < searchStrLen; i++){\n\t\tif (str.toLowerCase().contains(searchStrArray.get(i).toLowerCase())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tif(str==null || searchStrArray==null)\n\t\treturn false;\n\t\n\tfor(String s:searchStrArray)\n\t{\n\t\tif(str.toLowerCase().contains(s.toLowerCase()))\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tfor(int i = 0;i<searchStrArray.size();i++){\n\t\tif(str.indexOf(searchStrArray.get(i))>=0) return true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n    boolean result=false;\n    if(str!=null){\n        if(str.length()>0)\n        {\n            for(int i=0;i<searchStrArray.size();i++){\n                if(searchStrArray.get(i).equalsIgnoreCase(str)){\n                    result=true;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tint length = str.length();\n\tfor(int i = 0; i < length;i++){\n\t\tif(str.charAt(i) == searchStrArray.get(0).charAt(0)){", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif (str==null || str.length()<1) return false;\n\tfor (String s:searchStrArray){\n\t\tif (str.toLowerCase().contains(s.toLowerCase())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\t\n\tboolean flag=false;\n\tfor (String s:searchStrArray){\n\t\tif (str.contains(s))\n\t\t\tflag=true;\n\t}\n\treturn flag;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n    for(String s : searchStrArray)\n        if(str.contains(s))\n            return true;\n    return false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif(str==null||str.length()==0) return false;\n\tboolean flag=true;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tflag=flag&&(str.toLowerCase().indexOf(searchStrArray.get(i).toLowerCase())>=0);\n\t}\n\treturn flag;\n}"]}
{"_id": "636767021a6d9265ec0178bc", "generate_results": ["public static int indexOf(String str,String searchStr){\n\t\n\tif (str == null) return -1;\n\tif (searchStr == null) return -1;\n\tif (str.equals(searchStr)) return 0;\n\t\n\tint start=str.indexOf(searchStr);\n\tif (start < 0){\n\t\tstart=str.indexOf(searchStr);\n\t}\n\treturn start;\n}", "public static int indexOf(String str,String searchStr){\n\tif(str==null||searchStr==null)\n\t\treturn -1;\n\tif(str.indexOf(searchStr)==-1)\n\t\treturn -1;\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\t\treturn str.indexOf(searchStr);\n\t}", "public static int indexOf(String str,String searchStr){\n\t\n\tif(str==null)\n\t\treturn 0;\n\t\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\tif(str==null){\n\t\treturn -1;\n\t}\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\t\n\tif(str==null)\n\t\treturn -1;\n\t\t\n\tint pos=0;\n\t\n\tif(searchStr==null)\n\t\tsearchStr=\"\";\n\t\n\t\n\twhile(pos<str.length() && str.charAt(pos)!=searchStr.charAt(0))\n\t\tpos++;\n\t\t\n\treturn pos;\n}", "public static int indexOf(String str,String searchStr){\n\t\n\tif(str==null){\n\t\treturn -1;\n\t}\n\t\n\tif(searchStr==null){\n\t\treturn str.indexOf(null);\n\t}\n\t\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\t\n\tif(str == null || str.length() == 0)\n\t\treturn -1;\n\t\n\tint i = str.indexOf(searchStr);\n\treturn (i < 0)? -1 : i;\n}", "public static int indexOf(String str,String searchStr){\n\t\n\tif(str==null){\n\t\treturn -1;\n\t}\n\treturn str.indexOf(searchStr);\n}"]}
{"_id": "636766fc1a6d9265ec0177da", "generate_results": ["/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\t\n\t// if the character is a separator, we can stop.\n\tif(c == ';' || c == ',' || c ==''){\n\t\treturn true;\n\t}\n\t\n\t// if the character is a period, we can stop.\n\tif(c == '.'){\n\t\treturn true;\n\t}\n\t\n\t// if the character is a non-digit, we can stop.\n\tif(Character.isDigit(c)){\n\t\treturn true;\n\t}\n\t\n\t// if the character is a non-letter, we can stop.\n\tif(c == '-' || c == '_' || c == '`' || c == '{' || c == '}' || c == '+' || c == '*'){\n\t\treturn true;\n\t}\n\t\n\t// if the character is a '%', we can stop.\n\tif(c == '%'){\n\t\treturn true;\n\t}\n\t\n\t// return false if the character is not a '%'\n\treturn false;\n}", "public static boolean isParameterSeparator(final char c){\n\treturn Character.isJavaIdentifierPart(c);\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\tif(c == ',' || c == ';' || c == ':'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\t\n\treturn c == '(' || c == ')';\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\t\n\tif(Character.isWhitespace(c))\n\t\treturn false;\n\t\n\tif(c =='')\n\t\treturn true;\n\t\n\tif(c == '=' &&!Character.isWhitespace(nextChar()))\n\t\treturn false;\n\t\n\treturn true;\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\treturn c == ',' || c == ';' || c == ':' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}';\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\tif(c == ',' || c == ')') return true;\n\treturn isSeparator(c);\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\treturn c == '=' || c == ':' || c == ',' || c == '(' || c == ')';\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\tif (Character.isWhitespace(c)){\n\t\treturn true;\n\t}else if (c == ','){\n\t\treturn true;\n\t}else if (Character.isDigit(c)){\n\t\treturn true;\n\t}else if (c == '('){\n\t\treturn true;\n\t}else if (c == ')'){\n\t\treturn true;\n\t}else if (c == ',' || c == ')'){\n\t\treturn true;\n\t}else if (c == '='){\n\t\treturn true;\n\t}else if (c == ':'){\n\t\treturn true;\n\t}else if (c == ';'){\n\t\treturn true;\n\t}else if (c == '/'){\n\t\treturn true;\n\t}else if (c == '?'){\n\t\treturn true;\n\t}else if (c == '@'){\n\t\treturn true;\n\t}else if (c == '.'){\n\t\treturn true;\n\t}else if (c == '\"'){\n\t\treturn true;\n\t}else if (c == '\\''){\n\t\treturn true;\n\t}else if (c == '*'){\n\t\treturn true;\n\t}else if (c == '/'){\n\t\treturn true;\n\t}else if (c == '+'){\n\t\treturn true;\n\t}else if (c == '<'){\n\t\treturn true;\n\t}else if (c == '>'){\n\t\treturn true;\n\t}else if (c == '!'){\n\t\treturn true;\n\t}else if (c == '%'){\n\t\treturn true;\n\t}else if (c == '|'){\n\t\treturn true;\n\t}else if (c == '&'){\n\t\treturn true;\n\t}else if (c == '%'){\n\t\treturn true;\n\t}else if (c == '&'){\n\t\treturn true;\n\t}else if (c == '('){\n\t\treturn true;\n\t}else if (c == ')'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n\nprivate static boolean isParameterSeparator(final char c){\n\tif(c=='(' || c==')' || c=='|' || c=='&' || c==':' || c=='+' || c=='@' || c=='*' || c=='!' || c=='(' || c==')') return true;\n\treturn false; \n}"]}
{"_id": "636767031a6d9265ec0178ef", "generate_results": ["/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif (array == null){\n\t\treturn Array.newInstance(newArrayComponentType, 1);\n\t}\n\treturn Array.newInstance(newArrayComponentType, array.length + 1);\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif (array == null){\n\t\treturn newArrayComponentType.cast(new Object[]{new Object()});\n\t}\n\tif (array.getClass().isArray()){\n\t\treturn array;\n\t}\n\tif (newArrayComponentType == null){\n\t\tnewArrayComponentType = array.getClass();\n\t}\n\tfinal int arrayLength = Array.getLength(array);\n\tfinal Object newArray = Array.newInstance(newArrayComponentType, arrayLength + 1);\n\tSystem.arraycopy(Array.get(array, 0), 0, newArray, 0, arrayLength);\n\tArray.set(newArray, arrayLength, array);\n\treturn newArray;\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif(array == null){\n\t\treturn newArrayComponentType.newInstance();\n\t}\n\tif(array instanceof Object[]){\n\t\treturn ((Object[])array).clone();\n\t}\n\telse if(array instanceof Object[][]){\n\t\treturn ((Object[][])array).clone();\n\t}\n\telse if(array.getClass().equals(newArrayComponentType)){\n\t\treturn array;\n\t}\n\treturn array.clone();\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif (array == null)\n\t\treturn null;\n\t\n\tif (array.getClass() == array.getClass().getSuperclass())\n\t\treturn array;\n\t\n\t//array.getClass() == array.getClass().getSuperclass()\n\tif (array.getClass().getComponentType() == newArrayComponentType)\n\t\treturn array;\n\t\n\tint newArraySize = array.getClass().getComponentType().getComponentType().size();\n\t\n\t//array.getClass().getComponentType().size() == newArrayComponentType.getComponentType().size()\n\tif (newArraySize == 1)\n\t\treturn array;\n\t\n\t//array.getClass().getComponentType().size() < 1\n\tif (newArraySize > 1)\n\t\tthrow new IllegalArgumentException(\"array.getClass().getComponentType().size() < 1\");\n\t\n\t//array.getClass().getComponentType().size() > 1\n\tObject newArray = (Object)Array.newInstance(newArrayComponentType, newArraySize);\n\t\n\tfor (int i = 0; i < newArraySize; i++)\n\t\tArray.set(newArray, i, array);\n\t\n\treturn newArray;\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif(newArrayComponentType == null){\n\t\treturn array;\n\t}\n\t\n\tif(array instanceof Object[]){\n\t\treturn ((Object[])array).clone();\n\t}\n\t\n\treturn new Object[]{array};\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tfinal int length = array.getClass().getComponentType().getActualTypeArguments().length;\n\tif (length == 0) {\n\t\treturn ArrayUtils.EMPTY_OBJECT_ARRAY;\n\t}\n\tfinal Object result = ArrayUtils.newArray(newArrayComponentType,length);\n\tSystem.arraycopy(array,0,result,0,length);\n\treturn result;\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif(array == null) {\n\t\treturn null;\n\t}\n\telse if(newArrayComponentType == null) {\n\t\treturn Arrays.copyOf(array, array.length);\n\t}\n\telse {\n\t\treturn Arrays.copyOf(array, array.length, newArrayComponentType);\n\t}\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tint i=0;\n\tObject newArray=null;\n\tif(array!=null){\n\t\tnewArray=new ArrayList<Object>(1);\n\t\tnewArray.add(array);\n\t}else{\n\t\tnewArray=new ArrayList<Object>(1);\n\t}\n\tnewArray.add(newArrayComponentType);\n\treturn newArray;\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif(array == null){\n\t\treturn newArrayComponentType.newInstance();\n\t}\n\treturn array.getClass().newInstance();\n}", "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tif(array == null){\n\t\treturn newArrayComponentType.newInstance();\n\t}\n\telse{\n\t\treturn array.getClass().newInstance();\n\t}\n}"]}
{"_id": "636766fe1a6d9265ec017834", "generate_results": ["public static String sessionId(){\n    return \"session:\"+System.identityHashCode(this)+\":\"+System.identityHashCode(Session.this);\n}", "public static String sessionId(){\n\treturn sessionId;\n}", "public static String getSessionIdString(){\n\tString str = sessionId();\n\tif(str.length()==0) str = \"Anonymous\";\n\treturn str;\n}", "public static String sessionId(){\n        \n        return \"\";\n    }", "public static SessionInfo newInstance(){\n\treturn new SessionInfo(sessionId());\n}", "public static String sessionId(){\n\treturn \"session\";\n}", "public static String sessionId(){\n\treturn \"a\";\n}", "public static String sessionId(){\n\treturn server.getSessionId();\n}", "public static String sessionId(){\n\treturn \"sessID\";\n}", "public static String getSessionId(){\n\t\n\t// Return the session id. \n\treturn sessionId();\n}"]}
{"_id": "636766ae1a6d9265ec0175dc", "generate_results": ["public Boolean isPartialContentResponse(){\n\t//TODO: implement\n\tlogger.debug(\"isPartialContentResponse\");\n\treturn false;\n}", "public Boolean isPartialContentResponse(){\n    return isPartialContent;\n}", "public Boolean isPartialContentResponse(){\n\t\n\tif(this.status == 200 && this.contentLength > 0){\n\t\tif(this.contentType == \"text/html\"){\n\t\t\treturn true;\n\t\t}\n\t\telse if(this.contentType == \"application/json\"){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public Boolean isPartialContentResponse(){\n\treturn isPartialContent;\n}", "public Boolean isPartialContentResponse(){\n\t\n\treturn isPartialContent(this.getResponse());\n}", "public Boolean isPartialContentResponse(){\n\treturn response.isPartialContent();\n}", "public Boolean isPartialContentResponse(){\n\tPartialContentResponse response = (PartialContentResponse) getResponse();\n\tif (response == null)\n\t\treturn null;\n\telse if (response.getStatus() == null)\n\t\treturn null;\n\telse if (response.getStatus().equals(\"206\"))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "public Boolean isPartialContentResponse(){\n\treturn partialContent;\n}", "public Boolean isPartialContentResponse(){\n\tif (isPartialContent) {\n\t\treturn Boolean.TRUE;\n\t}\n\treturn Boolean.FALSE;\n}", "public Boolean isPartialContentResponse(){\n    if (this.headers == null){\n        return false;\n    }\n    String header = this.headers.getFirst(\"Content-Range\");\n    if (header == null){\n        return false;\n    }\n    return header.endsWith(\".partial\");\n}"]}
{"_id": "636766ae1a6d9265ec0175d8", "generate_results": ["public String getContentRange(){\n\treturn buildContentRange();\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"bytes \");\n  sb.append(getContentLength());\n  sb.append(\"/\");\n  sb.append(getContentLength());\n  sb.append(\"-\");\n  sb.append(getContentLength());\n  sb.append(\"/\");\n  sb.append(getContentLength());\n  return sb.toString();\n}", "public void write(File file, String contentType, String contentDisposition, String contentEncoding) throws IOException{\n\t// Create the 'Content-Type' HTTP Header value\n\tString contentTypeHeader = contentType;\n\t\n\t// Build the 'Content-Type' value\n\tif(contentTypeHeader == null || contentTypeHeader.length() == 0)\n\t\tcontentTypeHeader = buildContentType();\n\t\t\n\t// Build the 'Content-Length' HTTP Header value\n\tString contentLengthHeader = buildContentLength();\n\t\n\t// Build the 'Content-Range' HTTP Header value\n\tString contentRangeHeader = buildContentRange();\n\t\n\t// Build the 'Content-Length' value\n\tString contentLength = Integer.toString(contentLengthHeader.length());\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue = contentTypeHeader;\n\t\n\t// Build the 'Content-Disposition' value\n\tString contentDispositionHeaderValue = contentDisposition;\n\t\n\t// Build the 'Content-Encoding' value\n\tString contentEncodingHeaderValue = contentEncoding;\n\t\n\t// Build the 'Content-Disposition' value\n\tString contentDispositionHeaderValue2 = contentDispositionHeaderValue;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue2 = contentLengthHeader;\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue2 = contentTypeHeaderValue;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue3 = contentLengthHeader;\n\t\n\t// Build the 'Content-Range' value\n\tString contentRangeHeaderValue3 = contentRangeHeader;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue3 = contentLengthHeader;\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue3 = contentTypeHeaderValue;\n\t\n\t// Build the 'Content-Disposition' value\n\tString contentDispositionHeaderValue3 = contentDispositionHeaderValue2;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue4 = contentLengthHeader;\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue4 = contentTypeHeaderValue;\n\t\n\t// Build the 'Content-Disposition' value\n\tString contentDispositionHeaderValue4 = contentDispositionHeaderValue3;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue5 = contentLengthHeader;\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue5 = contentTypeHeaderValue2;\n\t\n\t// Build the 'Content-Disposition' value\n\tString contentDispositionHeaderValue5 = contentDispositionHeaderValue3;\n\t\n\t// Build the 'Content-Length' value\n\tString contentLengthHeaderValue6 = contentLengthHeader;\n\t\n\t// Build the 'Content-Type' value\n\tString contentTypeHeaderValue", "public, max-age=\" + getMaxAge() + \", s-maxage=\" + getMaxAge() + \", no-cache\";\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n    StringBuilder result = new StringBuilder();\n    \n    // Content-Range: 0-1524682878708824\n    result.append(\"bytes/\").append(getTotalBytes()).append(\"-\").append(getTotalBytes());\n    \n    return result.toString();\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n\t\n\tStringBuilder sb = new StringBuilder(200);\n\t\n\tsb.append(CONTENT_RANGE);\n\tsb.append(\"bytes \");\n\tsb.append(totalSize);\n\tsb.append(\"/\" + totalSize);\n\t\n\treturn sb.toString();\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n\t\n\tString contentRange = \"bytes\";\n\t\n\tcontentRange += \" \\\"\" + getContentLength() + \"\\\"\";\n\tcontentRange += \" - \" + getLastModified() + \"\";\n\t\n\treturn contentRange;\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n    return \"bytes \"+getContentLength()+\"-\"+getContentLength()+\"/\"+getContentLength()+\"/\"+getContentLength();\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Content-Range: \");\n    sb.append(getContentRange());\n    return sb.toString();\n}", "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n\nprivate String buildContentRange(){\n    \n    StringBuilder value = new StringBuilder();\n\n    value.append(\"bytes \");\n    value.append(getLength());\n    value.append(\": \");\n    value.append(getLastModified());\n    value.append(\"\\r\\n\");\n    \n    return value.toString();\n}"]}
{"_id": "636766f01a6d9265ec01763e", "generate_results": ["/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n\tif(charset.equals(\"UTF-8\")){\n\t\treturn \"UTF-8\";\n\t} else if(charset.equals(\"ISO-8859-1\")){\n\t\treturn \"ISO-8859-1\";\n\t} else if(charset.equals(\"ISO-8859-2\")){\n\t\treturn \"ISO-8859-2\";\n\t} else if(charset.equals(\"ISO-8859-3\")){\n\t\treturn \"ISO-8859-3\";\n\t} else if(charset.equals(\"ISO-8859-4\")){\n\t\treturn \"ISO-8859-4\";\n\t} else if(charset.equals(\"ISO-8859-5\")){\n\t\treturn \"ISO-8859-5\";\n\t} else if(charset.equals(\"ISO-8859-6\")){\n\t\treturn \"ISO-8859-6\";\n\t} else if(charset.equals(\"ISO-8859-7\")){\n\t\treturn \"ISO-8859-7\";\n\t} else if(charset.equals(\"ISO-8859-8\")){\n\t\treturn \"ISO-8859-8\";\n\t} else if(charset.equals(\"ISO-8859-9\")){\n\t\treturn \"ISO-8859-9\";\n\t} else if(charset.equals(\"ISO-8859-10\")){\n\t\treturn \"ISO-8859-10\";\n\t} else if(charset.equals(\"ISO-8859-11\")){\n\t\treturn \"ISO-8859-11\";\n\t} else if(charset.equals(\"ISO-8859-13\")){\n\t\treturn \"ISO-8859-13\";\n\t} else if(charset.equals(\"ISO-8859-14\")){\n\t\treturn \"ISO-8859-14\";\n\t} else if(charset.equals(\"ISO-8859-15\")){\n\t\treturn \"ISO-8859-15\";\n\t} else if(charset.equals(\"ISO-8859-16\")){\n\t\treturn \"ISO-8859-16\";\n\t} else if(charset.equals(\"ISO-IRGB\")){\n\t\treturn \"ISO-IRGB\";\n\t} else if(charset.equals(\"ISO-IRGB-1\")){\n\t\treturn \"ISO-IRGB-1\";\n\t} else if(charset.equals(\"ISO-IRGB-2\")){\n\t\treturn \"ISO-IRGB-2\";\n\t} else if(charset.equals(\"ISO-IRGB-3\")){\n\t\treturn \"ISO-IRGB-3\";\n\t} else if(charset.equals(\"ISO-IRGB-4\")){\n\t\treturn \"ISO-IRGB-4\";\n\t} else if(charset.equals(\"ISO-IRGB-5\")){\n\t\treturn \"ISO-IRGB-5\";\n\t} else if(charset.equals(\"ISO-IRGB-6\")){\n\t\treturn \"ISO-IRGB-6\";\n\t} else if(charset.equals(\"ISO-IRGB-7\")){\n\t\treturn \"ISO-IRGB-7\";\n\t} else if(charset.equals(\"ISO-IRGB-8\")){\n\t\treturn \"ISO-IRGB-8\";\n\t} else if(charset.equals(\"ISO-IRGB-9\")){\n\t\treturn \"ISO-IRGB-9\";\n\t} else if(charset.equals(\"ISO-IRGB-10\")){\n\t\treturn \"ISO-IRGB-10\";\n\t} else if(charset.equals(\"ISO-IRGB-11\")){\n\t\treturn \"ISO-IRGB-11\";\n\t} else if(charset.equals(\"ISO-IRGB-12\")){\n\t\treturn \"ISO-IRGB-12\";\n\t} else if(charset.equals(\"ISO-IRGB-13\")){\n\t\treturn \"ISO-IRGB-13\";\n\t} else if(charset.equals(\"ISO-IRGB-14", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n    if (charset.length() == 1) {\n        if (charset.charAt(0) == 'U')\n            return \"UTF-8\";\n        else\n            return \"ISO-8859-1\";\n    } else if (charset.length() == 2) {\n        if (charset.charAt(0) == 'U')\n            return \"UTF-16\";\n        else\n            return \"UTF-16BE\";\n    } else if (charset.length() == 3) {\n        if (charset.charAt(0) == 'U')\n            return \"UTF-32\";\n        else\n            return \"UTF-32BE\";\n    } else if (charset.length() == 4) {\n        if (charset.charAt(0) == 'U')\n            return \"UTF-64\";\n        else\n            return \"UTF-64BE\";\n    } else\n        return \"UTF-8\";\n}", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n    if (charset.equals(\"UTF-16\")) return \"UTF-16\";\n    if (charset.equals(\"UTF-16BE\")) return \"UTF-16\";\n    if (charset.equals(\"UTF-16LE\")) return \"UTF-16\";\n    if (charset.equals(\"UTF-8\")) return \"UTF-8\";\n    if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\";\n    if (charset.equals(\"ISO-8859-2\")) return \"ISO-8859-2\";\n    if (charset.equals(\"ISO-8859-3\")) return \"ISO-8859-3\";\n    if (charset.equals(\"ISO-8859-4\")) return \"ISO-8859-4\";\n    if (charset.equals(\"ISO-8859-5\")) return \"ISO-8859-5\";\n    if (charset.equals(\"ISO-8859-6\")) return \"ISO-8859-6\";\n    if (charset.equals(\"ISO-8859-7\")) return \"ISO-8859-7\";\n    if (charset.equals(\"ISO-8859-8\")) return \"ISO-8859-8\";\n    if (charset.equals(\"ISO-8859-9\")) return \"ISO-8859-9\";\n    if (charset.equals(\"ISO-8859-10\")) return \"ISO-8859-10\";\n    if (charset.equals(\"ISO-8859-11\")) return \"ISO-8859-11\";\n    if (charset.equals(\"ISO-8859-13\")) return \"ISO-8859-13\";\n    if (charset.equals(\"ISO-8859-14\")) return \"ISO-8859-14\";\n    if (charset.equals(\"ISO-8859-15\")) return \"ISO-8859-15\";\n    if (charset.equals(\"ISO-8859-16\")) return \"ISO-8859-16\";\n    if (charset.equals(\"ISO-IR-165\")) return \"ISO-IR-165\";\n    if (charset.equals(\"ISO-IR-144\")) return \"ISO-IR-144\";\n    if (charset.equals(\"ISO-IR-148\")) return \"ISO-IR-148\";\n    if (charset.equals(\"ISO-IR-149\")) return \"ISO-IR-149\";\n    if (charset.equals(\"ISO-IR-150\")) return \"ISO-IR-150\";\n    if (charset.equals(\"ISO-IR-143\")) return \"ISO-IR-143\";\n    if (charset.equals(\"ISO-IR-148\")) return \"ISO-IR-148\";\n    if (charset.equals(\"ISO-IR-149\")) return \"ISO-IR-149\";\n    if (charset.equals(\"ISO-IR-150\")) return \"ISO-IR-150\";\n    if (charset.equals(\"ISO-IR-143\")) return \"ISO-IR-143\";\n    if (charset.equals(\"ISO-IR-148\")) return \"ISO-IR-148\";\n    if (charset.equals(\"ISO-IR-149\")) return \"ISO-IR-149\";\n    if (charset.equals(\"ISO-IR-150\")) return \"ISO-IR-150\";\n    if (charset.equals(\"ISO-IR-143\")) return \"ISO-IR-143\";\n    if (charset.equals(\"ISO-IR-148\")) return \"ISO-IR-148\";\n    if (charset.equals(\"ISO-IR-149\")) return \"ISO-IR-149\";\n    if (charset.equals(\"ISO-IR-150\")) return \"ISO-IR-150\";\n    if (charset.equals(\"ISO-IR-143\")) return \"ISO-IR-143\";\n    if (charset.equals(\"ISO-IR-148\")) return \"ISO-IR-148\";\n", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n\t// The Java equivalent of the MIME standard name\n\t// \"ISO-8859-1\"\n\tif(charset.equals(\"ISO-8859-1\")){ return \"ISO-8859-1\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-8\"\n\tif(charset.equals(\"UTF-8\")){ return \"UTF-8\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-16\"\n\tif(charset.equals(\"UTF-16\")){ return \"UTF-16\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-16BE\"\n\tif(charset.equals(\"UTF-16BE\")){ return \"UTF-16BE\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-16LE\"\n\tif(charset.equals(\"UTF-16LE\")){ return \"UTF-16LE\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-32\"\n\tif(charset.equals(\"UTF-32\")){ return \"UTF-32\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-32BE\"\n\tif(charset.equals(\"UTF-32BE\")){ return \"UTF-32BE\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-32LE\"\n\tif(charset.equals(\"UTF-32LE\")){ return \"UTF-32LE\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-8BE\"\n\tif(charset.equals(\"UTF-8BE\")){ return \"UTF-8BE\"; }\n\t// The Java equivalent of the MIME standard name\n\t// \"UTF-8LE\"\n\tif(charset.equals(\"UTF-8LE\")){ return \"UTF-8LE\"; }\n\treturn null;\n}", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n\tif(charset.equals(\"UTF-8\")) return \"UTF8\";\n\tif(charset.equals(\"UTF-16\")) return \"UTF16\";\n\tif(charset.equals(\"UTF-32\")) return \"UTF32\";\n\treturn charset;\n}", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n    if (charset.equals(\"UTF-8\")) return \"UTF8\";\n    if (charset.equals(\"UTF-16\")) return \"UTF-16\";\n    if (charset.equals(\"ISO-8859-1\")) return \"ISO-8859-1\";\n    if (charset.equals(\"ISO-8859-2\")) return \"ISO-8859-2\";\n    if (charset.equals(\"ISO-8859-3\")) return \"ISO-8859-3\";\n    if (charset.equals(\"ISO-8859-4\")) return \"ISO-8859-4\";\n    if (charset.equals(\"ISO-8859-5\")) return \"ISO-8859-5\";\n    if (charset.equals(\"ISO-8859-6\")) return \"ISO-8859-6\";\n    if (charset.equals(\"ISO-8859-7\")) return \"ISO-8859-7\";\n    if (charset.equals(\"ISO-8859-8\")) return \"ISO-8859-8\";\n    if (charset.equals(\"ISO-8859-9\")) return \"ISO-8859-9\";\n    if (charset.equals(\"ISO-8859-10\")) return \"ISO-8859-10\";\n    if (charset.equals(\"ISO-8859-13\")) return \"ISO-8859-13\";\n    if (charset.equals(\"ISO-8859-14\")) return \"ISO-8859-14\";\n    if (charset.equals(\"ISO-8859-15\")) return \"ISO-8859-15\";\n    if (charset.equals(\"ISO-8859-16\")) return \"ISO-8859-16\";\n    if (charset.equals(\"ISO-IR-165\")) return \"ISO-IR-165\";\n    if (charset.equals(\"Shift_JIS\")) return \"Shift_JIS\";\n    if (charset.equals(\"JIS_X0201\")) return \"JIS_X0201\";\n    if (charset.equals(\"JIS_X0212\")) return \"JIS_X0212\";\n    if (charset.equals(\"JIS_X0322\")) return \"JIS_X0322\";\n    if (charset.equals(\"JIS_X0376\")) return \"JIS_X0376\";\n    if (charset.equals(\"JIS_X0208\")) return \"JIS_X0208\";\n    if (charset.equals(\"JIS_X0212_2\")) return \"JIS_X0212_2\";\n    if (charset.equals(\"JIS_X0322_2\")) return \"JIS_X0322_2\";\n    if (charset.equals(\"JIS_X0208_2\")) return \"JIS_X0208_2\";\n    if (charset.equals(\"JIS_X0212_3\")) return \"JIS_X0212_3\";\n    if (charset.equals(\"JIS_X0322_3\")) return \"JIS_X0322_3\";\n    if (charset.equals(\"JIS_X0208_3\")) return \"JIS_X0208_3\";\n    if (charset.equals(\"JIS_X0212_4\")) return \"JIS_X0212_4\";\n    if (charset.equals(\"JIS_X0322_4\")) return \"JIS_X0322_4\";\n    if (charset.equals(\"JIS_X0208_4\")) return \"JIS_X0208_4\";\n    if (charset.equals(\"JIS_X0212_5\")) return \"JIS_X0212_5\";\n    if (charset.equals(\"JIS_X0322_5\")) return \"JIS_X0322_5\";\n    if (charset.equals(\"JIS_X0208_5\")) return \"JIS", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n\tif (charset.equals(\"UTF-8\")){\n\t\treturn \"UTF-8\";\n\t}\n\tif (charset.equals(\"ISO-8859-1\")){\n\t\treturn \"ISO-8859-1\";\n\t}\n\tif (charset.equals(\"ISO-8859-2\")){\n\t\treturn \"ISO-8859-2\";\n\t}\n\tif (charset.equals(\"ISO-8859-3\")){\n\t\treturn \"ISO-8859-3\";\n\t}\n\tif (charset.equals(\"ISO-8859-4\")){\n\t\treturn \"ISO-8859-4\";\n\t}\n\tif (charset.equals(\"ISO-8859-5\")){\n\t\treturn \"ISO-8859-5\";\n\t}\n\tif (charset.equals(\"ISO-8859-6\")){\n\t\treturn \"ISO-8859-6\";\n\t}\n\tif (charset.equals(\"ISO-8859-7\")){\n\t\treturn \"ISO-8859-7\";\n\t}\n\tif (charset.equals(\"ISO-8859-8\")){\n\t\treturn \"ISO-8859-8\";\n\t}\n\tif (charset.equals(\"ISO-8859-9\")){\n\t\treturn \"ISO-8859-9\";\n\t}\n\tif (charset.equals(\"ISO-8859-10\")){\n\t\treturn \"ISO-8859-10\";\n\t}\n\tif (charset.equals(\"ISO-8859-13\")){\n\t\treturn \"ISO-8859-13\";\n\t}\n\tif (charset.equals(\"ISO-8859-14\")){\n\t\treturn \"ISO-8859-14\";\n\t}\n\tif (charset.equals(\"ISO-8859-15\")){\n\t\treturn \"ISO-8859-15\";\n\t}\n\tif (charset.equals(\"ISO-8859-16\")){\n\t\treturn \"ISO-8859-16\";\n\t}\n\tif (charset.equals(\"ISO-8859-2\")){\n\t\treturn \"ISO-8859-2\";\n\t}\n\tif (charset.equals(\"ISO-8859-3\")){\n\t\treturn \"ISO-8859-3\";\n\t}\n\tif (charset.equals(\"ISO-8859-4\")){\n\t\treturn \"ISO-8859-4\";\n\t}\n\tif (charset.equals(\"ISO-8859-5\")){\n\t\treturn \"ISO-8859-5\";\n\t}\n\tif (charset.equals(\"ISO-8859-6\")){\n\t\treturn \"ISO-8859-6\";\n\t}\n\tif (charset.equals(\"ISO-8859-7\")){\n\t\treturn \"ISO-8859-7\";\n\t}\n\tif (charset.equals(\"ISO-8859-8\")){\n\t\treturn \"ISO-8859-8\";\n\t}\n\tif (charset.equals(\"ISO-8859-9\")){\n\t\treturn \"ISO-8859-9\";\n\t}\n\tif (charset.equals(\"ISO-8859-10\")){\n\t\treturn \"ISO-8859-10\";\n\t}\n\tif (charset.equals(\"ISO-8859-13\")){\n\t\treturn \"ISO-8859-13\";\n\t}\n\tif (charset.equals(\"ISO-8859-15\")){\n\t\treturn \"ISO-8859-15\";\n\t}\n\tif (charset.equals(\"ISO-8859-16\")){\n\t\treturn \"ISO-8859-16\";\n\t}\n\tif (charset.equals(\"ISO-2022-JP\")){\n\t\treturn \"ISO-2022-JP\";\n\t}\n\tif (charset.equals(\"ISO-2022-KR\")){\n\t\treturn \"ISO-2022-KR\";\n\t}\n\tif (charset.equals(\"ISO-2022-", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n    if(charset.equals(\"ISO-8859-1\")){\n        return \"ISO-8859-1\";\n    } else if(charset.equals(\"ISO-8859-2\")){\n        return \"ISO-8859-2\";\n    } else if(charset.equals(\"ISO-8859-3\")){\n        return \"ISO-8859-3\";\n    } else if(charset.equals(\"ISO-8859-4\")){\n        return \"ISO-8859-4\";\n    } else if(charset.equals(\"ISO-8859-5\")){\n        return \"ISO-8859-5\";\n    } else if(charset.equals(\"ISO-8859-6\")){\n        return \"ISO-8859-6\";\n    } else if(charset.equals(\"ISO-8859-7\")){\n        return \"ISO-8859-7\";\n    } else if(charset.equals(\"ISO-8859-8\")){\n        return \"ISO-8859-8\";\n    } else if(charset.equals(\"ISO-8859-8-I\")){\n        return \"ISO-8859-8-I\";\n    } else if(charset.equals(\"ISO-2022-JP\")){\n        return \"ISO-2022-JP\";\n    } else if(charset.equals(\"ISO-2022-KR\")){\n        return \"ISO-2022-KR\";\n    } else if(charset.equals(\"ISO-2022-CN\")){\n        return \"ISO-2022-CN\";\n    } else if(charset.equals(\"ISO-2022-CN-TRAD\")){\n        return \"ISO-2022-CN-TRAD\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-CN-MTRP\")){\n        return \"ISO-2022-CN-MTRP\";\n    } else if(charset.equals(\"ISO-2022-JP\")){\n        return \"ISO-2022-JP\";\n    } else if(charset.equals(\"ISO-2022-KR\")){\n        return \"ISO-2022-KR\";\n    } else if(charset.equals(\"ISO-2022-KR\")){\n        return \"ISO-2022-KR\";\n    } else if(charset.equals(\"ISO-2022-KR\")){\n        return \"ISO-2022-KR\";\n    } else if(charset.equals(\"ISO-", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n\tif(charset == null){\n\t\treturn null;\n\t}\n\tif(charset.equals(\"ISO-8859-1\")){\n\t\treturn \"ISO-8859-1\";\n\t}\n\tif(charset.equals(\"UTF-16\")){\n\t\treturn \"UTF-16\";\n\t}\n\tif(charset.equals(\"UTF-16BE\")){\n\t\treturn \"UTF-16BE\";\n\t}\n\tif(charset.equals(\"UTF-16LE\")){\n\t\treturn \"UTF-16LE\";\n\t}\n\tif(charset.equals(\"UTF-8\")){\n\t\treturn \"UTF-8\";\n\t}\n\treturn charset;\n}", "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n\nprivate static String javaCharset(String charset){\n  String newCharset = \"ISO-8859-1\";\n  try{\n    newCharset = charset.replaceAll(\"-\", \"\");\n  } catch (Exception e){\n    // ignore\n  }\n  return newCharset;\n}"]}
{"_id": "636767441a6d9265ec017cc1", "generate_results": ["/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}", "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}"]}
{"_id": "636767551a6d9265ec017f3f", "generate_results": ["public static final <V>void swap(V[] arr,int i,int j){\n\tarr[i] = arr[j];\n\tarr[j] = arr[i];\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n    V temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV tmp = arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=tmp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n}", "public static final <V>V swap(V[] arr,int i,int j){\n    V temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    return arr[i];\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}"]}
{"_id": "6367675c1a6d9265ec018058", "generate_results": ["public String get() {\n            return new String(new char[capacity]).substring(start, endPos);\n        }", "public String get(){\n            String s = new String();\n            for(String i = start; i < this.get(); i++){\n                s = s + \"\" + i;\n            }\n            return s;\n        }", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\treturn () -> {\n\t\tlong i = start;\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(i-- > 0){\n\t\t\tsb.append(i);\n\t\t}\n\t\treturn sb.toString();\n\t};\n}", "public String get(){\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tbuffer.append(Integer.toString(start));\n\t\t\tfor(int i=min; i<=max; i+=step){\n\t\t\t\tbuffer.append(Integer.toString(i));\n\t\t\t\tbuffer.append(Integer.toString(i));\n\t\t\t}\n\t\t\tbuffer.append(Integer.toString(step));\n\t\t\tbuffer.append(Integer.toString(step));\n\t\t\treturn buffer.toString();\n\t\t}", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\treturn () -> \"0\" + start;\n}", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n  return new Supplier<String>() {\n    @Override public String get() { return Integer.toString(start); }\n  };\n}", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new Supplier<String>(){\n        private String value = \"\";\n        public String get(){\n            return value;\n        }\n    };\n}", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\treturn new Supplier<String>() {\n\t\tpublic String get(){\n\t\t\tint i = start;\n\t\t\tint j = i;\n\t\t\tint k = j;\n\t\t\twhile (i <= j){\n\t\t\t\tif (i % 2 == 0){\n\t\t\t\t\tk++;\n\t\t\t\t}else{\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn i + \" \" + k;\n\t\t}\n\t};\n}", "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n\n@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n    return new Supplier<String>() {\n        @Override public String get() {\n            StringBuilder sb = new StringBuilder();\n            for(int i = start; i < 10; i++){\n                sb.append(String.valueOf(i));\n            }\n            return sb.toString();\n        }\n    };\n}", "public static Supplier<String> createStringSupplier(int start, int maxValue, int minValue){\n\treturn () -> start+\"\";\n}"]}
{"_id": "636767501a6d9265ec017e86", "generate_results": ["public ListNode<E> previousNode(){\n\treturn head.previousNode();\n}", "public ListNode<E> previousNode(){\n  return previousNode(1);\n}", "public ListNode<E> previousNode(){\n\treturn null;\n}", "public ListNode<E> previousNode(){\n\treturn new ListNode<E>();\n}", "public ListNode<E> previousNode(){\n    ListNode<E> ret = new ListNode<E>(null);\n    ret.setNext(head);\n    ret.setPrev(null);\n    ListNode<E> prev = head;\n    while(prev!= null){\n        prev = prev.getNext();\n        ret.setNext(ret.getNext().getPrev());\n        ret.setNext(ret.getNext().getPrev());\n    }\n    return ret;\n}", "public ListNode<E> previousNode(){\n    ListNode<E> node = new ListNode<E>(null);\n    node.next = this;\n    return node;\n}", "public ListNode<E> previousNode(){\n  return null;\n}", "public ListNode<E> previousNode(){\n    ListNode<E> r = new ListNode<E>(0);\n    ListNode<E> t = r;\n    ListNode<E> n = t;\n    for(int i=1;i<=size;i++){\n        if(!t.nextNode().isEmpty()){\n            t = t.nextNode();\n            n = t;\n        }\n        else{\n            return t;\n        }\n    }\n    return n;\n}", "public ListNode<E> previousNode(){\n    return null;\n}", "public ListNode<E> prevNode(){\n  return new ListNode<E>(get(end()-1).previousNode());\n}"]}
{"_id": "636767581a6d9265ec017fc4", "generate_results": ["public static long factorial(int n){\n\tif (n == 0) return 1;\n\tif (n == 1) return 1;\n\tif (n == 2) return 1;\n\tif (n == 3) return 2;\n\tif (n == 4) return 4;\n\tif (n == 5) return 20;\n\tif (n == 6) return 120;\n\tif (n == 7) return 900;\n\tif (n == 8) return 3628800;\n\tif (n == 9) return 1843200;\n\tif (n == 10) return 1209600;\n\tif (n == 11) return 2432902008176640000L;\n\tif (n == 12) return 609600;\n\tif (n == 13) return 3628800;\n\tif (n == 14) return 1843200;\n\tif (n == 15) return 1209600;\n\tif (n == 16) return 2432902008176640000L;\n\tif (n == 17) return 609600;\n\tif (n == 18) return 3628800;\n\tif (n == 19) return 1843200;\n\tif (n == 20) return 1209600;\n\tif (n == 21) return 2432902008176640000L;\n\tif (n == 22) return 609600;\n\tif (n == 23) return 3628800;\n\tif (n == 24) return 1843200;\n\tif (n == 25) return 1209600;\n\tif (n == 26) return 2432902008176640000L;\n\tif (n == 27) return 609600;\n\tif (n == 28) return 3628800;\n\tif (n == 29) return 1843200;\n\tif (n == 30) return 1209600;\n\tif (n == 31) return 2432902008176640000L;\n\tif (n == 32) return 609600;\n\tif (n == 33) return 3628800;\n\tif (n == 34) return 1843200;\n\tif (n == 35) return 1209600;\n\tif (n == 36) return 2432902008176640000L;\n\tif (n == 37) return 609600;\n\tif (n == 38) return 3628800;\n\tif (n == 39) return 1843200;\n\tif (n == 40) return 1209600;\n\tif (n == 41) return 2432902008176640000L;\n\tif (n == 42) return 609600;\n\tif (n == 43) return 3628800;\n\tif (n == 44) return 1843200;\n\tif (n == 45) return 1209600;\n\tif (n == 46) return 2432902008176640000L;\n\tif (n == 47) return 609600;\n\tif (n == 48) return 3628800;\n\tif (n == 49) return 1843200;\n\tif (n == 50) return 1209600;\n\tif (n == 51) return 2432902008176640000L;\n\tif (n == 52) return 609600;\n\tif (n == 53) return 3628800;\n\tif (n == 54) return 1843200;\n\tif (n == 55) return 1209600;\n\tif (n == 56) return 2432902008176640000L;\n\tif (n == 57) return 609600;\n\tif (n == 58) return 3628800;\n\tif (n == 59) return 1843200;\n\tif (n == 60) return 1209600;\n\tif (n == 61) return 2432902008176640000L;\n\tif (n == 62) return 609600;\n\tif (n == 63) return 3628800;\n\tif (n == 64) return 1843200;\n\tif (n == 65) return 1209600;\n\tif (n == 66) return 2432902008176640000L;\n\tif (n == 67) return 609600;\n\tif (n == 68) return 3628800;\n\tif (n == 69) return 1843200;\n\tif (n == 70) return 1209600;\n\tif (n == 71) return 2432902008176640000L;\n\tif (n == 72) return 609", "public static long factorial(int n){\n    if(n==0) return 1;\n    long nn = n;\n    while(nn>1){\n        nn = nn * n;\n    }\n    return nn;\n}", "public static int factorial(int n){\n    int fact = 1;\n    for(int i = 1; i <= n; i++){\n        fact *= i;\n    }\n    return fact;\n}", "public static long factorial(int n){\n    if(n == 0) return 1;\n    if(n == 1) return 1;\n    if(n == 2) return 1;\n    if(n == 3) return 2;\n    if(n == 4) return 5;\n    if(n == 5) return 10;\n    if(n == 6) return 100;\n    if(n == 7) return 1000;\n    if(n == 8) return 10000;\n    if(n == 9) return 100000;\n    if(n == 10) return 1000000;\n    if(n == 11) return 10000000;\n    if(n == 12) return 1000000000;\n    if(n == 13) return 1000000000000;\n    if(n == 14) return 10000000000000;\n    if(n == 15) return 100000000000000;\n    if(n == 16) return 1000000000000000;\n    if(n == 17) return 10000000000000000;\n    if(n == 18) return 100000000000000000;\n    return (long) n * factorial(n - 1);\n}", "public static long factorial(int n){\n    if(n == 0){\n        return 1;\n    }\n    else if(n < 0){\n        return 0;\n    }\n    else {\n        long factorial = 1;\n        for(int i = 1; i < n; i++){\n            factorial *= i;\n        }\n        return factorial;\n    }\n}", "public static int factorial(int n){\n    if(n<=0){\n        throw new IllegalArgumentException(\"The number of factors cannot be negative.\");\n    }\n    int fact = 1;\n    for(int i=2; i<=n; i++){\n        fact = fact * i;\n    }\n    return fact;\n}", "public static int factorial(int n){\n    int res = 1;\n    while(n!=1){\n        res *= n;\n        n = n * n;\n    }\n    return res;\n}", "public static long factorial(int n){\n\n\tif(n < 1)\n\t\treturn 1;\n\telse {\n\t\tif(n == 1)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn n * factorial(n-1);\n\t}\n}", "public static long factorial(int n){\n\tif (n == 1) return 1;\n\tlong result = 1;\n\tfor (int i = 2; i <= n; i++){\n\t\tresult *= i;\n\t}\n\treturn result;\n}", "public static long factorial(int n){\n    if(n==0){\n        return 1;\n    }\n    else{\n        long result = 1;\n        long num = n;\n        while(num > 0){\n            result *= num;\n            num--;\n        "]}
{"_id": "636767631a6d9265ec018171", "generate_results": ["/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}", "public void unlink(ListNodeImpl<E> node){\n\tListNodeImpl<E> next = node.next;\n\tif(node.next!= null){\n\t\tnode.next = next.next;\n\t\tnext.next = null;\n\t}else{\n\t\tnode.next = null;\n\t}\n}", "/** \n * Remove the non null  {@code node}", "/** \n * Remove the non null  {@code node}"]}
{"_id": "636767491a6d9265ec017d90", "generate_results": ["public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=from;i<to;i++){\n\t\tarr[i]=arr[to-1];\n\t}\n\t\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif (to<from) return;\n\t\n\tint length = to-from+1;\n\t\n\tfor (int i=from;i<length;i++){\n\t\tswap(arr,i,length-1-i);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=from;i<to;i++){\n\t\tSystem.arraycopy(arr,i,arr,i+1,1);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tint n = to - from;\n\tif(n == 0) return;\n\t\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tarr[i + from] = arr[i];\n\t}\n\t\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tarr[i + to] = arr[i];\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n    for(int i=from; i<to; i++){\n        swap(arr,i);\n    }\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tint n = to-from;\n\tif (n > 0) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tswap(arr,from,to-i);\n\t\t}\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(from<0 || to<0 || from>=to || to>=arr.length){\n\t\tthrow new IndexOutOfBoundsException(\"Invalid range: \"+from+\", \"+to);\n\t}\n\t\n\tfor(int i=from;i<=to;i++){\n\t\tarr[i]=arr[to-1];\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n    if(from<0 || to>arr.length){\n        throw new IndexOutOfBoundsException();\n    }\n    \n    for(int i=from;i<to;i++){\n        arr[i]=arr[to-1];\n    }\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tif(from>to){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"from must be smaller than to\");\n\t}\nif(from==to){\n\tSystem.arraycopy(arr,0,arr,from,to-from);\n\treturn;\n}\n\tV tmp=arr[to];\n\tarr[to]=arr[from];\n\tarr[from]=tmp;\n\tfor(int i=from;i<=to;i++){\n\t\tSystem.arraycopy(arr,i+1,arr,i,to-i);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\tfor(int i=from;i<to;i++){\n\t\tV tmp=arr[i];\n\t\tarr[i]=arr[to];\n\t\tarr[to]=tmp;\n\t}\n}"]}
{"_id": "6367674a1a6d9265ec017da9", "generate_results": ["/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "public void removeAllListNodes(DoublyLinkedList<E> list){\n\tfor (ListNode<E> node : list){\n\t\tnode.setParent(null);\n\t\tnode.setPrevious(null);\n\t\tnode.setNext(null);\n\t}\n}", "/** \n * Atomically moves all  {@link ListNode ListNodes}", "/** \n * Atomically moves all  {@link ListNode ListNodes}"]}
{"_id": "6367675f1a6d9265ec0180d3", "generate_results": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<V,E>(graph,graph.neighbors(graph.vertex()));\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    //noinspection unchecked\n    return IsomorphicGraphMapping.identity(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph, new IsomorphismHierarchy<V,E>(graph));\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\tif (graph.isEmpty())\n\t\treturn new IsomorphicGraphMapping<V,E>(graph);\n\telse\n\t\treturn new IsomorphicGraphMapping<V,E>(graph.subgraph(graph.size()));\n}", "public static <V,E> IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<V,E>(graph, new Identity<V,E>());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<>(graph,new HashMap<>());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return IdentityMapping.create(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\t\n\treturn new IsomorphicGraphMapping<V,E>(graph.size(),graph.vertexSet(),graph.edgeSet());\n}"]}
{"_id": "636767641a6d9265ec01817d", "generate_results": ["public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\t\n\tfor(V v : target.vertexSet()){\n\t\t\n\t\tresultMap.put(v.toString(),v);\n\t\t\n\t\t//System.out.println(\"v \"+v+\" \"+resultMap.get(v.toString()));\n\t}\n\t\n\t\n\t\n\t\n\tfor(E e : target.edgeSet()){\n\t\t\n\t\tV v1 = resultMap.get(e.v1().toString());\n\t\tV v2 = resultMap.get(e.v2().toString());\n\t\t\n\t\t\n\t\tif(v1==null||v2==null){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tif(v1.equals(v2)){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(v1.equals(v2.getOpposite())){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(!v1.equals(v2.getOpposite().getOpposite())){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tint v1_weight = target.getWeight(v1);\n\t\tint v2_weight = target.getWeight(v2);\n\t\t\n\t\tif(v1_weight==0){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(v2_weight==0){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(v1_weight==v2_weight){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(v1.equals(v2.getOpposite().getOpposite().getOpposite())){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\t// get the number of nodes in the graph\n\tint n = target.size();\n\t\n\t// get the number of edges in the graph\n\tint e = target.getEdgeCount();\n\t\n\t// get the number of edges in the graph\n\tint n1 = target.getEdgeCount(target.getEdge(0));\n\t\n\t// get the number of edges in the graph\n\tint n2 = target.getEdgeCount(target.getEdge(1));\n\t\n\t// get the number of edges in the graph\n\tint n3 = target.getEdgeCount(target.getEdge(2));\n\t\n\t// get the number of edges in the graph\n\tint n4 = target.getEdgeCount(target.getEdge(3));\n\t\n\t// get the number of edges in the graph\n\tint n5 = target.getEdgeCount(target.getEdge(4));\n\t\n\t// get the number of edges in the graph\n\tint n6 = target.getEdgeCount(target.getEdge(5));\n\t\n\t// get the number of edges in the graph\n\tint n7 = target.getEdgeCount(target.getEdge(6));\n\t\n\t// get the number of edges in the graph\n\tint n8 = target.getEdgeCount(target.getEdge(7));\n\t\n\t// get the number of edges in the graph\n\tint n9 = target.getEdgeCount(target.getEdge(8));\n\t\n\t// get the number of edges in the graph\n\tint n10 = target.getEdgeCount(target.getEdge(9));\n\t\n\t// get the number of edges in the graph\n\tint n11 = target.getEdgeCount(target.getEdge(10));\n\t\n\t// get the number of edges in the graph\n\tint n12 = target.getEdgeCount(target.getEdge(11));\n\t\n\t// get the number of edges in the graph\n\tint n13 = target.getEdgeCount(target.getEdge(12));\n\t\n\t// get the number of edges in the graph\n\tint n14 = target.getEdgeCount(target.getEdge(13));\n\t\n\t// get the number of edges in the graph\n\tint n15 = target.getEdgeCount(target.getEdge(14));\n\t\n\t// get the number of edges in the graph\n\tint n16 = target.getEdgeCount(target.getEdge(15));\n\t\n\t// get the number of edges in the graph\n\tint n17 = target.getEdgeCount(target.getEdge(16));\n\t\n\t// get the number of edges in the graph\n\tint n18 = target.getEdgeCount(target.getEdge(17));\n\t\n\t// get the number of edges in the graph\n\tint n19 = target.getEdgeCount(target.getEdge(18));\n\t\n\t// get the number of edges in the graph\n\tint n20 = target.getEdgeCount(target.getEdge(19));\n\t\n\t// get the number of edges in the graph\n\tint n21 = target.getEdgeCount(target.getEdge(20));\n\t\n\t// get the number of edges in the graph\n\tint n22 = target.getEdgeCount(target.getEdge(21));\n\t\n\t// get the number of edges in the graph\n\tint n23 = target.getEdgeCount(target.getEdge(22));\n\t\n\t// get the number of edges in the graph\n\tint n24 = target.getEdgeCount(target.getEdge(23));\n\t\n\t// get the number of edges in the graph\n\tint n25 = target.getEdgeCount(target.getEdge(24));\n\t\n\t// get the number of edges in the graph\n\tint n26 = target.getEdgeCount(target.getEdge(25));\n\t\n\t// get the number of edges in the graph\n\tint n27 = target.getEdgeCount(target.getEdge(26));\n\t\n\t// get the number of edges in the graph\n\tint n28 = target.getEdgeCount(target.getEdge(27));\n\t\n\t// get the number of edges in the graph\n\tint n29 = target.getEdgeCount(target.getEdge(28));\n\t\n\t// get the number of edges in", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\t\n\t//Initialization of the graph\n\ttarget.initGraph();\n\t\n\t//For each vertex\n\tfor(V v : resultMap.keySet()){\n\t\t//For each edge\n\t\tfor(E e : resultMap.get(v).getEdges()){\n\t\t\t//If the edge is connected to another vertex, then add the edge\n\t\t\tif(target.connectedTo(v,e)){\n\t\t\t\ttarget.addEdge(v,e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t// TODO Auto-generated method stub\n\t\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\ttarget.addEdge(\"a\",resultMap.get(\"a\"));\n\ttarget.addEdge(\"b\",resultMap.get(\"b\"));\n\ttarget.addEdge(\"c\",resultMap.get(\"c\"));\n\ttarget.addEdge(\"d\",resultMap.get(\"d\"));\n\ttarget.addEdge(\"e\",resultMap.get(\"e\"));\n\ttarget.addEdge(\"f\",resultMap.get(\"f\"));\n\ttarget.addEdge(\"g\",resultMap.get(\"g\"));\n\t\n\t\n\t\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tfor(V v: target.getVertices()){\n\t\tfor(E e: target.getEdges(v)){\n\t\t\tV source = e.getSource();\n\t\t\tV target = e.getTarget();\n\t\t\tif(!resultMap.containsKey(source.toString()) ||!resultMap.containsKey(target.toString())){\n\t\t\t\tresultMap.put(source.toString(), target);\n\t\t\t}else{\n\t\t\t\tgenerateGraph(target, resultMap);\n\t\t\t}\n\t\t}\n\t}\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n    \n    V vertex = resultMap.get(vertexName);\n    if(vertex!=null){\n        target.addEdge(new E(vertex,vertex));\n    }\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t//create the result map\n\tresultMap.put(\"E\",target);\n\t\n\t//create a map to store the edges of the graph\n\tMap<V,Set<E>> graphMap = new HashMap<V,Set<E>>();\n\t\n\t//create a map to store the edges of the graph\n\tMap<V,Set<E>> resultMapCopy = new HashMap<V,Set<E>>();\n\t\n\t//create the edges of the graph\n\tfor(V v : target)\n\t\tgraphMap.put(v,new HashSet<E>());\n\t\t\n\tfor(V v : target)\n\t\tresultMapCopy.put(v,new HashSet<E>());\n\t\n\t//iterate over the edges of the graph\n\tfor(Set<E> edgeSet : graphMap.values()){\n\t\t\n\t\t//iterate over all edges of the graph\n\t\tfor(E edge : edgeSet){\n\t\t\t\n\t\t\t//iterate over all edges of the graph\n\t\t\tfor(V v : resultMap.get(edge)){\n\t\t\t\t\n\t\t\t\t//iterate over all edges of the graph\n\t\t\t\tfor(E e: graphMap.get(v)){\n\t\t\t\t\t\n\t\t\t\t\t//if it is not a direct edge, then add the edge\n\t\t\t\t\tif(!graphMap.get(v).contains(e)){\n\t\t\t\t\t\tresultMapCopy.get(v).add(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//create the result map\n\tresultMap.put(\"E\",resultMapCopy);\n}", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n  \n   // Initialize the graph\n  \n  target.init();\n  \n  // Define the path in the graph\n  \n  target.addEdge(target.getEdge(0,1),target.getEdge(0,2));\n  target.addEdge(target.getEdge(1,2),target.getEdge(1,0));\n  target.addEdge(target.getEdge(2,1),target.getEdge(2,0));\n  \n  // Define the vertices\n  \n  target.addVertex(target.getVertex(0));\n  target.addVertex(target.getVertex(1));\n  target.addVertex(target.getVertex(2));\n  \n  // Define the edges\n  \n  target.addEdge(target.getEdge(0,1),target.getEdge(0,2));\n  target.addEdge(target.getEdge(1,2),target.getEdge(2,0));\n  target.addEdge(target.getEdge(2,1),target.getEdge(2,0));\n  \n  // Define the path\n  \n  target.addPath(target.getPath(0,2),target.getPath(1,0));\n  target.addPath(target.getPath(1,2),target.getPath(2,0));\n  \n  // Print the path\n  \n  System.out.println(\"The path is \");\n  System.out.println(target.getPath(0,2));\n  System.out.println(target.getPath(1,0));\n  System.out.println(target.getPath(2,0));\n  \n  // Print the vertices\n  \n  System.out.println(\"The vertices are \");\n  target.print();\n  \n  // Print the edges\n  \n  System.out.println(\"The edges are \");\n  target.print();\n  \n  // Print the path\n  \n  System.out.println(\"The path is \");\n  target.print();\n  \n  // Print the vertices\n  \n  System.out.println(\"The vertices are \");\n  target.print();\n  \n  // Print the edges\n  \n  System.out.println(\"The edges are \");\n  target.print();\n  \n  // Print the path\n  \n  System.out.println(\"The path is \");\n  target.print();\n  \n  // Print the vertices\n  \n  System.out.println(\"The vertices are \");\n  target.print();\n  \n  // Print the edges\n  \n  System.out.println(\"The edges are \");\n  target.print();\n  \n  // Print the path\n  \n  System.out.println(\"The path is \");\n  target.print();\n  \n  // Print the vertices\n  \n  System.out.println(\"The vertices are \");\n  target.print();\n  \n  // Print the edges\n  \n  System.out.println(\"The edges are \");\n  target.print();\n  \n  // Print the path\n  \n  System.out.println(\"The path is \");\n  target.print();\n  \n  // Print the vertices\n  \n  System.out.println(\"The vertices are \");\n  target.print();\n  \n  // Print the edges\n  \n  System.out.println(\"The edges are \");\n  target.print();\n   \n  }", "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\t\n\tint numEdges = target.size();\n\t\n\t// Create an empty graph\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.remove(j);\n\t\t\t\ttarget.remove(i);\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Add edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\tV newNext = resultMap.get(next);\n\t\t\t\ttarget.addEdge(i,newNext);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.removeEdge(i,j);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Remove edges\n\tfor(int i = 0;i < numEdges;i++){\n\t\tV cur = target.get(i);\n\t\tfor(int j = 0;j < numEdges;j++){\n\t\t\tV next = target.get(j);\n\t\t\tif(cur.equals(next)){\n\t\t\t\ttarget.remove"]}
{"_id": "636767531a6d9265ec017efb", "generate_results": ["/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}", "/** \n * Inserts this bucket in the data structure before the  {@code bucket}"]}
{"_id": "636767561a6d9265ec017f63", "generate_results": ["public boolean hasNext(){return visited.size()>0;}", "public boolean hasNext(){\n\treturn m_unvisited.size() > 0;\n}", "public boolean hasNext(){\n    return m_unvisited.size() > 0;\n}", "public T remove(){\n\tT removed = null;\n\tif(hasNext()){\n\t\tremoved = next();\n\t\tremoveImpl();\n\t}\n\treturn removed;\n}", "public double nextDouble(){\n\tif(hasNext()){\n\t\treturn v.nextDouble();\n\t}\n\treturn -1;\n}", "public boolean hasNext(){\n      return i < size();\n    }", "public boolean hasNext(){\n\treturn vertexList!= null;\n}", "public boolean hasNext(){ return hasNext; }", "public boolean hasNext(){return vertexSet.size()!=0;}", "public boolean hasNext(){\n  return _visited.isEmpty();\n}"]}
{"_id": "6367675a1a6d9265ec018010", "generate_results": ["/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n    for(int i=0; i<b_buckets.size(); ++i){\n        if(b_buckets[i] == this){\n            b_buckets.remove(i);\n            return;\n        }\n    }\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n    for(int i = 0; i < data.size(); i++) {\n        if(data[i] == self) {\n            data.erase(data.begin() + i);\n        }\n    }\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n    for(int i=0; i<size; i++){\n        if(i==0){\n            b1=0;\n        }\n        else{\n            b1=b1-1;\n        }\n    }\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n\tif(myBucket!=null)\n\t\tdelete myBucket;\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n  if(self == NULL){\n    return;\n  }\n  delete self;\n  self = NULL;\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n\tBucket* oldBucket = bucket;\n\tbucket = bucket->next;\n\tdelete oldBucket;\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n  buckets.erase(this);\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n\tBucket* p = new Bucket(0);\n\tdelete p;\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n    if (self.data.length == 0){\n        return;\n    }\n    self.data.length--;\n    self.data[self.data.length] = self.data[self.data.length - 1];\n    self.data[self.data.length - 1] = self.data[self.data.length - 1];\n}", "/** \n * Removes this bucket from the data structure.\n */\n\nvoid removeSelf(){\n\tbucketTable[self] = bucketTable[self+1];\n}"]}
{"_id": "6367674b1a6d9265ec017dc0", "generate_results": ["/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n  Set<V> v = new HashSet<>();\n  for( V v1 : this ){\n    for( V v2 : this ){\n      if( v1.degree() > v2.degree() ){\n        v.add( v2 );\n      }\n    }\n  }\n  return v;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n\t//initially empty set\n\tSet<V> result = new HashSet<>();\n\t\n\tfor(Edge e : this.edges){\n\t\tif(e.getDegree() > 0){\n\t\t\tresult.add(e.getVertex1());\n\t\t\tresult.add(e.getVertex2());\n\t\t}\n\t}\n\t\n\treturn result;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n    Set<V> set = new HashSet<V>();\n    for (int i = 0; i < edges.length; i++) {\n        if (edges[i].degree() > 0) {\n            set.add(edges[i].source() + \" \" + edges[i].target());\n        }\n    }\n    return set;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n\tSet<V> set = new HashSet<>();\n\tfor( int i = 0; i < 8; i++ ){\n\t\tint[] edge = new int[2];\n\t\tedge[0] = i;\n\t\tedge[1] = i + 1;\n\t\tV vertex = GraphUtil.findVertex( graph, edge );\n\t\tif( vertex == null )\n\t\t\tthrow new IllegalStateException(\"No vertex found\");\n\t\tif(!graph.isAdjacentTo( vertex, GraphUtil.findVertex( graph, edge ) ) )\n\t\t\tthrow new IllegalStateException(\"Not adjacent to vertex\");\n\t\tset.add( vertex );\n\t}\n\treturn set;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n\tSet<V> set = new HashSet<V>();\n\tfor(Edge edge : graph.getAllEdges()){\n\t\tif(edge.getE().isVisited()){\n\t\t\tV vertex = edge.getE();\n\t\t\tif(!set.contains(vertex)){\n\t\t\t\tset.add(vertex);\n\t\t\t}\n\t\t}\n\t}\n\treturn set;\n}", "public Set<V> getVisibleVertices(){\n\treturn initVisibleVertices();\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n\tHashSet<V> result = new HashSet<>();\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(!isVisibleEdge(i, j)){\n\t\t\t\tresult.add(new V(i, j));\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n\t\n\tSet<V> set = new HashSet<V>();\n\t\n\tfor(V vertex: graph.getVertices()){\n\t\tif(graph.getEdgeWeight(vertex) > 0){\n\t\t\tset.add(vertex);\n\t\t}\n\t}\n\t\n\treturn set;\n}", "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n\nprivate Set<V> initVisibleVertices(){\n    Set<V> set = new HashSet<V>();\n    for(E e: graph.getEdges()){\n        V v = e.getSource();\n        if(v.getDegree() >= 0){\n            set.add(v);\n        }\n    }\n    return set;\n}", "public Set<V> getVisibleVertices() {\n\treturn initVisibleVertices();\n}"]}
{"_id": "6367675c1a6d9265ec01805b", "generate_results": ["public void removeFromTreeEdgeList(){\n  if(!this.treeEdgeList.isEmpty()){\n    this.treeEdgeList.remove(this);\n  }\n}", "public void removeFromTreeEdgeList(){\n\tif(this.treeEdgeList.size()==0)\n\t\treturn;\n\t\n\tthis.treeEdgeList.remove(this);\n\tthis.treeEdgeList.remove(this);\n}", "public void removeFromTreeEdgeList(){\n\ttreeEdgeList = null;\n\ttreeEdgeList = new ArrayList<TreeEdge>();\n\ttreeEdgeList.add( this );\n\t\n\ttreeEdgeList = null;\n}", "public void removeFromTreeEdgeList(){\n\tif(treeEdgeList.size() > 0){\n\t\ttreeEdgeList.remove(treeEdgeList.size()-1);\n\t}\n}", "public void removeFromTreeEdgeList(){\n    \n    if (this.edgeList.size() == 1){\n        \n        this.edgeList.remove(this.edgeList.size()-1);\n        \n    }else if (this.edgeList.size() == 2){\n        \n        this.edgeList.remove(this.edgeList.size()-2);\n        \n    }else{\n        \n        this.edgeList.remove(this.edgeList.size()-1);\n        \n        this.edgeList.remove(this.edgeList.size()-2);\n        \n    }\n    \n}", "public void removeFromTreeEdgeList(){\n\t\n\t//Remove this edge from both doubly linked lists of tree edges\n\tif(this.prev!= null){\n\t\tif(this.prev.next!= null){\n\t\t\tthis.prev.next.prev = this.next;\n\t\t}else{\n\t\t\tthis.prev.next = null;\n\t\t}\n\t}\n\t\n\tif(this.next!= null){\n\t\tif(this.next.prev!= null){\n\t\t\tthis.next.prev.next = this.prev;\n\t\t}else{\n\t\t\tthis.next.prev = null;\n\t\t}\n\t}\n\t\n}", "public void removeFromTreeEdgeList(){\n  removeFromTreeEdgeList(this);\n}", "public void removeFromTreeEdgeList(){\n\t\n\t// Remove this edge from both doubly linked lists of tree edges\n\t//if(edgeList[2] == edgeList[1]){\n\t\t//System.out.println(\"Remove from the edgeList.\");\n\t\t//edgeList[1] = edgeList[2];\n\t\t//edgeList[2] = null;\n\t//}\n\t//if(edgeList[0] == edgeList[1]){\n\t\t//System.out.println(\"Remove from the edgeList.\");\n\t\t//edgeList[1] = edgeList[0];\n\t\t//edgeList[0] = null;\n\t//}\n\t\n\t// If the value is null, then the edge was not in the list\n\tif(edgeList[0] == null && edgeList[1] == null){\n\t\tSystem.out.println(\"Edge not in the edgeList.\");\n\t}\n\t\n\t// Change the value of the edge in the doubly linked list of tree edges\n\t//if(edgeList[0]!= null){\n\t\t//edgeList[0] = edgeList[1];\n\t//}\n\t//if(edgeList[1]!= null){\n\t\t//edgeList[1] = edgeList[2];\n\t//}\n\t\n\t// Set the value of the edge to null\n\tedgeList[0] = null;\n\tedgeList[1] = null;\n\t\n\t\n}", "public void removeFromTreeEdgeList(){\n\tTreeEdgeList temp = this.treeEdgeList;\n\tthis.treeEdgeList = this.treeEdgeList.next;\n\ttemp.next = null;\n\ttemp.prev = null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif (this.treeEdgeList.isEmpty()){\n\t\treturn;\n\t}\n\t\n\tthis.treeEdgeList.remove(this);\n\t\n\tif (this.treeEdgeList.size() > 0){\n\t\tthis.treeEdgeList.getLast().removeFromList();\n\t}\n\t\n\tthis.treeEdgeList.clear();\n}"]}
{"_id": "636767601a6d9265ec0180fd", "generate_results": ["/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tindex.add(new Object[]{sourceVertex,targetVertex,e});\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!indexed){\n\t\treturn;\n\t}\n\tif(sourceVertex.equals(targetVertex)){\n\t\treturn;\n\t}\n\tif(sourceVertex==null || targetVertex==null){\n\t\treturn;\n\t}\n\te.setSourceVertex(sourceVertex);\n\te.setTargetVertex(targetVertex);\n\tif(!indexed){\n\t\tindexed=true;\n\t\t//TODO: make this a hashtable\n\t\tHashtable<V,V> index = new Hashtable<V,V>();\n\t\tindex.put(sourceVertex,targetVertex);\n\t\tindex.put(targetVertex,sourceVertex);\n\t\tindexed=false;\n\t\tindex.notifyAll();\n\t}else{\n\t\tindex.notifyAll();\n\t}\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif (sourceVertex == targetVertex) return;\n\tif (sourceVertex == null || targetVertex == null)\n\t\tthrow new IllegalArgumentException(\"Source and target vertex must not be null\");\n\tif (e == null)\n\t\tthrow new IllegalArgumentException(\"Edge must not be null\");\n\t\n\tif (sourceVertex.equals(targetVertex))\n\t\treturn;\n\t\n\tif (sourceVertex == null)\n\t\tthis.index.add(new Integer(targetVertex.getID()));\n\telse if (targetVertex == null)\n\t\tthis.index.add(new Integer(sourceVertex.getID()));\n\telse if (sourceVertex.equals(targetVertex))\n\t\tthis.index.add(new Integer(targetVertex.getID()));\n\telse\n\t\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n\t\n\tthis.index.add(new Integer(targetVertex.getID()));\n\tthis.index.add(new Integer(sourceVertex.getID()));\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//add the edge to the index\n\tthis.edgeList.add(e);\n\t//update the index\n\tthis.index = this.index + 1;\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(index.contains(sourceVertex)){\n\t\tindex.add(sourceVertex,targetVertex);\n\t\tindex.add(targetVertex,e);\n\t}\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t\n\tif(!e.isVertex()){\n\t\tthrow new IllegalArgumentException(\"The edge is not a vertex\");\n\t}\n\t\n\tif(!e.getTarget().equals(targetVertex)){\n\t\tthrow new IllegalArgumentException(\"The edge is not pointing to the target vertex\");\n\t}\n\t\n\tthis.index.add(e);\n\t\n\tif(this.index.size() == this.capacity){\n\t\tthis.index.remove(this.index.size() - 1);\n\t}\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t\n\tif(!addEdge(sourceVertex,targetVertex,e)) return;\n\t\n\t//add edge to the index\n\tindex[sourceVertex.getID()][targetVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[targetVertex.getID()][sourceVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[sourceVertex.getID()][targetVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[sourceVertex.getID()][targetVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[targetVertex.getID()][sourceVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[sourceVertex.getID()][targetVertex.getID()]=e;\n\t\n\t//add edge to the index\n\tindex[targetVertex.getID()][sourceVertex.getID()]=e;\n\t\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tint src = sourceVertex.getIndex();\n\tint tgt = targetVertex.getIndex();\n\tif(src==tgt)\n\t\treturn;\n\tif(src==tgt+1)\n\t\taddToIndex(sourceVertex,targetVertex,e);\n\telse {\n\t\tif(src==tgt-1)\n\t\t\taddToIndex(targetVertex,sourceVertex,e);\n\t\telse\n\t\t\taddToIndex(sourceVertex,targetVertex,e);\n\t}\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\t//find the source and target vertices\n\tV source = getSource(sourceVertex);\n\tV target = getTarget(targetVertex);\n\tV sourceSrc = getSource(source);\n\tV targetSrc = getTarget(target);\n\t\n\t//check if the edge is already in the index\n\tif(index.containsKey(sourceSrc, targetSrc)){\n\t\tindex.put(sourceSrc, targetSrc, e);\n\t} else {\n\t\tindex.put(sourceSrc, targetSrc, e);\n\t}\n}", "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif (e.getTargetVertex()==null){\n\t\tSystem.out.println(\"Null target vertex\");\n\t\treturn;\n\t}\n\t//System.out.println(\"addToIndex \"+sourceVertex+\" \"+targetVertex);\n\t//System.out.println(\"e.getTargetVertex() \"+e.getTargetVertex());\n\t//System.out.println(\"e.getSourceVertex() \"+e.getSourceVertex());\n\t//System.out.println(\"e.getSourceVertex().equals(e.getTargetVertex()\"));\n\tif (e.getSourceVertex().equals(sourceVertex)){\n\t\tif (e.getSourceVertex()!=null && e.getTargetVertex()!=null){\n\t\t\t//System.out.println(\"e.getTargetVertex() \"+e.getTargetVertex());\n\t\t\tindex.addEdge(e.getTargetVertex(),e.getSourceVertex(),e.getWeight());\n\t\t}\n\t}\n\telse if (e.getTargetVertex().equals(targetVertex)){\n\t\tif (e.getTargetVertex()!=null && e.getSourceVertex()!=null){\n\t\t\t//System.out.println(\"e.getTargetVertex() \"+e.getTargetVertex());\n\t\t\tindex.addEdge(e.getSourceVertex(),e.getTargetVertex(),e.getWeight());\n\t\t}\n\t}\n}"]}
{"_id": "636767521a6d9265ec017ecc", "generate_results": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tif (box == null) return null;\n\t\n\tdouble x0 = box.getXmin();\n\tdouble x1 = box.getXmax();\n\tdouble y0 = box.getYmin();\n\tdouble y1 = box.getYmax();\n\t\n\tif (x0 > x", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\t\n\tdouble leftX = box.getMaxX();\n\tdouble rightX = box.getMinX();\n\t\n\tdouble leftY = box.getMinY();\n\tdouble rightY = box.getMaxY();\n\t\n\treturn new Pair<>(new Box2D(leftX,leftY,rightX,rightY),new Box2D(leftX,leftY,rightX,rightY));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    // The boxes are already equal\n    return new Pair<>(new Box2D(box.getMinX(), box.getMinY()),\n        new Box2D(box.getMaxX(), box.getMinY()));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    return new Pair<>(new Box2D(box.getMinX(),box.getMaxX()),new Box2D(box.getMinX(),box.getMaxX()));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\t// get the axis\n\tAxis axis = box.getAxis();\n\t// get the length of the axis\n\tdouble length = axis.getLength();\n\n\t// get the first and second box\n\tBox2D firstBox = box.getBox(0);\n\tBox2D secondBox = box.getBox(1);\n\n\t// create an axis and length for the first box\n\tAxis axis1 = new Axis(firstBox);\n\taxis1.setLength(length);\n\t// create an axis and length for the second box\n\tAxis axis2 = new Axis(secondBox);\n\taxis2.setLength(length);\n\n\t// split the box along the axis\n\treturn new Pair<Box2D,Box2D>(firstBox,secondBox);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\t\n\tif(box.getX().getX() == box.getY().getX()){\n\t\treturn new Pair<>(box.getX(),box.getY());\n\t}\n\t\n\tBox2D left = box.getX().splitAlongXAxis(1);\n\tBox2D right = box.getX().splitAlongXAxis(2);\n\t\n\treturn new Pair<>(left,right);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tdouble sizeX = box.getWidth();\n\tdouble sizeY = box.getHeight();\n\tdouble size = Math.sqrt(sizeX*sizeX+sizeY*sizeY);\n\tdouble halfSize = size/2;\n\tdouble left = box.getMinX();\n\tdouble right = box.getMaxX();\n\tdouble top = box.getMinY();\n\tdouble bottom = box.getMaxY();\n\tdouble halfLeft = left - halfSize;\n\tdouble halfRight = right + halfSize;\n\tdouble halfTop = top - halfSize;\n\tdouble halfBottom = bottom + halfSize;\n\treturn new Pair<Box2D,Box2D>(new Box2D(left,top),new Box2D(right,bottom));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble xmin = box.getMinX();\n\tdouble xmax = box.getMaxX();\n\t\n\tdouble ymin = box.getMinY();\n\tdouble ymax = box.getMaxY();\n\t\n\tdouble xminP = xmin;\n\tdouble xmaxP = xmax;\n\t\n\tdouble yminP = ymin;\n\tdouble ymaxP = ymax;\n\t\n\tdouble xstep = xmaxP - xminP;\n\tdouble ystep = ymaxP - yminP;\n\t\n\treturn new Pair<Box2D,Box2D>(new Box2D(xminP,yminP,xmaxP,ymaxP), new Box2D(xminP,ymaxP,xmaxP,ymaxP));\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tdouble h = box.getSize", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n    Box2D result = new Box2D();\n    result.setXMin(box.getXMin());\n    result.setXMax(box.getXMax());\n    result.setYMin(box.getYMin());\n    result.setYMax(box.getYMax());\n    return new Pair<Box2D,Box2D>(result,result);\n}"]}
{"_id": "636767531a6d9265ec017ef1", "generate_results": ["public static boolean equals(Point2D p1,Point2D p2){\n\treturn (Math.abs(p1.getX()-p2.getX())<1e-9) && (Math.abs(p1.getY()-p2.getY())<1e-9);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tdouble x1,y1,x2,y2;\n\tif(p1.getX()==p2.getX() && p1.getY()==p2.getY()){\n\t\treturn true;\n\t}else{\n\t\tx1=p1.getX();\n\t\ty1=p1.getY();\n\t\tx2=p2.getX();\n\t\ty2=p2.getY();\n\t\treturn (Math.abs(x1-x2)<=1e-9 && Math.abs(y1-y2)<=1e-9);\n\t}\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\treturn (Math.abs(p1.getX()-p2.getX()) < 1e-9)\n\t\t&& (Math.abs(p1.getY()-p2.getY()) < 1e-9);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\tif (p1==null) return p2 == null;\n\tif (p2==null) return p1 == null;\n\treturn p1.x==p2.x && p1.y==p2.y;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1==null||p2==null) return false;\n\treturn p1.equals(p2);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\t\n\tif(p1==null || p2==null)\treturn false;\n\treturn p1.x==p2.x && p1.y==p2.y;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tif(p1.getX()==p2.getX() && p1.getY()==p2.getY()){\n\t\treturn true;\n\t}\n\tdouble d1=p1.getX()-p2.getX();\n\tdouble d2=p1.getY()-p2.getY();\n\tdouble diff=d1*d2;\n\tif(Math.abs(d1)<Math.abs(d2)){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean equals(Point2D p1,Point2D p2){\n    return (p1.getX()==p2.getX() && p1.getY()==p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\treturn (p1.getX()==p2.getX() && p1.getY()==p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\tdouble x1 = p1.getX();\n\tdouble y1 = p1.getY();\n\tdouble x2 = p2.getX();\n\tdouble y2 = p2.getY();\n\t\n\treturn (Math.abs(x1-x2)<=1e-9 && Math.abs(y1-y2)<=1e-9);\n}"]}
{"_id": "6367674a1a6d9265ec017dab", "generate_results": ["public int compare(Double o1,Double o2){\n\tif(o1.compareTo(o2) == 0){\n\t\treturn 0;\n\t}\n\telse if(o1.compareTo(o2) < 0){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}", "public int compare(Double o1,Double o2){\n    if(o1==null || o2==null){\n        if(o1==null){\n            return -1;\n        }else{\n            return 1;\n        }\n    }else if(o1.compareTo(o2) < 0){\n        return -1;\n    }else if(o1.compareTo(o2) > 0){\n        return 1;\n    }else{\n        return 0;\n    }\n}", "public int compare(Double o1,Double o2){ return Double.compare(o1,o2); }", "public int compare(Double o1,Double o2){\n    return Double.compare(o1,o2);\n}", "public int compare(Double o1,Double o2){\n\tif(o1 instanceof Double && o2 instanceof Double){\n\t\treturn o1.compareTo(o2);\n\t}\n\treturn o1.compareTo(o2);\n}", "public int compare(Double o1,Double o2){\n\treturn Double.compare(o1, o2);\n}", "public int compare(Double o1,Double o2){\n    return Double.compare(o1, o2);\n}", "public int compare(Double o1,Double o2){\n\treturn o1.compareTo(o2);\n}", "public int compare(Double o1,Double o2){\n\treturn Double.compare(o1, o2);\t\n}", "public int compare(Double o1,Double o2){\n\tif(o1.compareTo(o2) == 0) return 0;\n\tif(o1.compareTo(o2) > 0) return -1;\n\treturn 1;\n}"]}
{"_id": "6367674f1a6d9265ec017e74", "generate_results": ["public String toString(){\n  return queue.toString();\n}", "public String toString(){\n   return \"Queue [size = \" + size() + \"]\";\n}", "public String toString(){\n\treturn \"QUEUE:\" + queue.size();\n}", "public String toString(){\n\tStringBuffer sb=new StringBuffer();\n\tint i;\n\tQueueNode first=null;\n\tQueueNode last=null;\n\t\n\tsb.append(\"[\");\n\tfor(i=0;i<size();i++){\n\t\tfirst=first.next;\n\t\tlast=last.next;\n\t\tif(last!=null){\n\t\t\tsb.append(last.data);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(first.data);\n\t\tif(first!=null){\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(\"\\n\");\n\t}\n\tsb.append(\"] \");\n\treturn sb.toString();\n}", "public String toString(){\n    String s = \"\";\n    while (count!= 0){\n        s = s + \"(\" + count + \") \";\n        count--;\n    }\n    return s;\n}", "public String toString(){\n\tString ret = new String(\"\");\n\t\n\tfor(int i=0;i<size();i++){\n\t\tret += ((IQueueElement)get(i)).toString();\n\t}\n\n\treturn ret;\n}", "public String toString(){\n\n\tString output = \"\";\n\t\n\tint i,j;\n\tfor(i=0;i<size();i++){\n\t\t\n\t\toutput += \"(\"+i+\"): \"+get(i);\n\t\tif(i<size()-1){\n\t\t\toutput += \",\";\n\t\t}\n\t\tfor(j=i+1;j<size();j++){\n\t\t\toutput += get(j);\n\t\t}\n\t}\n\t\n\treturn output;\n\t\n}", "public String toString(){\n    String result = \"\";\n    for( int i = 0; i < this.size(); ++i){\n        QueueNode node = this.get(i);\n        String tmp = \"(\" + node.getLabel() + \") \";\n        for( int j = 0; j < this.size(); ++j){\n            QueueNode temp = this.get(j);\n            tmp += temp.getLabel() + \" \";\n        }\n        result = result + tmp;\n        result = result.substring(0, result.length()-1);\n    }\n    return result;\n}", "public String toString(int start){\n\tStringBuffer sb = new StringBuffer();\n\tfor (int i=start; i<n; i++)\n\t\tsb.append(newItem[i]);\n\treturn sb.toString();\n}", "public String toString(){\n    return \"Queue: \" + this.size() + \" items\";\n}"]}
{"_id": "636767431a6d9265ec017c8d", "generate_results": ["/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n\t\n\tif (n < 0) {\n\t\treturn -1;\n\t}\n\t\n\tint log2 = Math.log(n);\n\t\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\t\n\treturn (int)Math.floor(log2 + 1) + 1;\n\t\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n    if (n <= 0) return 1;\n    int log = log2(n);\n    return (log == n)? 1 : 0;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n    int k = 1;\n    while(k < n){\n        k *= 2;\n    }\n    return k - 1;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n    int result = 0;\n    while (n >= 1) {\n        result += 1;\n        n >>= 1;\n    }\n    return result;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n    int d = 1;\n    while(d <= n){\n        d *= 2;\n    }\n    return d;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n\t\n\tif (n == 0) {\n\t\treturn 0;\n\t}\n\t\n\treturn (int) Math.log(n) + 1;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n    int result = 0;\n\n    while (n > 0){\n        result += (n % 2)? 1 : 0;\n        n /= 2;\n    }\n\n    return result;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n\tif(n==0)return 1;\n\tif(n<=1)return 1;\n\treturn Math.floor(Math.log(n)/Math.log(2));\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n\t\n\tint result = n;\n\t\n\tfor (int i = 2; i <= n; i += 2) {\n\t\tresult += i - 1;\n\t}\n\t\n\treturn result;\n}", "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n\nprivate int computeBinaryLog(int n){\n\treturn (int)(Math.log(n) / Math.log(2));\n}"]}
{"_id": "636767611a6d9265ec018106", "generate_results": ["public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V w : v){\n\t\tsum += w.weight();\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor (V w : v)\n\t\tsum += weights[w] * weights[v];\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor (V w : v){\n\t\tsum += w.weight();\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum=0;\n\tfor(V vv : v){\n\t\tsum+= vertexWeight(vv);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor (V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\t\n\tdouble sum = 0;\n\t\n\tfor(V w : v){\n\t\tsum += vertexWeight(w);\n\t}\n\t\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor (V w : v){\n\t\tsum += w.weight();\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum=0;\n\tfor(V w:v){\n\t\tsum+=w.weight;\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\t\n\tdouble sum = 0;\n\t\n\tfor(V v: v){\n\t\tsum += vertexWeight(v);\n\t}\n\t\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor (V vv: v){\n\t\tsum += vertexWeight(vv);\n\t}\n\treturn sum;\n}"]}
{"_id": "636767611a6d9265ec018116", "generate_results": ["public Set<V> intersection(Set<V> set1,Set<V> set2){\n\t\n\tSet<V> result=new HashSet<V>();\n\t\n\tSet", "public Set<V> intersection(Set<V> set1,Set<V> set2){\n\treturn intersection(set1,set2);\n}", "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(!set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n    if(set1.size()==0 && set2.size()==0){\n        return Collections.<V>emptySet();\n    }\n    Set<V> result = new HashSet<V>();\n    if(set1.size()==0){\n        result.addAll(set2);\n    }else if(set2.size()==0){\n        result.addAll(set1);\n    }else{\n        result.addAll(set1);\n        result.addAll(set2);\n    }\n    return result;\n}", "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> res = new HashSet<V>();\n\tres.addAll(set1);\n\tres.removeAll(set2);\n\treturn res;\n}", "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> intersection = new HashSet<V>();\n\tSet<V> intersection1 = intersection(set1,set2);\n\tSet<V> intersection2 = intersection(set2,set1);\n\tintersection.addAll(intersection1);\n\tintersection.addAll(intersection2);\n\treturn intersection;\n}", "public Set<V> intersection(Set<V> set1,Set<V> set2) {\n\treturn intersection(set1,set2);\n}", "public Set<V> intersection(Set<V> set1,Set<V> set2){\n\treturn intersection(set1,set2,set2);\n}", "public Set<V> intersection(Set<V> set1,Set<V> set2){\n    Set<V> result = new HashSet<>();\n    for(V element : set1){\n        if(set2.contains(element)){\n            result.add(element);\n        }\n    }\n    return result;\n}", "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tif(set1.size()==0||set2.size()==0) return Collections.EMPTY_SET;\n\tSet<V> intersection=new HashSet<>();\n\t\n\tfor(V v1:set1){\n\t\tfor(V v2:set2){\n\t\t\tif(v1.equals(v2)) continue;\n\t\t\tif(v1.contains(v2)) intersection.add(v1);\n\t\t}\n\t}\n\treturn intersection;\n}"]}
{"_id": "636767511a6d9265ec017eb6", "generate_results": ["/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}", "public boolean isValid() {\n\t\treturn this.stop.equals(this.start);\n\t}", "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate}"]}
{"_id": "6367675d1a6d9265ec018082", "generate_results": ["/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\tif(this.indexInPath() < 2)\n\t\treturn null;\n\treturn this.getEdge(this.getPathTo(this.indexInPath()-1).get(this.indexInPath()-1));\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\treturn nextEdge;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\t\n\t// if the current node is virtual, it is not returned\n\tif(!this.vNode){\n\t\treturn null;\n\t}\n\t\n\t// if the next node is virtual, it is not returned\n\tif(!this.nextNode){\n\t\treturn null;\n\t}\n\t\n\t// if the next node is not real, it is returned\n\tif(!this.nextNode.vNode){\n\t\treturn this.nextNode;\n\t}\n\t\n\t// if the next node is not real, it is incident to its real counterpart\n\treturn this.nextNode.nextNode;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n    if(!isVirtual()){\n        return this.edgeNext;\n    }\n    \n    if(this.nodeToNext == null) {\n        return null;\n    }\n    \n    if(this.nodeToNext.equals(this.nodeToNext.next)){\n        return this.edgeNext;\n    }\n    \n    if(this.nodeToNext.next.equals(this.nodeToNext.next.next)){\n        return this.edgeNext;\n    }\n    \n    return null;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\tEdge edge = null;\n\tNode prevNode = null;\n\t//if the node is virtual, just return null\n\tif(this.node.virtual){\n\t\treturn edge;\n\t}\n\t//if the node is virtual, just return null\n\tif(this.node.virtual){\n\t\treturn null;\n\t}\n\t//if the node is real, return edge\n\tif(!this.node.real){\n\t\treturn edge;\n\t}\n\t//if the node is real, just return null\n\tif(!this.node.real){\n\t\treturn null;\n\t}\n\tprevNode = this.node;\n\t//first, get the next node\n\tthis.node = this.node.real.next;\n\tif(this.node == null){\n\t\t//if the next node is not virtual, return null\n\t\treturn null;\n\t}\n\t//next, get the edge\n\tedge = this.node.next;\n\t//if the next node is not virtual, return null\n\tif(this.node.virtual){\n\t\treturn null;\n\t}\n\t//if the next node is virtual, just return null\n\tif(this.node.virtual){\n\t\treturn null;\n\t}\n\t//if the next node is not real, return null\n\tif(!this.node.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, return edge\n\tif(!this.node.real.next){\n\t\treturn edge;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual.next){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next node is real, just return null\n\tif(!this.node.real.next.real.virtual.next.real.virtual.next.real.virtual.next.real){\n\t\treturn null;\n\t}\n\t//if the next", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\tEdge edge = null;\n\tif(currentNode.isVirtual()){\n\t\tif(nextNode.isVirtual())\n\t\t\tedge = nextNode.getEdge(currentNode);\n\t\telse\n\t\t\tedge = nextNode.getEdge(nextNode);\n\t}else{\n\t\tif(nextNode.isVirtual()){\n\t\t\tedge = nextNode.getEdge(currentNode);\n\t\t}else{\n\t\t\tedge = nextNode.getEdge(nextNode);\n\t\t}\n\t}\n\treturn edge;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\t\n\tif(this.nodeVirt==this.nodeNext){\n\t\treturn this.nodeNext;\n\t}\n\t\n\tif(this.nodeNext!=null){\n\t\treturn this.nodeNext.edgeToNext();\n\t}\n\t\n\treturn null;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\t\n\tif(this.v == null || this.v.v == null){\n\t\treturn null;\n\t}\n\t\n\tEdge tempEdge;\n\t\n\ttry{\n\t\ttempEdge = this.v.v.edgeToNext(this);\n\t\t\n\t}catch(NullPointerException e){\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tif(tempEdge == null){\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tif(tempEdge.v == null){\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\treturn tempEdge;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n    if (this.v == null)\n        return null;\n    Edge edge = this.v.edgeToNext();\n    if (edge!= null)\n        return edge;\n    \n    if (this.v.next == null){\n        return null;\n    }\n    else{\n        edge = this.v.next.edgeToNext();\n        if (edge!= null)\n            return edge;\n    }\n    \n    return null;\n}", "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n\nEdge edgeToNext(){\n\tEdge edge = new Edge(nodes[edge.nodes[0]],nodes[edge.nodes[1]]);\n\tedge.nodes[1] = edge.nodes[2];\n\tedge.nodes[2] = edge.nodes[3];\n\tedge.nodes[0] = edge.nodes[1];\n\tedge.nodes[3] = edge.nodes[0];\n\tedge.real = edge.nodes[3];\n\tedge.real.incidentTo = edge.nodes[0];\n\tedge.real.incidentTo.incidentTo = edge.nodes[1];\n\tedge.real.incidentTo.incidentTo = edge.nodes[2];\n\treturn edge;\n}"]}
{"_id": "636767561a6d9265ec017f7c", "generate_results": ["/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\t// The graph is represented as a set of edges\n\t// Each edge has the following properties:\n\t// - the source and target of the edge\n\t// - the edge's weight\n\t// - the weight of the edge\n\t// - the graph path to which the edge is added\n\t// \n\t// For each edge, the weight is the sum of the weight of the source,\n\t// the weight of the target and the weight of the edge\n\n\t// The weight of the edge\n\tdouble weight = 0;\n\t\n\t// The graph path to which the edge is added\n\tGraphPath<V,E> path = null;\n\t\n\t// The source and target of the edge\n\tV source = null;\n\tV target = null;\n\t\n\t// The weight of the edge\n\tdouble weight_source = 0;\n\tdouble weight_target = 0;\n\t\n\t// The weight of the edge\n\tdouble weight_edge = 0;\n\t\n\t// The number of edges in the tour\n\tint num_edges = tour.size();\n\t\n\t// The edges in the tour\n\tIterator<E> it = tour.iterator();\n\t\n\t// The edges in the tour\n\tSet<E> edges = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new HashSet<E>(num_edges);\n\t\n\t// The edges in the tour\n\tSet<E> edges_graph_graph_tour = new", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n    return GraphPathImpl<V,E>\n       .fromSet(tour,graph);\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tif (graph.getEdgeCount() == 0) return null;\n        return new GraphPath<V,E>(graph,new EdgeIterator<V,E>() {\n            @Override\n            public void addStep(E e, int j){}\n            @Override\n            public V getEdge(E e){\n                return null;\n            }\n            @Override\n            public Set<E> getVertices() {\n                return tour;\n            }\n            @Override\n            public double getCost(E e) {\n                return getEdgeCost(e);\n            }\n            @Override\n            public boolean hasNext() {\n                return false;\n            }\n            @Override\n            public GraphPath<V,E> next() {\n                throw new NoSuchElementException();\n            }\n            @Override\n            public void removeStep(E e, int j) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void removeVertices() {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public int getNumVertices() {\n                return 0;\n            }\n            @Override\n            public int getNumEdges() {\n                return 0;\n            }\n            @Override\n            public E getEdge(int i) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public int getEdgeIndex(E e) {\n                return 0;\n            }\n            @Override\n            public int getEdgeCost(E e) {\n                return 0;\n            }\n            @Override\n            public boolean hasNext() {\n                return false;\n            }\n            @Override\n            public GraphPath<V,E> next() {\n                throw new NoSuchElementException();\n            }\n            @Override\n            public void removeEdge(int i, int j) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void removeEdge(E e) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void setEdge(int i, E e) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void setEdgeIndex(int i, int j) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void setEdgeCost(int i, double edgeCost) {\n                throw new UnsupportedOperationException();\n            }\n            @Override\n            public void setVertices(Set<V> vertices) {\n            }\n            @Override\n            public void setVertices(Collection<V> vertices) {\n            }\n            @Override\n            public void setEdges(Set<E> edges) {\n            }\n            @Override\n            public void setEdges(Collection<E> edges) {\n            }\n            @Override\n            public void removeVertices() {\n            }\n            @Override\n            public void setVertices(V[] vertices) {\n            }\n            @Override\n            public void setVertices(Collection<V> vertices) {\n            }\n            @Override\n            public void setEdges(E[] edges) {\n            }\n            @Override\n            public void setEdges(Collection<E> edges) {\n            }\n            @Override\n            public void setEdge(E e, V v) {\n            }\n            @Override\n            public void setEdge(E e, V v, double cost) {\n            }\n            @Override\n            public void setEdge(E e, V v, E cost) {\n            }\n            @Override\n            public void setEdge(E e, V v, double cost, double weight) {\n            }\n            @Override\n            public void setEdge(E e, V v, E cost, double weight) {\n            }\n            @Override\n            public void setEdge(E e, V v, E cost, double weight, double weight2) {\n            }\n            @Override\n            public void setEdge(E e, V v, E cost, double weight, double weight2, double weight3) {\n            }\n            @Override\n            public void setEdge(E e, V v, E cost", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tfor (E e : tour){\n\t\tgraph.addEdge(e);\n\t}\n\t\n\treturn new GraphPath<V,E>(graph);\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tif (tour.size()==0){\n\t\treturn null;\n\t}\n\t\n\tint minNodeNum = tour.iterator().next();\n\t\n\t// add an edge with the minimum number of nodes\n\t\n\tV v1 = graph.getVertex(minNodeNum);\n\tV v2 = graph.getVertex(tour.iterator().next());\n\t\n\tE e = graph.getEdge(v1,v2);\n\t\n\tif (e==null){\n\t\treturn null;\n\t}\n\t\n\t// add the path\n\t\n\tGraphPath<V,E> path = new GraphPath<V,E>(graph);\n\t\n\tpath.addEdge(e);\n\t\n\treturn path;\n\t\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tif(tour==null || tour.size()==0){\n\t\treturn null;\n\t}\n\t\n\t//the edges of the tour are the nodes of the tour\n\t\n\tSet<V> tourNodes = new HashSet<V>();\n\tfor(E e:tour){\n\t\ttourNodes.add(e.getTarget());\n\t}\n\t\n\t//get the tour nodes\n\t\n\tSet<V> tourNodes2 = new HashSet<V>();\n\tfor(V v:graph.getNodes()){\n\t\ttourNodes2.add(v);\n\t}\n\t\n\t//check if the tour nodes are in the graph\n\t\n\tif(!tourNodes.containsAll(tourNodes2)){\n\t\treturn null;\n\t}\n\t\n\t//get the tour nodes in the graph\n\t\n\tSet<V> tourNodes3 = new HashSet<V>();\n\tfor(V v:graph.getNodes()){\n\t\ttourNodes3.add(v);\n\t}\n\t\n\t//check if the tour nodes are in the graph\n\t\n\tif(!tourNodes.containsAll(tourNodes3)){\n\t\treturn null;\n\t}\n\t\n\t//construct a graph path by adding the tour nodes\n\t\n\tList<GraphPath<V,E>> path = new ArrayList<GraphPath<V,E>>();\n\tpath.add(new GraphPath<V,E>(tourNodes,graph));\n\tpath.add(new GraphPath<V,E>(tourNodes2,graph));\n\tpath.add(new GraphPath<V,E>(tourNodes3,graph));\n\t\n\treturn new GraphPath<V,E>(path,graph);\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tgraph.clear();\n\t\n\tfor(E e : tour){\n\t\tgraph.addEdge(e);\n\t}\n\t\n\treturn new GraphPath<V,E>(e,graph);\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tGraphPath<V,E> gp = new GraphPath<V,E>(graph);\n\tfor(E edge: tour){\n\t\tgp.addEdge(edge, gp.getTarget(edge));\n\t}\n\treturn gp;\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\tGraphPath<V,E> result = null;\n\t\n\tfor(E edge : tour){\n\t\tresult = new GraphPath<V,E>(graph.getEdgeWeight(edge),edge,graph.getEdge(edge));\n\t\tresult.setNode(graph.getEdgeSource(edge));\n\t\tresult.setNode(graph.getEdgeTarget(edge));\n\t}\n\treturn result;\n}", "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\tGraphPath<V,E> g = new GraphPath<V,E>(graph);\n\tg.addEdge(tour.iterator().next(), tour.iterator().next());\n\treturn g;\n}"]}
{"_id": "636767641a6d9265ec018190", "generate_results": ["/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}", "/** \n * Moves all vertices from the bucket with label  {@code minLabel}"]}
{"_id": "636767611a6d9265ec018112", "generate_results": ["/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}", "/** \n * {@inheritDoc}"]}
{"_id": "636767601a6d9265ec0180e2", "generate_results": ["/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}", "/** \n * Computes the global separator list of the  {@code graph}"]}
{"_id": "636767461a6d9265ec017d0e", "generate_results": ["/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}", "public Long computeSuffixSum(List<Integer> bounds){\n    return bounds.size()==0?0L:(bounds.size()==1?bounds.get(0):bounds.get(bounds.size()-1));\n}", "/** \n * Computes a suffix sum of the  {@code bounds}", "/** \n * Computes a suffix sum of the  {@code bounds}"]}
{"_id": "636767431a6d9265ec017c88", "generate_results": ["/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> result = new ArrayList<Integer>(keys.size());\n\tfor(K key : keys){\n\t\tresult.add(computeLowerBounds(key));\n\t}\n\treturn result;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tlowerBounds.add(keys.get(i).getLowerBound());\n\t}\n\treturn lowerBounds;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\n    List<Integer> list = new ArrayList<Integer>();\n    \n    for (K k : keys){\n        list.add(k.getKey());\n    }\n    \n    Collections.sort(list);\n    \n    return list;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> result = new ArrayList<Integer>();\n    for(K key: keys)\n        result.add(key.getLowerBound());\n    return result;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    // Initialization.\n    List<Integer> lowerBounds = new ArrayList<Integer>();\n    \n    // Step 1.\n    for (K key: keys){\n        lowerBounds.add(key.getLowerBound());\n    }\n    \n    // Step 2.\n    for (int i=0; i<keys.size(); i++){\n        if (lowerBounds.get(i) > keys.get(i).getLowerBound()) {\n            lowerBounds.set(i, keys.get(i).getLowerBound());\n        }\n    }\n    \n    // Step 3.\n    for (int i=0; i<keys.size(); i++){\n        if (lowerBounds.get(i) < keys.get(i).getLowerBound()) {\n            lowerBounds.set(i, keys.get(i).getLowerBound());\n        }\n    }\n    \n    // Step 4.\n    for (int i=0; i<keys.size(); i++){\n        if (lowerBounds.get(i) <= keys.get(i).getLowerBound()){\n            lowerBounds.set(i, keys.get(i).getLowerBound());\n        }\n    }\n    \n    // Step 5.\n    for (int i=0; i<keys.size(); i++){\n        if (lowerBounds.get(i) >= keys.get(i).getLowerBound()){\n            lowerBounds.set(i, keys.get(i).getLowerBound());\n        }\n    }\n    \n    // Return.\n    return lowerBounds;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> result = new ArrayList<>(keys.size());\n    for(K key : keys){\n        result.add(key.getLowerBound());\n    }\n    return result;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> lowerBounds = new ArrayList<Integer>();\n    for (K key : keys){\n        lowerBounds.add(key.getLowerBound());\n    }\n    return lowerBounds;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> lowerBounds = new ArrayList<Integer>();\n    for(K key : keys){\n        lowerBounds.add(key.getLowerBounds());\n    }\n    return lowerBounds;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> lowerBounds = new ArrayList<Integer>(keys.size());\n\tfor(K key : keys){\n\t\tlowerBounds.add(key.getLowerBound());\n\t}\n\treturn lowerBounds;\n}", "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n\nprivate List<Integer> computeLowerBounds(List<K> keys){\n    List<Integer> lowerBounds = new ArrayList<>();\n    List<Integer> lowerBoundsAll = new ArrayList<>();\n    for(int i=0;i<keys.size();i++){\n        int key = keys.get(i);\n        if(i>0){\n            lowerBoundsAll.add(key);\n        }\n        if(key<lowerBoundsAll.get(lowerBoundsAll.size()-1)){\n            lowerBoundsAll.add(key);\n        }\n    }\n    return lowerBoundsAll;\n}"]}
{"_id": "636767581a6d9265ec017fb4", "generate_results": ["public List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = computeUpperBounds(keys);\n    int min = upperBounds.get(0);\n    int max = upperBounds.get(upperBounds.size() - 1);\n    \n    return new ArrayList<Integer>(Collections.singletonList(min));\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> values = new ArrayList<Integer>(keys.size());\n    for (K key : keys) {\n        values.add(key.getUpperBound());\n    }\n    return values;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> uBounds = new ArrayList<>();\n\tfor(int key : keys){\n\t\tuBounds.add(key);\n\t}\n\treturn uBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<Integer>();\n    for(K key: keys){\n        upperBounds.add(key.getUpperBound());\n    }\n    return upperBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> result = new ArrayList<Integer>();\n    for(int i=0;i<keys.size();i++){\n        result.add(keys.get(i).getKey());\n    }\n    return result;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<Integer>(keys.size());\n    for (K key : keys){\n        upperBounds.add(key.upperBound());\n    }\n    return upperBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\t\n\tfor (int key: keys){\n\t\tupperBounds.add(key);\n\t}\n\t\n\treturn upperBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\t\n\tfor(int i=0;i<keys.size();i++){\n\t\tupperBounds.add(i);\n\t}\n\t\n\treturn upperBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n    List<Integer> upperBounds = new ArrayList<Integer>();\n    for(K key : keys){\n        upperBounds.add(key.computeUpperBound());\n    }\n    return upperBounds;\n}", "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\t//Create a list of all lower bound for keys\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tupperBounds.add(keys.get(i));\n\t}\n\t\n\t//Compute the upper bound for every key\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tInteger upperBound = upperBounds.get(i);\n\t\tint lowerBounds = upperBounds.get(i);\n\t\tupperBounds.set(i, lowerBounds + 1);\n\t}\n\t\n\treturn upperBounds;\n}"]}
{"_id": "6367675f1a6d9265ec0180cf", "generate_results": ["/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\tSet<V> vertices2 = new HashSet<V>(vertices);\n\t\n\t// Add all vertices to the induced subgraph.\n\tfor(V vertex: vertices2){\n\t\tgraph.addEdge(vertex, vertex);\n\t}\n\t\n\t// Check whether the induced subgraph is complete.\n\treturn graph.isComplete();\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n    if(graph.getVertices().size()!=vertices.size()){\n        return false;\n    }\n    \n    //create new clique\n    Clique<V,E> clique = new Clique<V,E>();\n    \n    for(V v : vertices){\n        clique.addVertex(v);\n    }\n    \n    //iterate over edges in the graph\n    for(E edge : graph.getEdges()){\n        V v1 = graph.getEdgeTarget(edge);\n        V v2 = graph.getEdgeSource(edge);\n        \n        //check if this edge is a clique edge\n        if(!isClique(graph,vertices)){\n            continue;\n        }\n        \n        //check if this edge is a clique edge\n        if(edges.contains(edge)){\n            continue;\n        }\n        \n        //create new clique edge\n        clique.addEdge(edge);\n        \n        //check if the clique has been created\n        if(!cliques.contains(clique)){\n            cliques.add(clique);\n        }\n        \n        //check if the clique has been processed\n        if(!clique.isProcessed()){\n            clique.process();\n        }\n        \n        //check if this edge is a subgraph edge\n        if(!edges.contains(edge)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2,v2,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1,v2,v1)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2,v2,v1,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1,v2,v1,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1,v2,v1,v2,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2,v2,v1,v2,v2)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v1,v2,v2,v1,v2,v2,v1)){\n            continue;\n        }\n        \n        //check if this edge is a subgraph edge\n        if(edges.contains(edge,v2,v1,v2,v1,v2,v2,v1)){\n            continue;\n        }\n        \n", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\tboolean done = false;\n\t\n\tfor(V v : vertices){\n\t\tif(graph.containsEdge(v,null)){\n\t\t\tif(!done){\n\t\t\t\tdone = true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\t\n\t//Create a new set of vertices that are not in the original graph.\n\tSet<V> verticesNotInGraph = new HashSet<>();\n\tfor(V v:graph.getVertices()){\n\t\tif(!vertices.contains(v)) {\n\t\t\tverticesNotInGraph.add(v);\n\t\t}\n\t}\n\t\n\t//Initialize a new clique, then add vertices to it.\n\tClique<V,E> clique = new Clique<>();\n\tclique.setVertices(vertices);\n\tclique.addVertices(verticesNotInGraph);\n\treturn clique.isComplete();\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tif(vertices.size()==graph.size()){\n\t\tfor(V v:vertices){\n\t\t\tif(!graph.contains(v)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n    \n    for(V v:vertices){\n        if(isComplete(graph,v)){\n            return true;\n        }\n    }\n    return false;\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tboolean isClique=true;\n\tfor( V vertex : vertices){\n\t\tList<V> clique=graph.get(vertex);\n\t\tif(clique.size()>1){\n\t\t\tisClique=false;\n\t\t}\n\t}\n\treturn isClique;\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tSet<V> cliques = graph.getCliques(vertices);\n\treturn cliques.size()>0;\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tfor (V vertex : vertices) {\n\t\tSet<E> successors = getSuccessors(graph, vertex);\n\t\tif(!successors.isEmpty()){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tfor (V v : vertices){\n\t\tif (graph.getEdgeWeight(v, v) == 0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"]}
{"_id": "636767511a6d9265ec017eb0", "generate_results": ["public int nonZeros(int row){\n\treturn numNonZeros[row];\n}", "public int nonZeros(int row){\n\tint nonZeros = 0;\n\tint count = 0;\n\tint temp = 0;\n\tint i = 0;\n\t\n\tfor(i=0; i<size; i++){\n\t\tif(isZeros(i, row)){\n\t\t\tcount++;\n\t\t}\n\t\telse{\n\t\t\ttemp = i;\n\t\t}\n\t}\n\treturn count;\n}", "public int nonZeros(int row){\n    return  nonZeros(row, row);\n}", "public int nonZeros(int row){\n    if (row!= row)\n        throw new IllegalArgumentException(\"row must be equal to row\");\n    return nonZeros(row, row);\n}", "public int nonZeros(int row){\n\treturn rowNonzero(row);\n}", "public int nonZeros(int row){\n\tint nz = 0;\n\tfor (int i = 0; i < m; i++){\n\t\tnz += ((row & 1) == 0)? 1: 0;\n\t\trow = row >> 1;\n\t}\n\treturn nz;\n}", "public int nonZeros(int row){\n\treturn row * row + nonZeros(row);\n}", "public int nonZeros(int row){\n  if(row==0){\n    return 0;\n  }else{\n    return row*cols-1;\n  }\n}", "public int nonZeros(int row){\n    // get the number of non-zero entries of a row\n    int nz = 0;\n    for (int i=0; i<row; i++){\n        if (data[i]!= 0){\n            nz++;\n        }\n    }\n    return nz;\n}", "public int nonZeros(int row){\n\tif(row == 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn 1;\n\t}\n}"]}
{"_id": "636767461a6d9265ec017d17", "generate_results": ["/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n    int idx = input.indexOf('.');\n    StringBuffer output = new StringBuffer();\n    if (idx == -1){\n        output.append(input);\n    }else{\n        output.append(input.substring(0, idx));\n        int last = input.indexOf('.', idx+1);\n        if (last == -1){\n            output.append(input.substring(idx+1));\n        }else{\n            output.append(input.substring(idx+1, last));\n            output.append(input.substring(last+1));\n        }\n    }\n    return output.toString();\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\n\tString output = \"\";\n\t\n\tfor (int i = 0; i < input.length(); i++){\n\t\t\n\t\tif (input.charAt(i) == '.'){\n\t\t\t\n\t\t\toutput += \".\";\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\toutput += input.charAt(i);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn output;\n\t\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\tint start = input.indexOf(\".\");\n\tif(start == -1){\n\t\treturn input;\n\t}\n\t\n\tint end = input.indexOf(\".\", start+1);\n\tif(end == -1){\n\t\treturn input;\n\t}\n\t\n\tString output = input.substring(start+1, end);\n\t\n\treturn output;\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n    String unescaped = input; // The unescaped output\n    \n    // Handle quoted strings\n    if (input.startsWith(\"'\")){\n        unescaped = unescape(input, \"'\");\n    } else if (input.startsWith(\"\\\"\")){\n        unescaped = unescape(input, \"\\\"\");\n    }\n    \n    return unescaped;\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\tString out = \"\";\n\tfor (int i = 0; i < input.length(); i++){\n\t\tchar ch = input.charAt(i);\n\t\t\n\t\tif (ch == '\\\\'){\n\t\t\tout += \"\\\\\\\\\";\n\t\t\ti++;\n\t\t} \n\t\telse if (ch == '\"'){\n\t\t\tout += \"\\\\\\\"\";\n\t\t\ti++;\n\t\t} \n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '$'){\n\t\t\tout += \"\\\\$\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '?'){\n\t\t\tout += \"\\\\?\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '@'){\n\t\t\tout += \"\\\\@\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '{'){\n\t\t\tout += \"\\\\{\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '}'){\n\t\t\tout += \"\\\\}\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '[' || ch == ']'){\n\t\t\tout += \"\\\\[\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '(' || ch == ')'){\n\t\t\tout += \"\\\\(\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\\\'){\n\t\t\tout += \"\\\\\\\\\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '`'){\n\t\t\tout += \"\\\\`\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\\\\"\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\\\\"\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\\\\"\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\\\\"\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\telse if (ch == '\\''){\n\t\t\tout += \"\\\\'\";\n\t\t\ti++;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tout += ch;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn out;\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n    StringBuffer out = new StringBuffer();\n\n    int i = 0;\n    while (i < input.length()){\n        int c = input.charAt(i);\n        if (c == '\\\\'){\n            out.append(input.charAt(++i));\n        }\n        else if (c == '.'){\n            if (i < input.length()-1){\n                i++;\n                out.append(input.charAt(i));\n            }\n        }\n        else{\n            out.append(c);\n        }\n    }\n\n    return out.toString();\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\treturn input.replaceAll(\"\\\\.\", \"/\");\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n    String unescaped = input;\n    if (input.charAt(0) == '\\\\') {\n        unescaped = unescape(input.substring(1));\n    }\n    return unescaped;\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\t\n\tString[] result = new String[2];\n\t\n\tresult[0] = input.replaceAll(\"(.)\", \"$1\");\n\t\n\tif (result[0].equals(\".\")) {\n\t\tresult[0] = \".\";\n\t}\n\t\n\tresult[1] = input.replaceAll(\"(.)\", \",\");\n\t\n\treturn result[0] + \".\" + result[1];\n}", "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n\nprivate String unescapeId(String input){\n\tStringBuilder out = new StringBuilder(input.length());\n\tfor(int i=0; i<input.length(); i++){\n\t\tchar c = input.charAt(i);\n\t\tif(c == '.' || c == '$'){\n\t\t\tout.append(\"\\\\\");\n\t\t}else{\n\t\t\tout.append(c);\n\t\t}\n\t}\n\treturn out.toString();\n}"]}
{"_id": "6367667f1a6d9265ec017457", "generate_results": ["/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint codePoint = bb.get();\n\tif (codePoint > 0x7F) {\n\t\t// UTF-8\n\t\tsb.append((char) codePoint);\n\t\treturn 1;\n\t} else {\n\t\t// UTF-16\n\t\tsb.append((char) codePoint);\n\t\tsb.append((char) (codePoint >> 8));\n\t\treturn 2;\n\t}\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n    int n = bb.remaining();\n    if(i > n){\n        return i;\n    }\n    int j = 0;\n    int k=0;\n    int o = 0;\n    int l = 0;\n    int m = 0;\n    int nl = 0;\n    int nm = 0;\n    for(int i=0;i<i;i++){\n        o = (o<<7) | (bb.get() & 0x7f);\n        if(o==127){\n            sb.append(\"\\\\u\");\n            l = 4;\n            m = 4;\n        }else if(o==128){\n            sb.append(\"\\\\u00\");\n            l = 2;\n            m = 4;\n        }else if(o==129){\n            sb.append(\"\\\\u000\");\n            l = 4;\n            m = 4;\n        }else if(o==130){\n            sb.append(\"\\\\u00a0\");\n            l = 2;\n            m = 4;\n        }else if(o==131){\n            sb.append(\"\\\\u00b0\");\n            l = 2;\n            m = 4;\n        }else if(o==132){\n            sb.append(\"\\\\u0300\");\n            l = 4;\n            m = 4;\n        }else if(o==133){\n            sb.append(\"\\\\u0301\");\n            l = 4;\n            m = 4;\n        }else if(o==134){\n            sb.append(\"\\\\u0302\");\n            l = 4;\n            m = 4;\n        }else if(o==135){\n            sb.append(\"\\\\u0303\");\n            l = 4;\n            m = 4;\n        }else if(o==136){\n            sb.append(\"\\\\u0304\");\n            l = 4;\n            m = 4;\n        }else if(o==137){\n            sb.append(\"\\\\u0305\");\n            l = 4;\n            m = 4;\n        }else if(o==138){\n            sb.append(\"\\\\u0306\");\n            l = 4;\n            m = 4;\n        }else if(o==139){\n            sb.append(\"\\\\u0307\");\n            l = 4;\n            m = 4;\n        }else if(o==140){\n            sb.append(\"\\\\u0308\");\n            l = 4;\n            m = 4;\n        }else if(o==141){\n            sb.append(\"\\\\u0309\");\n            l = 4;\n            m = 4;\n        }else if(o==142){\n            sb.append(\"\\\\u030a\");\n            l = 4;\n            m = 4;\n        }else if(o==143){\n            sb.append(\"\\\\u030b\");\n            l = 4;\n            m = 4;\n        }else if(o==144){\n            sb.append(\"\\\\u030c\");\n            l = 4;\n            m = 4;\n        }else if(o==145){\n            sb.append(\"\\\\u030d\");\n            l = 4;\n            m = 4;\n        }else if(o==146){\n            sb.append(\"\\\\u030e\");\n            l = 4;\n            m = 4;\n        }else if(o==147){\n            sb.append(\"\\\\u030f\");\n            l = 4;\n            m = 4;\n        }else if(o==148){\n            sb.append(\"\\\\u0310\");\n            l = 4;\n            m = 4;\n        }else if(o==149){\n            sb.append(\"\\\\u0311\");\n            l = 4;\n            m = 4;\n        }else if(o==150){\n            sb.append(\"\\\\u0312\");\n            l = 4;\n            m = 4;\n        }else if(o==151){\n            sb.append(\"\\\\u0313\");\n            l = 4;\n            m = 4;\n        }else if(o==152){\n            sb.append(\"\\\\u0314\");\n", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint j = i;\n\tif (i < bb.limit()) {\n\t\tint k = bb.get(i);\n\t\tif (k >= 128)\n\t\t\tk = k & 0x7f;\n\t\tsb.append((char)k);\n\t\ti++;\n\t}\n\tif (i < bb.limit()) {\n\t\tint k = bb.get(i);\n\t\tif (k >= 128)\n\t\t\tk = k & 0x7f;\n\t\tsb.append((char)k);\n\t\ti++;\n\t}\n\treturn i;\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c=bb.get();\n\tif (c<0)return -1;\n\tint length=c;\n\tc=bb.get();\n\tif (c<0)return -1;\n\tint len=c;\n\tc=bb.get();\n\tif (c<0)return -1;\n\tint n=c;\n\tif (n>length)n=length;\n\tsb.append(new String(new char[n]),\"UTF-8\");\n\tint o=0;\n\tfor(int i=0;i<n;i++){\n\t\tif (i<len)c=bb.get();\n\t\telse if (i==len)c=0;\n\t\telse c=bb.get();\n\t\tif (c<0)break;\n\t\tsb.append((char)c,i);\n\t\to+=c;\n\t}\n\treturn o;\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\t\n\tif(i==-1){\n\t\treturn -1;\n\t}\n\t\n\tif(i<0){\n\t\ti=0;\n\t}\n\t\n\tint len = 0;\n\t\n\tfor(int j=0;j<i;j++){\n\t\tint c = bb.get();\n\t\tlen++;\n\t\tif(c<0x80){\n\t\t\tsb.append((char)c);\n\t\t}\n\t\telse if(c<0x800){\n\t\t\tsb.append((char)(0xc0 | (c>>6)));\n\t\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\t}\n\t\telse if(c<0xD800){\n\t\t\tsb.append((char)(0xe0 | (c>>12)));\n\t\t\tsb.append((char)(0x80 | ((c>>6) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\t}\n\t\telse if(c<0xDFFF){\n\t\t\tsb.append((char)(0xf0 | (c>>18)));\n\t\t\tsb.append((char)(0x80 | ((c>>12) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | ((c>>6) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\t}\n\t\telse{\n\t\t\tsb.append((char)(0xf0 | (c>>24)));\n\t\t\tsb.append((char)(0x80 | ((c>>18) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | ((c>>12) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | ((c>>6) & 0x3f)));\n\t\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\t}\n\t}\n\t\n\treturn len;\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n    int c;\n    int b=bb.get();\n    while(b!=0x00){\n        if(b<0x80){\n            c=b;\n        }else{\n            c=decodeUTF8(bb,i,b);\n        }\n        if(c==-1){\n            return i;\n        }\n        sb.append((char)c);\n        i++;\n        b=bb.get();\n    }\n    return i;\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c = bb.get();\n\t//if (c < 0x80) return c;\n\tif (c < 0xC0) {\n\t\t//if (c < 0xE0) return c;\n\t\tif (c < 0xF0) return c;\n\t\tif (c < 0xF8) return c;\n\t\tif (c < 0xFC) return c;\n\t\tif (c < 0xFE) return c;\n\t\treturn c;\n\t}\n\tif (c < 0xD800) {\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c < 0xDC00) return c;\n\t\t//if (c < 0xDC00) return c;\n\t\tif (c <", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint t = 0;\n\tint c;\n\twhile(i < bb.limit()){\n\t\tc = bb.get();\n\t\tif(c < 0x80){\n\t\t\tsb.append((char)(c));\n\t\t}else if(c < 0x800){\n\t\t\tc = ((c & 0x7f) << 6) | (bb.get() & 0x3f);\n\t\t\tsb.append((char)(c));\n\t\t}else if(c < 0x10000){\n\t\t\tc = ((c & 0x3fff) << 12) | ((bb.get() & 0x3f) << 6) | (bb.get() & 0x3f);\n\t\t\tsb.append((char)(c));\n\t\t}else{\n\t\t\tc = ((c & 0x1fffff) << 16) | ((bb.get() & 0x3f) << 18) | ((bb.get() & 0x3f) << 12) | ((bb.get() & 0x3f) << 6) | (bb.get() & 0x3f);\n\t\t\tsb.append((char)(c));\n\t\t}\n\t\ti++;\n\t}\n\treturn sb.length();\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\t\n\tint c;\n\tint len = (i>=0x80)?(i&0x7f)+1 : 0;\n\tbb.clear();\n\tbb.put((byte)i);\n\tfor(int j=0;j<len;j++){\n\t\tc = bb.get();\n\t\tif(c<0){\n\t\t\tthrow new RuntimeException(\"Invalid UTF-8 encoding: \"+i);\n\t\t}\n\t\tsb.append((char)c);\n\t}\n\treturn len;\n}", "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint i2 = i;\n\tint i3 = i2;\n\tint i4 = i3;\n\tint i5 = i4;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\tint i9 = 0;\n\tint i10 = 0;\n\tint i11 = 0;\n\tint i12 = 0;\n\tint i13 = 0;\n\tint i14 = 0;\n\tint i15 = 0;\n\tint i16 = 0;\n\tint i17 = 0;\n\tint i18 = 0;\n\tint i19 = 0;\n\tint i20 = 0;\n\tint i21 = 0;\n\tint i22 = 0;\n\tint i23 = 0;\n\tint i24 = 0;\n\tint i25 = 0;\n\tint i26 = 0;\n\tint i27 = 0;\n\tint i28 = 0;\n\tint i29 = 0;\n\tint i30 = 0;\n\tint i31 = 0;\n\t\n\tif(i < 0x80){\n\t\tif(i < 0x40){\n\t\t\tsb.append((char) (i & 0x1f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x80){\n\t\t\tsb.append((char) (i & 0x0f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x800){\n\t\t\tsb.append((char) (i & 0x07));\n\t\t\ti = i2;\n\t\t}else if(i < 0x10000){\n\t\t\tsb.append((char) (i & 0x03f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x200000){\n\t\t\tsb.append((char) (i & 0x01f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x4000000){\n\t\t\tsb.append((char) (i & 0x0ff));\n\t\t\ti = i2;\n\t\t}else if(i < 0x8000000){\n\t\t\tsb.append((char) (i & 0x1ff));\n\t\t\ti = i2;\n\t\t}else if(i < 0x100000){\n\t\t\tsb.append((char) (i & 0x0f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x200000){\n\t\t\tsb.append((char) (i & 0x0f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x400000){\n\t\t\tsb.append((char) (i & 0x1f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x800000){\n\t\t\tsb.append((char) (i & 0x1f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x100000){\n\t\t\tsb.append((char) (i & 0x0f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x200000){\n\t\t\tsb.append((char) (i & 0x0f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x400000){\n\t\t\tsb.append((char) (i & 0x1f));\n\t\t\ti = i2;\n\t\t}else if(i < 0x800000){\n\t\t\tsb.append((char) (i & 0x1f));\n\t\t\ti = i2;\n\t\t}else{\n\t\t\ti = i2;\n\t\t}\n\t\t\n\t}else if(i < 0x800){\n\t\tif(i < 0x40){\n\t\t\ti = i2;\n\t\t}else if(i < 0x80){\n\t\t\ti = i3;\n\t\t}else if(i < 0x800){\n\t\t\ti = i4;\n\t\t}else if(i < 0x10000){\n\t\t\ti = i5;\n\t\t}else if(i < 0x200000){\n\t\t\ti = i6;\n\t\t}else if(i < 0x400000){\n\t\t\ti = i7;\n\t\t}else if(i < 0x800000){\n\t\t\ti = i8;\n\t\t}else if(i < 0x1"]}
{"_id": "6367667f1a6d9265ec01745d", "generate_results": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tString path=u.getSchemeSpecificPart();\n\tif(path==null){\n\t\tpath=\"\";\n\t}\n\treturn decode(path,decode);\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\t\n\tList<PathSegmentImpl> result = new ArrayList<PathSegmentImpl>();\n\t\n\tString path = u.getRawPath();\n\t\n\tif (path.startsWith(\"/\")){\n\t\t\n\t\tString path2 = path.substring(1);\n\t\tif (path2.endsWith(\"/\")){\n\t\t\tpath2 = path2.substring(0, path2.length()-1);\n\t\t}\n\t\t\n\t\tpath = path2;\n\t\tif (decode){\n\t\t\tresult = decodePath(path);\n\t\t}\n\t\t\n\t}else{\n\t\t\n\t\tString path2 = path;\n\t\t\n\t\tif (decode){\n\t\t\tresult = decodePath(path);\n\t\t}\n\t\t\n\t\tif (result.size()>0 && result.get(0).getType()==PathSegmentImpl.Type.SLASH){\n\t\t\tpath = path.substring(1);\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn result;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tif(u == null){\n\t\treturn null;\n\t}\n\tString path = u.getPath();\n\tList<PathSegmentImpl> list = new ArrayList<PathSegmentImpl>();\n\tif(path == null){\n\t\treturn list;\n\t}\n\tint index = path.indexOf('/');\n\tif(index == -1){\n\t\tindex = path.length();\n\t}\n\t\n\tint endIndex = index;\n\tif(index > 0 && path.charAt(index-1) == '/'){\n\t\tendIndex--;\n\t}\n\t\n\tString segment;\n\twhile(index < endIndex){\n\t\tsegment = path.substring(index, endIndex);\n\t\tif(segment.length() == 0 || segment.charAt(0) == '/'){\n\t\t\tif(decode){\n\t\t\t\tlist.add(new PathSegmentImpl(segment,true));\n\t\t\t}\n\t\t\tindex = endIndex;\n\t\t}else{\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn list;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> pathSegments=new ArrayList<PathSegmentImpl>();\n\tString path;\n\t\n\tif(u.hasScheme()){\n\t\tpath=u.getSchemeSpecificPart();\n\t\tif(path.length()>0){\n\t\t\tint index=path.indexOf(':');\n\t\t\tif(index>0){\n\t\t\t\tpath=path.substring(0,index);\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tpath=decode?u.getPath():null;\n\t\tif(path.length()>0){\n\t\t\tint index=path.indexOf(':');\n\t\t\tif(index>0){\n\t\t\t\tpath=path.substring(0,index);\n\t\t\t}\n\t\t\tif(index>0){\n\t\t\t\tpath=path.substring(index+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(path!=null){\n\t\tint index=path.indexOf(\"/\");\n\t\tif(index>0){\n\t\t\tString pathSegment=path.substring(index+1);\n\t\t\tint index2=pathSegment.indexOf(\"?\");\n\t\t\tif(index2>0){\n\t\t\t\tpathSegment=pathSegment.substring(0,index2);\n\t\t\t}\n\t\t\tpathSegments.add(new PathSegmentImpl(pathSegment,index2<0?-1:0));\n\t\t\tif(index2>0){\n\t\t\t\tpathSegment=pathSegment.substring(index2+1);\n\t\t\t\tint index3=pathSegment.indexOf(\"#\");\n\t\t\t\tif(index3>0){\n\t\t\t\t\tpathSegment=pathSegment.substring(0,index3);\n\t\t\t\t\tint index4=pathSegment.indexOf(\"?\");\n\t\t\t\t\tif(index4>0){\n\t\t\t\t\t\tpathSegment=pathSegment.substring(index4+1);\n\t\t\t\t\t}\n\t\t\t\t\tpathSegments.add(new PathSegmentImpl(pathSegment,index4<0?-1:0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pathSegments;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tif(u.isAbsolute()){\n\t\treturn decodePath(u.getPath(),decode);\n\t}\n\telse{\n\t\treturn new ArrayList<PathSegmentImpl>();\n\t}\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n    List<PathSegmentImpl> p = new ArrayList<>();\n    if (u.getScheme()==null){\n        return p;\n    }\n    int i = u.getScheme().length();\n    while (i>0 && Character.isWhitespace(u.getScheme().charAt(i-1)))\n        --i;\n    if (i>0 && Character.isLetter(u.getScheme().charAt(i-1))){\n        p.add(new PathSegmentImpl(u.getScheme().substring(i),decode));\n    }else if (u.getScheme().equals(\"//\")){\n        if (u.getUserInfo()!=null){\n            String userInfo = u.getUserInfo();\n            int i1 = userInfo.indexOf(\":\");\n            String user = userInfo.substring(0, i1);\n            String password = userInfo.substring(i1+1);\n            p.add(new PathSegmentImpl(user,decode));\n            p.add(new PathSegmentImpl(password,decode));\n        }\n    }else if (u.getScheme().equals(\"+\")){\n        p.add(new PathSegmentImpl(u.getScheme(),decode));\n    }else if (u.getScheme().equals(\"/\")){\n        p.add(new PathSegmentImpl(u.getScheme(),decode));\n    }else if (u.getScheme().equals(\"#\")){\n        p.add(new PathSegmentImpl(u.getScheme(),decode));\n    }\n    return p;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> result = new ArrayList<>();\n\tString path = u.getPath();\n\tint index = path.indexOf( '#' );\n\tif(index > 0){\n\t\tpath = path.substring( index+1 );\n\t}\n\t\n\tString[] tokens = path.split(\"/\");\n\tfor(int i=0;i<tokens.length;i++){\n\t\tPathSegmentImpl segment = new PathSegmentImpl();\n\t\tsegment.setPath(tokens[i]);\n\t\tsegment.setType(PathSegmentImpl.PATH);\n\t\tresult.add(segment);\n\t}\n\tif(decode){\n\t\tfor(int i=0;i<result.size();i++){\n\t\t\tresult.get(i).setType(PathSegmentImpl.PATH);\n\t\t}\n\t}\n\treturn result;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tif(decode){\n\t\t//decode the path component\n\t\tu = u.toURL();\n\t\tif(u.getProtocol().equals(\"file\")){\n\t\t\tString path = u.getPath();\n\t\t\tint index = path.indexOf('/');\n\t\t\tif(index == -1){\n\t\t\t\treturn new ArrayList<>();\n\t\t\t}\n\t\t\treturn decodePath(path.substring(0,index),decode);\n\t\t}\n\t\telse if(u.getScheme().equals(\"file\")){\n\t\t\tString path = u.getPath();\n\t\t\tint index = path.indexOf(':');\n\t\t\tif(index == -1){\n\t\t\t\treturn new ArrayList<>();\n\t\t\t}\n\t\t\treturn decodePath(path.substring(0,index),decode);\n\t\t}\n\t}\n\treturn new ArrayList<>();\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\treturn decodePath(u.getPath(),decode);\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n    List<PathSegmentImpl> pathSegments=new ArrayList<PathSegmentImpl>();\n    if(u.getScheme().equals(\"http\")){\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",0));\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",1));\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",2));\n    }else if(u.getScheme().equals(\"https\")){\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",0));\n    }else if(u.getScheme().equals(\"file\")){\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",0));\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",1));\n        pathSegments.add(new PathSegmentImpl(\"\",u.getSchemeSpecificPart(),\"\",2));\n    }\n    return pathSegments;\n}"]}
{"_id": "636766861a6d9265ec01755a", "generate_results": ["public final MatchResult match(CharSequence uri){\n  MatchResult result = null;\n\n  // check for a \"*\" wildcard\n  int wildcard = uri.indexOf('*');\n  if(wildcard!= -1){\n    uri = uri.subSequence(0, wildcard);\n  }\n\n  // check for a \"?\" wildcard\n  int question = uri.indexOf('?');\n  if(question!= -1){\n    uri = uri.subSequence(question+1, uri.length());\n  }\n\n  // check for a \":\" wildcard\n  int colon = uri.indexOf(':');\n  if(colon!= -1){\n    uri = uri.subSequence(colon+1, uri.length());\n  }\n\n  // check for a \":\" wildcard\n  int semicolon = uri.indexOf(';');\n  if(semicolon!= -1){\n    uri = uri.subSequence(semicolon+1, uri.length());\n  }\n\n  // if the uri is a simple string\n  if(uri.length() == 0){\n    // if the uri has no wildcard\n    if(wildcard == -1){\n      // if the uri has no question mark\n      if(question == -1){\n        // if the uri has no colon\n        if(colon == -1){\n          // if the uri has no semicolon\n          if(semicolon == -1){\n            // if the uri has no end\n            if(uri.length() == 0){\n              // if the uri has no end\n              result = null;\n            }else{\n              // if the uri has a \"*\" wildcard\n              else if(uri.charAt(0) == '*'){\n                result = MatchResult.MATCH_ALL;\n              }else if(uri.charAt(0) == '?'){\n                result = MatchResult.MATCH_ANY;\n              }else{\n                result = MatchResult.MATCH_NO_MATCH;\n              }\n            }\n          }else{\n            // if the uri has a \":\" wildcard\n            else if(uri.charAt(0) == ':'){\n              result = MatchResult.MATCH_ANY;\n            }else if(uri.charAt(0) == ';'){\n              result = MatchResult.MATCH_NO_MATCH;\n            }else{\n              result = MatchResult.MATCH_NO_MATCH;\n            }\n          }\n        }\n      }\n    }\n  }else{\n    // if the uri has no wildcard\n    if(wildcard == -1){\n      // if the uri has no question mark\n      if(question == -1){\n        // if the uri has no colon\n        if(colon == -1){\n          // if the uri has no semicolon\n          if(semicolon == -1){\n            // if the uri has no end\n            if(uri.length() == 0){\n              // if the uri has no end\n              result = null;\n            }else{\n              // if the uri has a \"*\" wildcard\n              else if(uri.charAt(0) == '*'){\n                result = MatchResult.MATCH_ALL;\n              }else if(uri.charAt(0) == '?'){\n                result = MatchResult.MATCH_ANY;\n              }else{\n                result = MatchResult.MATCH_NO_MATCH;\n              }\n            }\n          }else{\n            // if the uri has a \":\" wildcard\n            else if(uri.charAt(0) == ':'){\n              result = MatchResult.MATCH_ANY;\n            }else if(uri.charAt(0) == ';'){\n              result = MatchResult.MATCH_NO_MATCH;\n            }else{\n              result = MatchResult.MATCH_NO_MATCH;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}", "public final boolean match(CharSequence uri){\n\t\n\treturn match(uri);\n}", "public final MatchResult match(CharSequence uri){\n    if(uri == null || uri.length() == 0) return null;\n    String uriStr = uri.toString();\n    int start = 0;\n    int end = uriStr.length();\n    int pos = uriStr.indexOf(uri.charAt(0));\n    if(pos >= 0){\n        start = pos;\n    }else{\n        pos = uriStr.indexOf(uri.charAt(1));\n        if(pos >= 0){\n            start = pos + 1;\n        }else{\n            pos = uriStr.indexOf(uri.charAt(2));\n            if(pos >= 0){\n                start = pos + 2;\n            }\n        }\n    }\n    if(start < 0){\n        return null;\n    }\n    if(end == 0){\n        end = uriStr.length();\n    }\n    return getMatchResult(uriStr.substring(start, end));\n}", "public final MatchResult match(CharSequence uri){\n    // TODO: optimize by using a fast path\n    \n    String pattern = getTemplate().getPattern();\n    \n    if(uri instanceof CharSequence){\n        CharSequence t = (CharSequence)uri;\n        if(pattern.length()==t.length()){\n            return match(pattern, t);\n        }\n    }\n    \n    if(uri.length()==0){\n        return null;\n    }\n    \n    int i = uri.length()-1;\n    int j = pattern.length()-1;\n    \n    while(i>=0 && j>=0){\n        if(uri.charAt(i)==pattern.charAt(j)){\n            i--;\n            j--;\n            if(j==0){\n                return null;\n            }\n        }\n        else if(uri.charAt(i)=='%' && pattern.charAt(j)=='%'){\n            i++;\n            j++;\n            if(j==0){\n                return null;\n            }\n        }\n        else if(uri.charAt(i)=='%' && pattern.charAt(j)=='%'){\n            i--;\n            j--;\n            if(j==0){\n                return null;\n            }\n        }\n        else if(uri.charAt(i)=='%' && pattern.charAt(j)=='%'){\n            i--;\n            j--;\n            if(j==0){\n                return null;\n            }\n        }\n        else{\n            return null;\n        }\n    }\n    \n    // we have to check that the match is exact\n    if(i==0 && j==0){\n        return null;\n    }\n    \n    return null;\n}", "public final MatchResult match(CharSequence uri){\n\t\n\tif(uri == null){\n\t\treturn null;\n\t}\n\t\n\tint uriLength = uri.length();\n\t\n\tif(uriLength < 0 || uri.length() <= 0){\n\t\treturn null;\n\t}\n\t\n\tString template = this.template;\n\t\n\tif(template == null){\n\t\treturn null;\n\t}\n\t\n\tint templateLength = template.length();\n\t\n\tif(templateLength < 0 || template.length() <= 0){\n\t\treturn null;\n\t}\n\t\n\tString[] templateArgs = new String[templateLength];\n\t\n\tfor(int i = 0; i < templateLength; i++){\n\t\ttemplateArgs[i] = template.charAt(i);\n\t}\n\t\n\tint start = 0;\n\tint end = uriLength;\n\t\n\tif(uriLength > 0){\n\t\tstart = uri.charAt(0) == '?'? 1 : 0;\n\t}\n\t\n\tif(uriLength > 1){\n\t\tend = uri.charAt(uriLength - 1) == '?'? uriLength - 1 : uriLength;\n\t}\n\t\n\tint matchLength = end - start;\n\t\n\tif(matchLength < 0){\n\t\treturn null;\n\t}\n\t\n\tString match = template.substring(start, start + matchLength);\n\t\n\tString[] matchArgs = new String[matchLength];\n\t\n\tfor(int i = 0; i < matchLength; i++){\n\t\tmatchArgs[i] = match.charAt(i);\n\t}\n\t\n\treturn new MatchResult(uri, matchArgs);\n}", "public final MatchResult match(CharSequence uri){\n  return match(uri, null);\n}", "public final MatchResult match(CharSequence uri){\n  // if the uri contains a literal character, we can't do anything\n  if(uri.length()==1 && uri.charAt(0)=='%'){\n    return null;\n  }\n  \n  // we have to match the template against the uri\n  CharSequence template = uri;\n  CharSequence templateArgs = null;\n  int templatePos = uri.length();\n  int templateStart = uri.indexOf(template);\n  int templateEnd = templateStart+template.length();\n  int templateArgStart = templateStart+templatePos;\n  \n  // the template is fully matched\n  if(templatePos==templateEnd){\n    return new MatchResult(uri, template, templatePos, templateStart);\n  }\n  \n  // the template doesn't contain a literal character, so we have to \n  // match the uri.  \n  if(templatePos+1>templateEnd){\n    return null;\n  }\n  \n  // get the arguments\n  templateArgs = uri.subSequence(templatePos+1, templateEnd);\n  templatePos = templateEnd;\n  \n  // is there a template argument?\n  int argStart = templateArgs.length();\n  int argEnd = templateArgs.length();\n  if(argStart==0 || argEnd==0){\n    // if no args, then we can't do anything\n    return null;\n  }\n  \n  // is the template argument a literal character?\n  char templateArg = templateArgs.charAt(argStart);\n  if(templateArg=='%'){\n    // we have to have the literal character here\n    if(argEnd!=argStart+1){\n      return null;\n    }\n    // the template argument is the literal character\n    templateArgs = templateArgs.subSequence(argStart+1, argEnd);\n  }\n  \n  // get the template argument\n  templateArgs = templateArgs.subSequence(argStart+1, argEnd);\n  \n  // if the template argument is a literal character, we can't do anything\n  if(templateArgs.length()==1 && templateArgs.charAt(0)=='%'){\n    return null;\n  }\n  \n  // we have to match the template against the templateArgs\n  return new MatchResult(uri, template, templatePos, templateStart, templateArgs);\n}", "public final MatchResult match(CharSequence uri){\n\tif (uri == null) return null;\n\tString pattern = m_uriPattern;\n\tif (pattern.length() == 0) return null;\n\tint index = uri.indexOf(pattern);\n\tif (index < 0) return null;\n\treturn new MatchResult(uri.subSequence(0,index), uri.length());\n}", "public final MatchResult match(CharSequence uri){\n\treturn match(uri, null);\n}", "public final MatchResult match(CharSequence uri){\n    if(uri==null)\n        return null;\n    try{\n        return match(uri.toString());\n    }catch(Exception e){\n        return null;\n    }\n}"]}
{"_id": "636766861a6d9265ec017553", "generate_results": ["public final boolean isTemplateVariablePresent(String name){\n    return getVariable(name)!= null;\n}", "public final boolean isTemplateVariablePresent(String name){\n    \n    if (tmplVarsToBeRemoved.contains(name)){\n        return false;\n    }\n    \n    return true;\n}", "public final boolean isTemplateVariablePresent(String name){\n\tif(name.equalsIgnoreCase(\"template\")){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public final boolean isTemplateVariablePresent(String name){\n\tboolean isPresent = false;\n\tif(templateVariables.containsKey(name)){\n\t\tisPresent = true;\n\t}\n\treturn isPresent;\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn isTemplateVariablePresent(name, \"\", \"\");\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\t\n\treturn getTemplateVariables().contains(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\treturn (this.templates.containsKey(name) && this.templates.get(name).isMemberOfTemplate());\n}", "public final boolean isTemplateVariablePresent(String name){\n  return (this.templateVariables.containsKey(name));\n}", "public final boolean isTemplateVariablePresent(String name){\n    return templateVariables.containsKey(name);\n}"]}
{"_id": "636766801a6d9265ec017487", "generate_results": ["public static String encodeTemplateNames(String s){\n\tif(s == null) return \"\";\n\tint len = s.length();\n\tStringBuilder sb = new StringBuilder();\n\tchar ch;\n\tfor(int i = 0; i < len; i++){\n\t\tch = s.charAt(i);\n\t\tif(ch == '{'){\n\t\t\tsb.append('%');\n\t\t\tsb.append(Character.toUpperCase(ch));\n\t\t\tsb.append('%');\n\t\t}else if(ch == '}'){\n\t\t\tsb.append('%');\n\t\t\tsb.append('%');\n\t\t}else{\n\t\t\tsb.append(ch);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"%\");\n\t\t}\n\t\telse{ //if not a {\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Decodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded template parameters names\n * @return the string with decoded template parameters names.\n */\n\npublic static String decodeTemplateNames(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '%'){\n\t\t\tsb.append('%');\n\t\t}\n\t\telse{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Encodes a string with variable parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with encoded variable parameters names\n * @return the string with encoded variable parameters names.\n */\n\npublic static String encodeVariableNames(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"%\");\n\t\t}\n\t\telse{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Decodes a string with variable parameters names present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded variable parameters names\n * @return the string with decoded variable parameters names.\n */\n\npublic static String decodeVariableNames(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '%'){\n\t\t\tsb.append('%');\n\t\t}\n\t\telse{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Encodes a string with variable arguments present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with encoded variable arguments present\n * @return the string with encoded variable arguments present.\n */\n\npublic static String encodeVariables(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"%\");\n\t\t}\n\t\telse{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Decodes a string with variable arguments present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded variable arguments present\n * @return the string with decoded variable arguments present.\n */\n\npublic static String decodeVariables(String s){\n\tStringBuilder sb = new StringBuilder();\n\t//build a string builder\n\tfor(int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '%'){\n\t\t\tsb.append('%');\n\t\t}\n\t\telse{\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}\n\n/**\n * Enc", "public static String encodeTemplateNames(String s){\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(\"{\");\n\tboolean first = true;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t}else {\n\t\t\tsb.append(\"&\");\n\t\t}\n\t\tchar c = s.charAt(i);\n\t\tif (c!= '{' && c!= '}') {\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\tsb.append(\"}\");\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n\tif (s == null)\n\t\treturn null;\n\tStringBuffer sb = new StringBuffer();\n\tfor (int i = 0; i < s.length(); i++){\n\t\tchar c = s.charAt(i);\n\t\tif (c == '{')\n\t\t\tsb.append('%');\n\t\telse if (c == '}')\n\t\t\tsb.append('%');\n\t\telse\n\t\t\tsb.append(c);\n\n\t}\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n    StringBuilder sb = new StringBuilder();\n    Pattern p = Pattern.compile(\"\\\\{(.*?)\\\\}\");\n    Matcher m = p.matcher(s);\n    while(m.find()){\n        String[] t = m.group(1).split(\"\\\\{\");\n        for(int i=0;i<t.length;i++){\n            sb.append(t[i]);\n            if(i+1 < t.length){\n                sb.append('{');\n            }\n        }\n    }\n    return sb.toString();\n}\n\n/** \n * Decodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded template parameters names\n * @return the string with decoded template parameters names.\n */\n\npublic static String decodeTemplateNames(String s){\n    StringBuilder sb = new StringBuilder();\n    Pattern p = Pattern.compile(\"\\\\{(.*?)\\\\}\");\n    Matcher m = p.matcher(s);\n    while(m.find()){\n        String[] t = m.group(1).split(\"\\\\{\");\n        for(int i=0;i<t.length;i++){\n            sb.append(t[i]);\n            if(i+1 < t.length){\n                sb.append('{');\n            }\n", "public static String encodeTemplateNames(String s){\n\tStringBuilder builder = new StringBuilder(s);\n\tbuilder.append('{');\n\tStringBuilder name = new StringBuilder();\n\tfor(String name_ : s.split(\"\\\\{|\\\\}\")){\n\t\tif(name.length() > 0){\n\t\t\tbuilder.append(name);\n\t\t\tname.delete(0, name.length());\n\t\t}\n\t\tbuilder.append(name);\n\t\tname = new StringBuilder();\n\t}\n\tbuilder.append('}');\n\treturn builder.toString();\n}", "public static String encodeTemplateNames(String s){\n\tif (s == null) return null;\n\t\n\tStringBuffer sb = new StringBuffer();\n\tfor (int i=0; i<s.length(); i++){\n\t\tchar cur = s.charAt(i);\n\t\tif (cur == '{'){\n\t\t\tsb.append(cur);\n\t\t} else {\n\t\t\tsb.append('%');\n\t\t\tsb.append(String.format(\"%02X\", cur));\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n}\n\n", "public static String encodeTemplateNames(String s){\n\tStringBuffer result = new StringBuffer();\n\tint i = 0;\n\tchar c = s.charAt(i);\n\twhile(c!= '{' && c!= '}'){\n\t\tif(c == '{'){\n\t\t\tresult.append('{');\n\t\t\ti++;\n\t\t}\n\t\telse if(c == '}'){\n\t\t\tresult.append('}');\n\t\t\ti++;\n\t\t}\n\t\tc = s.charAt(i);\n\t}\n\tresult.append(s.substring(i));\n\treturn result.toString();\n}", "public static String encodeTemplateNames(String s){\n    if(s == null){\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    char c;\n    boolean first = true;\n    int len = s.length();\n    for(int i=0;i<len;++i){\n        c = s.charAt(i);\n        if(c == '{'){\n            if(first){\n                first = false;\n                sb.append(c);\n            }else{\n                sb.append(\"{\");\n            }\n            c = '}';\n        }else{\n            if(first){\n                first = false;\n            }else{\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}\n\n/** \n * Decodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded template parameters names\n * @return the string with decoded template parameters names.\n */\n\npublic static String decodeTemplateNames(String s){\n    if(s == null){\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    char c;\n    boolean first = true;\n    int len = s.length();\n    for(int i=0;i<len;++i){\n        c = s.charAt(i);\n        if(c == '{'){\n            if(first){\n                first = false;\n                sb.append('{');\n            }else{\n                sb.append(c);\n            }\n            c = '}';\n        }else{\n            if(first){\n                first = false;\n            }else{\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}\n\n/** \n * Encodes a string with template parameters values present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters values\n * @return the string with encoded template parameters values.\n */\n\npublic static String encodeTemplateValues(String s){\n    if(s == null){\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    char c;\n    boolean first = true;\n    int len = s.length();\n    for(int i=0;i<len;++i){\n        c = s.charAt(i);\n        if(c == '{'){\n            if(first){\n                first = false;\n                sb.append(c);\n            }else{\n                sb.append(\"{\");\n            }\n            c = '}';\n        }else{\n            if(first){\n                first = false;\n            }else{\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}\n\n/** \n * Decodes a string with template parameters values present, specifically the characters '{' and '}' will be percent-decoded.\n * @param s the string with encoded template parameters values\n * @return the string with decoded template parameters values.\n */\n\npublic static String decodeTemplateValues(String s){\n    if(s == null){\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    char c;\n    boolean first = true;\n    int len = s.length();\n    for(int i=0;i<len;++i){\n        c = s.charAt(i);\n        if(c == '{'){\n            if(first){\n                first = false;\n                sb.append('{');\n            }else{\n                sb.append(c);\n            }\n            c = '}';\n        }else{\n            if(first){\n                first = false;\n            }else{\n                sb.append(c);\n            }\n        }\n    }\n    return sb.toString();\n}\n\n/** \n * Encodes a string with template parameters names present, specifically the characters '", "public static String encodeTemplateNames(String s){\n\tif(s == null){\n\t\treturn null;\n\t}\n\tStringBuilder sb = new StringBuilder();\n\t\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{') {\n\t\t\tsb.append('%');\n\t\t\tsb.append(Character.forDigit(0, 2));\n\t\t\tsb.append(Character.forDigit(0, 4));\n\t\t\tsb.append(Character.forDigit(0, 6));\n\t\t\tsb.append('}');\n\t\t} else if(c == '}') {\n\t\t\tsb.append('%');\n\t\t\tsb.append(Character.forDigit(0, 2));\n\t\t\tsb.append(Character.forDigit(0, 4));\n\t\t\tsb.append(Character.forDigit(0, 6));\n\t\t\tsb.append('%');\n\t\t} else {\n\t\t\tsb.append(c);\n\t\t}\n\t}"]}
{"_id": "6367667f1a6d9265ec01745c", "generate_results": ["public static void addToClassPath(Vector<URL> cpV,String dir){\n\tif (cpV==null || cpV.isEmpty())\n\t\treturn;\n\t\n\tVector<URL> cp = new Vector<URL>();\n\tfor (int i = 0; i < cpV.size(); i++) {\n\t\tcp.add(cpV.elementAt(i).addTrailingSlash(dir));\n\t}\n\t\n\t// add the jars\n\t\n\tfor (int i = 0; i < cp.size(); i++) {\n\t\tVector<String> jarV = (Vector<String>) cp.elementAt(i);\n\t\t\n\t\t// build the jar name\n\t\t\n\t\tString jarName = jarV.elements().nextElement().toString();\n\t\t\n\t\t// add the jar to the classpath\n\t\t\n\t\tcp.add(cpV.elementAt(i).addTrailingSlash(jarName));\n\t}\n\t\n\t// add the jar to the classpath\n\t\n\taddToClassPath(cp,dir);\n\t\n\t\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\ttry{\n\t\tClass.forName(\"java.lang.ClasspathScanner\");\n\t\tVector<URL> cpV2 = new Vector<URL>();\n\t\tcpV2.addAll(cpV);\n\t\tClass.forName(\"java.lang.ClasspathScanner\");\n\t\tcpV = cpV2;\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n\tfor(int i=0;i<cpV.size();i++){\n\t\tcpV.set(i, cpV.get(i).addAll(cpV.get(i).addAll(cpV.get(i))));\n\t}\n\tSystem.setProperty(\"java.class.path\", cpV.toString());\n\t\n\tadd(cpV);\n\tSystem.setProperty(\"java.class.path\", \"\");\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    //System.out.println(\"Adding jar files in \"+dir);\n    Vector<URL> jarV = new Vector<URL>(cpV);\n    FileUtils.addJarFiles(dir,jarV);\n}", "public static void addToClassPath(Vector<URL> cpV,String dir){\n\t//System.out.println(\"addToClassPath \"+cpV+\" \"+dir);\n\tif(dir.endsWith(\".jar\")){\n\t\tVector<URL> cpV2=new Vector<URL>();\n\t\ttry{\n\t\t\tcpV2.addAll(cpV);\n\t\t} catch(Exception e){\n\t\t\tSystem.out.println(\"addToClassPath \"+cpV+\" \"+e);\n\t\t}\n\t\tcpV.removeAllElements();\n\t\tSystem.out.println(\"addToClassPath \"+cpV+\" \"+dir);\n\t\tcpV.addElement(new URL(\"jar:\"+dir+\";classpath=\"+cpV2.toString()));\n\t}\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\tVector<URL> jarV = new Vector<URL>();\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t\n\tFile dirFolder = new File(dir);\n\t\n\tif(!dirFolder.exists()){\n\t\t\n\t\t\n\t\tSystem.out.println(\"Error: \" + dirFolder.getAbsolutePath() + \" does not exist\");\n\t\t\n\t\treturn;\n\t\t\n\t}\n\t\n\tFile[] files = dirFolder.listFiles();\n\t\n\tfor(File file : files){\n\t\t\n\t\tif(file.isDirectory()){\n\t\t\t\n\t\t\taddToClassPath(cpV, file.getAbsolutePath());\n\t\t\t\n\t\t}else{\n\t\t\t\n\t\t\tString fileName = file.getName();\n\t\t\t\n\t\t\tif(fileName.endsWith(\".jar\")){\n\t\t\t\t\n\t\t\t\tfileName = fileName.substring(0, fileName.length()-4);\n\t\t\t\t\n\t\t\t\tURL jarURL = new URL(file.getAbsolutePath());\n\t\t\t\tjarV.addElement(jarURL);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");\n\t\n\t//System.out.println(\"Adding jar files to classpath\");", "public static void addToClassPath(Vector<URL> cpV,String dir){\n\t//System.out.println(\"addToClassPath\");\n\t\n\tString path=dir;\n\tif (dir.endsWith(File.separator))\n\t\tpath=path.substring(0,path.length()-1);\n\t\n\tVector<URL> cp=new Vector<URL>();\n\ttry{\n\t\tFile f=new File(path);\n\t\tif (f.isDirectory()){\n\t\t\tFile[] files=f.listFiles();\n\t\t\tfor (int i=0;i<files.length;i++){\n\t\t\t\tString fileName=files[i].getName();\n\t\t\t\tif (fileName.endsWith(\".jar\")){\n\t\t\t\t\tcp.add(files[i].toURI().toURL());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n\t\n\tcp.addAll(cpV);\n\t\n\tfor (URL url:cp.toArray()){\n\t\tSystem.out.println(\"Adding jar file \"+url);\n\t\tSystem.out.println(path+\" -> \"+url);\n\t\tSystem.out.println(\"Adding to classpath:\");\n\t\tClassLoader.getSystemClassLoader().addURL(url);\n\t}\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tif(cpV.size() == 0) return;\n\tString name = null;\n\tfor(int i = 0;i < cpV.size();i++) {\n\t\tname = cpV.elementAt(i);\n\t\tif(name.endsWith(\".jar\")){\n\t\t\tString path = name.substring(0,name.length()-5);\n\t\t\tif(!cpV.contains(path)) cpV.addElement(path);\n\t\t}\n\t}\n}", "public static void addToClassPath(Vector<URL> cpV,String dir){\n\tVector<File> files=new Vector<File>();\n\tFile dirFile=new File(dir);\n\tif(!dirFile.exists()){\n\t\tSystem.err.println(\"The directory \"+dir+\" does not exist.\");\n\t\treturn;\n\t}\n\tFile[] filesArray = dirFile.listFiles();\n\tfor(int i=0;i<filesArray.length;i++){\n\t\tFile file = filesArray[i];\n\t\tif(file.getName().endsWith(\".jar\")){\n\t\t\tfiles.add(file);\n\t\t}\n\t}\n\tfor(int i=0;i<files.size();i++){\n\t\tString jarFile = files.elementAt(i).getAbsolutePath();\n\t\tcpV.add(jarFile);\n\t}\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\t\n\t// get the classpath\n\tString path = System.getProperty(\"java.class.path\");\n\tString[] classpath = path.split(File.pathSeparator);\n\tVector<String> v = new Vector<String>();\n\t\n\t// add the jars to the classpath\n\tfor(int i = 0; i < cpV.size(); i++){\n\t\t// add the path to the vector\n\t\tv.add(cpV.get(i).toString());\n\t}\n\t\n\t// set the classpath to use\n\tSystem.setProperty(\"java.class.path\", v.toString());\n\t\n\t// set the dir to use\n\tSystem.setProperty(\"java.class.path.entry\", dir);\n\t\n\t// start the classloader\n\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n\ttry {\n\t\tClass<URL> clazz = (Class<URL>) cl.loadClass(\"java.net.URL\");\n\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\tURL url = (URL) clazz.newInstance();\n\t\t\tv.set(i, url.toString());\n\t\t}\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n}", "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\tFile f = new File(dir);\n\tif (f.isDirectory()){\n\t\tVector<URL> cp = new Vector<URL>();\n\t\tfor (File jar : f.listFiles()){\n\t\t\tcp.add(jar.toURI().toURL());\n\t\t}\n\t\tcpV.addAll(cp);\n\t}\n\telse{\n\t\tcpV.add(new File(dir).toURI().toURL());\n\t}\n}"]}
{"_id": "636766821a6d9265ec0174bf", "generate_results": ["public static String decapitalize(String name){\n", "public static String decapitalize(String name){\n    if (name == null) return null;\n    if (name.length() == 0) return name;\n\n    if (name.charAt(0) == '_') return name;\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < name.length(); i++){\n        char ch = name.charAt(i);\n        if (Character.isUpperCase(ch)) {\n            sb.append(Character.toLowerCase(ch));\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}", "public static String capitalize(String name){\n\tint index = name.lastIndexOf(\" \");\n\tif (index == -1){\n\t\treturn name;\n\t}\n\telse{\n\t\treturn name.substring(index+1).toUpperCase(Locale.ENGLISH) + name.substring(0, index);\n\t}\n}", "public static String decapitalize(String name){\n\n    return Introspector.decapitalize(name);\n}", "public static String decapitalize(String name){\n    return name.substring(0, 1).toLowerCase() + name.substring(1);\n}", "public static String decapitalize(String name){\n    StringBuilder sb = new StringBuilder(name.length());\n    for (int i=0;i<name.length();i++){\n        char ch = name.charAt(i);\n        if (ch=='e') ch = 'e';\n        if (ch=='i') ch = 'I';\n        if (ch=='o') ch = 'O';\n        if (ch=='u') ch = 'U';\n        if (ch=='r') ch = 'R';\n        sb.append(ch);\n    }\n    return sb.toString();\n}", "public static String decapitalize(String name){\n    if (name == null) return null;\n\n    String upper = name.toUpperCase(Locale.US);\n\n    if (upper.equals(name)) return upper;\n\n    return upper.substring(0, 1).toLowerCase(Locale.US) + upper.substring(1);\n}", "public static String decapitalize(String name){\n\treturn Introspector.decapitalize(name);\n}", "public static String decapitalize(String name){\n    String newName = Introspector.decapitalize(name);\n    if (newName.equals(name))\n        return newName;\n    else\n        return newName.substring(0, 1).toLowerCase() + newName.substring(1);\n}", "public static String capitalize(String name){\n    if (name == null){\n        return null;\n    }\n    String result = name.substring(0, 1).toLowerCase();\n    result = Character.toLowerCase(result.charAt(0)) + result.substring(1);\n    return result;\n}"]}
{"_id": "6367667d1a6d9265ec017401", "generate_results": ["public static String unescapeJava(String str) {\n\tif (str == null) {", "public static String unescapeJava(String str) {\n  return unescapeJava(str, null, -1);\n}", "public static String unescapeJava(String str) throws Exception {\n    if (str == null) {\n        return null;\n    }\n    if (str.startsWith(\"'\") && str.endsWith(\"'\")) {\n        return str.substring(1, str.length()-1);\n    }\n    StringBuffer buf = new StringBuffer();\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        if (ch == '\\\\') {\n            i++;\n            if (i < len) {\n                ch = str.charAt(i);\n                if (ch == 'u') {\n                    int code = 0;\n                    try {\n                        code = Integer.parseInt(String.valueOf(str.substring(i+4, i+8)));\n                    } catch (NumberFormatException e) {\n                        // ignore\n                    }\n                    if (code >= 128) {\n                        buf.append((char) code);\n                    } else {\n                        buf.append(\"\\\\u\");\n                        buf.append(String.format(\"%04X\", code));\n                    }\n                } else if (ch == 'n') {\n                    buf.append('\\n');\n                } else if (ch == 'r') {\n                    buf.append('\\r');\n                } else if (ch == 't') {\n                    buf.append('\\t');\n                } else if (ch == 'b') {\n                    buf.append('\\b');\n                } else if (ch == 'f') {\n                    buf.append('\\f');\n                } else {\n                    buf.append(ch);\n                }\n                i++;\n            }\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tint length = str.length();\n\tif (length < 2) {\n\t\treturn str;\n\t}\n\n\tchar first = str.charAt(0);\n\tif (first == '\\'') {\n\t\t//if (first == '\\'') {\n\t\t\t//return str;\n\t\t//}\n\t\t//else {\n\t\t\t//return new String(str.substring(1));\n\t\t//}\n\t}\n\t\n\t//if (first == '\\'') {\n\t\t//return new String(str.substring(1, length -1));\n\t//}\n\t\n\tint end = length - 1;\n\tfor (int i = 1; i < end; i++) {\n\t\tchar ch = str.charAt(i);\n\t\tif (ch == '\\'') {\n\t\t\t//if (ch == '\\'') {\n\t\t\t\t//return new String(str.substring(i + 1, end));\n\t\t\t//}\n\t\t\t//else {\n\t\t\t\t//return new String(str.substring(i + 1, end - 1));\n\t\t\t//}\n\t\t}\n\t}\n\treturn str;\n}", "public static String unescapeJava(String str) {\n    if (str == null) {\n        return null;\n    }\n    StringBuffer buf = new StringBuffer();\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c == '\\\\') {\n            i++;\n            if (i == len) {\n                buf.append('\\\\');\n            } else {\n                buf.append(str.charAt(i));\n            }\n        } else {\n            buf.append(c);\n        }\n    }\n    return buf.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n  if (str == null || str.trim().length() == 0) {\n    return null;\n  }\n  StringBuffer sb = new StringBuffer();\n  for (int i = 0; i < str.length(); i++) {\n    char ch = str.charAt(i);\n    if (ch == '\\\\') {\n      if (i + 1 < str.length()) {\n        char ch2 = str.charAt(i + 1);\n        switch (ch2) {\n          case 'n':\n            ch = '\\n';\n            break;\n          case 'r':\n            ch = '\\r';\n            break;\n          case 't':\n            ch = '\\t';\n            break;\n          default:\n            // Do nothing\n        }\n      }\n    }\n    sb.append(ch);\n  }\n  return sb.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\t\n\tint sz = str.length();\n\tif (sz == 0) {\n\t\treturn null;\n\t}\n\t\n\tStringBuffer buf = new StringBuffer();\n\tfor (int i = 0; i < sz; i++) {\n\t\tchar ch = str.charAt(i);\n\t\tswitch (ch) {\n\t\tcase '\\b':\n\t\t\tbuf.append(\"\\\\b\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tbuf.append(\"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tbuf.append(\"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\f':\n\t\t\tbuf.append(\"\\\\f\");\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tbuf.append(\"\\\\r\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tbuf.append(\"\\\\\\\\\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tbuf.append(\"\\\\\\\"\");\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tbuf.append(\"\\\\\\'\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ch <'') {\n\t\t\t\tbuf.append('\\\\');\n\t\t\t}\n\t\t\tbuf.append(ch);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tint len = str.length();\n\tint i = 0;\n\tint start = 0;\n\tint end = 0;\n\tint pos = 0;\n\tint count = 0;\n\tchar c;\n\tStringBuffer out = new StringBuffer(len);\n\twhile (i < len) {\n\t\tc = str.charAt(i);\n\t\tif (c == '\\'') {\n\t\t\tif (i < len - 1 && str.charAt(i + 1) == '\\'' && str.charAt(i + 2) == '\\'') {\n\t\t\t\ti += 2;\n\t\t\t\tend = i;\n\t\t\t\tcount = 2;\n\t\t\t\tstart = end - 2;\n\t\t\t} else {\n\t\t\t\tstart = i + 1;\n\t\t\t\tend = len;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t} else if (c == '\"') {\n\t\t\tif (i < len - 1 && str.charAt(i + 1) == '\"') {\n\t\t\t\ti += 2;\n\t\t\t\tend = i;\n\t\t\t\tcount = 2;\n\t\t\t\tstart = end - 2;\n\t\t\t} else {\n\t\t\t\tstart = i + 1;\n\t\t\t\tend = len;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tout.append(c);\n\t\t\tcount++;\n\t\t}\n\t\ti++;\n\t}\n\tif (count > 0) {\n\t\tif (count % 2 == 0) {\n\t\t\tthrow new Exception(\"Illegal escape sequence: \\\"\" + str + \"\\\"\");\n\t\t} else {\n\t\t\treturn out.toString();\n\t\t}\n\t}\n\treturn out.toString();\n\n}", "public static String unescapeJava(String str) throws Exception {\n    if (str == null) {\n        return null;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        switch (ch) {\n            case '\"':\n                sb.append(\"\\\\\\\"\");\n                break;\n            case '\\\\':\n                sb.append(\"\\\\\\\\\");\n                break;\n            case '\\b':\n                sb.append(\"\\\\b\");\n                break;\n            case '\\f':\n                sb.append(\"\\\\f\");\n                break;\n            case '\\n':\n                sb.append(\"\\\\n\");\n                break;\n            case '\\r':\n                sb.append(\"\\\\r\");\n                break;\n            case '\\t':\n                sb.append(\"\\\\t\");\n                break;\n            default:\n                if ((ch >='') && (ch < 127)) {\n                    sb.append((char) ch);\n                } else {\n                    sb.append(\"\\\\u\").append(Character.forDigit((ch >> 12) & 0xF, 16)).append((char) (ch >> 8 & 0xF)).append((char) (ch & 0xF));\n                }\n        }\n    }\n    return sb.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tif (str.indexOf('\\\\')<0) {\n\t\treturn str;\n\t}\n\tint start = 0;\n\tint end = str.indexOf('\\\\');\n\twhile (end<0) {\n\t\tend = str.indexOf('\\\\', start);\n\t\tif (end<start) {\n\t\t\tbreak;\n\t\t}\n\t\tstart = end+1;\n\t}\n\tint len = end-start;\n\tif (len==0) {\n\t\treturn str;\n\t}\n\tchar[] arr = str.toCharArray();\n\tchar[] result = new char[len];\n\tint i = start;\n\tint j = 0;\n\twhile (i<len) {\n\t\tif (j==len) {\n\t\t\tbreak;\n\t\t}\n\t\tchar c = arr[i];\n\t\tif (c=='\"') {\n\t\t\tc = '\\'';\n\t\t}\n\t\tif (c=='\\\\') {\n\t\t\tif (j==0) {\n\t\t\t\tresult[j++] = c;\n\t\t\t}\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tresult[j++] = c;\n\t\ti++;\n\t}\n\treturn new String(result);\n}"]}
{"_id": "636766851a6d9265ec01751b", "generate_results": ["public static int decodeHexNibble(final char c){\n    if(c>=0x30 && c<=0x39){\n        return (char)((c-0x30) & 0x0f);\n    }else if(c>=0x41 && c<=0x5a){\n        return (char)((c-0x41) & 0x07);\n    }else if(c>=0x61 && c<=0x7a){\n        return (char)((c-0x61) & 0x03);\n    }else{\n        return Character.MAX_VALUE;\n    }\n}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "public static char decodeHexNibble(final char c){\n    return decodeHexNibble(c);\n}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}", "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}"]}
{"_id": "636766821a6d9265ec0174b6", "generate_results": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType pType= (ParameterizedType) genericType;\n\t\treturn resolveArguments(pType.getActualTypeArguments(),targetType);\n\t} else if(genericType instanceof Class){\n\t\treturn resolveArguments(genericType.getTypeArguments(),targetType);\n\t} else if(genericType instanceof ParameterizedType){\n\t\tParameterizedType pType= (ParameterizedType) genericType;\n\t\treturn resolveArguments(pType.getActualTypeArguments(),targetType);\n\t} else if(genericType instanceof TypeVariable){\n\t\tTypeVariable<?> tVar= (TypeVariable<?>) genericType;\n\t\treturn resolveArguments(tVar.getBounds(),targetType);\n\t} else if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArray= (GenericArrayType) genericType;\n\t\treturn resolveArguments(genericArray.getGenericComponentType().getTypeArguments(),targetType);\n\t} else if(genericType instanceof WildcardType){\n\t\tWildcardType wildcard= (WildcardType) genericType;\n\t\treturn resolveArguments(wildcard.getUpperBounds(),targetType);\n\t} else if(genericType instanceof Type){\n\t\treturn resolveArguments(genericType.getTypeArguments(),targetType);\n\t} else {\n\t\treturn null;\n\t}\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif (genericType instanceof ParameterizedType) {\n\t\treturn resolveArguments((ParameterizedType) genericType,(Class<?>) targetType);\n\t}else if (genericType instanceof TypeVariable) {\n\t\tTypeVariable<?> v = (TypeVariable<?>) genericType;\n\t\tType t = v.getBounds()[0];\n\t\tif (t instanceof ParameterizedType) {\n\t\t\treturn resolveArguments((ParameterizedType) t,(Class<?>) targetType);\n\t\t}else if (t instanceof TypeVariable) {\n\t\t\treturn resolveArguments(v.getBounds()[0],(Class<?>) targetType);\n\t\t}\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\t\n\tif(genericType instanceof ParameterizedType){\n\t\treturn resolveArguments((ParameterizedType)genericType,targetType);\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\treturn resolveArguments((TypeVariable)genericType,targetType);\n\t}\n\telse\n\t\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\t\n\t\n\tif (genericType instanceof ParameterizedType){\n\t\t\n\t\tParameterizedType parametrizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parametrizedType.getActualTypeArguments();\n\t\t\n\t\tClass<?>[] classes = new Class[typeArguments.length];\n\t\tfor (int i = 0; i < typeArguments.length; i++){\n\t\t\tclasses[i] = getActualTypeArgument(targetType,typeArguments[i]);\n\t\t}\n\t\treturn classes;\n\t}\n\t\n\treturn null;\n\t\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif (genericType instanceof ParameterizedType){\n\t\tParameterizedType pType = (ParameterizedType) genericType;\n\t\tType[] actualTypeArguments = pType.getActualTypeArguments();\n\t\tClass<?>[] argTypes = new Class[actualTypeArguments.length];\n\t\tfor (int i = 0; i < argTypes.length; i++){\n\t\t\targTypes[i] = resolveType(actualTypeArguments[i]);\n\t\t}\n\t\treturn argTypes;\n\t}\n\telse if (genericType instanceof Class<?>){\n\t\tClass<?> cType = resolveType(targetType);\n\t\treturn new Class<?>[]{cType};\n\t}\n\telse if (genericType instanceof ParameterizedType){\n\t\tParameterizedType pType = (ParameterizedType) genericType;\n\t\tType[] actualTypeArguments = pType.getActualTypeArguments();\n\t\tClass<?>[] argTypes = new Class[actualTypeArguments.length];\n\t\tfor (int i = 0; i < argTypes.length; i++){\n\t\t\targTypes[i] = resolveType(actualTypeArguments[i]);\n\t\t}\n\t\treturn argTypes;\n\t}\n\telse if (genericType instanceof GenericArrayType){\n\t\treturn resolveGenericArrayType(genericType,(GenericArrayType) genericType,targetType);\n\t}\n\telse if (genericType instanceof WildcardType){\n\t\treturn resolveWildcardType(genericType,(WildcardType) genericType,targetType);\n\t}\n\telse if (genericType instanceof TypeVariable){\n\t\treturn resolveTypeVariable(genericType,(TypeVariable) genericType,targetType);\n\t}\n\telse if (genericType instanceof ParameterizedGenericType){\n\t\treturn resolveGenericType(genericType,(ParameterizedGenericType) genericType,targetType);\n\t}\n\telse if (genericType instanceof GenericArrayType){\n\t\treturn resolveGenericArrayType(genericType,(GenericArrayType) genericType,targetType);\n\t}\n\telse if (genericType instanceof TypeVariable){\n\t\treturn resolveTypeVariable(genericType,(TypeVariable) genericType,targetType);\n\t}\n\telse if (genericType instanceof WildcardType){\n\t\treturn resolveWildcardType(genericType,(WildcardType) genericType,targetType);\n\t}\n\telse if (genericType instanceof ParameterizedType){\n\t\treturn resolveParameterizedType(genericType,(ParameterizedType) genericType,targetType);\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif (genericType instanceof ParameterizedType) {\n\t\treturn resolveArguments((ParameterizedType) genericType, ((ParameterizedType) genericType).getActualTypeArguments());\n\t}\n\t\n\tif (genericType instanceof TypeVariable) {\n\t\treturn resolveArguments((TypeVariable) genericType, ((TypeVariable) genericType).getBounds());\n\t}\n\t\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n    if(genericType instanceof ParameterizedType){\n        ParameterizedType pType = (ParameterizedType) genericType;\n        Type[] args = pType.getActualTypeArguments();\n        Class<?>[] argClasses = new Class<?>[args.length];\n        for(int i=0;i<args.length;i++){\n            Class<?> argClass = resolveClass(args[i]);\n            argClasses[i] = argClass;\n        }\n        return argClasses;\n    }\n    return null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof Class<?>) return (Class<?>[]) ((Class<?>)genericType).getTypeArguments();\n\tif(genericType instanceof ParameterizedType) return resolveArguments((ParameterizedType)genericType,targetType);\n\tif(genericType instanceof ParameterizedType) {\n\t\tType[] typeArgs = ((ParameterizedType)genericType).getActualTypeArguments();\n\t\treturn resolveArguments(typeArgs,targetType);\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\t\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\t\n\t\tif(typeArguments!= null){\n\t\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\t\tfor(int i = 0; i < typeArguments.length; i++){\n\t\t\t\tclasses[i] = resolve(typeArguments[i]);\n\t\t\t}\n\t\t\treturn classes;\n\t\t}\n\t}\n\t\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n        if(genericType instanceof ParameterizedType){\n                ParameterizedType t= (ParameterizedType) genericType;\n                for(Type t2: t.getActualTypeArguments()){\n                        Class<?> cl= resolveArguments(t2,targetType);\n                        if(cl!=null){\n                                return new Class[] {cl};\n                        }\n                }\n        }\n        return null;\n}"]}
{"_id": "6367667d1a6d9265ec01741d", "generate_results": ["public static Class<?> resolveBound(TypeVariable<?> typeVariable){\n    return BoundConstants.UNKNOWN;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tType bound = typeVariable.getBounds().iterator().next();\n\tif(bound.getKind() == TypeKind.UNKNOWN){\n\t\treturn unknown;\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    return typeVariable.getUpperBounds().isEmpty()? Unknown.class : typeVariable.getUpperBounds().get(0).getLowerBound();\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    Type bound = resolveBound(typeVariable.getGenericDeclaration());\n    if(bound == null) return Unknown.class;\n    return bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\t// We can't just check if the type is a bound, because we don't know the upper bounds\n\tif(typeVariable.getBounds().isEmpty()){\n\t\treturn Unknown.class;\n\t}\n\t\n\tfor(Type bound : typeVariable.getBounds()){\n\t\tif(bound.getSort() == TypeKind.OBJECT_TYPE){\n\t\t\tType resolved = resolveBound(bound);\n\t\t\tif(resolved!= null){\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn Unknown.class;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    return resolveBound(typeVariable, TYPE_VARIABLE_TYPE_ARRAY);\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    Type[] bounds = typeVariable.getBounds();\n    if(bounds.length!= 1)\n        return unknownType();\n    \n    return resolveBound(bounds[0]);\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n    return resolveBound(typeVariable, Resolve.instance());\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tType bound = typeVariable.getBounds().iterator().next();\n\treturn!(bound instanceof ParameterizedType)? bound : resolveBound((ParameterizedType) bound);\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\treturn resolveBound(typeVariable, false);\n}"]}
{"_id": "636766821a6d9265ec0174d2", "generate_results": ["public static HttpServletResponse wrap(HttpServletRequest request){\n\treturn new HttpServletResponse(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    if(request == null) return null;\n    \n    AtmosphereRequest requestAtmosphere = new AtmosphereRequest(request);\n    requestAtmosphere.setRequestURI(request.getRequestURI());\n    requestAtmosphere.setServletPath(request.getServletPath());\n    requestAtmosphere.setMethod(request.getMethod());\n    requestAtmosphere.setProtocol(request.getProtocol());\n    requestAtmosphere.setRequestHeaders(request.getHeaderNames());\n    requestAtmosphere.setRequestBody(request.getContent());\n    \n    return requestAtmosphere;\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\treturn (AtmosphereRequest)request;\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\tAtmosphereRequest result = new AtmosphereRequest();\n\tresult.setRequest(request);\n\treturn result;\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new AtmosphereRequestImpl(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\t\n\tAtmosphereRequest r = new AtmosphereRequest(request);\n\tr.setContentType(request.getContentType());\n\tr.setClient(request.getHeader(\"X-Forwarded-For\").substring(0,request.getHeader(\"X-Forwarded-For\").indexOf(\"; \")));\n\tr.setUser(request.getUserPrincipal().getName());\n\tr.setRemoteAddress(request.getRemoteAddr());\n\tr.setScheme(request.getScheme());\n\tr.setServerName(request.getServerName());\n\tr.setLocalAddress(request.getLocalAddr());\n\tr.setLocalPort(request.getLocalPort());\n\tr.setRequestURI(request.getRequestURI());\n\tr.setQueryString(request.getQueryString());\n\treturn r;\n}"]}
{"_id": "6367667f1a6d9265ec017458", "generate_results": ["public boolean removeAtmosphereHandler(String mapping){\n\treturn _removeAtmosphereHandler(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn removeAtmosphereHandler(mapping, null);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn this.removeAtmosphereHandler(mapping, null);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn (mapping!= null)? m_handlers.remove(mapping) : null;\n}", "public AtmosphereHandler removeAtmosphereHandler(String mapping){\n\treturn removeAtmosphereHandler(mapping, null);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\tif (mapping == null) return false;\n\treturn m_atmosphereHandlers.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\tremoveAtmosphereHandler(mapping,null);\n\treturn true;\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\ttry{\n\t\tmapping = mapping.toLowerCase();\n\t\tif(mapping.equals(AtmosphereHandler.class.getName())){\n\t\t\treturn removeAtmosphereHandler(ATMOptions.getInstance().getAtmosphereHandler());\n\t\t}\n\t\treturn false;\n\t}\n\tcatch(Exception e){\n\t\treturn false;\n\t}\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\treturn removeAtmosphereHandler(mapping, null);\n}", "public boolean removeAtmosphereHandler(String mapping){\n\tif(isAtmosphereHandler(mapping)){\n\t\tremoveAtmosphereHandler(mapping,getAtmosphereHandler(mapping));\n\t\treturn true;\n\t}\n\treturn false;\n}"]}
{"_id": "636766821a6d9265ec0174b3", "generate_results": ["/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}", "/** \n * Invoke the  {@link BroadcastFilter}"]}
{"_id": "636766811a6d9265ec017499", "generate_results": ["/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "public static boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n    return checkDuplicate(interceptorList,c);\n}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}", "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor}"]}
{"_id": "6367667c1a6d9265ec0173f7", "generate_results": ["public boolean hasBytes(){\n\treturn (byte[].class.isAssignableFrom(bodyType));\n}", "public boolean hasBytes(){\n  return (body instanceof byte[]);\n}", "public boolean hasBytes(){\n\treturn (body!= null && body instanceof byte[]);\n}", "public boolean hasBytes(){\n\treturn (body!= null);\n}", "public boolean hasBytes(){\n\treturn true;\n}", "public boolean hasBytes(){\n\treturn true;\n}", "public boolean hasBytes(){\n\treturn (body instanceof byte[]);\n}", "public boolean hasBytes(){\n\treturn true;\n}", "public boolean hasBytes(){\n\treturn body!=null && body.length()>0;\n}", "public boolean hasBytes(){\n\treturn body.length()>0;\n}"]}
{"_id": "6367667d1a6d9265ec0173ff", "generate_results": ["public static Meteor lookup(HttpServletRequest r){\n\treturn (Meteor)request.getAttribute(\"meteor\");\n}", "public static Meteor lookup(HttpServletRequest r){\n\tString u = r.getUserPrincipal().getName();\n\tif(u == null) return null;\n\treturn lookup(u);\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn get(r.getContextPath() + \"/\" + r.getServletPath(), new Meteor());\n}", "public static Meteor lookup(HttpServletRequest r){\n\tif(r.getAttribute(Meteor.class.getName())!=null)\n\t\treturn (Meteor)r.getAttribute(Meteor.class.getName());\n\treturn null;\n}", "public static Meteor lookup(HttpServletRequest r){\n  String key = r.getParameter(KEY);\n  if (key == null)\n    return null;\n\n  return _lookup(key);\n}", "public static Meteor lookup(HttpServletRequest r){\n\t\n\tr.setAttribute(\"_meteor\",new Meteor());\n\treturn (Meteor)r.getAttribute(\"_meteor\");\n\t\n}", "public static Meteor lookup(HttpServletRequest r){\n\treturn Meteor.lookup(r);\n}", "public static Meteor lookup(HttpServletRequest r){\n\t\n\t\n\t\n\t if (r.getParameter(\"name\")!=null) {\n\t\t return Meteor.lookup(r.getParameter(\"name\"));\n\t }\n\t \n\t return null;\n\t\n}", "public static UUID lookup(HttpServletRequest r){\n    return UUID.instantiate(r);\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\tString api = r.getParameter(\"api\");\n\tString version = r.getParameter(\"version\");\n\tString uuid = r.getParameter(\"uuid\");\n\n\tif(api == null || api.equals(\"\")){\n\t\tapi = \"1.0.0\";\n\t}\n\tif(version == null || version.equals(\"\")){\n\t\tversion = \"1.0.0\";\n\t}\n\tif(uuid == null || uuid.equals(\"\")){\n\t\tuuid = \"0\";\n\t}\n\n\tif(Meteor.isEnabled()){\n\t\treturn Meteor.get(api, version, uuid);\n\t}\n\treturn null;\n}"]}
{"_id": "6367667c1a6d9265ec0173fb", "generate_results": ["public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\tif(!(e instanceof AtmosphereResourceEventListener))\n\t\tthrow new IllegalArgumentException(\"AtmosphereResourceEventListener must be an instance of AtmosphereResourceEventListener\");\n\treturn super.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n  return _resource.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){ return super.addEventListener(e) ;}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n    return (AtmosphereResource) super.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn this.addEventListener(e,null);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\tif(e == null){\n\t\tthrow new IllegalArgumentException(\"The event listener can't be null\");\n\t}\n\t\n\tif(!this.eventListeners.contains(e)){\n\t\tthis.eventListeners.add(e);\n\t\treturn this;\n\t}\n\treturn null;\n}", "public void addEventListener(AtmosphereResourceEventListener e){\n    this.addEventListener(e);\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\taddEventListener(e.getType(), e.getEventClass(), e.getEventName(), e.getEventMessage(), e.getEventParameters());\n\treturn this;\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n    synchronized(this) {\n        if(!this.eventListeners.contains(e)){\n            this.eventListeners.add(e);\n        }\n    }\n    return this;\n}", "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\tAtmosphereResourceEventListener add = new AtmosphereResourceEventListener(e);\n\treturn add.getRef();\n}"]}
{"_id": "636766811a6d9265ec017496", "generate_results": ["public InputStream next() throws IOException {\n\tif (this.files.isEmpty()) {\n\t\treturn null;\n\t}\n\telse {\n\t\treturn this.files.remove(0);\n\t}\n}", "public InputStream next() throws IOException {\n\t\n\tFile file = fileQueue.peek();\n\t\n\tif (file == null) {\n\t\treturn null;\n\t}\n\t\n\treturn new FileInputStream(file);\n}", "public InputStream next() throws IOException {\n\tif (files.size() == 0) {\n\t\treturn null;\n\t}\n\tFile file = files.poll();\n\treturn new FileInputStream(file);\n}", "public InputStream next() throws IOException {\n\treturn super.next();\n}", "public InputStream next() throws IOException {\n    if (index >= files.length) {\n        return null;\n    }\n    return files[index++];\n}", "public InputStream next() throws IOException {\n\n\t// check if file is empty\n\tif (file.length() == 0) {\n\t\treturn null;\n\t}\n\n\t// get the next file\n\tFile next = new File(file.toString());\n\n\t// return the next file\n\treturn next.exists()? new FileInputStream(next) : null;\n}", "public InputStream next() throws IOException {\n    if (files.size() == 0) {\n        return null;\n    }\n    \n    File file = files.remove(files.size() - 1);\n    \n    // if the file does not exist, then create it.\n    if (!file.exists()) {\n        file.createNewFile();\n    }        \n    \n    try {\n        return new FileInputStream(file);\n    } catch (FileNotFoundException e) {\n        return null;\n    }\n}", "public InputStream next() throws IOException {\n\ttry {\n\t\treturn getFile();\n\t} catch (FileNotFoundException e) {\n\t\treturn null;\n\t}\n}", "public InputStream next() throws IOException {\n\t\n\tif (count == 0) return null;\n\t\n\treturn ios.next();\n}", "public InputStream next() throws IOException {\n    int n;\n    try {\n        n = getNext();\n    } catch (InterruptedException e) {\n        throw new IOException(e.getMessage());\n    }\n    if (n == -1) {\n        throw new IOException(\"No more files available.\");\n    }\n    return new FileInputStream(new File(fileName, n));\n}"]}
{"_id": "636766821a6d9265ec0174c9", "generate_results": ["public static void main(String[] args) {\n\tSystem.out.println(classPath());\n\tSystem.out.println(classPath(\"./\"));\n\tSystem.out.println(classPath(\"./\"));\n\tSystem.out.println(classPath(\"/\"));\n\tSystem.out.println(classPath(\"/\"));\n\tSystem.out.println(classPath(\"/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"D:/\"));\n\tSystem.out.println(classPath(\"/\", \"", "/** \n * Returns the class path of the current JVM instance as an array of  {@link File}", "/** \n * Returns the class path of the current JVM instance as an array of  {@link File}", "public static void main(String[] args) throws Exception {\n    try {\n        checkIncludePath(new File(\"bin/java\"));\n        checkIncludePath(new File(\"bin/java.jar\"));\n        checkIncludePath(new File(\"bin/java.jar\"));\n        checkIncludePath(new File(\"bin/java.jar\"));\n        System.out.println(\"Classpath: \" + classPath());\n        System.out.println(\"Classpath: \" + Arrays.toString(classPath()));\n\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        File currentDirectory = new File(\".\");\n        File currentPath = currentDirectory;\n        for (File f : classPath()) {\n            if (f.getAbsolutePath().startsWith(currentDirectory.getAbsolutePath())) {\n                currentPath = f;\n            }\n        }\n\n        System.out.println(\"Current class loader: \" + currentClassLoader.getClass().getName());\n        System.out.println(\"Current directory: \" + currentDirectory.getAbsolutePath());\n\n        ClassLoader classLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(\"System class loader: \" + classLoader.getClass().getName());\n\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(\"System class loader: \" + systemClassLoader.getClass().getName());\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "/** \n * Returns the class path of the current JVM instance as an array of  {@link File}", "/** \n * Returns the class path of the current JVM instance as an array of  {@link File}", "/** \n * Returns the class path of the current JVM instance as an array of  {@link File}", "public static File[] classPath(){\n\treturn classPath();\n}", "public static File[] classPathFile(){\n\treturn classPath();\n}", "public static File classPath(){\n    return new File(classPath());\n}"]}
{"_id": "636766801a6d9265ec017482", "generate_results": ["public void readFrom(final InputStream in) throws IOException {\n\tfinal byte[] buffer = new byte[this.bufferSize];\n\tint readCount = in.read(buffer);\n\tif (readCount!= -1) {\n\t\tthis.buffer = buffer;\n\t\tthis.bufferSize = readCount;\n\t}\n}", "public void readFrom(final InputStream in) throws IOException {\n\tint count = in.read(buffer);\n\tif (count == -1) {\n\t\tthrow new IOException(\"No data in buffer\");\n\t}\n\tbuffer[0] = (byte) (count & 0xFF);\n\tbuffer[1] = (byte) (count >> 8 & 0xFF);\n\tbuffer[2] = (byte) (count >> 16 & 0xFF);\n\tbuffer[3] = (byte) (count >> 24 & 0xFF);\n\tbuffer[4] = (byte) (count >> 32 & 0xFF);\n\tbuffer[5] = (byte) (count >> 40 & 0xFF);\n\tbuffer[6] = (byte) (count >> 48 & 0xFF);\n\tbuffer[7] = (byte) (count >> 56 & 0xFF);\n\tbuffer[8] = (byte) (0xFF & count);\n\tbuffer[9] = (byte) (0xFF & count >> 8);\n\tbuffer[10] = (byte) (0xFF & count >> 16);\n\tbuffer[11] = (byte) (0xFF & count >> 24);\n\tbuffer[12] = (byte) (0xFF & count >> 32);\n\tbuffer[13] = (byte) (0xFF & count >> 40);\n\tbuffer[14] = (byte) (0xFF & count >> 48);\n\tbuffer[15] = (byte) (0xFF & count >> 56);\n\tbuffer[16] = (byte) 0xFF;\n\tbuffer[17] = (byte) 0xFF;\n\tbuffer[18] = (byte) 0xFF;\n\tbuffer[19] = (byte) 0xFF;\n\tbuffer[20] = (byte) 0xFF;\n\tbuffer[21] = (byte) 0xFF;\n\tbuffer[22] = (byte) 0xFF;\n\tbuffer[23] = (byte) 0xFF;\n\tbuffer[24] = (byte) 0xFF;\n\tbuffer[25] = (byte) 0xFF;\n\tbuffer[26] = (byte) 0xFF;\n\tbuffer[27] = (byte) 0xFF;\n\tbuffer[28] = (byte) 0xFF;\n\tbuffer[29] = (byte) 0xFF;\n\tbuffer[30] = (byte) 0xFF;\n\tbuffer[31] = (byte) 0xFF;\n\tbuffer[32] = (byte) 0xFF;\n\tbuffer[33] = (byte) 0xFF;\n\tbuffer[34] = (byte) 0xFF;\n\tbuffer[35] = (byte) 0xFF;\n\tbuffer[36] = (byte) 0xFF;\n\tbuffer[37] = (byte) 0xFF;\n\tbuffer[38] = (byte) 0xFF;\n\tbuffer[39] = (byte) 0xFF;\n\tbuffer[40] = (byte) 0xFF;\n\tbuffer[41] = (byte) 0xFF;\n\tbuffer[42] = (byte) 0xFF;\n\tbuffer[43] = (byte) 0xFF;\n\tbuffer[44] = (byte) 0xFF;\n\tbuffer[45] = (byte) 0xFF;\n\tbuffer[46] = (byte) 0xFF;\n\tbuffer[47] = (byte) 0xFF;\n\tbuffer[48] = (byte) 0xFF;\n\tbuffer[49] = (byte) 0xFF;\n\tbuffer[50] = (byte) 0xFF;\n\tbuffer[51] = (byte) 0xFF;\n\tbuffer[52] = (byte) 0xFF;\n\tbuffer[53] = (byte) 0xFF;\n\tbuffer[54] = (byte) 0xFF;\n\tbuffer[55] = (byte) 0xFF;\n\tbuffer[56] = (byte) 0xFF;\n\tbuffer[57] = (byte) 0xFF;\n\tbuffer[58] = (byte) 0xFF;\n\tbuffer[59] = (byte) 0xFF;\n\tbuffer[60] = (byte) 0xFF;\n", "public void readFrom(final InputStream in) throws IOException {\n  this.buffer = new byte[this.length];\n  this.read(in, this.buffer);\n}", "public void readFrom(final InputStream in) throws IOException {\n    int n = 0;\n    int offset = 0;\n    byte[] data = new byte[in.available()];\n    while (n < data.length) {\n        n += in.read(data, offset, data.length - offset);\n        offset = 0;\n    }\n    \n    if (data.length > 0) {\n        this.bytes = data;\n        this.offset = 0;\n    }\n}", "public void readFrom(final InputStream in) throws IOException {\n\t\n\tint b;\n\t\n\tint currentPos = 0;\n\tint read = 0;\n\t\n\t//read until the end of the byte array\n\twhile ((read < bytesIn) && (currentPos < bytesIn)) {\n\t\t\n\t\tb = in.read();\n\t\tif (b == -1) {\n\t\t\tthrow new IOException(\"Could not read from input stream\");\n\t\t}\n\t\t\n\t\tbuffer[currentPos++] = (byte) b;\n\t\t\n\t\tread++;\n\t}\n\t\n\t//if the read pointer is at the end of the byte array, reset it to the start of the buffer\n\tif (currentPos == bytesIn) {\n\t\tcurrentPos = 0;\n\t}\n\t\n\t//reset the read pointer\n\tread = 0;\n}", "public void readFrom(final InputStream in) throws IOException {\n    final int len = in.read();\n    if (len >= 0) {\n        final byte[] buffer = new byte[len];\n        in.read(buffer);\n        buffer = null;\n        length = buffer.length;\n        if (buffer!= null) {\n            length = 0;\n            buffer = null;\n        }\n    }\n}", "public void readFrom(final InputStream in) throws IOException {\n\t\n\tfinal byte[] buf = new byte[32];\n\tint read = in.read(buf);\n\t\n\t// Read the first 3 bytes of the byte array\n\t\n\tif (read < 3) {\n\t\tthrow new IOException(\"Unexpected end of stream\");\n\t}\n\t\n\tthis.buffer = buf;\n\t\n\t// Read the last 3 bytes of the byte array\n\t\n\tif (read > 3) {\n\t\tread = read - 3;\n\t}\n\t\n\tif (read > 0) {\n\t\tthis.buffer = new byte[read];\n\t\tread = in.read(this.buffer);\n\t}\n\t\n\tthis.readPointer = 0;\n\t\n\t// Now, read the rest of the byte array\n\t\n\tif (read > 0) {\n\t\tread = in.read(this.buffer, read);\n\t}\n\t\n}", "public void readFrom(final InputStream in) throws IOException {\n\t\n\tfinal int len = getLength();\n\t\n\tint inPos = 0;\n\tint outPos = 0;\n\t\n\tfinal byte[] buf = new byte[len];\n\t\n\twhile(inPos < len) {\n\t\tfinal int n = in.read(buf, inPos, len - inPos);\n\t\t\n\t\tif(n == -1)\n\t\t\tbreak;\n\t\t\n\t\tinPos += n;\n\t}\n\t\n\t//System.out.println(\"len=\"+len+\" readPos=\"+inPos+\" outPos=\"+outPos);\n\t\n\tfinal byte[] out = new byte[outPos];\n\t\n\tfor(int i = 0; i < outPos; i++) {\n\t\tout[i] = buf[i];\n\t}\n\t\n\tthis.read(out, 0, outPos);\n\t\n\t//System.out.println(\"out=\"+new String(out));\n\t\n}", "public void readFrom(final InputStream in) throws IOException {\n\tif (in == null) {\n\t\tthrow new NullPointerException(\"in is null\");\n\t}\n\tfinal byte[] buffer = new byte[4096];\n\tfinal int length = in.read(buffer);\n\tif (length < 0) {\n\t\tthrow new IOException(\"Read failed\");\n\t}\n\tthis.buffer = buffer;\n\tthis.bufferLength = length;\n\tthis.readPointer = 0;\n\tthis.writePointer = 0;\n\tthis.readPosition = 0;\n\tthis.writePosition = length;\n}", "public void readFrom(final InputStream in) throws IOException {\n    final byte[] buffer = new byte[BUFFER_LENGTH];\n    int read = in.read(buffer);\n    \n    int offset = 0;\n    while (read > 0) {\n        buffer[offset] = (byte) read;\n        offset++;\n        read = in.read(buffer);\n    }\n    \n    this.buffer = buffer;\n    this.readPointer = offset;\n    \n    this.writePointer = 0;\n}"]}
{"_id": "636766801a6d9265ec017477", "generate_results": ["/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n    \n    for (int i=files.length-1; i>=0; i--){\n        \n        try{\n            addFile(files[i]);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\n\t// create list of files\n\tfinal List<File> filesList = new ArrayList<>();\n\n\t// add file in reverse order\n\tfor(final InputStream file : files){\n\t\tfilesList.add(file);\n\t}\n\n\t// add files in reverse order\n\tCollections.reverse(filesList);\n\n\t// add files in reverse order\n\tfor(final InputStream file : files){\n\t\tfilesList.add(file);\n\t}\n\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\ttry {\n\t\tfor (int i = files.length - 1; i >= 0; i--) {\n\t\t\tfinal InputStream stream = files[i];\n\t\t\tfinal boolean added = stream.markSupported();\n\t\t\tif (added) {\n\t\t\t\tstream.reset();\n\t\t\t} else {\n\t\t\t\t// if the stream is not marked, then we try to reset it\n\t\t\t\tstream.reset();\n\t\t\t}\n\t\t}\n\t} catch (final IOException e) {\n\t\t// this means the stream was not marked\n\t\t// so we just add it without resetting it\n\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\tfinal InputStream stream = files[i];\n\t\t\tif (stream.markSupported()) {\n\t\t\t\tstream.reset();\n\t\t\t} else {\n\t\t\t\t// if the stream was not marked, then we try to reset it\n\t\t\t\tstream.reset();\n\t\t\t}\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\n    for(int i = 0; i < files.length; i++){\n        files[i] = new FileInputStream(files[i]);\n    }\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\tfinal File[] reverse = new File[files.length];\n\tfor(int i=files.length-1;i>=0;i--){\n\t\treverse[i] = files[i].getCanonicalFile();\n\t}\n\t\n\tfor(int i=0;i<files.length;i++){\n\t\ttry{\n\t\t\tfiles[i].getCanonicalFile();\n\t\t}catch(IOException e){\n\t\t}\n\t}\n\t\n\tadd(reverse);\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\tfor (int i = files.length - 1; i >= 0; i--){\n\t\tSystem.out.println(\"Adding \" + files[i]);\n\t\ttry {\n\t\t\tFileUtil.addFile(files[i]);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\"Error adding file: \" + files[i].getAbsolutePath(), e);\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\n    // Create a new stream for the files\n    final InputStream in = new FileInputStream(files[files.length - 1]);\n\n    // Create a new stream to read the files\n    final InputStream in2 = new FileInputStream(files[0]);\n\n    // Write the file contents to a new stream\n    final FileOutputStream out = new FileOutputStream(files[files.length - 1]);\n\n    // Read the first file\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) > 0) {\n        out.write(buffer, 0, bytesRead);\n    }\n\n    // Close the streams\n    out.close();\n    in2.close();\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\t\n\tint count = 0;\n\t\n\tfor(int i=files.length-1; i>=0; i--){\n\t\t\n\t\tif(files[i]!= null){\n\t\t\t\n\t\t\tif(files[i].read()!= -1){\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(count == files.length){\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=0; j<count; j++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tfiles[j].close();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfiles = null;\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(files == null){\n\t\t\n\t\tfiles = new InputStream[files.length];\n\t}\n\t\n\tfor(int i=0; i<files.length; i++){\n\t\t\n\t\tfiles[i] = null;\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\t\n\tfinal int n = files.length;\n\t\n\tfor(int i=0; i<n; i++){\n\t\t\n\t\tfinal InputStream is = files[i];\n\t\t\n\t\ttry {\n\t\t\tis.close();\n\t\t} catch (final IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final InputStream[] files){\n\tfor (int i = files.length - 1; i >= 0; i--){\n\t\ttry {\n\t\t\taddFile(files[i]);\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"]}
{"_id": "636766831a6d9265ec0174eb", "generate_results": ["/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\tfor (int i = files.length - 1; i >= 0; i--){\n\t\tif (files[i].isDirectory()){\n\t\t\taddReverse(files[i].listFiles());\n\t\t}else{\n\t\t\tadd(files[i]);\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n    for(int i=files.length-1; i>=0; i--){\n        files[i].delete();\n    }\n    files[0].delete();\n    files.length = 1;\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\tif (files == null){\n\t\treturn;\n\t}\n\t\n\tfor (int i=files.length-1; i>=0; i--){\n\t\tFile f = files[i];\n\t\tif (f.isDirectory()){\n\t\t\ttry {\n\t\t\t\tFile[] sorted = f.listFiles();\n\t\t\t\tArrays.sort(sorted);\n\t\t\t\tfor (int j=sorted.length-1; j>=0; j--){\n\t\t\t\t\tFile f2 = sorted[j];\n\t\t\t\t\tif (f.equals(f2)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2.isDirectory()){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFile[] sorted2 = f2.listFiles();\n\t\t\t\t\t\t\tArrays.sort(sorted2);\n\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f2.getName());\n\t\t\t\t\t\t\tfor (int k=0; k<sorted2.length; k++){\n\t\t\t\t\t\t\t\tFile f3 = sorted2[k];\n\t\t\t\t\t\t\t\tif (f2.equals(f3)){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (f3.isDirectory()){\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tFile[] sorted3 = f3.listFiles();\n\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted3);\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f3.getName());\n\t\t\t\t\t\t\t\t\t\tfor (int k2=0; k2<sorted3.length; k2++){\n\t\t\t\t\t\t\t\t\t\t\tFile f4 = sorted3[k2];\n\t\t\t\t\t\t\t\t\t\t\tif (f3.equals(f4)){\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (f4.isDirectory()){\n\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\tFile[] sorted4 = f4.listFiles();\n\t\t\t\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted4);\n\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f4.getName());\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k3=0; k3<sorted4.length; k3++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile f5 = sorted4[k3];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f4.equals(f5)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f5.isDirectory()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile[] sorted5 = f5.listFiles();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted5);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f5.getName());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k4=0; k4<sorted5.length; k4++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile f6 = sorted5[k4];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f5.equals(f6)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f6.isDirectory()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile[] sorted6 = f6.listFiles();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted6);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f6.getName());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k5=0; k5<sorted6.length; k5++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile f7 = sorted6[k5];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f6.equals(f7)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f7.isDirectory()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile[] sorted7 = f7.listFiles();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted7);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f7.getName());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k6=0; k6<sorted7.length; k6++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile f8 = sorted7[k6];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f7.equals(f8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (f8.isDirectory()){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFile[] sorted8 = f8.listFiles();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrays.sort(sorted8);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"adding \" + f8.getName());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k7=0; k7<sorted8", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\tfor(int i = files.length - 1; i >= 0; i--){\n\t\tFile f = files[i];\n\t\tif(f.isDirectory()){\n\t\t\tif(!f.isDirectory()) addReverse(f.listFiles());\n\t\t}else{\n\t\t\tInputStream input = new FileInputStream(f);\n\t\t\ttry{\n\t\t\t\tbyte[] buf = new byte[1024];\n\t\t\t\tint numRead = input.read(buf);\n\t\t\t\twhile(numRead!= -1){\n\t\t\t\t\tout.write(buf, 0, numRead);\n\t\t\t\t\tnumRead = input.read(buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally{\n\t\t\t\tinput.close();\n\t\t\t}\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\t\n\t// Add the files in reverse order\n\tfor (int i = 0; i < files.length; i++){\n\t\t\n\t\tFile fileToAdd = files[i];\n\t\t\n\t\t// First, add a file if it doesn't exist\n\t\tif (!fileToAdd.exists()){\n\t\t\t\n\t\t\t// Create a temporary directory\n\t\t\tFile temporaryDir = new File(System.getProperty(\"java.io.tmpdir\"));\n\t\t\t\n\t\t\t// If this fails, the directory already exists, return (and don't add the file)\n\t\t\ttry {\n\t\t\t\tfileToAdd = temporaryDir.mkdir();\n\t\t\t\tlog.info(\"Temporary directory \" + temporaryDir + \" created\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"Failed to create temporary directory \" + temporaryDir + \" for file \" + fileToAdd, e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Add the file to the directory\n\t\t\ttry {\n\t\t\t\tfileToAdd.createNewFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlog.error(\"Failed to create file \" + fileToAdd, e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Add the file to the list\n\t\t\tfiles[i] = fileToAdd;\n\t\t\t\n\t\t}\n\t\t\n\t\t// Add the file to the list\n\t\taddFile(fileToAdd);\n\t\t\n\t}\n\t\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\t\n\tfor (int i = files.length - 1; i >= 0; i--) {\n\t\t\n\t\tfinal File file = files[i];\n\t\t\n\t\tif (file.exists()){\n\t\t\t\n\t\t\tfinal long modified = file.lastModified();\n\t\t\t\n\t\t\tif (modified!= files[i].lastModified()){\n\t\t\t\t\n\t\t\t\tfinal File[] temp = new File[files.length];\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < temp.length; j++){\n\t\t\t\t\t\n\t\t\t\t\ttemp[j] = files[j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfiles = temp;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfiles[i].delete();\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n    \n    for(int i = files.length - 1; i >= 0; i--){\n        // check if the file exists\n        if(files[i].isFile()){\n            files[i].delete();\n        }\n    }\n    \n    // add the specified files in reverse order\n    for(int i = files.length - 1; i >= 0; i--){\n        files[i].mkdir();\n        files[i].deleteOnExit();\n    }\n    \n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\tif (files == null) return;\n\tArrays.sort(files);\n\tfor (int i = files.length - 1; i >= 0; i--) {\n\t\tif (files[i].getName().compareToIgnoreCase(\"\") == 0) continue;\n\t\t\n\t\tfinal File f = files[i];\n\t\t\n\t\ttry{\n\t\t\t// If the file is a.sh file, add it to the list of files.\n\t\t\tif (f.getName().endsWith(\".sh\")) {\n\t\t\t\tfileList.add(f);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// If the file is a.c or.cpp file, add it to the list of files.\n\t\t\tfinal String extension = f.getName().substring(f.getName().lastIndexOf('.') + 1).toLowerCase();\n\t\t\tif (extension.equals(\"c\") || extension.equals(\"cpp\") || extension.equals(\"cxx\")) {\n\t\t\t\tfileList.add(f);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// If the file is a.cc or.cpp file, add it to the list of files.\n\t\t\tfinal String name = f.getName().toLowerCase();\n\t\t\tif (name.endsWith(\".c\") || name.endsWith(\".cc\") || name.endsWith(\".cpp\")) {\n\t\t\t\tfileList.add(f);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// If the file is a.txt file, add it to the list of files.\n\t\t\tif (f.getName().endsWith(\".txt\")) {\n\t\t\t\tfileList.add(f);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Add the file to the list of files.\n\t\t\tfileList.add(f);\n\t\t}\n\t\tcatch(final Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\tfor (final File file : files){\n\t\tif (file.isDirectory() &&!file.isHidden()) {\n\t\t\taddReverse(file.listFiles());\n\t\t} else {\n\t\t\tFileInputStream fis = null;\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(file);\n\t\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\t\tIOUtils.copy(fis, bos);\n\t\t\t\tbos.close();\n\t\t\t\tString content = bos.toString();\n\t\t\t\tif (content.length()!= 0) {\n\t\t\t\t\tbyte[] bytes = content.getBytes(\"UTF-8\");\n\t\t\t\t\tbyte[] bytes2 = bos.toByteArray();\n\t\t\t\t\tSystem.arraycopy(bytes2, bytes2.length - bytes.length, bytes, bytes2.length, bytes.length);\n\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes2, 0, bytes2.length);\n\t\t\t\t\tcontent = new String(bytes2, \"UTF-8\");\n\t\t\t\t}\n\t\t\t\tString content2 = content;\n\t\t\t\tif (content2.length()!= 0) {\n\t\t\t\t\tbyte[] bytes = content2.getBytes(\"UTF-8\");\n\t\t\t\t\tbyte[] bytes2 = bos.toByteArray();\n\t\t\t\t\tSystem.arraycopy(bytes2, bytes2.length - bytes.length, bytes, bytes2.length, bytes.length);\n\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes2, 0, bytes2.length);\n\t\t\t\t\tcontent2 = new String(bytes2, \"UTF-8\");\n\t\t\t\t}\n\t\t\t\tif (content == null || content.length() == 0) {\n\t\t\t\t\tcontent = \"\";\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"Adding file \" + file.getName() + \" to \" + file.getName() + \" with content \" + content);\n\t\t\t\tFileOutputStream fos = null;\n\t\t\t\ttry {\n\t\t\t\t\tfos = new FileOutputStream(file);\n\t\t\t\t\tfos.write(content2.getBytes(\"UTF-8\"));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfos.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\tif (fis!= null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfis.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "/** \n * Add the specified files in reverse order.\n */\n\nprivate void addReverse(final File[] files){\n\t\n\tfor(int i=files.length-1;i>=0;i--){\n\t\t\n\t\tFile[] files2 = files;\n\t\t\n\t\twhile(files2.length>1){\n\t\t\t\n\t\t\tFile file2 = files2[files2.length-1];\n\t\t\t\n\t\t\tif(file2.isDirectory()){\n\t\t\t\t\n\t\t\t\tfiles2 = file2.listFiles();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tfiles2 = new File[file2.listFiles().length];\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<file2.listFiles().length;j++){\n\t\t\t\t\tfiles2[j] = file2.listFiles()[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfiles2[files2.length-1].delete();\n\t\tfiles2[files2.length-1].mkdirs();\n\t\t\n\t\tfiles2[files2.length-1].deleteOnExit();\n\t\t\n\t\tfiles2[files2.length-1].renameTo(files2[files2.length-1]);\n\t}\n}"]}
{"_id": "6367667e1a6d9265ec01743a", "generate_results": ["public long lastWriteTimeStampInMilliseconds(){\n    return lastWriteTimeStampInMilliseconds;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStampInMilliseconds;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n  return lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn this.lastWriteTimeStampInMilliseconds;\n}", "public long lastWriteTimeStampInMilliseconds(){\n    return this.lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n    return this.lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}"]}
{"_id": "636766851a6d9265ec017515", "generate_results": ["public Action inspect(AtmosphereResource r){\n    if(r.getTransport() == null) return Action.CONTINUE;\n    if(r.getTransport() == AtmosphereResource.TRANSPORT.SESSION) return Action.CONTINUE;\n    return Action.CONTINUE;\n}", "public Action inspect(AtmosphereResource r){\n    return Action.CONTINUE;\n}", "public Action inspect(AtmosphereResource r){\n\tString transport = r.transport();\n\tif(transport == null){\n\t\ttransport = AtmosphereResource.TRANSPORT.value();\n\t}\n\t\n\t\n\t\n\tif(transport.equals(AtmosphereResource.TRANSPORT.value())){\n\t\treturn Action.CONTINUE;\n\t}\n\treturn Action.CONTINUE;\n}", "public Action inspect(AtmosphereResource r){\n\tif(r.getTransport()==Transport.RTS) return Action.CONTINUE;\n\treturn Action.INVOKE_TRANSPORT;\n}", "public Action inspect(AtmosphereResource r){\n\tif(r.getTransport().equals(Transport.ASYNC)){\n\t\treturn Action.CONTINUE;\n\t}\n\treturn null;\n}", "public Action inspect(AtmosphereResource r){\n\tAtmosphereResource.TRANSPORT transport = r.getTransport();\n\tif(transport == null) return Action.CONTINUE;\n\t\n\tString transportStr = transport.getTransportName();\n\tif(transportStr == null) return Action.CONTINUE;\n\t\n\treturn Action.INSPECT;\n}", "public Action inspect(AtmosphereResource r){\n    return Action.CONTINUE;\n}", "public Action inspect(AtmosphereResource r){\n\tif (r.getTransport() == null) return Action.CONTINUE;\n\t\n\tif (r.getTransport().equals(AtmosphereResource.TRANSPORT.HTTP)){\n\t\treturn Action.CONTINUE;\n\t}\n\t\n\treturn Action.CONTINUE;\n}", "public Action inspect(AtmosphereResource r){\n\tif(r.getTransport().getName().equals(AtmosphereResource.TRANSPORT_HTTP_TRANSPORT)) return Action.CONTINUE;\n\treturn super.inspect(r);\n}", "public Action inspect(AtmosphereResource r){\n    if(r.getTransport() == null){\n        return Action.CONTINUE;\n    }\n    return Action.INSPECT;\n}"]}
{"_id": "6367676d1a6d9265ec018229", "generate_results": ["public static String[] trimArrayElements(String[] array){\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\t\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\tfor(int i=0;i<array.length;i++){\n\t\tarray[i]=StringUtil.trim(array[i]);\n\t}\n\treturn array;\n}", "public static String[] trimArrayElements(String[] array){\n\treturn (String[])array.clone();\n}", "public static String[] trimArrayElements(String[] array){\n\tString[] result = new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\t\n\tString[] trimmedArray = new String[array.length];\n\t\n\tfor(int i = 0; i < trimmedArray.length; i++){\n\t\ttrimmedArray[i] = array[i].trim();\n\t}\n\t\n\treturn trimmedArray;\n}", "public static String[] trimArrayElements(String[] array){\n\tfor (int i = 0; i < array.length; i++){\n\t\tarray[i] = StringUtil.trim(array[i]);\n\t}\n\treturn array;\n}", "public static String[] trimArrayElements(String[] array){\n\tfor(int i = 0; i < array.length; i++){\n\t\tarray[i] = array[i].trim();\n\t}\n\treturn array;\n}", "public static String[] trimArrayElements(String[] array){\n\t\n\tif (array == null)\n\t\treturn null;\n\t\n\tint size = array.length;\n\t\n\tif (size == 0)\n\t\treturn new String[0];\n\t\n\tString[] trimmedArray = new String[size];\n\t\n\tfor (int i = 0; i < size; ++i)\n\t\ttrimmedArray[i] = array[i].trim();\n\t\n\treturn trimmedArray;\n}", "public static String[] trimArrayElements(String[] array){\n\tif(array.length == 0){\n\t\treturn new String[0];\n\t}\n\t\n\tString[] trimmedArray = new String[array.length];\n\t\n\tfor(int i = 0; i < array.length; i++){\n\t\ttrimmedArray[i] = array[i].trim();\n\t}\n\t\n\treturn trimmedArray;\n}", "public static String[] trimArrayElements(String[] array){\n\tint i = 0;\n\twhile(i < array.length){\n\t\tarray[i] = array[i].trim();\n\t\ti++;\n\t}\n\treturn array;\n}"]}
{"_id": "636767691a6d9265ec0181aa", "generate_results": ["public static int nullSafeHashCode(long[] array){\n\tif (array == null) return 0;\n\tint hash = 0;\n\tfor (int i = 0; i < array.length; i++){\n\t\thash += array[i];\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tif (array == null) return 0;\n\tint hash = 0;\n\tfor (int i = 0; i < array.length; i++) {\n\t\thash += array[i];\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tif (array == null){\n\t\treturn 0;\n\t}\n\tint hash = 0;\n\tfor (int i = 0; i < array.length; i++){\n\t\thash += array[i];\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tif(array==null){\n\t\treturn 0;\n\t}\n\treturn Arrays.hashCode(array);\n}", "public static int nullSafeHashCode(long[] array){\n\tif (array == null)\n\t\treturn 0;\n\tint hash = 1;\n\tfor (int i = 0; i < array.length; i++)\n\t\thash = 31 * hash + (int)array[i];\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tif(array==null) return 0;\n\tint hashcode = 0;\n\tfor(int i=0;i<array.length;i++){\n\t\thashcode += array[i]*i;\n\t}\n\treturn hashcode;\n}", "public static int nullSafeHashCode(long[] array){\n\tif (array==null) return 0;\n\tint hash = 0;\n\tfor(int i=0;i<array.length;i++){\n\t\thash += array[i];\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\tif(array == null){\n\t\treturn 0;\n\t}else{\n\t\treturn hashCode(array);\n\t}\n}", "public static int nullSafeHashCode(long[] array){\n\tif(array == null)\n\t\treturn 0;\n\tint result = 0;\n\tint j = array.length;\n\twhile(--j >= 0){\n\t\tresult = 31*result + (int)(array[j]&0x7F);\n\t\tif(j > 0){\n\t\t\tresult = 31*result + (int)((array[j-1]&0x80)>>>0);\n\t\t}\n\t}\n\treturn result;\n}", "public static int nullSafeHashCode(long[] array){\n\tif(array == null) return 0;\n\tint hash = 1;\n\tfor(long i : array) hash = 31 * hash + (int)i;\n\treturn hash;\n}"]}
{"_id": "6367676b1a6d9265ec0181df", "generate_results": ["public static boolean startsWithIgnoreCase(String str,String prefix){\n  return str.startsWith(prefix);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str!= null){\n\t\treturn str.startsWith(prefix);\n\t}\n\treturn false;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str==null || prefix==null)\n\t\treturn false;\n\tif(str.startsWith(prefix))\n\t\treturn true;\n\treturn false;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str == null || prefix == null){\n\t\treturn false;\n\t}\n\treturn str.startsWith(prefix);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif (str == null || prefix == null){\n\t\treturn false;\n\t}\n\tif (str.length()==0){\n\t\treturn false;\n\t}\n\tif (str.toLowerCase().startsWith(prefix.toLowerCase())){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n    if (str.startsWith(prefix)) {\n        return true;\n    }\n    return false;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n    if(!str.startsWith(prefix)) return false;\n    int index=str.indexOf(prefix);\n    if(index<0) return false;\n    return true;\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\t\n\treturn str.startsWith(prefix);\n\t\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n  return str.startsWith(prefix);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\t\n\tif(str.length() > prefix.length()){\n\t\treturn false;\n\t}\n\t\n\tint i = 0;\n\t\n\twhile(i < str.length() && Character.isUpperCase(str.charAt(i))){\n\t\ti++;\n\t}\n\t\n\treturn str.startsWith(prefix);\n\t\n\t\n}"]}
{"_id": "6367676b1a6d9265ec0181e2", "generate_results": ["public static Object findFirstMatch(Collection source,Collection candidates){\n  for (Iterator i = candidates.iterator(); i.hasNext();) {\n    Object candidate = i.next();\n    if (source.contains(candidate)) return candidate;\n  }\n  return null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tif(source==null || candidates==null){\n\t\treturn null;\n\t}\n\tIterator iter = candidates.iterator();\n\twhile(iter.hasNext()){\n\t\tObject candidate = iter.next();\n\t\tif(source.contains(candidate)){\n\t\t\treturn candidate;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tObject first = null;\n\t\n\tif(source==null || candidates==null || source.size()==0){\n\t\treturn first;\n\t}\n\t\n\tIterator it = candidates.iterator();\n\twhile(it.hasNext()){\n\t\tObject o = it.next();\n\t\tif(o instanceof Collection){\n\t\t\tif(o.equals(source)){\n\t\t\t\tfirst = o;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else{\n\t\t\tif(o.equals(source)){\n\t\t\t\tfirst = o;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn first;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tfor(Object candidate:candidates){\n\t\tif(source.contains(candidate)){\n\t\t\treturn candidate;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\t\n\tif(source == null || candidates == null){\n\t\treturn null;\n\t}\n\n\tObject result = null;\n\t\n\tint index = 0; // index of first match we found\n\t\n\twhile(index < candidates.size()){\n\t\t\n\t\tresult = candidates.get(index);\n\t\t\n\t\tif(source.contains(result)){\n\t\t\tindex++;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tfor(Object candidate:candidates){\n\t\tif(source.contains(candidate)) return candidate;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tif(candidates==null) return null;\n\tIterator it = candidates.iterator();\n\twhile(it.hasNext()){\n\t\tObject o = it.next();\n\t\tif(o instanceof String) return o;\n\t\tif(o instanceof Object[]){\n\t\t\tObject[] a = (Object[])o;\n\t\t\tif(a[0] instanceof Object[]){\n\t\t\t\tObject[] c = (Object[])a[0];\n\t\t\t\tif(c[0] instanceof String) return c[0];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tIterator iterator = candidates.iterator();\n\twhile (iterator.hasNext()){\n\t\tObject element = iterator.next();\n\t\tif (source.contains(element))\n\t\t\treturn element;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tIterator iter = source.iterator();\n\tObject object = null;\n\twhile(iter.hasNext()){\n\t\tobject = iter.next();\n\t\tif(candidates.contains(object)){\n\t\t\treturn object;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\tif(source==null || candidates==null)\n\t\treturn null;\n\treturn findMatch(source.iterator(), candidates);\n}"]}
{"_id": "6367676b1a6d9265ec0181ee", "generate_results": ["public static String trimTrailingWhitespace(String str){\n\t\n\tif (str == null)\n\t\treturn null;\n\t\n\tint len = str.length();\n\t\n\tif (len == 0)\n\t\treturn \"\";\n\t\n\tif (Character.isWhitespace(str.charAt(len - 1)))\n\t\treturn str.substring(0, len - 1);\n\t\n\treturn str;\n\n}", "public static String trimTrailingWhitespace(String str){\n\tif (str == null){\n\t\treturn null;\n\t}\n\tint strLen = str.length();\n\tif (strLen > 0){\n\t\tString s = str.substring(strLen - 1);\n\t\treturn s.trim();\n\t}\n\treturn str;\n}", "public static String trimTrailingWhitespace(String str){\n    if (str == null) {\n        return null;\n    }\n    int len = str.length();\n    if (len <= 1) {\n        return str;\n    }\n    if (len > 2 && str.charAt(len - 2) ==''){\n        return str.substring(0, len - 2);\n    } else {\n        return str.substring(0, len - 1);\n    }\n}", "public static String trimTrailingWhitespace(String str){\n\treturn str.trim().replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n}", "public static String trimTrailingWhitespace(String str){\n\tif (str==null) return null; // should not happen\n\tint i = str.length()-1;\n\twhile (i>=0 && Character.isWhitespace(str.charAt(i))) i--;\n\treturn str.substring(0,i+1);\n}", "public static String trimTrailingWhitespace(String str){\n\tif (str==null) return null;\n\t\n\tint strLen = str.length();\n\t\n\tif (strLen==0) return \"\";\n\t\n\tchar ch = str.charAt(strLen-1);\n\t\n\tif (Character.isWhitespace(ch)){\n\t\treturn str;\n\t}\n\t\n\treturn str.substring(0, strLen-1);\n}", "public static String trimTrailingWhitespace(String str){\n\treturn str.trim().replaceAll(\"\\\\s+$\", \"\");\n}", "public static String trimTrailingWhitespace(String str){\n\tif(str == null || str.length() == 0)\n\t\treturn str;\n\t\n\tint len = str.length();\n\t\n\tfor(int i = 0; i < len; i++){\n\t\tif(Character.isWhitespace(str.charAt(i)))\n\t\t\tbreak;\n\t}\n\t\n\tif(i == len)\n\t\treturn str;\n\t\n\treturn str.substring(i);\n}", "public static String trimTrailingWhitespace(String str){\n\tif (str == null) {\n\t\treturn null;\n\t}\n\t\n\tint sz = str.length();\n\tint p = sz-1;\n\twhile (p >= 0 && Character.isWhitespace(str.charAt(p))) {\n\t\tp--;\n\t}\n\treturn str.substring(0, p+1);\n}", "public static String trimTrailingWhitespace(String str){\n    return str == null? null : str.trim();\n}"]}
{"_id": "6367676a1a6d9265ec0181bf", "generate_results": ["public static Object quoteIfString(Object obj){\n    if (obj instanceof String){\n        return \"'\" + obj + \"'\";\n    }\n    return obj;\n}", "public static Object quoteIfString(Object obj){\n    if(obj instanceof String){\n        return quoteIfString((String)obj);\n    }\n    else{\n        return obj;\n    }\n}", "public static Object quoteIfString(Object obj){\n\tif(obj instanceof String){\n\t\treturn \"'\"+(String)obj+\"'\";\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\tif (obj instanceof String){\n\t\treturn \"'\" + obj + \"'\";\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\tif (obj instanceof String) {\n\t\treturn \"'\" + obj + \"'\";\n\t} else {\n\t\treturn obj;\n\t}\n}", "public static Object quoteIfString(Object obj){\n\tif (obj instanceof String) return \"'\" + obj + \"'\";\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n    if (obj instanceof String) {\n        return \"'\" + obj + \"'\";\n    } else {\n        return obj;\n    }\n}", "public static String quoteIfString(Object obj) {\n    return obj.toString();\n}", "public static Object quoteIfString(Object obj){\n\tif (obj == null || obj instanceof String) return obj;\n\treturn \"'\" + obj.toString() + \"'\";\n}", "public static Object quoteIfString(Object obj){\n    if(obj instanceof String){\n        return \"'\"+(String)obj+\"'\";\n    }else{\n        return obj;\n    }\n}"]}
{"_id": "6367676a1a6d9265ec0181cd", "generate_results": ["public static String trimLeadingWhitespace(String str){\n\treturn trimLeadingWhitespace(str, 0);\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str == null)\n\t\treturn null;\n\t\n\tint len = str.length();\n\tif (len == 0)\n\t\treturn \"\";\n\t\n\tchar c = str.charAt(0);\n\tif (c == '\\n')\n\t\treturn \"\";\n\t\n\tif (Character.isWhitespace(c))\n\t\treturn str.substring(1);\n\telse\n\t\treturn str;\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str == null) {\n\t\treturn null;\n\t}\n\t\n\t// Get rid of leading whitespace\n\tint index = str.indexOf(CHAR_SPACE);\n\tif (index < 0) {\n\t\treturn str;\n\t}\n\t\n\t// Trim leading whitespace\n\treturn str.substring(index + CHAR_SPACE.length());\n}", "public static String trimLeadingWhitespace(String str){\n    if (str == null){\n        return null;\n    }\n    char ch;\n    int start = 0;\n    int end = str.length();\n    while (end > start && (ch = str.charAt(end - 1)) ==''){\n        end--;\n    }\n    return new String(str.substring(start, end));\n}", "public static String trimLeadingWhitespace(String str){\n\treturn trimLeadingWhitespace(str, 0);\n}", "public static String trimLeadingWhitespace(String str){\n    if (str == null) {\n        return null;\n    }\n    \n    str = str.trim();\n    \n    if (str.length() == 0) {\n        return str;\n    }\n    \n    char ch = str.charAt(0);\n    char last = str.charAt(str.length() - 1);\n    \n    if (Character.isWhitespace(ch) && Character.isWhitespace(last)) {\n        return str.substring(1, str.length() - 1);\n    }\n    \n    return str;\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str!= null) {\n\t\tint len = str.length();\n\t\tif (len > 0) {\n\t\t\tif (Character.isWhitespace(str.charAt(0))) {\n\t\t\t\treturn str.substring(1);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str==null) return null;\n\tstr = str.trim();\n\tif (str.length()==0) return \"\";\n\n\treturn str;\n}", "public static String trimLeadingWhitespace(String str){\n\tif (str == null) {\n\t\treturn null;\n\t}\n\t\n\tint len = str.length();\n\t\n\tif (len <= 0) {\n\t\treturn \"\";\n\t}\n\t\n\tif (str.charAt(0) == '\\n') {\n\t\tstr = str.substring(1);\n\t}\n\t\n\tif (str.charAt(0) =='') {\n\t\tstr = str.substring(1);\n\t}\n\t\n\treturn str;\n}", "public static String trimLeadingWhitespace(String str){\n    if (str == null) {\n        return null;\n    }\n    \n    int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    \n    if (Character.isWhitespace(str.charAt(0))) {\n        return str;\n    }\n    \n    char ch = str.charAt(0);\n    \n    if (ch =='') {\n        return str.substring(1);\n    } else {\n        return str;\n    }\n}"]}
{"_id": "636767691a6d9265ec0181ae", "generate_results": ["public static String[] toStringArray(Enumeration<String> enumeration){\n\tif (enumeration == null) {\n\t\treturn null;\n\t}\n\tString[] stringArray = new String[enumeration.size()];\n\tint i = 0;\n\twhile (enumeration.hasMoreElements()) {\n\t\tstringArray[i] = enumeration.nextElement();\n\t\ti++;\n\t}\n\treturn stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    if (enumeration == null) return null;\n    if (!enumeration.hasMoreElements()) return new String[0];\n    String[] result = new String[enumeration.available()];\n    String element = enumeration.nextElement();\n    while (enumeration.hasMoreElements()){\n        result[index++] = element;\n        element = enumeration.nextElement();\n    }\n    return result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] result = new String[enumeration.size()];\n\tint i = 0;\n\twhile(enumeration.hasMoreElements()){\n\t\tresult[i] = enumeration.nextElement();\n\t\tif (result[i] == null) {\n\t\t\tresult[i] = \"\"; //$NON-NLS-1$\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    if (enumeration == null) return null;\n    String[] result = new String[enumeration.count()];\n    for (int i = 0; enumeration.hasMoreElements(); i++) {\n        result[i] = enumeration.nextElement();\n    }\n    return result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tif (enumeration == null){\n\t\treturn null;\n\t}\n\tString[] result = new String[enumeration.hasMoreElements()? enumeration.size() : 1];\n\t\n\twhile (enumeration.hasMoreElements()){\n\t\tresult[0] = enumeration.nextElement();\n\t}\n\t\n\treturn result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tif (enumeration == null) return null;\n\tString[] stringArray = new String[enumeration.count()];\n\tint i = 0;\n\twhile (enumeration.hasMoreElements()){\n\t\tstringArray[i++] = enumeration.nextElement();\n\t}\n\treturn stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] result = new String[enumeration.hasMoreElements()? enumeration.nextElement().length() : 0];\n\twhile (enumeration.hasMoreElements()){\n\t\tString element = enumeration.nextElement();\n\t\tif (element!= null) {\n\t\t\tfor (int i=0; i < element.length(); i++) {\n\t\t\t\tresult[i] = element.charAt(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tif (enumeration == null)\n\t\tthrow new IllegalArgumentException(\"The enumeration must not be null\");\n\tif (!enumeration.hasMoreElements())\n\t\treturn null;\n\tString[] result = new String[enumeration.count()];\n\tint idx = 0;\n\twhile (enumeration.hasMoreElements()){\n\t\tresult[idx++] = enumeration.nextElement();\n\t}\n\treturn result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n    if (enumeration == null)\n        return null;\n\n    String[] result = new String[enumeration.size()];\n    int i = 0;\n    while (enumeration.hasMoreElements())\n        result[i++] = enumeration.nextElement();\n\n    return result;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\tif (enumeration == null) return null;\n\tString[] result = new String[enumeration.size()];\n\tint i = 0;\n\twhile (enumeration.hasMoreElements()){\n\t\tresult[i++] = enumeration.nextElement();\n\t}\n\treturn result;\n}"]}
{"_id": "6367676c1a6d9265ec01820b", "generate_results": ["public static String deleteAny(String inString,String charsToDelete){\n\tString outString = inString;\n\tfor (int i=0; i<charsToDelete.length(); i++){\n\t\tchar c = charsToDelete.charAt(i);\n\t\tif (outString.length()==0)\n\t\t\treturn \"\";\n\t\toutString = outString.replace(c, \"\");\n\t}\n\treturn outString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString result = \"\";\n\tStringBuilder builder = new StringBuilder();\n\tint len = inString.length();\n\tfor(int i = 0; i < len; i++){\n\t\tif(inString.charAt(i) == charsToDelete.charAt(0)){\n\t\t\tbuilder.append(inString.substring(i, i+1));\n\t\t}else{\n\t\t\tbuilder.append(inString.charAt(i));\n\t\t}\n\t}\n\treturn builder.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString result = \"\";\n\tfor (int i = 0; i < inString.length(); i++){\n\t\tif(charsToDelete.contains(inString.charAt(i))){\n\t\t\tresult += inString.charAt(i);\n\t\t}\n\t}\n\treturn result;\n}", "public static String deleteAny(String inString,String charsToDelete){\n    String outString = inString;\n    \n    for(char aChar : charsToDelete.toCharArray()){\n        int index = inString.indexOf(aChar);\n        if(index > -1){\n            outString = outString.substring(0, index) + outString.substring(index+1);\n        }\n    }\n    return outString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tif(inString==null || inString.length()==0)\n\t\treturn null;\n\tint inIndex=0;\n\tchar[] inArray=inString.toCharArray();\n\tchar[] charsToDeleteArray=charsToDelete.toCharArray();\n\twhile(inIndex<inArray.length)\n\t{\n\t\tif(inArray[inIndex]==charsToDeleteArray[0])\n\t\t{\n\t\t\tinArray[inIndex]=charsToDeleteArray[1];\n\t\t\tinIndex++;\n\t\t}\n\t\telse\n\t\t\tinIndex++;\n\t}\n\treturn new String(inArray);\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString[] charsToDeleteArray = new String[charsToDelete.length()];\n\tfor (int i = 0; i < charsToDelete.length(); i++){\n\t\tcharsToDeleteArray[i] = charsToDelete.charAt(i);\n\t}\n\t\n\tString outString = \"\";\n\t\n\tfor (int i = 0; i < inString.length(); i++){\n\t\tif (inString.charAt(i) == charsToDeleteArray[0]){\n\t\t\toutString = outString + inString.substring(i);\n\t\t}\n\t}\n\treturn outString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n    StringBuffer outString = new StringBuffer();\n    \n    for (int i = 0; i < inString.length()-charsToDelete.length(); i++){\n        outString.append(inString.substring(i,i+charsToDelete.length()));\n    }\n    \n    return outString.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString outString = \"\";\n\t\n\tfor(int i = 0;i < inString.length();i++){\n\t\tchar inChar = inString.charAt(i);\n\t\tfor(int j = 0;j < charsToDelete.length();j++){\n\t\t\tif(Character.toUpperCase(charsToDelete.charAt(j)) == inChar){\n\t\t\t\toutString += inString.substring(0,i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j == charsToDelete.length()){\n\t\t\toutString += inString.substring(i+1);\n\t\t}\n\t}\n\treturn outString;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\t\n\tString result = \"\";\n\t\n\tfor(int i =0;i<inString.length();i++){\n\t\tif(inString.charAt(i)==charsToDelete.charAt(0)){\n\t\t\tresult = result + inString.substring(i,i+1);\n\t\t\ti--;\n\t\t}\t\n\t}\n\t\n\treturn result;\n}", "public static String deleteAny(String inString,String charsToDelete){\n\tString outString = inString;\n\tint index = -1;\n\tchar lastChar = '\\0';\n\t\n\tfor(int i=0;i<inString.length();i++){\n\t\tindex = inString.indexOf(charsToDelete,i);\n\t\tif(index!=-1){\n\t\t\tlastChar = inString.charAt(index);\n\t\t\toutString = outString.substring(0,index);\n\t\t}\n\t}\n\treturn outString;\n}"]}
{"_id": "6367676c1a6d9265ec018223", "generate_results": ["public static boolean containsInstance(Collection collection,Object element){\n    for(Iterator iter = collection.iterator(); iter.hasNext();){\n        if(iter.next()==element){\n            return true;\n        }\n    }\n    return false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null || element==null){\n\t\treturn false;\n\t}\n\tfor(Object o : collection){\n\t\tif(o==element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n    Iterator it = collection.iterator();\n    while(it.hasNext()){\n        Object o = it.next();\n        if(o.equals(element)){\n            return true;\n        }\n    }\n    return false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection.contains(element)){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tfor(Iterator iterator = collection.iterator();iterator.hasNext();){\n\t\tObject object = iterator.next();\n\t\tif(object.equals(element)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n    Iterator it = collection.iterator();\n    while(it.hasNext()){\n        Object o = it.next();\n        if(o.equals(element)){\n            return true;\n        }\n    }\n    return false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n    Iterator iterator = collection.iterator();\n    while(iterator.hasNext()){\n        if(iterator.next() == element){\n            return true;\n        }\n    }\n    return false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null) return false;\n\tfor (Iterator it = collection.iterator(); it.hasNext(); ){\n\t\tObject o = it.next();\n\t\tif(o!=null && o.equals(element)) return true;\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tfor(Iterator i = collection.iterator();i.hasNext();){\n\t\tObject o = i.next();\n\t\tif(o == element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null) return false;\n\tfor(Iterator iter=collection.iterator();iter.hasNext();){\n\t\tObject curr = iter.next();\n\t\tif(curr.equals(element)) return true;\n\t}\n\treturn false;\n}"]}
{"_id": "6367676c1a6d9265ec018204", "generate_results": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1==null){\n\t\treturn array2;\n\t}\n\tif (array2==null){\n\t\treturn array1;\n\t}\n\tint n = array1.length+array2.length;\n\tString[] ret = new String[n];\n\tSystem.arraycopy(array1,0,ret,0,array1.length);\n\tSystem.arraycopy(array2,0,ret,array1.length,array2.length);\n\treturn ret;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1==null) array1=new String[0];\n\tif (array2==null) array2=new String[0];\n\tif (array1.length==0) return array2;\n\tif (array2.length==0) return array1;\n\t\n\tString[] newArray=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArray,0,array1.length);\n\tSystem.arraycopy(array2,0,newArray,array1.length,array2.length);\n\treturn newArray;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\t\n\tif(array1 == null || array2 == null)\n\t\treturn null;\n\t\n\tint length = array1.length;\n\tStringBuffer result = new StringBuffer();\n\t\n\tif(length > 0){\n\t\tresult.append(array1[0]);\n\t\tfor(int i = 1; i < length; i++){\n\t\t\tresult.append(array1[i]);\n\t\t\tresult.append(array1[i]);\n\t\t}\n\t}\n\t\n\tif(length > 1){\n\t\tresult.append(array2[0]);\n\t\tfor(int i = 1; i < length; i++){\n\t\t\tresult.append(array2[i]);\n\t\t\tresult.append(array2[i]);\n\t\t}\n\t}\n\t\n\treturn result.toString().split(\"\\\\n\");\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1 == null){\n\t\treturn array2;\n\t}\n\tif (array2 == null){\n\t\treturn array1;\n\t}\n\tint length1 = array1.length;\n\tint length2 = array2.length;\n\tString[] result = new String[length1 + length2];\n\tint index1 = 0;\n\tint index2 = 0;\n\tfor (int i = 0; i < length1; i++){\n\t\tif (index1 == result.length){\n\t\t\tresult = Arrays.copyOf(result, index1);\n\t\t}\n\t\tresult[index1++] = array1[i];\n\t}\n\tfor (int i = 0; i < length2; i++){\n\t\tif (index2 == result.length){\n\t\t\tresult = Arrays.copyOf(result, index2);\n\t\t}\n\t\tresult[index2++] = array2[i];\n\t}\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1==null){\n\t\treturn array2;\n\t}\n\tif (array2==null){\n\t\treturn array1;\n\t}\n\tint i=0;\n\tint j=0;\n\tString toReturn=null;\n\twhile (i<array1.length || j<array2.length){\n\t\tif (i==array1.length){\n\t\t\tif (j==array2.length){\n\t\t\t\ttoReturn=array2[j];\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttoReturn=array1[j];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (j==array2.length){\n\t\t\ttoReturn=array1[i];\n\t\t\ti++;\n\t\t}\n\t\tif (i==array1.length){\n\t\t\ttoReturn=array2[j];\n\t\t\tj++;\n\t\t}\n\t}\n\treturn toReturn==null?array1:toReturn.concatenate(array2).toString();\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\t\n\tif(array1==null) \n\t\treturn null;\n\t\n\tif(array2==null)\n\t\treturn array1;\n\t\n\tint n=array1.length+array2.length;\n\tString[] result=new String[n];\n\tif(array1.length==0)\n\t\treturn result;\n\tif(array2.length==0)\n\t\treturn array1;\n\t\n\tfor(int i=0;i<array1.length;i++){\n\t\tresult[i]=array1[i];\n\t\tif(i<array2.length){\n\t\t\tfor(int j=0;j<array2.length;j++){\n\t\t\t\tif(j==i)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult[i]=result[i]+array2[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif(array1==null){\n\t\treturn array2;\n\t}\n\tif(array2==null){\n\t\treturn array1;\n\t}\n\tint length = array1.length;\n\tString newArray[] = new String[length+array2.length];\n\tint i = 0;\n\tfor(i=0;i<length;i++){\n\t\tnewArray[i] = array1[i];\n\t}\n\tfor(i=0;i<array2.length;i++){\n\t\tnewArray[length+i] = array2[i];\n\t}\n\treturn newArray;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1==null || array2==null){\n\t\treturn null;\n\t}\n\tString[] result = new String[array1.length + array2.length];\n\tSystem.arraycopy(array1, 0, result, 0, array1.length);\n\tSystem.arraycopy(array2, 0, result, array1.length, array2.length);\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1 == null) return array2;\n\tif (array2 == null) return array1;\n\tint length1 = array1.length;\n\tint length2 = array2.length;\n\tif (length1 == 0) return new String[0];\n\tif (length2 == 0) return new String[0];\n\tif (length1 == 1) return new String[] { array1[0] };\n\tif (length2 == 1) return new String[] { array2[0] };\n\tString[] result = new String[length1+length2];\n\tSystem.arraycopy(array1,0,result,0,length1);\n\tSystem.arraycopy(array2,0,result,length1,length2);\n\treturn result;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\tif (array1 == null) return array2;\n\tif (array2 == null) return array1;\n\tString[] result = new String[array1.length + array2.length];\n\tSystem.arraycopy(array1, 0, result, 0, array1.length);\n\tSystem.arraycopy(array2, 0, result, array1.length, array2.length);\n\treturn result;\n}"]}
{"_id": "6367676a1a6d9265ec0181d4", "generate_results": ["public static String[] addStringToArray(String[] array,String str){\n\tif (array==null){\n\t\tarray=new String[0];\n\t}\n\tif (str==null){\n\t\treturn array;\n\t}\n\tString[] result=new String[array.length+1];\n\tSystem.arraycopy(array,0,result,0,array.length);\n\tresult[array.length]=str;\n\treturn result;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif (array==null) array=new String[1];\n\tarray[0]=str;\n\treturn array;\t\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif (array==null) return new String[]{str};\n\tString[] newArray=new String[array.length+1];\n\tSystem.arraycopy(array,0,newArray,0,array.length);\n\tnewArray[array.length]=str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif (array == null) array = new String[1];\n\tarray[0] = str+\"\";\n\treturn array;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif(array==null) return new String[]{str};\n\treturn addStringToArray(array,str,array.length);\n}", "public static String[] addStringToArray(String[] array,String str){\n    if (array==null){\n        array=new String[1];\n    }\n    array[0]=str;\n    return array;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif (array == null) return new String[0];\n\telse {\n\t\tint len = array.length;\n\t\tString[] newArray = new String[len+1];\n\t\tSystem.arraycopy(array, 0, newArray, 0, len);\n\t\tnewArray[len] = str;\n\t\treturn newArray;\n\t}\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif (array == null){\n\t\treturn new String[]{str};\n\t}\n\tint len = array.length;\n\tString[] newArray = new String[len+1];\n\tif (len > 0){\n\t\tSystem.arraycopy(array,0,newArray,0,len);\n\t}\n\tnewArray[len] = str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif(array == null) return new String[] {str};\n\tString[] newArray = new String[array.length+1];\n\tSystem.arraycopy(array,0,newArray,0,array.length);\n\tnewArray[array.length] = str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\tif(array == null){\n\t\treturn new String[]{str};\n\t}\n\t\n\tint len = array.length;\n\t\n\tString[] newArray = new String[len+1];\n\tSystem.arraycopy(array,0,newArray,0,len);\n\tnewArray[len] = str;\n\t\n\treturn newArray;\n}"]}
{"_id": "6367676b1a6d9265ec0181dd", "generate_results": ["public static int countOccurrencesOf(String str,String sub){\n\tif(str==null || sub==null) return 0;\n\tint count=0;\n\tint pos=0;\n\twhile(pos<str.length() && pos<sub.length()){\n\t\tif(str.charAt(pos)==sub.charAt(0)) count++;\n\t\tpos++;\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif (str==null) return 0;\n\tint count = 0;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tchar c = str.charAt(i);\n\t\tif (c!= sub.charAt(0)) count++;\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n    if (str == null) return 0;\n    int result = 0;\n    int pos = 0;\n    int length = str.length();\n    while(pos < length){\n        if (str.charAt(pos) == sub.charAt(0)){\n            result++;\n        }\n        pos++;\n    }\n    return result;\n}", "public static int countOccurrencesOf(String str,String sub){\n    if(str==null || str.equals(sub)) return 0;\n    int count = 0;\n    int start = 0;\n    int end = str.length();\n    while(start<end){\n        int i = str.indexOf(sub, start);\n        if(i>=0){\n            count++;\n        }\n        start = i+sub.length();\n    }\n    return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\t\n\tif (str==null) return 0;\n\t\n\tif (str.equals(sub)) return 1;\n\t\n\tint i=0;\n\twhile(i<str.length()){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ti++;\n\t\t\n\t}\n\treturn i;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif (str == null) return 0;\n\tint count = 0;\n\tint index = 0;\n\twhile(index < str.length()){\n\t\tif (str.charAt(index) == sub.charAt(0) && index < str.length() - 1){\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}else{\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif(str==null || str.length()==0){\n\t\treturn 0;\n\t}\n\tint count=0;\n\tfor(int i=0;i<str.length();i++){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif(str == null || sub == null)\n\t\treturn 0;\n\tint index=0;\n\twhile(index<str.length() && index<sub.length()){\n\t\tif(str.charAt(index++)==sub.charAt(0))\n\t\t\tindex++;\n\t}\n\treturn index-index;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif(str==null || sub==null)\n\t\treturn 0;\n\tint count = 0;\n\tint index = indexOf(str,sub);\n\twhile(index>=0)\n\t{\n\t\tcount++;\n\t\tindex = indexOf(str,sub,index+1);\n\t}\n\treturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\tif(str==null || sub==null){\n\t\treturn 0;\n\t}\n\tint count = 0;\n\t\n\tint indexOf = str.indexOf(sub);\n\t\n\twhile (indexOf!= -1){\n\t\tcount++;\n\t\tindexOf = str.indexOf(sub, indexOf + 1);\n\t}\n\t\n\t\n\treturn count;\n}"]}
{"_id": "6367676c1a6d9265ec018220", "generate_results": ["public static String stripFilenameExtension(String path){\n\tif (path == null)\n\t\treturn null;\n\tint i = path.lastIndexOf('.');\n\tif (i!= -1)\n\t\treturn path.substring(0, i);\n\treturn null;\n}", "public static String stripFilenameExtension(String path){\n\n\tint slashPos = path.lastIndexOf('/');\n\tint dotPos = path.lastIndexOf('.');\n\tif(dotPos > slashPos){\n\t\treturn path.substring(dotPos+1);\n\t}\n\treturn null;\n}", "public static String stripFilenameExtension(String path){\n    if (path == null) {\n        return null;\n    }\n    int dotpos = path.lastIndexOf('.');\n    if (dotpos < 0) {\n        return null;\n    }\n    String newPath = path.substring(0, dotpos);\n    int lastDotpos = newPath.lastIndexOf('.');\n    if (lastDotpos < 0) {\n        return null;\n    }\n    return newPath.substring(lastDotpos + 1);\n}", "public static String stripFilenameExtension(String path){\n\tif (path == null) return null;\n\t\n\tint i = path.lastIndexOf('.');\n\tif (i > 0) {\n\t\ti = path.lastIndexOf('.', i-1);\n\t\tif (i > 0) {\n\t\t\tpath = path.substring(0, i);\n\t\t}\n\t}\n\t\n\treturn path;\n}", "public static String stripFilenameExtension(String path){\n\tif (path == null)\n\t\treturn null;\n\t\n\tint index = path.lastIndexOf(\".\");\n\tif (index < 0)\n\t\treturn null;\n\t\n\treturn path.substring(0, index);\n}", "public static String stripFilenameExtension(String path){\n    if (path == null) return null;\n    int index = path.lastIndexOf(\".\");\n    if (index == -1) return null;\n    return path.substring(0, index);\n}", "public static String stripFilenameExtension(String path){\n\tif(path==null){\n\t\treturn null;\n\t}\n\tif(path.length()<=1){\n\t\treturn null;\n\t}\n\tint index = path.lastIndexOf('.');\n\tif(index<0){\n\t\treturn null;\n\t}\n\treturn path.substring(0, index);\n}", "public static String stripFilenameExtension(String path){\n    return path!= null? path.replace('\\\\', '/') : null;\n}", "public static String stripFilenameExtension(String path){\n\tif(path == null){\n\t\treturn null;\n\t}\n\treturn path.substring(0, path.lastIndexOf(\".\"));\n}", "public static String stripFilenameExtension(String path){\n\tif(path == null) return null;\n\tint index = path.lastIndexOf('.');\n\tif(index == -1) return path;\n\treturn path.substring(0, index);\n}"]}
{"_id": "636767691a6d9265ec0181a7", "generate_results": ["public static String trimLeadingCharacter(String str,char leadingCharacter){\n\t\n\tif (str == null)\n\t\treturn null;\n\t\n\tfor (int i=0;i<str.length();i++){\n\t\tif ( str.charAt(i) == leadingCharacter ){\n\t\t\treturn str.substring(0,i);\n\t\t}\n\t}\n\treturn str;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString result = str;\n\tif (str!= null){\n\t\t// Trim leading characters.\n\t\tresult = result.substring(0, str.length() - 1);\n\t\t// Trim trailing characters.\n\t\tresult = result.substring(0, result.length() - 1);\n\t}\n\treturn result;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString result = str;\n\tif(str.length()>0){\n\t\tint indexOfLeading = result.indexOf(leadingCharacter);\n\t\twhile(indexOfLeading>=0){\n\t\t\tresult = result.substring(0,indexOfLeading);\n\t\t\tindexOfLeading = result.indexOf(leadingCharacter);\n\t\t}\n\t}\n\treturn result;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\t\n\tif(str == null){\n\t\treturn null;\n\t}\n\t\n\treturn str.trim().replace(new String(new char[]{leadingCharacter}),\"\");\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\t\n\treturn str.replaceAll(\"^\"+Character.toString(leadingCharacter)+\"+\", \"\");\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tif(str == null || str.length() == 0){\n\t\treturn str;\n\t}\n\t\n\tchar[] chars = str.toCharArray();\n\t\n\t//trim leading characters\n\tint index = 0;\n\twhile((index = str.indexOf(leadingCharacter))!= -1){\n\t\tchars[index] = chars[index+1];\n\t}\n\t\n\t//trim trailing characters\n\tint end = str.length();\n\twhile((end = str.lastIndexOf(leadingCharacter))!= -1){\n\t\tchars[end] = chars[end-1];\n\t}\n\t\n\tstr = new String(chars);\n\treturn str;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\t\n\tif(str == null){\n\t\treturn null;\n\t}\n\t\n\tif(str.length() == 0){\n\t\treturn str;\n\t}\n\t\n\tint pos = str.indexOf(leadingCharacter);\n\t\n\tif(pos == -1){\n\t\treturn str;\n\t}\n\t\n\treturn str.substring(0,pos);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tStringBuffer sb = new StringBuffer();\n\tboolean isLeading = false;\n\tfor(int i = 0; i < str.length(); i++){\n\t\tif(str.charAt(i) == leadingCharacter){\n\t\t\tisLeading = true;\n\t\t}\n\t\tif(!isLeading){\n\t\t\tsb.append(str.charAt(i));\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\t\n\tif(str == null){\n\t\treturn null;\n\t}\n\t\n\tint start = 0;\n\tint end = str.length();\n\t\n\twhile(start < end){\n\t\tif(str.charAt(start) == leadingCharacter){\n\t\t\t// Start of the match\n\t\t\tstart++;\n\t\t} else {\n\t\t\t// End of the match\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(start == end){\n\t\treturn str;\n\t} else {\n\t\treturn str.substring(start, end);\n\t}\n\t\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tif(str == null){\n\t\treturn null;\n\t}\n\tif(str.length() == 0){\n\t\treturn null;\n\t}\n\tint endIndex = str.length()-1;\n\twhile(endIndex > 0 && str.charAt(endIndex) == leadingCharacter){\n\t\tendIndex--;\n\t}\n\treturn str.substring(0,endIndex+1);\n}"]}
{"_id": "636767691a6d9265ec0181a6", "generate_results": ["public static String[] split(String toSplit,String delimiter){\n\tint index=toSplit.indexOf(delimiter);\n\tif(index<0){\n\t\treturn null;\n\t}\n\t\n\tString[] split=new String[2];\n\tsplit[0]=toSplit.substring(0,index);\n\tsplit[1]=toSplit.substring(index+delimiter.length(),toSplit.length());\n\treturn split;\n}", "public static String[] split(String toSplit,String delimiter){\n\t\n\tint index = toSplit.indexOf(delimiter);\n\t\n\tif(index==0){\n\t\treturn null;\n\t}else if(index==toSplit.length()){\n\t\treturn new String[]{toSplit};\n\t}else{\n\t\treturn new String[]{toSplit.substring(0,index),toSplit.substring(index+delimiter.length())};\n\t}\n}", "public static String[] split(String toSplit,String delimiter){\n\t\n\tString[] split = split(toSplit,delimiter);\n\tif(split!=null){\n\t\tString[] result = new String[2];\n\t\tfor(int i=0;i<split.length;i++){\n\t\t\tresult[0] = split[i];\n\t\t\tif(i==0)\n\t\t\t\tresult[1] = delimiter;\n\t\t\telse\n\t\t\t\tresult[1] = delimiter+result[1];\n\t\t}\n\t\treturn result;\n\t}\n\treturn null;\n}", "public static String[] split(String toSplit,String delimiter){\n\tif(delimiter.length()==0){\n\t\treturn null;\n\t}\n\t\n\tint index=toSplit.indexOf(delimiter);\n\t\n\tif(index==-1){\n\t\treturn null;\n\t}\n\t\n\tString[] split=new String[2];\n\t\n\tsplit[0]=toSplit.substring(0,index);\n\tsplit[1]=toSplit.substring(index+delimiter.length());\n\treturn split;\n}", "public static String[] split(String toSplit,String delimiter){\n\treturn split(toSplit,delimiter,0);\n}", "public static String[] split(String toSplit,String delimiter){\n\tString[] result = new String[2];\n\tint i=0;\n\twhile(toSplit.indexOf(delimiter)!= -1){\n\t\tresult[i]=toSplit.substring(0,toSplit.indexOf(delimiter));\n\t\ttoSplit = toSplit.substring(toSplit.indexOf(delimiter)+1);\n\t\ti++;\n\t}\n\tresult[i]=toSplit;\n\treturn result;\n}", "public static String[] split(String toSplit,String delimiter){\n\t\n\tint index = 0;\n\tString[] split = null;\n\t\n\t// find the delimiter\n\tindex = toSplit.indexOf(delimiter);\n\t\n\tif(index == -1){\n\t\treturn null;\n\t}\n\t\n\tsplit = new String[2];\n\t\n\tsplit[0] = toSplit.substring(0,index);\n\tsplit[1] = toSplit.substring(index+delimiter.length());\n\t\n\treturn split;\n}", "public static String[] split(String toSplit,String delimiter){\n\tStringBuilder sb=new StringBuilder();\n\tboolean delimiterFound=false;\n\twhile(index<toSplit.length()){\n\t\tindex=toSplit.indexOf(delimiter,index);\n\t\tif(index>=0) {\n\t\t\tindex1=index+delimiter.length();\n\t\t\tdelimiterFound=true;\n\t\t\tsb.append(toSplit.substring(index,index1));\n\t\t}\n\t\telse index1=index;\n\t}\n\tif(delimiterFound){\n\t\tsb.append(toSplit.substring(index1));\n\t}\n\treturn", "public static String[] split(String toSplit,String delimiter){\n\tif(toSplit==null || toSplit.length()<1) return null;\n\tint beforeIndex = toSplit.indexOf(delimiter);\n\tint afterIndex = beforeIndex;\n\tint indexOfDelimiter;\n\t\n\tif(beforeIndex==-1) indexOfDelimiter=toSplit.length();\n\telse {\n\t\tbeforeIndex++;\n\t\tafterIndex=toSplit.indexOf(delimiter,beforeIndex);\n\t\tif(afterIndex==-1) indexOfDelimiter=toSplit.length();\n\t\telse indexOfDelimiter=beforeIndex;\n\t}\n\t\n\tString[] result = new String[2];\n\tresult[0]=toSplit.substring(0,beforeIndex);\n\tresult[1]=toSplit.substring(afterIndex+delimiter.length());\n\treturn result;\n}", "public static String[] split(String toSplit,String delimiter){\n\t\n\t\n\tint index=0;\n\tString[] split=new String[2];\n\n\tif(toSplit!=null){\n\t\t\n\t\tindex=toSplit.indexOf(delimiter);\n\t\t\n\t\tif(index!=0){\n\t\t\t\n\t\t\tsplit[0]=toSplit.substring(0,index);\n\t\t\tsplit[1]=toSplit.substring(index+delimiter.length());\n\t\t}\n\t\telse{\n\t\t\tsplit[0]=toSplit.substring(0);\n\t\t\tsplit[1]=null;\n\t\t}\n\t}\n\t\n\treturn split;\n}"]}
{"_id": "636767691a6d9265ec0181ac", "generate_results": ["public static String applyRelativePath(String path,String relativePath){\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tif (path!= null) {\n\t\tif (path.length() > 1) {\n\t\t\tchar sep = path.charAt(0);\n\t\t\tif (sep == '/' || sep == '\\\\') {\n\t\t\t\tsb.append(path);\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t\tint index = path.indexOf(sep);\n\t\t\tif (index > 0) {\n\t\t\t\tsb.append(path.substring(0, index));\n\t\t\t\tsb.append(relativePath);\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(path);\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsb.append(path);\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\telse {\n\t\tsb.append(path);\n\t\treturn sb.toString();\n\t}\n\t\n}", "public static String applyRelativePath(String path,String relativePath){\n\t\n\tif(relativePath.equals(\"\")){\n\t\treturn path;\n\t}\n\t\n\tint pos=path.lastIndexOf(\"/\");\n\tif(pos>=0){\n\t\treturn path.substring(pos+1, path.length());\n\t}else{\n\t\treturn path;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\tif (relativePath.length() == 0) return path;\n\t\n\tString[] parts = relativePath.split(\"/\");\n\t\n\tif (parts.length == 1) return path;\n\n\tfor (int i = 0; i < parts.length - 1; i++) {\n\t\tString part = parts[i];\n\t\tfor (int j = i + 1; j < parts.length; j++) {\n\t\t\tString nextPart = parts[j];\n\t\t\tif (part.equals(nextPart)) {\n\t\t\t\t// skip this part\n\t\t\t} else if (part.equals(\"..\")) {\n\t\t\t\t// parent of this part\n\t\t\t\tpath = nextPart;\n\t\t\t\tbreak;\n\t\t\t} else if (part.equals(\".\")) {\n\t\t\t\t// this part\n\t\t\t\tpath = nextPart;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// add a separator\n\t\t\t\tpath = path + \"/\" + nextPart;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn path;\n\t\n}", "public static String applyRelativePath(String path,String relativePath){\n\tif (path.equals(\"\")) return relativePath;\n\t\n\tif (relativePath.startsWith(\"/\")) return path;\n\t\n\tString[] pathParts = StrUtils.split(path, \"/\");\n\tString[] relativePathParts = StrUtils.split(relativePath, \"/\");\n\t\n\t// if the path starts with a \"/\", it's relative\n\tif (pathParts.length == 0) {\n\t\treturn relativePathParts.length == 0? path : new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (pathParts.length == 1) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (pathParts.length == 2) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 0) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 1) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 2) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 3) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 4) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 5) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 6) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\t// if the path starts with a \"/\", it's relative to the current path\n\tif (relativePathParts.length == 7) {\n\t\treturn new File(path).getAbsolutePath();\n\t}\n\t\n\treturn path;\n}", "public static String applyRelativePath(String path,String relativePath){\n\t\n\t// If not a full file path\n\tif (relativePath.length()==0){\n\t\treturn path;\n\t}\n\t\n\t// If the path is relative to the full file path\n\tif (relativePath.startsWith(path)){\n\t\treturn path;\n\t}\n\t\n\t// Otherwise return the new path\n\t\n\treturn path + relativePath;\n}", "public static String applyRelativePath(String path,String relativePath){\n\tif (path == null || path.length() == 0) return path;\n\tString[] p = path.split(\"/\");\n\tString result = path;\n\tfor(int i = 0; i < p.length; i++){\n\t\tif (i == 0){\n\t\t\tresult = p[i];\n\t\t} else {\n\t\t\tresult = result.replace(p[i], relativePath);\n\t\t}\n\t}\n\treturn result;\n}", "public static String applyRelativePath(String path,String relativePath){\n\tStringBuilder sb = new StringBuilder();\n\tint index = path.lastIndexOf(\"/\");\n\tif (index == -1) {\n\t\tindex = path.lastIndexOf(\"\\\\\");\n\t}\n\tif (index!= -1) {\n\t\tsb.append(path.substring(0, index));\n\t}\n\tsb.append(relativePath);\n\treturn sb.toString();\n}", "public static String applyRelativePath(String path,String relativePath){\n\tpath=path.replace('\\\\','/');\n\treturn path.replace(relativePath, '/');\n}", "public static String applyRelativePath(String path,String relativePath){\n\treturn path.replace(relativePath,\"\");\n}", "public static String applyRelativePath(String path,String relativePath){\n    \n    if(path == null || relativePath == null)\n        return null;\n    \n    if(path.length() == 0)\n        return relativePath;\n    \n    char lastSlash = path.charAt(path.length() - 1);\n    if(lastSlash == '/' || lastSlash == '\\\\')\n        return path;\n    \n    String filePath = path;\n    if(filePath.startsWith(\"/\"))\n        filePath = filePath.substring(1);\n    \n    if(filePath.endsWith(\"/\"))\n        filePath = filePath.substring(0, filePath.length() - 1);\n    \n    if(filePath.endsWith(\"\\\\\"))\n        filePath = filePath.substring(0, filePath.length() - 1);\n    \n    return filePath + relativePath;\n}"]}
{"_id": "6367676b1a6d9265ec0181e9", "generate_results": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\t//System.out.println(str);\n\t//System.out.println(\"substr:\"+substring);\n\treturn str.substring(index,index+substring.length()).toString().equals(substring.toString());\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\treturn str.subSequence(index,index + substring.length()).toString().contains(substring);\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n    if(str == null || index < 0 || index >= str.length() || substring == null || substring.length() == 0) return false;\n    int start = index;\n    int end = start + substring.length();\n    while(start < str.length() && end < str.length() && substring.charAt(0) == str.charAt(start)){\n        start++;\n        end = start + substring.length();\n    }\n    return start >= index && end >= index;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\treturn substring.subSequence(index,index+substring.length()).equals(str);\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(str == null || substring == null){\n\t\treturn false;\n\t}\n\tint length = str.length();\n\tif(index < 0 || length < index){\n\t\treturn false;\n\t}\n\tboolean match = true;\n\tint start = index;\n\tfor(int i=index;i<length && match;i++){\n\t\tif(str.charAt(i)!= substring.charAt(i)){\n\t\t\tmatch = false;\n\t\t}\n\t}\n\treturn match;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif (index >= str.length() || index < 0) return false;\n\tint n = str.length() - index;\n\tif (n == 0) return false;\n\tif (n == 1) return substring.equals(str.charAt(index));\n\tfor (int i = 0; i < n; i++){\n\t\tif (!substring.regionMatches(true,index+i,str.charAt(index+i),0,1)) return false;\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\t\n\tif(str.length()<substring.length()){\n\t\treturn false;\n\t}\n\tint start=index;\n\tint end=index+substring.length();\n\tint index1=index;\n\twhile(index<end){\n\t\tif(str.charAt(index)==substring.charAt(index1)){\n\t\t\tindex++;\n\t\t\tindex1++;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\t\n\t\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif (index>=str.length()){\n\t\tindex=str.length();\n\t}\n\treturn substring.charAt(index-str.length())==str.charAt(index);\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif (index < 0 || index >= str.length()){\n\t\treturn false;\n\t}\n\tint strLength = str.length();\n\tint substringLength = substring.length();\n\tint indexInStr = index;\n\tint indexInSubString = index;\n\twhile (indexInStr < strLength){\n\t\tif (substringLength == 0){\n\t\t\treturn true;\n\t\t}\n\t\tif (indexInStr >= strLength){\n\t\t\treturn false;\n\t\t}\n\t\tchar firstChar = str.charAt(indexInStr);\n\t\tchar secondChar = substring.charAt(indexInSubString);\n\t\tif (firstChar!= secondChar){\n\t\t\treturn false;\n\t\t}\n\t\tindexInStr++;\n\t\tindexInSubString++;\n\t}\n\treturn false;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tint start = index;\n\tint end = index+substring.length();\n\tif(start<0)\n\t\treturn false;\n\tif(end<0)\n\t\tend = str.length();\n\tfor(int i=start;i<end;i++){\n\t\tif(str.charAt(i)!=substring.charAt(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"]}
{"_id": "636767821a6d9265ec0183a0", "generate_results": ["/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\ttry{\n\t\tFile file = new File(fileName);\n\t\tif(file.exists() && file.isFile()){\n\t\t\tfile.delete();\n\t\t}\n\t}\n\tcatch(Exception e){}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\t\n\tif (fileExists(fileName)) {\n\t\t\n\t\t//delete the file\n\t\t//System.out.println(\"Deleting \" + fileName);\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tSystem.out.println(\"Creating \" + fileName);\n\t\t\t\n\t\t\tFileOutputStream fos = new FileOutputStream(fileName);\n\t\t\tfos.write(\"DELETE\".getBytes());\n\t\t\tfos.close();\n\t\t\t\n\t\t} catch (FileNotFoundException e) {\n\t\t\t\n\t\t\tSystem.out.println(\"File \" + fileName + \" does not exist\");\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\tSystem.out.println(\"Unable to delete file\");\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\t\n\tFile f = new File(fileName);\n\t\n\tif (f.exists()) {\n\t\tf.delete();\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\n    File file = new File(fileName);\n    if (file.exists()) {\n        file.delete();\n    }\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif (file.exists()){\n\t\t\n\t\tif (file.isFile()){\n\t\t\t// file is a file\n\t\t\tfile.delete();\n\t\t} else if (file.isDirectory()){\n\t\t\t// file is a directory\n\t\t\tFile[] files = file.listFiles();\n\t\t\tfor (int i = 0; i < files.length; i++){\n\t\t\t\tfiles[i].delete();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\tif (fileExists(fileName)){\n\t\ttry {\n\t\t\tFileUtils.deleteFile(fileName);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\tif(CommonUtils.isEmpty(fileName)){\n\t\treturn;\n\t}\n\tFile file = new File(fileName);\n\tif(!file.exists()){\n\t\treturn;\n\t}\n\tif(file.isFile()){\n\t\tfile.delete();\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\t//System.out.println(\"deleteFile: \"+fileName);\n\tFile f = new File(fileName);\n\tif(f.exists()){\n\t\tf.delete();\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\ttry {\n\t\tFile file = new File(fileName);\n\t\tif(file.exists()){\n\t\t\tfile.delete();\n\t\t}\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t}\n}", "/** \n * Delete's the specified file if it exists \n */\n\nprotected static void deleteFile(String fileName){\n\ttry {\n\t\tFile f = new File(fileName);\n\t\tif (f.exists()){\n\t\t\tf.delete();\n\t\t}\n\t} catch (Exception e) {\n\t\tSystem.out.println(\"Error: \" + e.getMessage());\n\t}\n}"]}
{"_id": "6367677e1a6d9265ec01830f", "generate_results": ["public String format(LoggingEvent event){\n    StringBuffer sb = new StringBuffer();\n    sb.append(event.getMessage());\n    sb.append(\"\\n\");\n    List listeners = event.getSource();\n    if (listeners!= null) {\n        sb.append(\"Source: \");\n        for (Iterator i = listeners.iterator(); i.hasNext();) {\n            sb.append(((LogListener) i.next()).format(event));\n        }\n    }\n    if (event.getThrown()!= null) {\n        sb.append(\"\\nThrown:\");\n        sb.append(event.getThrown());\n    }\n    if (event.getThrowable()!= null) {\n        sb.append(\"\\nThrowable:\");\n        sb.append(event.getThrowable());\n    }\n    return sb.toString();\n}", "public String format(LoggingEvent event){\n    StringBuffer buf = new StringBuffer();\n    \n    buf.append(getPattern());\n    \n    buf.append(\" \");\n    buf.append(event.getMessage());\n    \n    buf.append(\" \");\n    buf.append(event.getLevel().toString());\n    \n    buf.append(\" \");\n    buf.append(event.getTime());\n    \n    buf.append(\" \");\n    buf.append(event.getLevel().toString());\n    \n    return buf.toString();\n}", "public String format(LoggingEvent event){\n    StringBuffer buf = new StringBuffer(event.getMessage());\n    \n    // Handle the timestamp\n    if (event.getLevel() == Level.TRACE){\n        buf.append(DateFormat.getDateTimeInstance().format(new Date(event.getTime())));\n    } else {\n        buf.append(DateFormat.getDateTimeInstance().format(new Date(System.currentTimeMillis())));\n    }\n\n    buf.append(newline);\n\n    // Handle the message text\n    buf.append(event.getMessage());\n    \n    // Handle the timestamp\n    if (event.getLevel() == Level.TRACE){\n        buf.append(newline);\n        buf.append(DateFormat.getDateTimeInstance().format(new Date(event.getTime())));\n        buf.append(newline);\n    } else {\n        buf.append(newline);\n    }\n\n    return buf.toString();\n}", "public String format(LoggingEvent event){\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(event.getLevel());\n    buffer.append(\" \");\n    buffer.append(event.getMessage());\n    buffer.append(\"\\n\");\n    return buffer.toString();\n  }", "public String format(LoggingEvent event){\n    StringBuffer buf = new StringBuffer();\n    buf.append(\"Logger: \" + event.getLoggerName() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Time: \" + event.getTime() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Throwable: \" + event.getThrowable() + \"\\n\");\n    buf.append(\"ThrowableNested: \" + event.getThrowable().getMessage() + \"\\n\");\n    buf.append(\"Thread: \" + event.getThread() + \"\\n\");\n    buf.append(\"Caller: \" + event.getCallerName() + \"\\n\");\n    buf.append(\"Source: \" + event.getSourceClassName() + \" \" + event.getSourceMethodName() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Thread: \" + event.getThread() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Thread: \" + event.getThread() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level: \" + event.getLevel() + \"\\n\");\n    buf.append(\"Message: \" + event.getMessage() + \"\\n\");\n    buf.append(\"Level", "public String format(LoggingEvent event){\n    String message = event.getMessage();\n    StringBuilder sb = new StringBuilder();\n    sb.append(message);\n    Pattern pattern = event.getPattern();\n    if(pattern == null){\n        return sb.toString();\n    }\n    Matcher matcher = pattern.matcher(message);\n    if(matcher.find()){\n        String message = matcher.group(1);\n        if(matcher.group(2)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(2));\n        }\n        if(matcher.group(3)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(3));\n        }\n        if(matcher.group(4)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(4));\n        }\n        if(matcher.group(5)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(5));\n        }\n        if(matcher.group(6)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(6));\n        }\n        if(matcher.group(7)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(7));\n        }\n        if(matcher.group(8)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(8));\n        }\n        if(matcher.group(9)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(9));\n        }\n        if(matcher.group(10)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(10));\n        }\n        if(matcher.group(11)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(11));\n        }\n        if(matcher.group(12)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(12));\n        }\n        if(matcher.group(13)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(13));\n        }\n        if(matcher.group(14)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(14));\n        }\n        if(matcher.group(15)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(15));\n        }\n        if(matcher.group(16)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(16));\n        }\n        if(matcher.group(17)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(17));\n        }\n        if(matcher.group(18)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(18));\n        }\n        if(matcher.group(19)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(19));\n        }\n        if(matcher.group(20)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(20));\n        }\n        if(matcher.group(21)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(21));\n        }\n        if(matcher.group(22)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(22));\n        }\n        if(matcher.group(23)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(23));\n        }\n        if(matcher.group(24)!= null){\n            sb.append(\"\\n\");\n            sb.append(matcher.group(24));\n        }\n        if", "public String format(LoggingEvent event){\n\t\n\tString result = \"\";\n\t\n\t//\n\t// Get the message from the event\n\t//\n\t\n\tString message = event.getMessage();\n\t\n\t//\n\t// Get the timestamp from the event\n\t//\n\t\n\tlong timestamp = event.getTime();\n\t\n\t//\n\t// Get the source object\n\t//\n\t\n\tObject source = event.getSource();\n\t\n\t//\n\t// Get the source object's class\n\t//\n\t\n\tClass<?> sourceClass = source.getClass();\n\t\n\t//\n\t// Determine the source object's type\n\t//\n\t\n\tString sourceType = sourceClass.getName();\n\t\n\t//\n\t// Build the pattern\n\t//\n\t\n\tString pattern = \"\";\n\t\n\t//\n\t// Determine the source object's type\n\t//\n\t\n\tString targetType = sourceClass.getName();\n\t\n\t//\n\t// Determine the source object's type\n\t//\n\t\n\tif (source instanceof LoggingEvent){\n\t\tLoggingEvent event = (LoggingEvent) source;\n\t\t\n\t\t//\n\t\t// Get the message from the event\n\t\t//\n\t\t\n\t\tString message = event.getMessage();\n\t\t\n\t\t//\n\t\t// Get the timestamp from the event\n\t\t//\n\t\t\n\t\tlong timestamp = event.getTime();\n\t\t\n\t\t//\n\t\t// Get the source object\n\t\t//\n\t\t\n\t\tObject source = event.getSource();\n\t\t\n\t\t//\n\t\t// Get the source object's class\n\t\t//\n\t\t\n\t\tClass<?> sourceClass = source.getClass();\n\t\t\n\t\t//\n\t\t// Determine the source object's type\n\t\t//\n\t\t\n\t\tString sourceType = sourceClass.getName();\n\t\t\n\t\t//\n\t\t// Determine the target object's type\n\t\t//\n\t\t\n\t\tString targetType = sourceClass.getName();\n\t\t\n\t\t//\n\t\t// Determine the target object's type\n\t\t//\n\t\t\n\t\tif (source instanceof LoggingEvent){\n\t\t\tLoggingEvent event = (LoggingEvent) source;\n\t\t\t\n\t\t\t//\n\t\t\t// Get the message from the event\n\t\t\t//\n\t\t\t\n\t\t\tString message = event.getMessage();\n\t\t\t\n\t\t\t//\n\t\t\t// Get the timestamp from the event\n\t\t\t//\n\t\t\t\n\t\t\tlong timestamp = event.getTime();\n\t\t\t\n\t\t\t//\n\t\t\t// Get the source object\n\t\t\t//\n\t\t\t\n\t\t\tObject source = event.getSource();\n\t\t\t\n\t\t\t//\n\t\t\t// Get the source object's class\n\t\t\t//\n\t\t\t\n\t\t\tClass<?> sourceClass = source.getClass();\n\t\t\t\n\t\t\t//\n\t\t\t// Determine the source object's type\n\t\t\t//\n\t\t\t\n\t\t\tString sourceType = sourceClass.getName();\n\t\t\t\n\t\t\t//\n\t\t\t// Determine the target object's type\n\t\t\t//\n\t\t\t\n\t\t\tString targetType = sourceClass.getName();\n\t\t\t\n\t\t\t//\n\t\t\t// Determine the target object's type\n\t\t\t//\n\t\t\t\n\t\t\tif (source instanceof LoggingEvent){\n\t\t\t\tLoggingEvent event = (LoggingEvent) source;\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Get the message from the event\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tString message = event.getMessage();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Get the timestamp from the event\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tlong timestamp = event.getTime();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Get the source object\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tObject source = event.getSource();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Get the source object's class\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tClass<?> sourceClass = source.getClass();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Determine the source object's type\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tString sourceType = sourceClass.getName();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Determine the target object's type\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tString targetType = sourceClass.getName();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// Determine the target object's type\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\tif (source instanceof LoggingEvent){\n\t\t\t\t\tLoggingEvent event = (LoggingEvent) source;\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// Get the message from the event\n\t\t\t\t\t//\n\t\t\t\t\t\n\t\t\t\t\tString message = event.getMessage();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// Get the timestamp from the event\n\t\t\t\t\t//\n\t\t\t\t\t\n\t\t\t\t\tlong timestamp = event.getTime();\n", "public String format(LoggingEvent event){\n    return \"\";\n}", "public String format(LoggingEvent event){\n    StringBuilder sb = new StringBuilder();\n    sb.append(event.getLevelName());\n    sb.append(\": \");\n    sb.append(event.getMessage());\n    sb.append(StringUtil.newLine);\n    \n    if (event.getThrowableInformation()!= null){\n        ThrowableInformation ti = event.getThrowableInformation();\n        sb.append(StringUtil.newLine);\n        sb.append(\"Throwable: \");\n        sb.append(ti.getThrowable().toString());\n    }\n    \n    if (event.getThrown()!= null){\n        Throwable throwable = event.getThrown();\n        sb.append(StringUtil.newLine);\n        sb.append(\"Thrown: \");\n        sb.append(throwable.toString());\n    }\n    \n    if (event.getThreadName()!= null){\n        sb.append(StringUtil.newLine);\n        sb.append(\"Thread: \");\n        sb.append(event.getThreadName());\n    }\n    \n    if (event.getLoggerName()!= null){\n        sb.append(StringUtil.newLine);\n        sb.append(\"Logger: \");\n        sb.append(event.getLoggerName());\n    }\n    \n    return sb.toString();\n}", "public String format(LoggingEvent event){\n\t\n\tStringBuilder buf = new StringBuilder();\n\t\n\tString type = event.getLoggerName();\n\t\n\tif (type == null) {\n\t\ttype = \"\";\n\t}\n\t\n\tbuf.append(type);\n\tbuf.append(\" [\");\n\tbuf.append(event.getLoggerName());\n\tbuf.append(\"]\");\n\t\n\tbuf.append(\" - \");\n\tbuf.append(event.getMessage());\n\t\n\tif (event.getThrown()!= null) {\n\t\tbuf.append(\" - \");\n\t\tbuf.append(event.getThrown().toString());\n\t}\n\t\n\tbuf.append(\"\\n\");\n\t\n\treturn buf.toString();\n}"]}
{"_id": "636767781a6d9265ec01823d", "generate_results": ["/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\tif(event.getLevel().compareTo(LEVEL_FINE) < 0){\n\t\t\n\t\t//write an empty line\n\t\twriteLine(\"\");\n\t\t\n\t\t//write the event timestamp\n\t\twriteLine(formatDate(event.getTimestamp()));\n\t\t\n\t\t//write the event message\n\t\twriteLine(event.getMessage());\n\t\t\n\t\t//write the exception message\n\t\twriteLine(event.getExceptionMessage());\n\t\t\n\t\t//write the exception stacktrace\n\t\twriteLine(event.getExceptionStackTrace());\n\t\t\n\t\t//write the exception class name\n\t\twriteLine(event.getExceptionClassName());\n\t\t\n\t\t//write the exception message\n\t\twriteLine(event.getExceptionMessage());\n\t}\n\telse{\n\t\t\n\t\t// write a line\n\t\twriteLine(event.getMessage());\n\t\t\n\t\t// write the exception stacktrace\n\t\twriteLine(event.getExceptionStackTrace());\n\t\t\n\t\t// write the exception class name\n\t\twriteLine(event.getExceptionClassName());\n\t\t\n\t\t// write the exception message\n\t\twriteLine(event.getExceptionMessage());\n\t}\n}", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\tString message = event.getLoggerName() + \" \" + event.getLoggerLevel() + \" \"\n\t+ event.getLevel().getName() + \" \" + event.getLoggerMessage();\n\t\n\tif (event.getMessage()!= null){\n\t\tmessage += \" [\" + event.getMessage() + \"]\";\n\t}\n\t\n\tif (event.getThrowable()!= null){\n\t\tmessage += \" [\" + event.getThrowable() + \"]\";\n\t}\n\t\n\tif (event.getThrown()!= null){\n\t\tmessage += \" [\" + event.getThrown() + \"]\";\n\t}\n\t\n\tif (event.getThreadName()!= null){\n\t\tmessage += \" [\" + event.getThreadName() + \"]\";\n\t}\n\t\n\tif (event.getThread()!= null){\n\t\tmessage += \" [\" + event.getThread() + \"]\";\n\t}\n\t\n\tif (event.getLoggerName().equals(Logger.ROOT_LOGGER_NAME)){\n\t\tmessage += \" [\" + Logger.ROOT_LOGGER_NAME + \"]\";\n\t}\n\t\n\tif (event.getTimeMillis()!= null){\n\t\tmessage += \" [\" + event.getTimeMillis() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(Logger.ROOT_LOGGER_NAME)){\n\t\tmessage += \" [\" + Logger.ROOT_LOGGER_NAME + \"]\";\n\t}\n\t\n\tif (event.getLoggerName().equals(event.getLoggerName())){\n\t\tmessage += \" [\" + event.getLoggerName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLoggerName().equals(Logger.ROOT_LOGGER_NAME)){\n\t\tmessage += \" [\" + Logger.ROOT_LOGGER_NAME + \"]\";\n\t}\n\t\n\tif (event.getTimeMillis()!= null){\n\t\tmessage += \" [\" + event.getTimeMillis() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(Logger.ROOT_LOGGER_NAME)){\n\t\tmessage += \" [\" + Logger.ROOT_LOGGER_NAME + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLoggerName().equals(Logger.ROOT_LOGGER_NAME)){\n\t\tmessage += \" [\" + Logger.ROOT_LOGGER_NAME + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif (event.getLevel().getName().equals(event.getLevel().getName())){\n\t\tmessage += \" [\" + event.getLevel().getName() + \"]\";\n\t}\n\t\n\tif", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\tif(event.getLevel()==LoggingEvent.ERROR){\n\t\t// do nothing\n\t}else if(event.getLevel()==LoggingEvent.WARNING){\n\t\t// write warning\n\t\twriteWarning(event);\n\t}else if(event.getLevel()==LoggingEvent.INFO){\n\t\t// write info\n\t\twriteInfo(event);\n\t}else if(event.getLevel()==LoggingEvent.DEBUG){\n\t\t// write debug\n\t\twriteDebug(event);\n\t}else{\n\t\t// write normal\n\t\twriteNormal(event);\n\t}\n}", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\tif(event.getLevel().equals(Level.ERROR)){\n\t\tSystem.err.println(\"Error: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.FATAL)){\n\t\tSystem.err.println(\"FATAL: \"+event.getLoggerName());\n\t\tif(event.getThrown()!= null){\n\t\t\tSystem.err.println(\"Thrown: \"+event.getThrown().getMessage());\n\t\t}\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.WARN)){\n\t\tSystem.err.println(\"WARN: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.INFO)){\n\t\tSystem.err.println(\"INFO: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.DEBUG)){\n\t\tSystem.err.println(\"DEBUG: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.ALL)){\n\t\tSystem.err.println(\"ALL: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.OFF)){\n\t\tSystem.err.println(\"OFF: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.LOG)){\n\t\tSystem.err.println(\"LOG: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.INFO)){\n\t\tSystem.err.println(\"INFO: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.FATAL)){\n\t\tSystem.err.println(\"FATAL: \"+event.getLoggerName());\n\t\tif(event.getThrown()!= null){\n\t\t\tSystem.err.println(\"Thrown: \"+event.getThrown().getMessage());\n\t\t}\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.ALL)){\n\t\tSystem.err.println(\"ALL: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.OFF)){\n\t\tSystem.err.println(\"OFF: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.LOG)){\n\t\tSystem.err.println(\"LOG: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.FATAL)){\n\t\tSystem.err.println(\"FATAL: \"+event.getLoggerName());\n\t\tif(event.getThrown()!= null){\n\t\t\tSystem.err.println(\"Thrown: \"+event.getThrown().getMessage());\n\t\t}\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.ALL)){\n\t\tSystem.err.println(\"ALL: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.OFF)){\n\t\tSystem.err.println(\"OFF: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.LOG)){\n\t\tSystem.err.println(\"LOG: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.FATAL)){\n\t\tSystem.err.println(\"FATAL: \"+event.getLoggerName());\n\t\tif(event.getThrown()!= null){\n\t\t\tSystem.err.println(\"Thrown: \"+event.getThrown().getMessage());\n\t\t}\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.ALL)){\n\t\tSystem.err.println(\"ALL: \"+event.getLoggerName());\n\t\treturn;\n\t}\n\tif(event.getLevel().equals(Level.OFF)){\n\t\tSystem.err.println(\"OFF: \"+event.getLoggerName());\n\t\treturn", "public void subAppend(LoggingEvent event) {\n\t\n\tif (event.getLevel().equals(Level.SEVERE)) {\n\t\tif (verbose)\n\t\t\tout.println(event.getMessage());\n\t\telse\n\t\t\tout.println(\"ERROR: \"+event.getMessage());\n\t}\n\telse {\n\t\tif (verbose)\n\t\t\tout.println(event.getMessage());\n\t\telse\n\t\t\tout.println(\"INFO: \"+event.getMessage());\n\t}\n}", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\tif (event.getLevel().compareTo(Level.INFO) <= 0) {\n\t\tif (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\t// if (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t// }\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\tif (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t\t// if (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\tif (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\t// if (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t// }\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\t\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\t\t// if (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event, Throwable t){\n\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\tif (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\t// if (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t// }\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (event.getLevel().compareTo(Level.WARN) <= 0) {\n\t\t\t\t// if (event.getLevel().compareTo(Level.ERROR) <= 0) {\n\t\t\t\tif (event.getLevel().compareTo(Level.FATAL) <= 0) {\n\t\t\t\t\t// if (event.getLevel().compareTo(Level.DEBUG) <= 0) {\n\t\t\t\t\t// \tSystem.out.println(\"[LoggingEvent] \" + event.getMessage());\n\t\t\t\t\tSystem.out.println(event.getMessage());\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n}\n", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n    // write the content of the event\n    // (i.e. write the message, then the timestamp, then the event name)\n    // for example, event.getMessage()\n    //   + event.getMessage() + event.getTimestamp() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLoggerName() + event.getLoggerName()\n    //   + event.getLoggerName() + event.getLoggerName()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   + event.getLevel().toString() + event.getLevel().toString()\n    //   ", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\t// get the timestamp\n\tlong timestamp = event.getTime();\n\t\n\t// write to the database\n\tStringBuffer logData = new StringBuffer();\n\tlogData.append(\"<\" + event.getLevel().getName() + \">\");\n\tlogData.append(new Date(timestamp+10*1000)); // timestamp is in seconds, not milliseconds\n\tlogData.append(event.getMessage());\n\tlogData.append(\"<\"+event.getLevel().getName()+\">\");\n\tlogData.append(event.getThrowable().getMessage());\n\tlogData.append(\"<\"+event.getThrowable().getClass().getName()+\">\");\n\tlogData.append(event.getThrowable().getStackTrace()[0].getClassName()+\"\\n\");\n\tlogData.append(event.getThrowable().getStackTrace()[0].getMethodName()+\"\\n\");\n\tlogData.append(event.getThrowable().getStackTrace()[0].getLineNumber()+\"\\n\");\n\tlogData.append(\"</\"+event.getLevel().getName()+\">\");\n\tthis.database.write(logData.toString());\n\n\t// log the event\n\tthis.logger.log(event);\n\t\n}", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n\t\n\t//log.debug(\"SubAppend(\"+event+\")\");\n\t\n\t// get the event's level\n\tint level = event.getLevel();\n\t\n\t// get the event's message\n\tString message = event.getMessage();\n\t\n\t// get the event's timestamp\n\tlong ts = event.getTimeStamp();\n\t\n\t// get the event's thread\n\tThread t = event.getThread();\n\t\n\t// get the event's source\n\tString source = event.getSourceClassName();\n\t\n\t// get the event's thread name\n\tString threadName = event.getThreadName();\n\t\n\t// get the event's source's name\n\tString sourceName = event.getSourceMethodName();\n\t\n\t// get the event's thread's name\n\tString threadName1 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName2 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName3 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName4 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName5 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName6 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName7 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName8 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName9 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName10 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName11 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName12 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName13 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName14 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName15 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName16 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName17 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName18 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName19 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName20 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName21 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName22 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName23 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName24 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName25 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName26 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName27 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName28 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName29 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName30 = event.getThread().getName();\n\t\n\t// get the event's thread's name\n\tString threadName31 = event", "/** \n * This method does actual writing\n */\n\nprotected void subAppend(LoggingEvent event){\n  \n  assert (event.getLogger().getLoggerBlock());\n  \n  try {\n    \n    event.getLogger().getLoggerBlock().append(event.getMessage());\n    \n  } catch (IOException e) {\n    \n    event.printStackTrace();\n    \n  }\n  \n}"]}
{"_id": "636767831a6d9265ec0183c9", "generate_results": ["public static String peek_and_remove_and_get_and_get_and_get(){\n\tString diagnostic_context = peek();\n\tif(diagnostic_context == \"\" || diagnostic_context == null){\n\t\treturn \"\";\n\t}\n\telse{\n\t\treturn diagnostic_context.substring(0, diagnostic_context.length() - 1) + \" \" + diagnostic_context.substring(diagnostic_context.length() -1, diagnostic_context.length()) + \" \" + diagnostic_context.substring(diagnostic_context.length() -1, diagnostic_context.length() -1) + \" \" + diagnostic_context.substring(diagnostic_context.length() -1, diagnostic_context.length());\n\t}\n}", "public static String peek(){\n\treturn (String)NDC.peek();\n}", "public static String peek(){\n\treturn getContext();\n}", "public static String topDeep(){\n\t\n\tString p = peek();\n\t\n\tif(p == null){\n\t\treturn \"\";\n\t}\n\t\n\treturn p;\n}", "public static String peek(){\n\treturn NDC.getLast();\n}", "public static String peek(){\n    \n    return _last.peek();\n}", "public static String peek(){\n\tif(!NDC.DEBUG) return \"\";\n\t\n\tString last = NDC.getLast();\n\t\n\tif(last!= \"\" && last.length() > 0) return last;\n\treturn \"\";\n}", "public static String peek(){\n\tif(null == ndc){\n\t\treturn \"\";\n\t}\n\tString result = ndc.getValue();\n\tif(null == result){\n\t\treturn \"\";\n\t}\n\treturn result;\n}", "public static String peek(){\n\tif (dcStack.size() == 0) return \"\";\n\treturn dcStack.get(dcStack.size() - 1);\n}", "public static String peek(){\n    return NDC.peek();\n}"]}
{"_id": "6367677e1a6d9265ec01832e", "generate_results": ["public Logger exists(String name){\n\tLogger logger;\n\t\n\tif (name!=null){\n\t\tlogger=getLogger(name);\n\t\tif (logger==null)\n\t\t\tlogger=this;\n\t}\n\telse{\n\t\tlogger=this;\n\t}\n\treturn logger;\n}", "public boolean exists(String name){\n\treturn exists(name).isPresent();\n}", "public Logger exists(String name){\n\treturn _loggers.get(name);\n}", "public Logger exists(String name){\n    \n    return Logger.get(name);\n}", "public Logger exists(String name){\n\treturn logger.getLogger(name);\n}", "public Logger exists(String name){\n\t\n\tif(loggers.containsKey(name)){\n\t\treturn loggers.get(name);\n\t}\n\telse{\n\t\treturn null;\n\t}\t\n}", "public Logger exists(String name){\n\tLogger.LOG.fine(\"Checking if \" + name + \" exists in hierarchy\");\n\tfor(Logger logger : Logger.LOG.values()){\n\t\tif(logger.getName().equals(name)){\n\t\t\treturn logger;\n\t\t}\n\t}\n\treturn null;\n}", "public boolean exists(String name){\n    return false;\n}", "public Logger exists(String name){\n\treturn logger.getLogger(name);\n}", "public Logger exists(String name){\n    \n    if(this.loggers.containsKey(name)){\n        return this.loggers.get(name);\n    }\n    return null;\n}"]}
{"_id": "6367677b1a6d9265ec0182bd", "generate_results": ["public String format(final LoggingEvent event){\n\n  StringWriter writer = new StringWriter();\n\n  try{\n    event.printStackTrace(new PrintWriter(writer));\n  }\n  catch(Exception e){\n    event.printStackTrace();\n  }\n\n  return writer.toString();\n}", "public String format(final LoggingEvent event){\n\n\tfinal StringBuilder sb = new StringBuilder();\n\tsb.append(\"Event: \").append(event.getMessage()).append(\"\\n\");\n\tsb.append(\"Level: \").append(event.getLevel().toString()).append(\"\\n\");\n\tsb.append(\"Time: \").append(String.valueOf(event.getTime())).append(\"\\n\");\n\tsb.append(\"Message: \").append(event.getMessage()).append(\"\\n\");\n\tsb.append(\"Throwable: \").append(event.getThrowable().toString()).append(\"\\n\");\n\tsb.append(\"Thread: \").append(event.getThread()).append(\"\\n\");\n\tsb.append(\"Level: \").append(event.getLevel()).append(\"\\n\");\n\tsb.append(\"Stacktrace: \").append(event.getTrace()).append(\"\\n\");\n\treturn sb.toString();\n}", "public String format(final LoggingEvent event){\n    final StringBuilder result = new StringBuilder();\n    appendFormat(event, result);\n    return result.toString();\n}", "public String format(final LoggingEvent event){\n    return event.getMessage() + \"\\n\\t\" + event.getLevel().getName() + \": \" + event.getThreadName() + \": \" + event.getLoggerName() + \": \" + event.getThrowable();\n}", "public String format(final LoggingEvent event){\n    \n    StringWriter writer = new StringWriter();\n    \n    String message = event.getMessage() == null? \"\" : event.getMessage();\n    \n    writer.write(message);\n    \n    if (event.getLoggerName()!= null){\n        writer.write(event.getLoggerName());\n        writer.write(\".\");\n    }\n    \n    writer.write(\" \");\n    writer.write(event.getLevel().toString());\n    \n    if (event.getThrowable()!= null){\n        writer.write(\" \");\n        writer.write(event.getThrowable().getMessage());\n        writer.write(\" \");\n        writer.write(event.getThrowable().getClass().getName());\n        writer.write(\" \");\n        writer.write(event.getThrowable().getStackTrace()[0].getClassName());\n        writer.write(\" \");\n        writer.write(event.getThrowable().getStackTrace()[0].getMethodName());\n    }\n    \n    writer.close();\n    \n    return writer.toString();\n}", "public String format(final LoggingEvent event){\n\t// Create a StringBuilder to hold this event.\n\tStringBuilder buffer = new StringBuilder(100);\n\n\t// Append the event type.\n\tbuffer.append(event.getLevel().toString());\n\n\t// Append the message.\n\tbuffer.append(event.getMessage());\n\n\t// Append the thread name.\n\tfinal String threadName = event.getThreadName();\n\tif (threadName!= null)\n\t\tbuffer.append(\" (\").append(threadName).append(\")\");\n\n\t// Append the throwable.\n\tfinal Throwable throwable = event.getThrowable();\n\tif (throwable!= null)\n\t\tbuffer.append(\" (\").append(throwable).append(\")\");\n\n\t// Append the stack trace.\n\tfinal StackTraceElement[] stackTrace = event.getStackTrace();\n\tif (stackTrace!= null)\n\t\tbuffer.append(\" (\").append(toString(stackTrace)).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String source = event.getSource();\n\tif (source!= null)\n\t\tbuffer.append(\" (\").append(source).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String caller = event.getCaller();\n\tif (caller!= null)\n\t\tbuffer.append(\" (\").append(caller).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String thread = event.getThread();\n\tif (thread!= null)\n\t\tbuffer.append(\" (\").append(thread).append(\")\");\n\n\t// Append the thread name.\n\tfinal String threadName = event.getThreadName();\n\tif (threadName!= null)\n\t\tbuffer.append(\" (\").append(threadName).append(\")\");\n\n\t// Append the exception.\n\tfinal Throwable throwable = event.getThrowable();\n\tif (throwable!= null)\n\t\tbuffer.append(\" (\").append(toString(throwable)).append(\")\");\n\n\t// Append the stack trace.\n\tfinal StackTraceElement[] stackTrace = event.getStackTrace();\n\tif (stackTrace!= null)\n\t\tbuffer.append(\" (\").append(toString(stackTrace)).append(\")\");\n\n\t// Append the exception.\n\tfinal Throwable throwable = event.getThrowable();\n\tif (throwable!= null)\n\t\tbuffer.append(\" (\").append(toString(throwable)).append(\")\");\n\n\t// Append the exception.\n\tfinal String source = event.getSource();\n\tif (source!= null)\n\t\tbuffer.append(\" (\").append(source).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String caller = event.getCaller();\n\tif (caller!= null)\n\t\tbuffer.append(\" (\").append(caller).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String thread = event.getThread();\n\tif (thread!= null)\n\t\tbuffer.append(\" (\").append(thread).append(\")\");\n\n\t// Append the thread name.\n\tfinal String threadName = event.getThreadName();\n\tif (threadName!= null)\n\t\tbuffer.append(\" (\").append(threadName).append(\")\");\n\n\t// Append the exception.\n\tfinal Throwable throwable = event.getThrowable();\n\tif (throwable!= null)\n\t\tbuffer.append(\" (\").append(toString(throwable)).append(\")\");\n\n\t// Append the exception.\n\tfinal String source = event.getSource();\n\tif (source!= null)\n\t\tbuffer.append(\" (\").append(source).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String caller = event.getCaller();\n\tif (caller!= null)\n\t\tbuffer.append(\" (\").append(caller).append(\")\");\n\n\t// Append the source of the exception.\n\tfinal String thread = event.getThread();\n\tif (thread!= null)\n\t\tbuffer.append(\" (\").append(thread).append(\")\");\n\n\t// Append the stack trace.\n\tfinal StackTraceElement[] stackTrace = event.getStackTrace();\n\tif (stackTrace!= null)\n", "public String format(final LoggingEvent event){\n\n    StringBuffer sb = new StringBuffer();\n\n    sb.append(\"Level: \");\n    sb.append(event.getLevel().getName());\n    sb.append(\"\\n\");\n\n    sb.append(\"Message: \");\n    sb.append(event.getMessage());\n    sb.append(\"\\n\");\n\n    sb.append(\"Logger: \");\n    sb.append(event.getLoggerName());\n    sb.append(\"\\n\");\n\n    sb.append(\"Time: \");\n    sb.append(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss z\").format(new Date(event.getTimeStamp())));\n    sb.append(\"\\n\");\n\n    sb.append(\"Message: \");\n    sb.append(event.getMessage());\n    sb.append(\"\\n\");\n\n    return sb.toString();\n}", "public String format(final LoggingEvent event){\n\n    StringWriter writer = new StringWriter();\n    try {\n        event.getMessage().getFormatter().format(event, writer);\n    } catch (java.text.ParseException ex) {\n        // This should never happen..\n        throw new IllegalArgumentException(ex);\n    }\n\n    return writer.toString();\n}", "public String format(final LoggingEvent event){\n\t\n\tStringBuilder sb=new StringBuilder();\n\tsb.append(event.getLevel().toString());\n\tsb.append(\" \");\n\tsb.append(event.getMessage());\n\tsb.append(\"\\n\");\n\tsb.append(event.getThrowableInformation().toString());\n\tsb.append(\"\\n\");\n\tsb.append(event.getParameters());\n\t\n\treturn sb.toString();\n}", "public String format(final LoggingEvent event){\n    StringBuilder buf = new StringBuilder();\n    buf.append(event.getLevel().getName());\n\n    buf.append(\": \");\n\n    buf.append(event.getMessage());\n\n    if(event.getThrowable()!= null){\n        buf.append(\": \");\n\n        buf.append(event.getThrowable().getMessage());\n        buf.append(\": \");\n\n        buf.append(event.getThrowable().getClass().getName());\n        buf.append(\"(message: \");\n        buf.append(event.getThrowable().getMessage());\n        buf.append(\", cause: \");\n        buf.append(event.getThrowable().getCause()!= null? event.getThrowable().getCause().getMessage() : \"\");\n        buf.append(\", stacktrace: \");\n        buf.append(event.getThrowable().getStackTrace()!= null? event.getThrowable().getStackTrace() : \"\");\n        buf.append(\")\");\n    }\n\n    return buf.toString();\n}"]}
{"_id": "636767791a6d9265ec018263", "generate_results": ["/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tif (className == null) {\n\t\tthrow new NullPointerException(\"className must not be null\");\n\t}\n\tClass c = null;\n\ttry {\n\t\tc = Class.forName(className);\n\t} catch (ClassNotFoundException e) {\n\t\tthrow new ClassNotFoundException(\"Class \" + className + \" not found\");\n\t}\n\treturn c;\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\treturn this.findClass(className, null);\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\tClass<?> clazz = null;\n\ttry {\n\t\tclazz = classLoader.loadClass(className);\n\t} catch (ClassNotFoundException e) {\n\t\t// ignore exception\n\t\treturn null;\n\t}\n\t\n\treturn clazz;\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    Class c = null;\n    try {\n        c = Class.forName(className);\n    } catch (ClassNotFoundException e) {\n        throw new ClassNotFoundException(className);\n    }\n    return c;\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\tif (loader == null) {\n\t\tloader = ClassLoader.getSystemClassLoader();\n\t}\n\treturn loader.loadClass(className);\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tif (className == null) {\n\t\tthrow new NullPointerException(\"className must not be null\");\n\t}\n\tif (className.length() == 0) {\n\t\tthrow new IllegalArgumentException(\"className must not be empty\");\n\t}\n\n\t// try to find it in the path\n\tClass clazz = findClassInPath(className);\n\tif (clazz == null) {\n\t\ttry {\n\t\t\tclazz = findClass(className.replace('.', '/'));\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// if not found try the parent directories\n\t\t\tString path = className.replace('.', '/');\n\t\t\tclazz = findClassInPath(path);\n\t\t}\n\t}\n\tif (clazz == null) {\n\t\tthrow new ClassNotFoundException(className);\n\t}\n\treturn clazz;\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    if (cl == null) {\n        cl = ClassLoader.getSystemClassLoader();\n    }\n    return cl.loadClass(className);\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    return findClass(className, null);\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n  return findClass(className, null);\n}", "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n\nprivate Class findClass(final String className) throws ClassNotFoundException {\n    Class c = null;\n    try {\n        c = Class.forName(className);\n    } catch (ClassNotFoundException x) {\n        throw x;\n    } catch (Throwable x) {\n        throw new ClassNotFoundException(className);\n    }\n    return c;\n}"]}
{"_id": "636767791a6d9265ec018257", "generate_results": ["public void addMessage(final LogRecord lr){\n    \n    final String log = lr.getMessage();\n           \n    if(!log.equals(\"\")){\n        \n       // System.out.println(\"Log Table : log = \" + log);\n       \n        if(SwingThread.currentThread().equals(logTable.getSwingThread())){\n            \n            logTable.addMessage(new LogMessage(lr));\n            \n        }else{\n            \n            // System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is not the LogTable's thread\");\n        }\n        \n    }\n    \n}", "public void addMessage(final LogRecord lr){\n  requestQueue.addRequest(new Runnable(){\n    public void run() {\n      try {\n        if (lr.getLoggerName().equals(LogTable.getLoggerName())){\n          if (lr.getThrown()!= null) {\n            SwingUtilities.invokeLater(new Runnable() {\n              public void run() {\n                LogTable.getLogger().log(lr);\n              }\n            });\n          } else {\n            LogTable.getLogger().log(lr);\n          }\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  });\n}", "public void addMessage(final LogRecord lr){\n    for(LogMessage m: this.logMessages){\n        if(lr.getMessage().equals(m.getMessage())){\n            this.logTable.add(lr);\n            return;\n        }\n    }\n    this.logTable.add(lr);\n}", "public void addMessage(final LogRecord lr){\n    if(lr==null){\n        return;\n    }\n    synchronized (LogRecords){\n        LogRecords.add(lr);\n    }\n}", "public void addMessage(final LogRecord lr){\n    //post the message to the Swing thread\n    SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n            LogRecord lr2 = lr;\n            lr2.addLogRecord();\n        }\n    });\n}", "public void addMessage(final LogRecord lr){\n    synchronized(this){\n        if(!this.isRecording()){\n            this.setRecording(true);\n            this.recordingLog.add(lr);\n        }else{\n            this.recordingLog.add(lr);\n        }\n    }\n}", "public void addMessage(final LogRecord lr){\n\tsynchronized(this){\n\t\tif(lr.getMessage() == null){\n\t\t\treturn;\n\t\t}\n\t\tif(!this.message.contains(lr.getMessage())){\n\t\t\tfinal int index = this.message.size();\n\t\t\tthis.message.add(lr.getMessage());\n\t\t\tthis.message.set(index, lr.getMessage());\n\t\t}\n\t\t\n\t\t// If the message is filtered, don't post the message\n\t\tif(!this.filter.matches(lr.getMessage())){\n\t\t\tthis.postMessage(lr.getMessage());\n\t\t}\n\t}\n}", "public void addMessage(final LogRecord lr){\n    //Get the SwingThread\n    final SwingThread s = SwingThread.getSwingThread();\n    if(s!=null)\n        s.addMessage(lr);\n    else\n        System.out.println(\"The SwingThread is null, cannot add the LogRecord to the table.\");\n}", "public void addMessage(final LogRecord lr){\n\tif(isLoggedIn()){\n\t\tif(lr.getMessage().length() > 0){\n\t\t\tLogTable.getInstance().getLogTable().addMessage(lr);\n\t\t}\n\t}\n}", "public void addMessage(final LogRecord lr){\n\t\n\tfinal SwingThread _s = getSwingThread();\n\t_s.run(_s.newMessage(lr));\n}"]}
{"_id": "636767841a6d9265ec0183ff", "generate_results": ["public static void deselectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.setViewportView(table);\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif(table==null) return;\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(pane.getViewport().getViewRect());\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\t\n\ttable.setRowSelectionInterval(row, row);\n\tpane.getVerticalScrollBar().setValue(table.getRowHeight(row)+pane.getVerticalScrollBar().getMaximum());\n\tpane.repaint();\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif(row<0){row=0;}\n\telse if(row>=table.getRowCount()){row=table.getRowCount()-1;}\n\telse{table.setRowSelectionInterval(row,row);}\n\tpane.scrollRectToVisible(table.getCellRect(row,0,true));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif(row<0){\n\t\treturn;\n\t}\n\tint tableRow = table.convertRowIndexToModel(row);\n\tint tableColumn = table.convertColumnIndexToModel(table.getColumnModel().getColumn(tableColumn).getModelIndex());\n\ttable.getSelectionModel().setSelectionInterval(tableRow,tableColumn);\n\tpane.repaint();\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row, row);\n\tpane.getVerticalScrollBar().setValue(table.getRowHeight(row) * table.getRowCount());\n\ttable.repaint();\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\tif(pane.getViewport().getViewCount()!= 1){\n\t\tthrow new IllegalArgumentException(\"Sorry, the row must belong to a JScrollPane\");\n\t}\n\tif(table.getRowCount() == 1){\n\t\tif(pane.getViewport().getViewCount()!= 0){\n\t\t\tthrow new IllegalArgumentException(\"Sorry, the row must belong to a JScrollPane\");\n\t\t}\n\t\tif(row < 0){\n\t\t\tthrow new IllegalArgumentException(\"Sorry, the row must be a number >0\");\n\t\t}\n\t\ttable.getRowSorter().setRowSelect(row);\n\t\treturn;\n\t}\n\ttable.getRowSorter().setRowSelectionInterval(row,row);\n\tpane.repaint();\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\t\n\tint selectedRow = table.convertRowIndexToModel(row);\n\t\n\t//scroll the table to the selected item\n\t\n\ttable.scrollRectToVisible(pane.getCellRect(selectedRow, 0, true));\n\t\n\t\n\t//repaint the newly selected row\n\t\n\tpane.repaint();\n\t\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.getSelectionModel().setSelectionInterval(row, row);\n\ttable.scrollRectToVisible(pane.getCellRect(row,0,true));\n\tpane.getViewport().repaint();\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\t\n\tif(table.getRowCount()>0){\n\t\tJTable table2 = (JTable)table.getTableHeader().getDefaultRenderer();\n\t\t\n\t\tif(table2.getRowCount()>0){\n\t\t\tscrollToRow(row,pane,table2);\n\t\t}\n\t}\n}"]}
{"_id": "636767871a6d9265ec01846d", "generate_results": ["public static void createConfigurationDirectory(){\n\t\n\t//Create the directory lf5\n\tString lf5 = System.getenv(\"USERPROFILE\");\n\tString lf5_path = lf5 + \"\\\\Documents and Settings\\\\\" + System.getenv(\"USERNAME\");\n\tlFolder.mkdirs();\n\tFile lf5_file = new File(lf5_path);\n\tif(!lf5_file.exists()){\n\t\tlf5_file.mkdirs();\n\t}\n\t\n\t//Create the directory lf5_path\n\tString lf5_path_path = lf5_path + \"\\\\\" + System.getenv(\"USERNAME\");\n\tFile lf5_file_path = new File(lf5_path_path);\n\tif(!lf5_file_path.exists()){\n\t\tlf5_file_path.mkdirs();\n\t}\n\t\n\t\n}", "public static void createConfigurationDirectory(){\n\tif(System.getenv(\"USERPROFILE\")!=null){\n\t\tSystem.out.println(\"The user profile directory is already created\");\n\t\treturn;\n\t}\n\tString directory = \"\";\n\tdirectory = \"Documents\";\n\tString home = \"\";\n\thome = System.getenv(\"HOMEDRIVE\") + System.getenv(\"HOMEPATH\") + System.getenv(\"USERPROFILE\");\n\tString userhome = home + System.getenv(\"HOMEPATH\") + System.getenv(\"USERPROFILE\");\n\tif(!(new File(userhome+\"\\\\AppData\\\\Local\\\\Temp\").exists())){\n\t\tif(!(new File(userhome+\"\\\\AppData\\\\Local\\\\Temp\").mkdirs())){\n\t\t\tSystem.out.println(\"Could not create directory for user profile\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif(!(new File(home+\"\\\\AppData\\\\Local\\\\Temp\").exists())){\n\t\tif(!(new File(home+\"\\\\AppData\\\\Local\\\\Temp\").mkdirs())){\n\t\t\tSystem.out.println(\"Could not create directory for user home\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif(!(new File(home+\"\\\\AppData\\\\Local\\\\Temp\").exists())){\n\t\tif(!(new File(home+\"\\\\AppData\\\\Local\\\\Temp\").mkdirs())){\n\t\t\tSystem.out.println(\"Could not create directory for user home\");\n\t\t\treturn;\n\t\t}\n\t}\n\tString userhome = home + System.getenv(\"HOMEPATH\") + System.getenv(\"USERPROFILE\");\n\tString userhome2 = home + System.getenv(\"HOMEPATH\") + System.getenv(\"USERPROFILE\");\n\tSystem.out.println(\"The user home directory is: \" + userhome);\n\tSystem.out.println(\"The user home directory is: \" + userhome2);\n\tif(!(new File(userhome+\"\\\\AppData\\\\Local\\\\Temp\").exists())){\n\t\tif(!(new File(userhome+\"\\\\AppData\\\\Local\\\\Temp\").mkdirs())){\n\t\t\tSystem.out.println(\"Could not create directory for user home\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif(!(new File(userhome2+\"\\\\AppData\\\\Local\\\\Temp\").exists())){\n\t\tif(!(new File(userhome2+\"\\\\AppData\\\\Local\\\\Temp\").mkdirs())){\n\t\t\tSystem.out.println(\"Could not create directory for user home\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttry {\n\t\tString[] list = userhome.split(\"\\\\\");\n\t\tfor(int i=0; i<list.length; i++){\n\t\t\tFile file = new File(list[i]);\n\t\t\tif(file.exists()){\n\t\t\t\tString[] list2 = list[i].split(\"\\\\\");\n\t\t\t\tString dirname = list2[1];\n\t\t\t\tdirname = dirname.substring(0, dirname.length()-1);\n\t\t\t\tFile folder = new File(userhome+\"\\\\\"+dirname);\n\t\t\t\tif(!(folder.exists())){\n\t\t\t\t\tif(!(folder.mkdirs())){\n\t\t\t\t\t\tSystem.out.println(\"Could not create directory for user home\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\ttry {\n\t\tString[] list2 = userhome2.split(\"\\\\\");\n\t\tfor(int i=0; i<list2.length; i++){\n\t\t\tFile file = new File(list2[i]);\n\t\t\tif(file.exists()){\n\t\t\t\tString[] list3 = list2[i].split(\"\\\\\");\n\t\t\t\tString dirname = list3[1];\n\t\t\t\tdirname = dirname.substring(0, dirname.length()-1);\n\t\t\t\tFile folder = new File(userhome+\"\\\\\"+dirname);\n\t\t\t\tif(!(folder.exists())){\n\t\t\t\t\tif(!(folder.mkdirs())){\n\t\t\t\t\t\tSystem", "public static void createConfigurationDirectory(){\n\tString userHome = System.getenv(\"USERPROFILE\");\n\tString directory = userHome + File.separator + \"Documents\" + File.separator + \"MRU\";\n\t\n\ttry {\n\t\tFile directoryFile = new File(directory);\n\t\tdirectoryFile.mkdirs();\n\t\t\n\t\tFile directoryFile2 = new File(directory);\n\t\tdirectoryFile2.mkdirs();\n\t} catch (Exception e) {\n\t\t// TODO Auto-generated catch block\n\t\tSystem.out.println(\"Error while creating the directory\");\n\t\te.printStackTrace();\n\t}\n}", "public static void createConfigurationDirectory(){\n\tif (System.getenv(\"SYSTEMROOT\")!= null)\n\t\tSystem.setenv(\"SystemRoot\", System.getenv(\"SystemRoot\") + \"/system\");\n\telse\n\t\tSystem.setenv(\"SystemRoot\", \"/system\");\n\n\tif (System.getenv(\"HOME\") == null)\n\t\tSystem.setenv(\"HOME\", System.getenv(\"USERPROFILE\"));\n\t\n\tcreateDirectory(new File(System.getenv(\"HOME\") + \"\\\\Documents\"));\n\tcreateDirectory(new File(System.getenv(\"HOME\") + \"\\\\Settings\"));\n}", "public static void createConfigurationDirectory(){\n    if(System.getenv(\"USERPROFILE\") == null){\n        System.setProperty(\"user.home\", \"C:\\\\Documents and Settings\\\\\");\n    }\n    System.setProperty(\"user.home\", \"C:\\\\Documents and Settings\\\\\");\n}", "public static void createConfigurationDirectory(){\n\tString lf5 = \"lf5\";\n\tString lf5_mnt = \"mnt\";\n\tFile lf5_dir = new File(lf5);\n\tlf5_dir.mkdirs();\n\tFile lf5_dir_mnt = new File(lf5_mnt);\n\tlf5_dir_mnt.mkdirs();\n\t\n\tFile lf5_dir_conf = new File(lf5_dir.getParent(), lf5_dir.getName() + \".conf\");\n\tif (!lf5_dir_conf.exists())\n\t\tlf5_dir_conf.mkdirs();\n\t\n\tFile lf5_dir_users = new File(lf5_dir.getParent(), lf5_dir.getName() + \".users\");\n\tif (!lf5_dir_users.exists())\n\t\tlf5_dir_users.mkdirs();\n}", "public static void createConfigurationDirectory(){\n\ttry {\n\t\tString path = \"\";\n\t\t\n\t\t// The \"LF5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n\t\tif (System.getenv(\"SystemDrive\")!= null) {\n\t\t\tpath = System.getenv(\"SystemDrive\");\n\t\t}\n\t\telse if (System.getenv(\"USERPROFILE\")!= null) {\n\t\t\tpath = System.getenv(\"USERPROFILE\");\n\t\t}\n\t\telse {\n\t\t\tpath = \"C:\\\\Documents and Settings\\\\\";\n\t\t}\n\t\t\n\t\t// Create the directory\n\t\tFile file = new File(path+\"MRU\\\\\");\n\t\tfile.mkdir();\n\t\t\n\t\t// Set the MRU file list to be in the same directory as the folder \"MRU\"\n\t\tFile fileMRU = new File(path+\"MRU\");\n\t\tfileMRU.mkdir();\n\t\t\n\t\t// Create the directory \"LF5\"\n\t\tFile fileLF5 = new File(path+\"LF5\");\n\t\tfileLF5.mkdir();\n\t\t\n\t} catch (Exception e) {\n\t\tSystem.out.println(\"Error: \" + e.getMessage());\n\t\te.printStackTrace();\n\t}\n\t\n}", "public static void createConfigurationDirectory(){\n\tif (System.getProperty(\"os.name\").toLowerCase().indexOf(\"win\") > -1){\n\t\tString path = \"C:\\\\Documents and Settings\\\\\" + System.getProperty(\"user.name\") + \"\\\\Application Data\\\\\" + System.getProperty(\"user.name\") + \"\\\\MRU\\\\\" + System.getProperty(\"user.name\") + \"\\\\MRU\";\n\t\tSystem.out.println(\"Creating the directory \" + path);\n\t\tnew File(path).mkdir();\n\t\tSystem.out.println(\"The directory \" + path + \" has been created.\");\n\t} else {\n\t\tString path = \"C:\\\\Documents and Settings\\\\\" + System.getProperty(\"user.name\") + \"\\\\MRU\";\n\t\tSystem.out.println(\"Creating the directory \" + path);\n\t\tnew File(path).mkdir();\n\t\tSystem.out.println(\"The directory \" + path + \" has been created.\");\n\t}\n}", "public static void createConfigurationDirectory(){\n\tif(!Util.isWindows()){\n\t\tString home = System.getenv(\"USERPROFILE\");\n\t\t\n\t\tif(home!= null){\n\t\t\tString path = home + File.separator + \"Documents\" + File.separator + \"Settings\" + File.separator + \"MRU\";\n\t\t\tFile dir = new File(path);\n\t\t\t\n\t\t\tif(dir.exists()){\n\t\t\t\tif(!dir.isDirectory()){\n\t\t\t\t\tdir.mkdirs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "public static void createConfigurationDirectory(){\n\n\tif (!isWindows()) {\n\t\t// The current directory is not a Windows machine.\n\t\tSystem.setProperty(\"user.dir\", \"C:\\\\\");\n\t\t// The current directory is not an AD in Windows.\n\t\tSystem.setProperty(\"user.home\", \"C:\\\\\");\n\t}\n\ttry {\n\t\tif (!isWindows()) {\n\t\t\t// The current directory is not a Windows machine.\n\t\t\tSystem.setProperty(\"user.dir\", \"C:\\\\Program Files\");\n\t\t\t// The current directory is not an AD in Windows.\n\t\t\tSystem.setProperty(\"user.home\", \"C:\\\\Program Files\");\n\t\t}\n\t} catch (SecurityException e) {\n\t\t// If the current directory does not exist then do nothing.\n\t}\n\tif (!isWindows()) {\n\t\t// The current directory is not an AD in Windows.\n\t\tSystem.setProperty(\"user.dir\", \"C:\\\\Program Files\");\n\t\t// The current directory is not an AD in Windows.\n\t\tSystem.setProperty(\"user.home\", \"C:\\\\Program Files\");\n\t}\n\t// The current directory is not an AD in Windows.\n\tSystem.setProperty(\"user.dir\", \"C:\\\\..\\\\Documents and Settings\\\\Administrator\\\\Application Data\");\n\t// The current directory is not an AD in Windows.\n\tSystem.setProperty(\"user.home\", \"C:\\\\..\\\\Documents and Settings\\\\Administrator\\\\Application Data\");\n}"]}
{"_id": "6367677f1a6d9265ec018347", "generate_results": ["public synchronized void send(final String message){\n\tSystem.out.println(\"Sending message: \" + message);\n\tfor (Client client : clients){\n\t\tclient.send(message);\n\t}\n}", "public synchronized void send(final String message){\n\tif(message.length()>2000){\n\t\tmessage = message.substring(0,2000);\n\t}\n\tsynchronized(this){\n\t\tfor(int i = 0; i < clients.size(); i++){\n\t\t\tclients.get(i).write(message + \"\\n\");\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\tfor(int i = 0; i < clients.size(); i++){\n\t\tfinal Client client = clients.get(i);\n\t\tfinal String command = client.getCommand();\n\t\tif(command.equals(command)){\n\t\t\tclient.write(message);\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(!isConnected()){\n\t\treturn;\n\t}\n\t\n\tif(message.length() > 0){\n\t\t\n\t\tsynchronized(this){\n\t\t\t\n\t\t\tif(!isConnected()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tsend(message.getBytes());\n\t\t\n\t\t}\n\t\t\n\t}\n}", "public void send(final String message){\n\t\n\t// the thread to send the message\n\tfinal Thread thread = new Thread(new Runnable(){\n\t\tpublic void run(){\n\t\t\t\n\t\t\t// send the message\n\t\t\ttry{\n\t\t\t\t//System.out.println(\"Sending message: \" + message);\n\t\t\t\tfor(int i = 0; i < Telnet.this.getClientCount(); i++){\n\t\t\t\t\tTelnet.this.send(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(InterruptedException e){\n\t\t\t\t//System.out.println(\"Exception occured while sending message: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// start the thread\n\tthread.start();\n\t\n\t// wait for all threads to finish\n\tthread.join();\n\t\n}", "public synchronized void send(final String message){\n\t\n\tfor (final Client client : this.clients){\n\t\tif (client.isConnected()){\n\t\t\tif (client.isConnectedToMe()){\n\t\t\t\tclient.send(message);\n\t\t\t\tclient.send(\"\\r\\n\");\n\t\t\t} else {\n\t\t\t\tclient.send(message);\n\t\t\t\tclient.send(\"\\r\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tfor(int i = 0; i < clients.size(); i++){\n\t\tclients.get(i).write(message);\n\t}\n}", "public synchronized void send(final String message){\n\tsynchronized(this){\n\t\tif(message == null)\n\t\t\treturn;\n\t\tfor(Client c : clients)\n\t\t\tc.send(message);\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(!hasOpenTelnetConnections()){\n\t\tSystem.out.println(\"No Telnet connections are open!\");\n\t\treturn;\n\t}\n\t\n\tSystem.out.println(\"Sending message: \" + message);\n\t\n\tsynchronized(telnetConnection){\n\t\tfor(TelnetConnection c : telnetConnection){\n\t\t\tc.write(message);\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\t\n\tif(message.length() == 0)\n\t\treturn;\n\t\n\tif(outChannel == null)\n\t\toutChannel = new Channel(new OutChannel(this));\n\t\n\toutChannel.write(message);\n\toutChannel.flush();\n\t\n\tif(outChannel.isConnected()){\n\t\toutChannel.close();\n\t\toutChannel = null;\n\t}\n}"]}
{"_id": "636767781a6d9265ec01823e", "generate_results": ["/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\tsynchronized(this){\n\t\ttry{\n\t\t\tString message = event.getMessage();\n\t\t\tif(message.length()>0){\n\t\t\t\tString[] lines = message.split(\"\\n\");\n\t\t\t\tif(lines.length>0){\n\t\t\t\t\tfor(int i=0; i<lines.length; i++){\n\t\t\t\t\t\tthis.write(lines[i].trim());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tthis.write(event.getMessage().trim());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tSystem.err.println(\"Error writing to log: \" + e.getMessage());\n\t\t}\n\t}\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\n\t//System.out.println(\"Appender: \" + this.getClass().getName());\n\t\n\tif(!this.isLoggable(event)){\n\t\treturn;\n\t}\n\t\n\ttry{\n\t\t\n\t\t//System.out.println(\"Appender: Writing to client: \" + event.getThreadName());\n\t\t\n\t\t//System.out.println(\"Appender: Client: \" + event.getThreadName());\n\t\t\n\t\tthis.log(event);\n\t\t\n\t}catch(Exception e){\n\t\t\n\t\t//System.out.println(\"Appender: Exception caught: \" + e.getMessage());\n\t\t\n\t}\n\t\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\tString msg = event.getMessage().toString();\n\tmsg = msg.replaceAll(\"\\\\s+\", \" \");\n\t\n\ttry{\n\t\t// get the first \"server\" token\n\t\tString server = msg.substring(0, msg.indexOf(\" \")).trim();\n\t\t\n\t\t// get the first \"client\" token\n\t\tString client = msg.substring(msg.indexOf(\" \") + 1, msg.indexOf(\" \")).trim();\n\t\t\n\t\tif(client.equals(\"\")){\n\t\t\t// no client token, so no need to send anything to a client\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString[] tokens = client.split(\":\");\n\t\t\n\t\t// get the first token\n\t\tString sender = tokens[0];\n\t\t\n\t\t// get the first token\n\t\tString receiver = tokens[1];\n\t\t\n\t\t// get the first token\n\t\tString timestamp = tokens[2];\n\t\t\n\t\t// get the first token\n\t\tString class = tokens[3];\n\t\t\n\t\t// get the first token\n\t\tString method = tokens[4];\n\t\t\n\t\t// get the first token\n\t\tString args = tokens[5];\n\t\t\n\t\t// get the first token\n\t\tString methodName = tokens[6];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[7];\n\t\t\n\t\t// get the first token\n\t\tString className = tokens[8];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[9];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[10];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[11];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[12];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[13];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[14];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[15];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[16];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[17];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[18];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[19];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[20];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[21];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[22];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[23];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[24];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[25];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[26];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[27];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[28];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[29];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[30];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[31];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[32];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[33];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[34];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[35];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[36];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[37];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[38];\n\t\t\n\t\t// get the first token\n\t\tString classNameString = tokens[39];\n\t\t\n\t\t// get the first token\n\t\tString methodNameString = tokens[40];\n\t\t\n\t\t// get the first token\n\t\tString argsString = tokens[41];\n\t\t\n\t\t// get the first token\n\t\t", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n    if(! event.getLoggerName().equals(\"com.sap.mlt.xsl.dmt.XSLTProcessor\")){\n        return;\n    }\n    \n    String message = event.getMessage();\n    \n    if(message == null){\n        return;\n    }\n    \n    //We only want to write to the client for non-log messages\n    if(!message.startsWith(\"log\")){\n        return;\n    }\n    \n    if(event.getThrown()!= null){\n        message = message.replace(\"\\n\", \" \");\n        \n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        event.getThrown().printStackTrace(pw);\n        pw.close();\n        \n        message = sw.toString();\n    }\n    \n    //This is a special case, because it is the only way to log messages that don't have a message\n    if(message.equals(\"log\")){\n        return;\n    }\n    \n    //If the message is a log message, write it to the client\n    if(message.startsWith(\"log\")){\n        String[] split = message.split(\" \");\n        \n        String clientId = split[0];\n        String clientHost = split[1];\n        int clientPort = split[2].split(\":\")[0];\n        \n        Client client = ClientFactory.getClient(clientId, clientHost, clientPort);\n        \n        if(client!= null){\n            client.write(clientId, clientHost, clientPort, message);\n        }\n        \n        return;\n    }\n    \n    //Otherwise, write it to the client\n    Client client = ClientFactory.getClient(event.getSource());\n    \n    if(client!= null){\n        client.write(event.getSource(), event.getMessage());\n    }\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\n\tString message = event.getMessage();\n\n\tif (message == null) {\n\t\tmessage = \"\";\n\t}\n\n\t//If the event is a log message, then write it to all connected clients.\n\t//Otherwise, write it to a single connected client.\n\t\n\tif (!message.startsWith(\"INFO\")) {\n\t\t//Write it to all connected clients.\n\t\tconnections.forEach(client -> client.write(message));\n\t} else {\n\t\t//Write it to the single connected client.\n\t\t//This is a special case for log messages, because the log message\n\t\t//is always followed by the message from the client.\n\t\tconnections.get(0).write(message);\n\t}\n\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n    \n    // We don't want to be logged twice\n    if(logged) return;\n    \n    String message = event.getMessage();\n    \n    try{\n        \n        // Get the line number\n        int lineNo = event.getLoggerName().length() + 1;\n        \n        // If the line number is greater than the last line in the file,\n        // we don't want to write the line to the file.\n        if(lineNo > lastLine){\n            return;\n        }\n        \n        // If the line number is less than the first line in the file,\n        // we need to write the line to the file and log it to the client.\n        if(lineNo < firstLine){\n            // Write the line to the file and log it to the client\n            appendLine(event.getMessage());\n            log.log(event.getLoggerName(), message);\n            \n            // Reset the line number\n            lineNo = 1;\n        }\n        \n        // If the line number is greater than the first line in the file,\n        // we need to write the line to the file and log it to the client.\n        else if(lineNo > firstLine){\n            \n            // Write the line to the file and log it to the client\n            appendLine(event.getMessage());\n            log.log(event.getLoggerName(), message);\n            \n            // Reset the line number\n            lineNo = 1;\n            \n        }\n        \n        // If the line number is less than the first line in the file,\n        // we need to write the line to the file and log it to the client.\n        else if(lineNo < firstLine){\n            \n            // Write the line to the file and log it to the client\n            appendLine(event.getMessage());\n            log.log(event.getLoggerName(), message);\n            \n            // Reset the line number\n            lineNo = 1;\n            \n        }\n        \n        // We are done if the line number is equal or greater than the last line in the file.\n        else{\n            \n            // Write the line to the file and log it to the client\n            appendLine(event.getMessage());\n            log.log(event.getLoggerName(), message);\n            \n            // Reset the line number\n            lineNo = 1;\n        }\n    }\n    catch(Exception e){\n        \n        // We don't want to log this line\n        log.log(event.getLoggerName(), \"Error: \" + e.getMessage());\n    }\n    \n    // Log the event\n    logged = true;\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\t\n\t// Get the client that sent the event\n\tClient client = (Client)event.getSource();\n\t\n\t// Get the message\n\tString message = event.getMessage();\n\t\n\t// Get the thread that the client is connected to\n\tThread thread = client.getThread();\n\t\n\t// Get the thread name\n\tString threadName = thread.getName();\n\t\n\t// Get the thread id\n\tlong threadId = thread.getId();\n\t\n\t// Write the message to the client\n\tclient.write(message, threadId);\n\t\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\n   if (event.getLevel().toString().equals(\"ERROR\")){\n\t   String message = \"Failed to send log message: \" + event.getMessage();\n\t   try {\n\t\t   //send the message to the client\n\t\t   Client client = (Client) getClient();\n\t\t   client.write(message);\n\t\t   //send the message to the server\n\t\t   Server server = (Server) getServer();\n\t\t   server.write(message);\n\t   } catch (Exception e) {\n\t\t   //log the error\n\t\t   Logger.getLogger(\"\").log(Level.SEVERE, \"Failed to send log message: \" + event.getMessage(), e);\n\t   }\n   } else {\n\t   String message = \"Logged: \" + event.getMessage();\n\t   try {\n\t\t   //send the message to the client\n\t\t   Client client = (Client) getClient();\n\t\t   client.write(message);\n\t\t   //send the message to the server\n\t\t   Server server = (Server) getServer();\n\t\t   server.write(message);\n\t   } catch (Exception e) {\n\t\t   //log the error\n\t\t   Logger.getLogger(\"\").log(Level.SEVERE, \"Failed to send log message: \" + message, e);\n\t   }\n   }\n\n}", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\t\n\tLogger logger = this.getLogger();\n\t\n\t// Check if this is a new log event.  If so, create a new log event.\n\t// TODO: This is a hack to get around a problem with getting a lot of events from the connection pool.  \n\tif (this.logEvent == null){\n\t\tthis.logEvent = new LogEvent(this.logger, event);\n\t}\n\t\n\t// If the event is a log event, send it to the clients.\n\tif (event.getLevel().equals(LogLevel.INFO)){\n\t\tthis.logger.info(this.logEvent);\n\t}\n\telse if (event.getLevel().equals(LogLevel.WARN)){\n\t\tthis.logger.warn(this.logEvent);\n\t}\n\telse if (event.getLevel().equals(LogLevel.ERROR)){\n\t\tthis.logger.error(this.logEvent);\n\t}\n\telse{\n\t\tthis.logger.debug(this.logEvent);\n\t}\n\t\n\t// If there are no more connected clients, disconnect the client.\n\tif (this.connectedClients.size() <= 0){\n\t\tlogger.info(\"Disconnecting client.\");\n\t\tlogger.info(\"Clients = \" + this.connectedClients.size());\n\t\tthis.logger.info(\"Clients = \" + this.connectedClients.size());\n\t\t\n\t\t// If the client has been disconnected, then we need to send a disconnect message to the clients.\n\t\tif (this.connectedClients.size() == 0){\n\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\n\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\n\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\n\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.info(\"Sending disconnect message.\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If the client has no connected clients, send a disconnect message.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.connectedClients.size() == 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.", "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n\nprotected void append(LoggingEvent event){\n\n    // do nothing if the event is null\n    if (event == null) {\n        return;\n    }\n\n    StringBuffer message = new StringBuffer();\n    message.append(event.getMessage());\n    \n    // do nothing if the event is from a client\n    if (event.getSource() == null) {\n        return;\n    }\n    \n    // get the message from the client\n    String clientMessage = event.getSource().getClientMessage();\n    \n    // if the message is null or empty, that means that the client has no message\n    if (clientMessage.length() == 0) {\n        return;\n    }\n\n    // if the message is a message from the client, then print the message\n    if (clientMessage.startsWith(\"[\")) {\n        message.append(clientMessage);\n    }\n    else {\n        // if the message is not a message from the client, then print the message as a string\n        message.append(clientMessage);\n    }\n    \n    // print the message\n    System.out.println(message.toString());\n}"]}
{"_id": "6367677f1a6d9265ec01834b", "generate_results": ["public void put(LoggingEvent o){\n\tbuffer.add(o);\n}", "public void put(LoggingEvent o){\n\t\n\t// check if the buffer is full\n\tif(!isFull())\n\t\treturn;\n\t\n\t// check if the buffer is full\n\tif(!isFull())\n\t\treturn;\n\t\n\t// check if the event is not null\n\tif(o == null)\n\t\treturn;\n\t\n\t// check if the event is not already in the buffer\n\tif(o.getLoggerName().equals(getLoggerName()))\n\t\treturn;\n\t\n\t// put the event in the buffer\n\to.setLoggerName(getLoggerName());\n\to.setLoggerName(null);\n\t\n\t// add the event to the buffer\n\tbuffer.add(o);\n\t\n\t// check if the event is in the buffer\n\tif(buffer.size() > maxBufferSize)\n\t\tbuffer.remove(0);\n}", "public void put(LoggingEvent o){\n\tif(!isFull()){\n\t\tsuper.put(o);\n\t}\n}", "public void put(LoggingEvent o){\n\tif(buffer.full()){\n\t\to.setLoggingLevel(LoggingLevel.ERROR);\n\t\treturn;\n\t}\n\tbuffer.put(o);\n}", "public void put(LoggingEvent o){\n\tif(bufferFull()){\n\t\to.setLoggingLevel(LoggingLevel.ERROR);\n\t}\n\tbuffer.add(o);\n}", "public void put(LoggingEvent o){\n\t\n\tif(this.size<this.capacity){\n\t\tthis.buffer.add(o);\n\t}else{\n\t\tthis.buffer.add(o);\n\t\tthis.buffer.add(o);\n\t}\n\t\n\tthis.size++;\n\t\n\tif(this.size==this.capacity){\n\t\tthis.flush();\n\t}\n}", "public void put(LoggingEvent o){\n\ttry{\n\t\tbuffer.write(o.getMessage());\n\t}catch(Exception e){\n\t\tSystem.err.println(\"Exception in put() \"+e);\n\t}\n}", "public void put(LoggingEvent o){\n    if (logBuffer.length() == bufferSize){\n\t\t//we have reached the end of the buffer\n\t\tif (logBuffer.length() == 0) logBuffer = null;\n\t\treturn;\n    }\n    \n    if (logBuffer == null) logBuffer = new LoggingEvent[bufferSize];\n    \n    //we need to copy the event to the buffer\n    //it was not possible to do this with a copy constructor because the event was not a clone, so we have to create a new one\n    logBuffer[logBuffer.length-1] = o;\n    \n    //add the event to the end of the buffer\n    logBuffer[logBuffer.length-1].setTimeStamp(o.getTimeStamp());\n    logBuffer[logBuffer.length-1].setLevel(o.getLevel());\n    logBuffer[logBuffer.length-1].setSource(o.getSource());\n    logBuffer[logBuffer.length-1].setMessage(o.getMessage());\n    logBuffer[logBuffer.length-1].setThrowable(o.getThrowable());\n    logBuffer[logBuffer.length-1].setThreadName(o.getThreadName());\n    logBuffer[logBuffer.length-1].setLoggerName(o.getLoggerName());\n    logBuffer[logBuffer.length-1].setLoggerFqcn(o.getLoggerFqcn());\n    logBuffer[logBuffer.length-1].setLoggerLevel(o.getLoggerLevel());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].setLoggerAppenders(o.getLoggerAppenders());\n    logBuffer[logBuffer.length-1].", "public void put(LoggingEvent o){\n\t\n\t// check if buffer is full\n\tif(!isFull()){\n\t\t\n\t\t// check if we have enough space\n\t\tif(buffer.length >= MAX_BUFFER_SIZE){\n\t\t\t\n\t\t\t// put the event\n\t\t\tbuffer.writeBytes(o);\n\t\t\t\n\t\t\t// check if we are done\n\t\t\tif(buffer.length == MAX_BUFFER_SIZE){\n\t\t\t\t\n\t\t\t\t// check if the buffer is empty\n\t\t\t\tif(buffer.capacity() == 0){\n\t\t\t\t\t\n\t\t\t\t\t// check if the buffer is empty\n\t\t\t\t\tif(buffer.length == 0){\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tbuffer = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "public void put(LoggingEvent o){\n\tif(!isFull()){\n\t\tsynchronized(this){\n\t\t\tout.append(o);\n\t\t\tout.append('\\n');\n\t\t}\n\t}\n}"]}
{"_id": "636767791a6d9265ec01826d", "generate_results": ["public static String findAndSubst(String key,Properties props){\n    String val=props.getProperty(key);\n    if(val==null){\n        return null;\n    }\n    int start=0;\n    int end=val.length();\n    while(start<end){\n        int i=val.indexOf(',',start);\n        if(i>=0){\n            //System.out.println(\"i=\"+i);\n            String sub=val.substring(start,i);\n            start=i+1;\n            end=val.indexOf(',',start);\n            if(end<0){\n                end=val.length();\n            }\n            val=val.substring(start,end);\n            start=end;\n        }else{\n            start=end;\n        }\n    }\n    return val;\n}", "public static String findAndSubst(String key,Properties props){\n\tString value=props.getProperty(key);\n\tif(value==null){\n\t\treturn null;\n\t}\n\treturn findAndSubst(value);\n}", "public static String findAndSubst(String key,Properties props){\n\tStringBuffer sb=new StringBuffer(key);\n\tsb.append('=');\n\tString value=System.getProperty(key);\n\tif (value!=null){\n\t\tsb.append(value);\n\t}\n\treturn sb.toString();\n}", "public static String findAndSubst(String key,Properties props){\n\tString val=props.getProperty(key);\n\tif(val==null){\n\t\treturn key;\n\t}\n\tString result=null;\n\tint index=val.indexOf(\"${\");\n\tint index2=val.indexOf(\"${\");\n\tif(index!=-1){\n\t\tresult=val.substring(index+2,index2);\n\t}\n\telse if(index2!=-1){\n\t\tresult=val.substring(index2+2,val.length());\n\t}\n\treturn result;\n}\n\n/**\n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\npublic static String findAndSubst(String key,Properties props,String var){\n\tString val=props.getProperty(key);\n\tif(val==null){\n\t\treturn key;\n\t}\n\tString result=null;\n\tint index=val.indexOf(var);\n\tif(index!=-1){\n\t\tresult=val.substring(index+var.length(),val.length());\n\t}\n\treturn result;\n}\n\n/** \n * This method will replace the ${variable} with the value of $variable in the input string.\n * \n * @param input\n * @return\n */\npublic static String replaceVarInInput(String input){\n\tString result=input;\n\tint index=input.indexOf(\"${\");\n\twhile(index!=-1){\n\t\tresult=result.replaceAll(\"\\\\${\"+index+\"}\",findAndSubst(input.substring(0,index),input));\n\t\tindex=input.indexOf(\"${\",index+1);\n\t}\n\treturn result;\n}\n\n/** \n * This method will replace the ${variable} with the value of $variable in the input string.\n * \n * @param input\n * @return\n */\npublic static String replaceVarInInput(String input,String var){\n\tString result=input;\n\tint index=input.indexOf(\"${\");\n\twhile(index!=-1){\n\t\tresult=result.replaceAll(\"\\\\${\"+index+\"}\",findAndSubst(input.substring(0,index),input,var));\n\t\tindex=input.indexOf(\"${\",index+1);\n\t}\n\treturn result;\n}\n\n/** \n * This method will replace the ${variable} with the value of $variable in the input string.\n * \n * @param input\n * @return\n */\npublic static String replaceVarInInput(String input,String var,String delim) {\n\tString result=input;\n\tint index=input.indexOf(\"${\",0);\n\twhile(index!=-1){\n\t\tresult=result.replaceAll(\"\\\\${\"+index+\"}\",findAndSubst(input.substring(0,index),input,var));\n\t\tindex=input.indexOf(\"${\",index+1);\n\t}\n\treturn result;\n}\n\n/** \n * This method will replace the ${variable} with the value of $variable in the input string.\n * \n * @param input\n * @return\n */\npublic static String replaceVarInInput(String input,String var,String delim){\n\tString result=input;\n\tint index=input.indexOf(\"${\",0);\n\twhile(index!=-1){\n\t\tresult=result.replaceAll(\"\\\\${\"+index+\"}\",findAndSubst(input.substring(0,index),input,var));\n\t\tindex=input.indexOf(\"${\",index+1);\n\t}\n\treturn result;\n}\n\n/** \n * This method will replace the ${variable} with the value of $variable in the input string.\n * \n * @param input\n * @return\n */\npublic static String replaceVarInInput(String input,String var,String delim,String delim2) {\n\tString result=input;\n\tint index=input.indexOf(\"${\",0);\n\twhile(index!=-1){\n\t\tresult=result.replaceAll(\"\\\\${\"+index+\"}\",findAndSubst(input.substring(0,index),input,var", "public static String findAndSubst(String key,Properties props){\n\tString value = props.getProperty(key);\n\tif(value!= null){\n\t\tvalue = substitute(value,props);\n\t\tprops.setProperty(key,value);\n\t}\n\treturn value;\n}", "public static String findAndSubst(String key,Properties props){\n\tString val = null;\n\tString s = (String) props.get(key);\n\tif(s!= null){\n\t\tval = s;\n\t}\n\telse {\n\t\tval = props.getProperty(key);\n\t}\n\treturn val;\n}", "public static String findAndSubst(String key,Properties props){\n\tString result = null;\n\tString value = null;\n\tif(props.containsKey(key)){\n\t\tString[] values = props.getProperty(key).split(\"\\\\$\");\n\t\tfor(int i=0; i<values.length; i++){\n\t\t\tvalue = values[i];\n\t\t\tif(value!= null){\n\t\t\t\tvalue = value.replaceAll(\"\\\\\\\\\", \"\\\\\\\\$\");\n\t\t\t\tresult = value.replaceAll(\"'\", \"\\\\'\");\n\t\t\t\tresult = result.replaceAll(\"\\\"\", \"\\\\\\\"\");\n\t\t\t\tresult = result.replaceAll(\"\\r\\n\", \"\\\\n\");\n\t\t\t\tresult = result.replaceAll(\"\\r\", \"\\\\r\");\n\t\t\t\tresult = result.replaceAll(\"\\n\", \"\\\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "public static String findAndSubst(String key,Properties props){\n\tString value = getValue(props,key);\n\tif (value == null) return null;\n\telse return subst(value);\n}", "public static String findAndSubst(String key,Properties props){\n\t\n\tString value = props.getProperty(key);\n\t\n\tif (value!=null)\n\t\tvalue = substitute(value,props);\n\t\n\treturn value;\n}", "public static String findAndSubst(String key,Properties props){\n\tString res=props.getProperty(key);\n\tif(res!=null){\n\t\treturn res;\n\t}\n\tString[] parts=key.split(\"\\\\.\");\n\tif(parts.length>=2){\n\t\tString val=parts[parts.length-1];\n\t\tif(parts.length>=3){\n\t\t\tval=parts[parts.length-2];\n\t\t}\n\t\treturn val;\n\t}\n\treturn null;\n}"]}
{"_id": "636767781a6d9265ec018238", "generate_results": ["public boolean isAttached(Appender appender){\n   return appender.getAttached();\n}", "public boolean isAttached(Appender appender){\n    return (this.appenders!= null && this.appenders.contains(appender));\n}", "public boolean isAttached(Appender appender){\n    return this.attached.contains(appender);\n}", "public boolean isAttached(Appender appender){\n\treturn appender.getAppenderName().equals(appenderName);\n}", "public boolean isAttached(Appender appender){\n    return appenders.contains(appender);\n}", "public boolean isAttached(Appender appender){\n\treturn (attachedAppenders.contains(appender.getClass()));\n}", "public boolean isAttached(Appender appender){\n\treturn attached.contains(appender);\n}", "public boolean isAttached(Appender appender){\n\treturn (appender instanceof AppenderList);\n}", "public boolean isAttached(Appender appender){\n    return appender!= null && appender.isAttached();\n}", "public boolean isAttached(Appender appender){\n\treturn appenderList.contains(appender);\n}"]}
{"_id": "6367677d1a6d9265ec0182fd", "generate_results": ["public static boolean toBoolean(String value,boolean dEfault){\n\tif(value.equalsIgnoreCase(\"true\")){\n\t\treturn true;\n\t}else if(value.equalsIgnoreCase(\"false\")){\n\t\treturn false;\n\t}else{\n\t\treturn dEfault;\n\t}\n}", "public static boolean toBoolean(String value,boolean dEfault){\n    if(value.equals(\"true\") || value.equals(\"false\")){\n        return value.equals(\"true\");\n    }\n    return dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif (value.equalsIgnoreCase(\"true\")){\n\t\treturn true;\n\t}\n\tif (value.equalsIgnoreCase(\"false\")){\n\t\treturn false;\n\t}\n\treturn dEfault;\n}", "public static Boolean toBoolean(String value,boolean dEfault){\n\t\n\tif(value.equals(\"true\")){\n\t\treturn true;\n\t}else if(value.equals(\"false\")){\n\t\treturn false;\n\t}else{\n\t\treturn dEfault;\n\t}\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value==null || value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")){\n\t     return dEfault;\n\t}\n\treturn true;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value == null || value.equals(\"\")){\n\t\treturn dEfault;\n\t}\n\tvalue = value.toLowerCase();\n\tif(value.equals(\"true\") || value.equals(\"t\")){\n\t\treturn true;\n\t}\n\tif(value.equals(\"false\") || value.equals(\"f\")){\n\t\treturn false;\n\t}\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value.equalsIgnoreCase(\"true\")){\n\t\treturn true;\n\t}else if(value.equalsIgnoreCase(\"false\")){\n\t\treturn false;\n\t}else{\n\t\treturn dEfault;\n\t}\n}", "public static boolean toBoolean(String value,boolean dEfault){\n    if(value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")){\n        return value.equalsIgnoreCase(\"true\");\n    }\n    if(dEfault){\n        return true;\n    }\n    return false;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n    if(value==null || value.trim().length()==0) return dEfault;\n    if(\"true\".equalsIgnoreCase(value)) return true;\n    if(\"false\".equalsIgnoreCase(value)) return false;\n    return dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n    if (value==null)\n        return dEfault;\n    if (value.equalsIgnoreCase(\"true\"))\n        return true;\n    if (value.equalsIgnoreCase(\"false\"))\n        return false;\n    if (value.equalsIgnoreCase(\"default\"))\n        return dEfault;\n    throw new IllegalArgumentException(\"not a valid boolean value: \"+value);\n}"]}
{"_id": "636767841a6d9265ec0183e8", "generate_results": ["public void add(LoggingEvent event){\n    if(event == null){\n        return;\n    }\n    synchronized(buffer){\n        if(buffer.size() == 1){\n            event.setLevel(Level.SEVERE);\n            return;\n        }\n        if(event.getLoggerName().equals(\"\")){\n            event.setLevel(Level.SEVERE);\n            return;\n        }\n        buffer.add(event);\n    }\n    \n}", "public void add(LoggingEvent event){\n    if (event == null) return;\n    if (last == null) last = event;\n    else last.add(event);\n}", "public void add(LoggingEvent event){\n\tsynchronized(events){\n\t\tif(events.size() < max){\n\t\t\tevents.add(event);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// if there is a buffer, add to the end of it\n\t\tif(buffer!= null)\n\t\t\tbuffer.add(event);\n\t\t\n\t\t// if there is no buffer, create a new one\n\t\telse{\n\t\t\tbuffer = new ArrayList<LoggingEvent>();\n\t\t\tbuffer.add(event);\n\t\t}\n\t}\n}", "public void add(LoggingEvent event){\n\tif(event.getType() == LoggingEvent.ERROR_TYPE)\n\t\tthrow new IllegalArgumentException(\"Can't add an ERROR_TYPE log event to a buffer.\");\n\t\n\tif(!buffers.containsKey(event.getLevel())){\n\t\tbuffers.put(event.getLevel(), new ArrayList<LoggingEvent>());\n\t}\n\tbuffers.get(event.getLevel()).add(event);\n}", "public void add(LoggingEvent event){\n   \n   // Check if the event has already been added to the buffer\n   \n   if(event.isAddedToBuffer())\n      return;\n   \n   // Add the event to the buffer\n   \n   event.setAddedToBuffer(true);\n   \n   // Update the buffer\n   \n   buffer.add(event);\n}", "public void add(LoggingEvent event){\n\tif(!first){\n\t\tlast.add(event);\n\t} else {\n\t\tfirst = false;\n\t\tlast.add(event);\n\t}\n}", "public void add(LoggingEvent event){\n    if(!this.isEmpty()){\n        this.shift(event);\n    }\n    this.add(event);\n}", "public void add(LoggingEvent event){\n    \n    if(event == null) return;\n    \n    synchronized(this){\n        event.setLogDate(this.getLogDate());\n        event.setLogTime(this.getLogTime());\n        \n        this.add(event);\n    }\n    \n}", "public void add(LoggingEvent event){\n\tsynchronized (this) {\n\t\tthis.events.add(event);\n\t}\n}", "public void add(LoggingEvent event){\n  \n  if (buffer == null) {\n    buffer = new EventVector();\n  }\n  \n  buffer.add(event);\n  \n  if (firstEvent == null) {\n    firstEvent = event;\n  }\n  \n  if (lastEvent == null) {\n    lastEvent = event;\n  }\n  \n}"]}
{"_id": "636767861a6d9265ec01844c", "generate_results": ["public void removeAppender(String name){\n\tsynchronized(appenders){\n\t\tappenders.remove(name);\n\t\tlogger.removeAppender(name);\n\t}\n}", "public void removeAppender(String name){\n    \n    for(Appender appender : appenders){\n        if(appender.getName().equals(name)){\n            appender.removeAppender();\n            return;\n        }\n    }\n}", "public void removeAppender(String name){\n\n\tfor(int i=0; i<appenders.size(); i++){\n\t\tif(appenders.get(i).getName().equals(name)){\n\t\t\tappenders.remove(i);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "public void removeAppender(String name){\n\tfor(Appender appender:getAppenders()){\n\t\tif(appender.getName().equals(name)){\n\t\t\tgetAppenders().remove(appender);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "public void removeAppender(String name){\n\t\n\tList list = getAppenders();\n\n\tif (list == null) {\n\t\treturn;\n\t}\n\n\tIterator it = list.iterator();\n\twhile(it.hasNext()){\n\t\tAppender a = (Appender) it.next();\n\t\tif (a.getName().equals(name)) {\n\t\t\tit.remove();\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n}", "public void removeAppender(String name){\n    for(Appender appender : appenders){\n        if(appender.getName().equals(name)){\n            appender.close();\n            appenders.remove(appender);\n            return;\n        }\n    }\n    throw new IllegalArgumentException(\"Appender not found.\");\n}", "public void removeAppender(String name){\n    if (appenders!=null) {\n        for (int i=0;i<appenders.length;i++) {\n            if (appenders[i].getName().equals(name)) {\n                appenders[i].stop();\n                appenders[i]=null;\n                System.arraycopy(appenders, 0, appenders=new Appender[appenders.length-1], 0, i);\n                appenders[i]=null;\n                break;\n            }\n        }\n    }\n}", "public void removeAppender(String name){\n    List<Appender> list = getAppenders();\n    for (Appender appender : list) {\n        if (appender.getName().equalsIgnoreCase(name)) {\n            list.remove(appender);\n            return;\n        }\n    }\n}", "public void removeAppender(String name){\n\tif(!this.appenders.contains(name)){\n\t\tthrow new IllegalArgumentException(\"The appender specified by name is not defined in the list of appenders\");\n\t}\n\tthis.appenders.remove(name);\n}", "public void removeAppender(String name){\n\tList appenders = getAppenders();\n\t\n\tfor(int i = 0; i < appenders.size(); i++){\n\t\tif(name.equals(appenders.get(i).getName())){\n\t\t\tappenders.remove(i);\n\t\t}\n\t}\n\t\n\tfireAppenderRemovedEvent(name, appenders);\n}"]}
{"_id": "636767781a6d9265ec018242", "generate_results": ["public int appendLoopOnAppenders(LoggingEvent event){\n\tint ret = 0;\n\tIterator it = event.getAppenders().iterator();\n\twhile (it.hasNext()){\n\t\tAppender app = (Appender) it.next();\n\t\tif (app instanceof Appender2)\n\t\t\tret += ((Appender2) app).appendLoopOnAppenders(event);\n\t\telse if (app instanceof Appender3)\n\t\t\tret += ((Appender3) app).appendLoopOnAppenders(event);\n\t}\n\treturn ret;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    for (Appender appender : appenders){\n        appender.doAppend(event);\n    }    \n    return event.getLevel().intValue();\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    int count = 0;\n    \n    for(Appender appender : appenderList){\n        if(appender.getAppender() == event.getAppender()){\n            appender.doAppend(event);\n            count++;\n        }\n    }\n    \n    return count;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\treturn doAppend(event);\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tint count = 0;\n\tif(event!= null){\n\t\tfor(Appender appender : event.getAppenders()){\n\t\t\tif(appender instanceof AppenderProxy)\n\t\t\t\tcount += appendLoopOnAppenderProxy((AppenderProxy)appender);\n\t\t\telse\n\t\t\t\tcount += appendLoopOnAppender(appender);\n\t\t}\n\t}\n\treturn count;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\t\n\tfor(Appender appender : appenders){\n\t\ttry {\n\t\t\tappender.doAppend(event);\n\t\t} catch(Exception e){\n\t\t\tLogging.log(e);\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\t\n\tint count = 0;\n\t\n\t// Loop through the appenders\n\tfor(Appender appender: this.appenders){\n\t\t\n\t\t// Check the appender\n\t\tif(appender.accepts(event)){\n\t\t\t\n\t\t\t// Call the <code>doAppend</code> method on the appender\n\t\t\tappender.doAppend(event);\n\t\t\t\n\t\t\t// Increment the count\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn count;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n    \n    if (event.getLevel().toInt() <= Level.ALL.toInt()) {\n        return appendLoopOnAppenders(event, LoggingEvent.ALL_LEVELS);\n    } else {\n        return appendLoopOnAppenders(event, LoggingEvent.ALL_LEVELS);\n    }\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\tfor(Appender appender: appenderMap.values()){\n\t\tif(appender.isAppended()){\n\t\t\tappender.doAppend(event);\n\t\t}\n\t}\n\t\n\treturn appenderMap.size();\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n  \n  int result = 0;\n  \n  Iterator it = appenders.iterator();\n  while(it.hasNext()){\n    Appender appender = (Appender)it.next();\n    result = appender.appendLoopOnAppenders(event);\n    \n    if(result!=0) break;\n  }\n  \n  return result;\n}"]}
{"_id": "636767821a6d9265ec0183ab", "generate_results": ["public boolean hasThrown(){\n  return (getThrown().length() > 0);\n}", "public boolean hasThrown(){\n\treturn (getThrown().toString().length() > 0);\n}", "public boolean hasThrown(){\n\tif (thrown!= null)\n\t\treturn true;\n\treturn false;\n}", "public String toString(){\n\tString s= \"\";\n\n\tif(hasThrown()){\n\t\ts+= getThrown().toString()+\"\\n\";\n\t}\n\n\tStackTraceElement[] st= getStackTrace();\n\tfor(int i=0; i<st.length; i++){\n\t\ts+= st[i].toString()+\"\\n\";\n\t}\n\n\treturn s;\n}", "public boolean hasThrown(){\n  return getThrown()!= null;\n}", "public boolean hasThrown(){\n\treturn thrown!= null && thrown.length()!= 0;\n}", "public boolean hasThrown(){\n    return (getThrown().toString().length() >0);\n}", "public boolean wasThrown(){\n  return!hasException() &&!hasThrown();\n}", "public boolean hasThrown(){\n    return _thrown.toString().length() > 0;\n}", "public boolean hasThrown(){\n  if (getThrown().toString().length()==0) return true;\n  else return false;\n}"]}
{"_id": "6367677e1a6d9265ec018314", "generate_results": ["/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\n    // Initialize the number of unused nodes\n    int unusedNodes = 0;\n\n    // Loop through the nodes in the tree\n    Iterator it;\n\n    // Walk through the nodes in the tree\n    while((it = getNodes().iterator()).hasNext()){\n\n        // If the node is not active\n        if(!((Node)it.next()).isActive()){\n\n            // Remove the node from the tree\n            removeNode((Node)it.next());\n            unusedNodes++;\n        }\n    }\n\n    return unusedNodes;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\t\n\t// Go through all the nodes\n\tint numNodes = 0;\n\tfor(int i=0; i<categoryNode.size(); i++){\n\t\tif(categoryNode.get(i).isInactive()){\n\t\t\t// Remove the node\n\t\t\tcategoryNode.remove(i);\n\t\t\t// Decrement the number of nodes\n\t\t\tnumNodes--;\n\t\t}\n\t}\n\t\n\treturn numNodes;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\tint n = 0;\n\tfor(int i = 1; i < m_tree.size(); i++){\n\t\tif(m_tree.isLeaf(i)){\n\t\t\tm_tree.remove(i);\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n    return (m_root.removeChild(m_root.getLastChild()));\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\tint unusedNodes = 0;\n\tfor (int i = 0; i < m_nodes.length; i++){\n\t\tif (m_nodes[i] == null)\n\t\t\tcontinue;\n\t\t\n\t\tif (m_nodes[i].compareTo(m_root) == 0){\n\t\t\t//Node is a root, so it has no children.\n\t\t\tm_nodes[i] = null;\n\t\t\tunusedNodes++;\n\t\t}\n\t\telse{\n\t\t\t//Node is not a root, so it has children.\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < m_nodes[i].getNumChildren(); j++){\n\t\t\t\tif (m_nodes[i].getChild(j) == null){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > 0){\n\t\t\t\tm_nodes[i].setNumChildren(count);\n\t\t\t\tunusedNodes++;\n\t\t\t}\n\t\t}\n\t}\n\treturn unusedNodes;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\n\t// Create a new empty tree\n\tCategoryTree newTree;\n\n\t// Create a new empty tree\n\tCategoryTree newTree2;\n\n\t// Create a new empty tree\n\tCategoryTree newTree3;\n\n\t// Create a new empty tree\n\tCategoryTree newTree4;\n\n\t// Create a new empty tree\n\tCategoryTree newTree5;\n\n\t// Create a new empty tree\n\tCategoryTree newTree6;\n\n\t// Create a new empty tree\n\tCategoryTree newTree7;\n\n\t// Create a new empty tree\n\tCategoryTree newTree8;\n\n\t// Create a new empty tree\n\tCategoryTree newTree9;\n\n\t// Create a new empty tree\n\tCategoryTree newTree10;\n\n\t// Create a new empty tree\n\tCategoryTree newTree11;\n\n\t// Create a new empty tree\n\tCategoryTree newTree12;\n\n\t// Create a new empty tree\n\tCategoryTree newTree13;\n\n\t// Create a new empty tree\n\tCategoryTree newTree14;\n\n\t// Create a new empty tree\n\tCategoryTree newTree15;\n\n\t// Create a new empty tree\n\tCategoryTree newTree16;\n\n\t// Create a new empty tree\n\tCategoryTree newTree17;\n\n\t// Create a new empty tree\n\tCategoryTree newTree18;\n\n\t// Create a new empty tree\n\tCategoryTree newTree19;\n\n\t// Create a new empty tree\n\tCategoryTree newTree20;\n\n\t// Create a new empty tree\n\tCategoryTree newTree21;\n\n\t// Create a new empty tree\n\tCategoryTree newTree22;\n\n\t// Create a new empty tree\n\tCategoryTree newTree23;\n\n\t// Create a new empty tree\n\tCategoryTree newTree24;\n\n\t// Create a new empty tree\n\tCategoryTree newTree25;\n\n\t// Create a new empty tree\n\tCategoryTree newTree26;\n\n\t// Create a new empty tree\n\tCategoryTree newTree27;\n\n\t// Create a new empty tree\n\tCategoryTree newTree28;\n\n\t// Create a new empty tree\n\tCategoryTree newTree29;\n\n\t// Create a new empty tree\n\tCategoryTree newTree30;\n\n\t// Create a new empty tree\n\tCategoryTree newTree31;\n\n\t// Create a new empty tree\n\tCategoryTree newTree32;\n\n\t// Create a new empty tree\n\tCategoryTree newTree33;\n\n\t// Create a new empty tree\n\tCategoryTree newTree34;\n\n\t// Create a new empty tree\n\tCategoryTree newTree35;\n\n\t// Create a new empty tree\n\tCategoryTree newTree36;\n\n\t// Create a new empty tree\n\tCategoryTree newTree37;\n\n\t// Create a new empty tree\n\tCategoryTree newTree38;\n\n\t// Create a new empty tree\n\tCategoryTree newTree39;\n\n\t// Create a new empty tree\n\tCategoryTree newTree40;\n\n\t// Create a new empty tree\n\tCategoryTree newTree41;\n\n\t// Create a new empty tree\n\tCategoryTree newTree42;\n\n\t// Create a new empty tree\n\tCategoryTree newTree43;\n\n\t// Create a new empty tree\n\tCategoryTree newTree44;\n\n\t// Create a new empty tree\n\tCategoryTree newTree45;\n\n\t// Create a new empty tree\n\tCategoryTree newTree46;\n\n\t// Create a new empty tree\n\tCategoryTree newTree47;\n\n\t// Create a new empty tree\n\tCategoryTree newTree48;\n\n\t// Create a new empty tree\n\tCategoryTree newTree49;\n\n\t// Create a new empty tree\n\tCategoryTree newTree50;\n\n\t// Create a new empty tree\n\tCategoryTree newTree51;\n\n\t// Create a new empty tree\n\tCategoryTree newTree52;\n\n\t// Create a new empty tree\n\tCategoryTree newTree53;\n\n\t// Create a new empty tree\n\tCategoryTree newTree54;\n\n\t// Create a new empty tree\n\tCategoryTree newTree55;\n\n\t// Create a new empty tree\n\tCategoryTree newTree56;\n\n\t// Create a new empty tree\n\tCategoryTree newTree57;\n\n\t// Create a new empty tree\n\tCategoryTree newTree58;\n\n\t// Create a new empty tree\n\tCategoryTree newTree59;\n\n\t// Create a new empty tree\n\tCategoryTree newTree60;\n\n\t// Create a new empty tree\n\tCategoryTree newTree61;\n\n\t// Create a new empty tree\n\tCategoryTree newTree62;\n\n\t// Create a new empty", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n    //  For each node in the tree,\n    //    remove it from the tree until it is no longer used.\n    //    If this is the last node, then the tree is empty.\n    //    This is the way to remove a node from the tree.\n    //    The method returns the number of nodes removed.\n    //    (The value is the number of nodes that have been removed.)\n    //    The value is the number of nodes that have been removed.\n    //    If the value is 1, then the node has been removed.\n    //    If the value is -1, then the node has not been removed.\n\n    //  The method is used to remove the last node in the tree.\n    //    If the value is 0, then the method returns the number of nodes\n    //    removed.\n    //    (The value is the number of nodes that have been removed.)\n    //    The value is the number of nodes that have been removed.\n    //    If the value is 1, then the node has been removed.\n    //    If the value is -1, then the node has not been removed.\n\n    //  The method is used to remove the first node in the tree.\n    //    If the value is 0, then the method returns the number of nodes\n    //    removed.\n    //    (The value is the number of nodes that have been removed.)\n    //    The value is the number of nodes that have been removed.\n    //    If the value is 1, then the node has been removed.\n    //    If the value is -1, then the node has not been removed.\n\n    int count=0;\n    int value=0;\n    Node first=null;\n    Node last=null;\n\n    //  For each node in the tree,\n    //    for each child in the node's subtree,\n    //      if the value of the subtree is 0, then\n    //        set the value of the child to 0\n    //      else if the value of the subtree is 1, then\n    //        set the value of the child to 1\n    //      else if the value of the subtree is -1, then\n    //        set the value of the child to -1\n    //      else,\n    //        set the value of the child to the value of the subtree\n    //    If the value is 0, then the value of the subtree is 0.\n    //    If the value is 1, then the value of the subtree is 1.\n    //    If the value is -1, then the value of the subtree is -1.\n    //    If the value is -1, then the value of the subtree is -1.\n\n    for(Node node=first; node!=null; node=node.getNext()){\n        value=0;\n        if(node.getChildCount()!=0){\n            for(int i=0; i<node.getChildCount(); i++){\n                value=value*2+node.getChild(i).getValue();\n                if(value==0){\n                    //  if the value of the subtree is 0, then set the node's value to 0\n                    //  and increment the count\n                    if(node.getChildCount()==1){\n                        count++;\n                        node.setValue(0);\n                    }\n                    //  if the value of the subtree is 1, then set the node's value to 1\n                    //  and increment the count\n                    else if(node.getChildCount()==2){\n                        count++;\n                        node.setValue(1);\n                    }\n                    //  if the value of the subtree is -1, then set the node's value to -1\n                    //  and increment the count\n                    else if(node.getChildCount()==-1){\n                        count++;\n                        node.setValue(0);\n                    }\n                    //  if the value of the subtree is -1, then set the node's value to -1\n                    //  and decrement the count\n                    else{\n                        count--;\n                        node.setValue(0);\n                    }\n                }\n                //  increment the count\n                count++;\n            }\n        }\n    }\n\n    return count;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\treturn removeFromCategoryTree(root, 0);\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n\tNode cur = root;\n\twhile (cur.left!= null) cur = cur.left;\n\twhile (cur.right!= null) cur = cur.right;\n\troot = null;\n\treturn 0;\n}", "/** \n * Removes any inactive nodes from the Category tree.\n */\n\nprotected int removeUnusedNodes(){\n    int x = 0;\n    for(int i = 0; i < n; i++){\n        if(!tree[i].isInUse()){\n            tree[x++] = tree[i];\n        }\n    }\n    return x;\n}"]}
{"_id": "636767841a6d9265ec0183f2", "generate_results": ["public int compare(Object aObj1,Object aObj2){\n\t\n\treturn ((Integer)aObj1).compareTo((Integer)aObj2);\n}", "public int compare(Object aObj1,Object aObj2){\n  \n  // get the first object from the array\n  int result=0;\n  \n  // get the second object from the array\n  result = ((Integer)aObj2).intValue();\n  \n  return result;\n}", "public int compare(Object aObj1,Object aObj2){\n\tif (aObj1 instanceof String) {\n\t\treturn ((String)aObj1).compareTo((String)aObj2);\n\t} else {\n\t\treturn ((Comparable) aObj1).compareTo((Comparable) aObj2);\n\t}\n}", "public int compare(Object aObj1,Object aObj2){\n\tif(aObj1.getClass().isArray() && aObj2.getClass().isArray()){\n\t\tint i = Array.getLength(aObj1);\n\t\tint j = Array.getLength(aObj2);\n\t\tif(i<j){\n\t\t\treturn -1;\n\t\t}else if(i==j){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\tint c = 0;\n\t\n\tif (aObj1 instanceof String && aObj2 instanceof String) {\n\t\tc = ((String)aObj1).compareTo((String)aObj2);\n\t} else if (aObj1 instanceof String) {\n\t\tc = ((String)aObj1).compareToIgnoreCase((String)aObj2);\n\t} else if (aObj2 instanceof String) {\n\t\tc = ((String)aObj2).compareToIgnoreCase((String)aObj1);\n\t} else if (aObj1 instanceof Integer && aObj2 instanceof Integer) {\n\t\tc = ((Integer)aObj1).compareTo((Integer)aObj2);\n\t}\n\t\n\treturn c;\n}", "public int compare(Object aObj1,Object aObj2){\n\t\n\tString aString1=null;\n\tString aString2=null;\n\t\n\tif(aObj1 instanceof String){\n\t\taString1=aObj1.toString();\n\t}\n\telse if(aObj1 instanceof Integer){\n\t\taString1=Integer.toString(((Integer)aObj1).intValue());\n\t}\n\telse if(aObj1 instanceof Long){\n\t\taString1=Long.toString(((Long)aObj1).longValue());\n\t}\n\telse if(aObj1 instanceof Boolean){\n\t\taString1=Boolean.toString(((Boolean)aObj1).booleanValue());\n\t}\n\telse if(aObj1 instanceof Double){\n\t\taString1=Double.toString(((Double)aObj1).doubleValue());\n\t}\n\telse if(aObj1 instanceof Float){\n\t\taString1=Float.toString(((Float)aObj1).floatValue());\n\t}\n\telse if(aObj1 instanceof Byte){\n\t\taString1=Byte.toString(((Byte)aObj1).byteValue());\n\t}\n\telse if(aObj1 instanceof Short){\n\t\taString1=Short.toString(((Short)aObj1).shortValue());\n\t}\n\telse if(aObj1 instanceof Character){\n\t\taString1=Character.toString(((Character)aObj1).charValue());\n\t}\n\t\n\tif(aObj2 instanceof String){\n\t\taString2=aObj2.toString();\n\t}\n\telse if(aObj2 instanceof Integer){\n\t\taString2=Integer.toString(((Integer)aObj2).intValue());\n\t}\n\telse if(aObj2 instanceof Long){\n\t\taString2=Long.toString(((Long)aObj2).longValue());\n\t}\n\telse if(aObj2 instanceof Boolean){\n\t\taString2=Boolean.toString(((Boolean)aObj2).booleanValue());\n\t}\n\telse if(aObj2 instanceof Double){\n\t\taString2=Double.toString(((Double)aObj2).doubleValue());\n\t}\n\telse if(aObj2 instanceof Float){\n\t\taString2=Float.toString(((Float)aObj2).floatValue());\n\t}\n\telse if(aObj2 instanceof Byte){\n\t\taString2=Byte.toString(((Byte)aObj2).byteValue());\n\t}\n\telse if(aObj2 instanceof Short){\n\t\taString2=Short.toString(((Short)aObj2).shortValue());\n\t}\n\telse if(aObj2 instanceof Character){\n\t\taString2=Character.toString(((Character)aObj2).charValue());\n\t}\n\t\n\treturn aString1.compareTo(aString2);\n}", "public int compare(Object aObj1,Object aObj2){\n\tint result = 0;\n\tswitch(this.getClass()){\n\t\tcase Long.class:\n\t\t\tLong aLong1 = (Long)aObj1;\n\t\t\tLong aLong2 = (Long)aObj2;\n\t\t\tresult = aLong1.compareTo(aLong2);\n\t\t\tbreak;\n\t\tcase Double.class:\n\t\t\tDouble aDouble1 = (Double)aObj1;\n\t\t\tDouble aDouble2 = (Double)aObj2;\n\t\t\tresult = aDouble1.compareTo(aDouble2);\n\t\t\tbreak;\n\t\tcase Float.class:\n\t\t\tFloat aFloat1 = (Float)aObj1;\n\t\t\tFloat aFloat2 = (Float)aObj2;\n\t\t\tresult = aFloat1.compareTo(aFloat2);\n\t\t\tbreak;\n\t\tcase Character.class:\n\t\t\tCharacter aChar1 = (Character)aObj1;\n\t\t\tCharacter aChar2 = (Character)aObj2;\n\t\t\tresult = aChar1.compareTo(aChar2);\n\t\t\tbreak;\n\t\tcase Date.class:\n\t\t\tDate aDate1 = (Date)aObj1;\n\t\t\tDate aDate2 = (Date)aObj2;\n\t\t\tresult = aDate1.compareTo(aDate2);\n\t\t\tbreak;\n\t\tcase Boolean.class:\n\t\t\tBoolean aBoolean1 = (Boolean)aObj1;\n\t\t\tBoolean aBoolean2 = (Boolean)aObj2;\n\t\t\tresult = aBoolean1.compareTo(aBoolean2);\n\t\t\tbreak;\n\t\tcase BigDecimal.class:\n\t\t\tBigDecimal aBigDecimal1 = (BigDecimal)aObj1;\n\t\t\tBigDecimal aBigDecimal2 = (BigDecimal)aObj2;\n\t\t\tresult = aBigDecimal1.compareTo(aBigDecimal2);\n\t\t\tbreak;\n\t\tcase BigInteger.class:\n\t\t\tBigInteger aBigInteger1 = (BigInteger)aObj1;\n\t\t\tBigInteger aBigInteger2 = (BigInteger)aObj2;\n\t\t\tresult = aBigInteger1.compareTo(aBigInteger2);\n\t\t\tbreak;\n\t\tcase BigDecimal.class:\n\t\t\tBigDecimal aBigDecimal1 = (BigDecimal)aObj1;\n\t\t\tBigDecimal aBigDecimal2 = (BigDecimal)aObj2;\n\t\t\tresult = aBigDecimal1.compareTo(aBigDecimal2);\n\t\t\tbreak;\n\t\tcase Object.class:\n\t\t\tObject aObj1 = (Object)aObj1;\n\t\t\tObject aObj2 = (Object)aObj2;\n\t\t\tresult = aObj1.compareTo(aObj2);\n\t\t\tbreak;\n\t\tcase String.class:\n\t\t\tString aString1 = (String)aObj1;\n\t\t\tString aString2 = (String)aObj2;\n\t\t\tresult = aString1.compareTo(aString2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = 0;\n\t}\n\treturn result;\n}", "public int compare(Object aObj1,Object aObj2){\n\t\n\tint thisIndex1 = ((Integer) aObj1).intValue();\n\tint thisIndex2 = ((Integer) aObj2).intValue();\n\t\n\tif ( thisIndex1 < thisIndex2){\n\t\treturn -1;\n\t}\n\tif ( thisIndex1 > thisIndex2){\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\t\n\t//if( aObj1 == null )\n\t\t//return -1;\n\t\t//if( aObj2 == null )\n\t\t\t//return 1;\n\n\tif( aObj1 == null )\n\t\treturn -1;\n\tif( aObj2 == null )\n\t\treturn 1;\n\n\tint i = aObj1.toString().compareTo(aObj2.toString());\n\tif( i!= 0 )\n\t\treturn i;\n\t\n\treturn aObj1.hashCode() - aObj2.hashCode();\n\t\n\t\n}", "public int compare(Object aObj1,Object aObj2){\n\t\n\t//System.out.println(\"compare \"+aObj1.getClass()+\" \"+aObj2.getClass()+\" \"+aObj1.hashCode()+\" \"+aObj2.hashCode());\n\t\n\treturn aObj1.hashCode() - aObj2.hashCode();\n}"]}
{"_id": "636767781a6d9265ec018250", "generate_results": ["public int decide(LoggingEvent event){\n  String source=event.getSource();\n  return NEUTRAL;\n}", "public int decide(LoggingEvent event){\n    if(event.getLevel().equals(LoggingEvent.Level.ERROR)){\n        return Filter.NEUTRAL;\n    }\n    return Filter.NEUTRAL;\n}", "public int decide(LoggingEvent event){\n\tif(event.getSource() instanceof String){\n\t\treturn NEUTRAL;\n\t}\n\treturn Filter.NEUTRAL;\n}", "public int decide(LoggingEvent event){\n\treturn EQUAL;\n}", "public int decide(LoggingEvent event){\n    int result = Filter.NEUTRAL;\n    String str = event.getMessage();\n\n    if(str!= null)\n    {\n        for(int i=0; i<str.length(); i++)\n        {\n            if(str.charAt(i) == '%')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) < 'A' || str.charAt(i) > 'Z')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) =='')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '%')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '.')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '+')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '-')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '_')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '^')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '!')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '=')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '=')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '$')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '\\\\')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '#')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '$')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '\\'')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '\"')\n                result = Filter.NEUTRAL;\n            else if(str.charAt(i) == '\\\\')\n                result = Filter.NEUTRAL;\n        }\n    }\n    return result;\n}", "public int decide(LoggingEvent event){\n\treturn NEUTRAL;\n}", "public int decide(LoggingEvent event){\n    return NEUTRAL;\n}", "public int decide(LoggingEvent event){\n    if (event.getSource() == null)\n        return NEUTRAL;\n    String pattern = event.getSource().getClass().getName();\n    if (pattern.startsWith(\"java.lang.Thread\"))\n        return NEUTRAL;\n    return checkPattern(pattern);\n}", "public int decide(LoggingEvent event){\n\tString str = event.getMessage();\n\tif(str == null)\n\t\treturn NEUTRAL;\n\telse if(str.equals(\"\"))\n\t\treturn NEUTRAL;\n\telse if(str.equals(\"0\"))\n\t\treturn NEUTRAL;\n\telse if(str.equals(\"1\"))\n\t\treturn NEUTRAL;\n\telse if(str.equals(\"2\") || str.equals(\"3\") || str.equals(\"4\") || str.equals(\"5\") || str.equals(\"6\") || str.equals(\"7\") || str.equals(\"8\") || str.equals(\"9\"))\n\t\treturn NEUTRAL;\n\telse if(str.equals(\"X\"))\n\t\treturn NEUTRAL;\n\telse\n\t\treturn NEUTRAL;\n}", "public int decide(LoggingEvent event){\n    return NEUTRAL;\n}"]}
{"_id": "636767861a6d9265ec018440", "generate_results": ["public void abbreviate(final int nameStart,final StringBuffer buf){\n    final int nameEnd = buf.length() - 1;\n    final int abbreviateLen = buf.lastIndexOf(' ',nameEnd);\n    if(abbreviateLen<=nameEnd){\n        buf.setLength(abbreviateLen);\n    }\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\t\n\tfinal int nameLen = buf.length();\n\t\n\t// If there is already a space, don't add the first character.\n\tif(buf.charAt(nameStart)==' ') return;\n\t\n\t// If there is no space, don't add the first character.\n\tif(nameLen==0) return;\n\t\n\t// If the first character is a '<', don't add the '>'.\n\tif(buf.charAt(nameStart)=='<'){\n\t\tbuf.setCharAt(nameStart,'>');\n\t\treturn;\n\t}\n\t\n\t// If the first character is a '>', don't add the '>'.\n\tif(buf.charAt(nameStart)=='>'){\n\t\tbuf.setCharAt(nameStart,'<');\n\t\treturn;\n\t}\n\t\n\t// If the first character is not a '<' or '>', don't add the '<'.\n\tif(buf.charAt(nameStart)=='>') return;\n\t\n\t// If the first character is not a '<' or '>', don't add the '>'.\n\tif(buf.charAt(nameStart)=='<') return;\n\t\n\t// If the first character is not a '<' or '>', don't add the '>'.\n\tif(buf.charAt(nameStart)=='>') return;\n\t\n\t// If the first character is not a '<' or '>', don't add the '>'.\n\tif(buf.charAt(nameStart)=='>') return;\n\t\n\t// If there is no space, don't add the first character.\n\tif(nameLen==0) return;\n\t\n\t// Append the first character.\n\tbuf.setCharAt(nameStart,buf.charAt(nameStart));\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tfinal int n = nameStart;\n\tfor (int i = n; i < buf.length(); i++){\n\t\tif (buf.charAt(i) == '%'){\n\t\t\tbuf.setCharAt(i,'');\n\t\t} else if (buf.charAt(i) == '\\''){\n\t\t\tbuf.setCharAt(i,'');\n\t\t} else if (buf.charAt(i) == '`'){\n\t\t\tbuf.setCharAt(i,'');\n\t\t} else if (buf.charAt(i) == '\\\\'){\n\t\t\tbuf.setCharAt(i,'');\n\t\t}\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\t\n\tbuf.setLength(0);\n\tif(nameStart == 0){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 1){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 2){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 3){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 4){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 5){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 6){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 7){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 8){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 9){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 10){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 11){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 12){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 13){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 14){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 15){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 16){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 17){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 18){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 19){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 20){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 21){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 22){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 23){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 24){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 25){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 26){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 27){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 28){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 29){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 30){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 31){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 32){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 33){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 34){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 35){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 36){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 37){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 38){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 39){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 40){\n\t\tbuf.append(\"<B>\");\n\t}\n\telse if(nameStart == 41){\n\t\tbuf.append(\"<B", "public void abbreviate(final int nameStart,final StringBuffer buf){\n    buf.setLength(0);\n    \n    int nameLength = nameStart;\n    while(nameLength<buf.length()){\n        buf.insert(nameLength, Character.toUpperCase(buf.charAt(nameLength)));\n        nameLength++;\n    }\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tfinal int nameEnd = buf.length();\n\tfinal int firstChar = buf.charAt(nameStart);\n\tfinal int lastChar = buf.charAt(nameEnd-1);\n\n\tif(firstChar ==''){\n\t\t// don't abbreviate space\n\t\tbuf.setCharAt(nameStart, '\\0');\n\t}else{\n\t\t// abbreviate a space\n\t\tbuf.setCharAt(nameStart, firstChar);\n\t}\n\tbuf.setCharAt(nameEnd-1, lastChar);\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n    int index = buf.length();\n    int len = nameStart;\n    while (true){\n        index = buf.lastIndexOf(nameStart, index - 1);\n        if (index < 0)\n            break;\n        buf.setCharAt(index,'');\n    }\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'A');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'B');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'C');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'D');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'E');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'F');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'G');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'H');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'I');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'J');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'K');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'L');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'M');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'N');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'O');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'P');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'Q');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'R');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index = buf.length();\n    buf.setCharAt(index, 'S');\n    index = buf.lastIndexOf(nameStart, index - 1);\n    if (index < 0)\n        index =", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint i,j,k=0,len=buf.length(),n=0;\n\tfor(i=0;i<len;i++){\n\t\tif(buf.charAt(i)==' '){\n\t\t\tif(j==0){\n\t\t\t\tbuf.setCharAt(i,n);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn=0;\n\t\t\tj--;\n\t\t}\n\t\telse{\n\t\t\tn=1;\n\t\t}\n\t}\n\tfor(i=0;i<len;i++){\n\t\tbuf.setCharAt(i,buf.charAt(i)+n);\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint end = buf.length();\n\tfor (int i = nameStart; i < end; i++) {\n\t\tif (buf.charAt(i) =='') {\n\t\t\tbuf.setCharAt(i, '_');\n\t\t}\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\t\n\tfinal int len = buf.length();\n\t\n\t// If the buffer is empty, just return.\n\tif( buf.length()==0 ){\n\t\treturn;\n\t}\n\t\n\tbuf.setLength(0);\n\t\n\t// If the buffer has no name, just return.\n\tif( buf.length()==0 ){\n\t\treturn;\n\t}\n\t\n\t// If we have to shift the length, do it.\n\tif( buf.charAt(len-1)=='\\n' ){\n\t\tbuf.setCharAt(len-1,' ');\n\t}\n\t\n\t// Otherwise, abbreviate the name.\n\telse{\n\t\tbuf.append( abbrev(nameStart,len-1));\n\t}\n}"]}
{"_id": "636767df1a6d9265ec01873c", "generate_results": ["public String id(String entityId){\n\treturn id(entityId, \"\");\n}", "public String id(String entityId){\n\treturn entityId;\n}", "public String id(String entityId){\n\treturn entityId;\n}", "public String id(String entityId){\n    return entityId;\n}", "public String id(String entityId){\n    return entityId;\n}", "public String id(String entityId){\n\treturn entityId;\n}", "public String id(String entityId){\n\treturn \"id_\" + entityId;\n}", "public String id(String entityId){\n\treturn get(entityId, \"id\");\n}", "public String id(String entityId){\n    return \"id_\" + entityId;\n}", "public String id(String entityId){\n\treturn entityId.substring(entityId.lastIndexOf(\"/\") + 1);\n}"]}
{"_id": "636767e11a6d9265ec018781", "generate_results": ["public void accept(final METRICS data){\n\tif(data == null)\n\t\treturn;\n\t\n\tfinal String old = _cache.put(data.getKey(), data.getValue());\n\tif(old!= null){\n\t\tdata.setValue(old);\n\t}\n}", "public void accept(final METRICS data){\n\tif(data==null) return;\n\tcached.put(data.getName(),data);\n\tcached.remove(data.getName());\n}", "public void accept(final METRICS data){\n\tfinal String key = data.key;\n\tfinal String value = data.value;\n\t\n\tif(key == null){\n\t\tthrow new IllegalArgumentException(\"the key is null\");\n\t}\n\tif(value == null){\n\t\tthrow new IllegalArgumentException(\"the value is null\");\n\t}\n\t\n\tsynchronized(this.cache){\n\t\t\n\t\tif(this.cache.containsKey(key)){\n\t\t\tthis.cache.put(key, value);\n\t\t}else{\n\t\t\tthis.cache.put(key, value);\n\t\t}\n\t}\n}", "public void accept(final METRICS data){\n\tfinal METRICS existing = this.dataMap.get(data.getData());\n\tif(existing!= null){\n\t\tthis.dataMap.put(data.getData(), data);\n\t}else {\n\t\tthis.dataMap.put(data.getData(), data);\n\t}\n}", "public void accept(final METRICS data){\n\tif(data == null)\n\t\treturn;\n\t\n\tsynchronized(this){\n\t\tthis.data = this.data.addAndGet(data);\n\t}\n}", "public void accept(final METRICS data){\n\tif(data == null){\n\t\tthrow new IllegalArgumentException(\"Data is null\");\n\t}\n\tif(data.containsKey(METRICS.KEY.getName())){\n\t\tthrow new IllegalArgumentException(\"Data already contains \"+ METRICS.KEY.getName() +\" object\");\n\t}\n\tdata.put(METRICS.KEY.getName(), data);\n}", "public void accept(final METRICS data){\n\tif(data.getMetric() == null)\n\t\tthrow new NullPointerException(\"data is null\");\n\t\n\tif(metricMap.containsKey(data.getMetric())){\n\t\tmetricMap.get(data.getMetric()).add(data);\n\t\treturn;\n\t}\n\tmetricMap.put(data.getMetric(), data);\n}", "public void accept(final METRICS data){\n\tfinal Object old = data.get();\n\tif(old!= null){\n\t\tdata.set(old);\n\t}\n}", "public void accept(final METRICS data){\n    if(!this.isEmpty()) {\n        this.remove(this.remove(this.get(data)));\n        return;\n    }\n    this.add(data);\n}", "public void accept(final METRICS data){\n\tif(data.isCacheable()){\n\t\tthis.cache.add(data);\n\t}\n\telse {\n\t\tthis.data.add(data);\n\t}\n}"]}
{"_id": "636767df1a6d9265ec018744", "generate_results": ["/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}", "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}"]}
{"_id": "636767de1a6d9265ec01871c", "generate_results": ["public Long valueAccumulation(String key,Long value){\n    this.value = value;\n    this.key = key;\n    return this.value;\n}", "public void valueAccumulation(String key,Long value){\n\t\n\tif(value == null){\n\t\treturn;\n\t}\n\t\n\tlong oldValue = this.get(key);\n\t\n\tif(value > oldValue){\n\t\tset(key,value);\n\t}\n\telse if(value < oldValue){\n\t\tdelete(key);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\t\n\tif(key.equals(\"\")){\n\t\t\n\t\tvalue = value + value;\n\t}else{\n\t\t\n\t\tvalue = value + value;\n\t}\n\t\n\tvalues.put(key,value);\n}", "public void valueAccumulation(String key,Long value){\n\tif(value == null){\n\t\tvalue = 0l;\n\t}\n\t\n\tvalues.put(key, value);\n}", "public void valueAccumulation(String key,Long value){\n\tInteger oldValue=_values.get(key);\n\tif(oldValue==null){\n\t\t_values.put(key, value);\n\t}\n\telse{\n\t\toldValue.longValue += value;\n\t}\n}", "public Float valueAccumulation(String key,Long value){\n\tFloat oldValue = map.get(key);\n\tmap.put(key, map.get(key) + value);\n\tmap.put(key, oldValue);\n\treturn oldValue;\n}", "public void valueAccumulation(String key,Long value){\n\t\n\tLong oldValue = this.keyValueMap.get(key);\n\tif(oldValue!= null){\n\t\t\n\t\tthis.keyValueMap.put(key, value + oldValue);\n\t}\n\telse{\n\t\tthis.keyValueMap.put(key, value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\tif(this.containsKey(key)){\n\t\tthis.put(key,this.get(key)+value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\tLong existing = values.get(key);\n\tif(existing!=null){\n\t\tvalues.put(key, existing+value);\n\t}\n}", "public Long valueAccumulation(String key,Long value){\n\t\n\tLong ret = this.values.get(key);\n\t\n\tif(ret!=null){\n\t\tret = value;\n\t}\n\t\n\treturn ret;\n}"]}
{"_id": "636767dd1a6d9265ec0186de", "generate_results": ["public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\tlong now = System.currentTimeMillis();\n\tlong lastUpdate = lastUpdateTime;\n\t\n\tlong lastUpdateTime = now;\n\tif(lastUpdateTime > 0){\n\t\tlastUpdate = lastUpdateTime;\n\t}\n\t\n\tlong maxAge = getMaxAge();\n\tlong current = System.currentTimeMillis();\n\tlong last = current;\n\t\n\tlong elapsed = (current - lastUpdate);\n\t\n\tif(elapsed > expiredThreshold){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif (!isExpired(timestamp)){\n\t\treturn false;\n\t}\n\t\n\tif (expiredThreshold!= -1){\n\t\tif (System.currentTimeMillis() - timestamp >= expiredThreshold){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\tlong now = System.currentTimeMillis();\n\tlong lastUpdateTime = lastUpdateTime(now);\n\t\n\treturn (now > lastUpdateTime + expiredThreshold);\n\t\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\t\n\treturn (timestamp - lastTime) > expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n    long now = new Date().getTime();\n    if(now - timestamp < expiredThreshold)\n        return true;\n    else\n        return false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\treturn (System.currentTimeMillis()>timestamp+expiredThreshold);\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(timestamp > System.currentTimeMillis() && expiredThreshold == -1){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif (timestamp - this.lastUpdate > expiredThreshold) return true;\n\t\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(System.currentTimeMillis() > timestamp + expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n    long now = System.currentTimeMillis();\n    long lastUpdate = now - expiredThreshold;\n    long firstUpdate = now;\n    \n    if(lastUpdate > now){\n        return true;\n    }else{\n        lastUpdate = now - expiredThreshold;\n        return false;\n    }\n}"]}
{"_id": "636767e01a6d9265ec018755", "generate_results": ["/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tJsonArray childrenArray = jsonObject.getAsJsonArray(\"content\");\n\t\n\tfor(JsonElement child:childrenArray){\n\t\tJsonObject childObj = child.getAsJsonObject();\n\t\tcontent.put(childObj.get(\"name\").getAsString(),childObj.get(\"content\").getAsString());\n\t}\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\t\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tif(jsonObject.has(\"content\")){\n\t\t\n\t\tJsonArray contentArray = jsonObject.getAsJsonArray(\"content\");\n\t\t\n\t\tfor(int i = 0; i < contentArray.size(); i++){\n\t\t\t\n\t\t\tJsonObject contentJsonObject = contentArray.get(i).getAsJsonObject();\n\t\t\t\n\t\t\tString name = contentJsonObject.get(\"name\").getAsString();\n\t\t\t\n\t\t\tif(name == null || name.isEmpty())\n\t\t\t\tname = \"content_\" + i;\n\t\t\t\n\t\t\tObject contentObject = contentJsonObject.get(\"content\");\n\t\t\t\n\t\t\tif(contentObject!= null){\n\t\t\t\t\n\t\t\t\tcontent.put(name, contentObject);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\t\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tif(jsonObject!= null){\n\t\t\n\t\t//if ats set,set the ats\n\t\t\n\t\tif(jsonObject.containsKey(\"atts\")){\n\t\t\t\n\t\t\tJsonObject ats = jsonObject.getJsonObject(\"atts\");\n\t\t\t\n\t\t\tcontent.put(\"atts\",ats);\n\t\t\t\n\t\t}\n\t\t\n\t\t//if ats and content,set the content\n\t\t\n\t\telse if(jsonObject.containsKey(\"content\")){\n\t\t\t\n\t\t\t//if ats set,set the ats\n\t\t\t\n\t\t\tif(jsonObject.containsKey(\"atts\")){\n\t\t\t\t\n\t\t\t\tJsonObject ats = jsonObject.getJsonObject(\"atts\");\n\t\t\t\t\n\t\t\t\tcontent.put(\"content\",ats);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//if content,set the content\n\t\t\t\n\t\t\telse if(jsonObject.containsKey(\"content\")){\n\t\t\t\t\n\t\t\t\t//if content set,set the content\n\t\t\t\t\n\t\t\t\tcontent.put(\"content\",jsonObject.getJsonObject(\"content\"));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content=new HashMap<String,Object>();\n\t\n\ttry{\n\t\tString contentString=jsonObject.getString(\"content\");\n\t\tif(contentString!=null){\n\t\t\tcontent.put(\"content\", contentString);\n\t\t}\n\t}catch(JsonSyntaxException jse){\n\t\tSystem.err.println(jse.getMessage());\n\t}\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\t\n\tif(jsonObject.has(\"content\")){\n\t\tObject content = jsonObject.get(\"content\");\n\t\t\n\t\treturn content;\n\t}else{\n\t\treturn null;\n\t}\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tGson gson = new Gson();\n\t\n\tMap<String,Object> result = new HashMap<String, Object>();\n\t\n\t//String name = jsonObject.getString(\"name\");\n\tString description = jsonObject.getString(\"description\");\n\t\n\t//String url = jsonObject.getString(\"url\");\n\t\n\t//String url2 = jsonObject.getString(\"url2\");\n\t\n\t\n\t//String image = jsonObject.getString(\"image\");\n\t\n\t\n\t\n\tresult.put(\"name\", name);\n\tresult.put(\"description\", description);\n\t\n\treturn result;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tif (jsonObject.has(\"content\")){\n\t\tcontent = jsonObject.getAsJsonObject(\"content\");\n\t}\n\t\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\t//if it has a content\n\tif(jsonObject.has(\"content\")){\n\t\t//get from the json\n\t\tObject content = jsonObject.get(\"content\");\n\t\t\n\t\t//if it has a ats\n\t\tif(content instanceof JsonObject){\n\t\t\tJsonObject ats = (JsonObject)content;\n\t\t\t\n\t\t\t//if it has ats\n\t\t\tif(ats.has(\"ats\")){\n\t\t\t\t//get from the ats\n\t\t\t\tObject atsContent = ats.get(\"ats\");\n\t\t\t\t\n\t\t\t\t//if it has the content\n\t\t\t\tif(atsContent instanceof JsonObject){\n\t\t\t\t\tJsonObject atsContentJsonObject = (JsonObject)atsContent;\n\t\t\t\t\t\n\t\t\t\t\t//if it has a content\n\t\t\t\t\tif(atsContentJsonObject.has(\"content\")){\n\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\tObject contentJsonObject = atsContentJsonObject.get(\"content\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t//if it has a ats\n\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\tJsonObject atsContentJsonObject = (JsonObject)contentJsonObject;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\tif(atsContentJsonObject.has(\"ats\")){\n\t\t\t\t\t\t\t\t//get from the ats\n\t\t\t\t\t\t\t\tObject atsContentJsonObject = atsContentJsonObject.get(\"ats\");\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//if it has the content\n\t\t\t\t\t\t\t\tif(atsContentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\tObject contentJsonObject = atsContentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t//if it has the content\n\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//get from the content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject contentJsonObject = contentJsonObject.get(\"content\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if it has the ats\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(contentJsonObject instanceof JsonObject){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject content", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tString name = jsonObject.getString(\"name\");\n\t\n\tSet<String> paths = new HashSet<String>();\n\t\n\tif(jsonObject.has(\"paths\")){\n\t\tJsonArray pathArray = jsonObject.getJsonArray(\"paths\");\n\t\tfor(int i = 0; i < pathArray.size(); i++){\n\t\t\tpaths.add(pathArray.getString(i));\n\t\t}\n\t}\n\t\n\tcontent.put(\"name\", name);\n\tcontent.put(\"paths\", paths);\n\treturn content;\n}", "/** \n * build content,if it has ats someone set the ats\n */\n\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\t\n\tif (jsonObject.get(\"content\")!=null && jsonObject.get(\"content\") instanceof JsonObject){\n\t\tJsonObject contentJsonObject = (JsonObject)jsonObject.get(\"content\");\n\t\t\n\t\tcontent.putAll(buildContent(contentJsonObject));\n\t}\n\treturn content;\n}"]}
{"_id": "636767de1a6d9265ec01871e", "generate_results": ["/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (indexedShardingKeyIndices.isContinuous()) {\n        LOG.warn(\"The index of \" + modelName + \" is a continuous sharding key index\");\n        throw new IllegalStateException(\"The index of \" + modelName + \" is a continuous sharding key index\");\n    }\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n\tif (!isContinuous) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The sharding key indices must be continuous\");\n\t}\n\tif (indexCount == 0) {\n\t\tthrow new IllegalStateException(\"The number of index shards must be greater than 0\");\n\t}\n\tif (indexCount!= 1) {\n\t\tthrow new IllegalStateException(\"The index shards must have the same number of shards\");\n\t}\n\tif (indexCount > MAX_INDEX_SHARDS) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The number of index shards must not exceed the maximum number of shards\");\n\t}\n\tif (indexShards == null) {\n\t\tthrow new IllegalStateException(\"The index shards must not be null\");\n\t}\n\tif (indexShards.length!= indexCount) {\n\t\tthrow new IllegalStateException(\"The number of index shards must match the number of index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\tif (indexShards[0]!= indexShards[indexCount - 1]) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"The index shards must be a view of the same index shards\");\n\t}\n\t", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n  if (!isContinuous()) {\n    throw new IllegalStateException(\"The sharding key indices must be continuous\");\n  }\n  if (getContinuousShardIndices().size()!= 1) {\n    throw new IllegalStateException(\"The sharding key indices must contain the same number of shards\");\n  }\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (Boolean.valueOf(getConfig().getProperty(modelName + \"_CHECK_KEY_INDICES\"))) {\n        throw new IllegalStateException(modelName + \" is not valid for sharding key indices\");\n    }\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n\tif (keyIndices.size()!= 1) {\n\t\tthrow new IllegalStateException(\"Only one key index is supported for sharding key indices.\");\n\t}\n\tif (isContinuous()) {\n\t\tthrow new IllegalStateException(\"Continuous sharding key indices are not supported.\");\n\t}\n\tif (keyIndices.get(0).getContinuous()) {\n\t\tthrow new IllegalStateException(\"Continuous sharding key indices are not supported.\");\n\t}\n\tcheckEntity(modelName);\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (shardingKeyIndices.contains(modelName)) {\n        throw new IllegalStateException(\"The model has continuous sharding key indices.\");\n    }\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (isContinuous(modelName)) {\n        throw new IllegalStateException(\"Sharding key indices must be continuous, but found \" + modelName + \"; the sharding key indices are \" + getContinuousShardingKeyIndices());\n    }\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n        throw new IllegalStateException(\"model name cannot be null\");\n    }\n    if (modelName.length() == 0) {\n        throw new IllegalStateException(\"model name cannot be empty\");\n    }\n  }", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n    if (!this.isContinuous())\n        throw new IllegalStateException(\"The entity is not continuous. \" + modelName);\n    if (this.getShardingKeyIndices().size() == 0)\n        throw new IllegalStateException(\"The entity is not sharded. \" + modelName);\n    if (this.getShardingKeyIndices().size() > 1)\n        throw new IllegalStateException(\"The entity is not sharded. \" + modelName);\n    if (this.getShardingKeyIndices().first().getKey().equals(this.getShardingKeyIndices().last().getKey()))\n        throw new IllegalStateException(\"The entity is not sharded. \" + modelName);\n}", "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n\nprivate void check(String modelName) throws IllegalStateException {\n\tif (keyIndices.isContinuous() == false) {\n\t\tthrow new IllegalStateException(\n\t\t\t\tkeyIndices.getName()\n\t\t\t\t+ \" is not continuous. Use setContinuous() to set it to continuous.\");\n\t}\n}"]}
{"_id": "636767dd1a6d9265ec0186f3", "generate_results": ["public void overrideName(String oldName,String newName){\n\tif(oldName.equals(newName)) return;\n\tthis.name = newName;\n\t\n\tif(this.name == null) throw new IllegalArgumentException(\"name is null\");\n\t\n\tif(this.name.length() > 0) {\n\t\tString newName_ = this.name.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t\tthis.name = newName_;\n\t\t\n\t\tthis.name = this.name.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\t}\n}", "public void overrideName(String oldName,String newName){\n\tString oldNameTemp = oldName;\n\tif(newName!= null){\n\t\tnewNameTemp = newName;\n\t\toldName = oldNameTemp.replaceFirst(oldNameTemp.indexOf(oldNameTemp.charAt(0))+1,oldNameTemp.length(),newNameTemp);\n\t}\n\t\n\tString[] temp = oldNameTemp.split(\"\\\\.\");\n\tString temp1 = temp[0];\n\tString temp2 = temp[1];\n\tString temp3 = temp[2];\n\t\n\tString[] temp4 = new String[3];\n\ttemp4[0] = temp1;\n\ttemp4[1] = temp2;\n\ttemp4[2] = temp3;\n\t\n\tString[] temp5 = new String[3];\n\ttemp5[0] = temp2;\n\ttemp5[1] = temp3;\n\ttemp5[2] = temp1;\n\t\n\tString[] temp6 = new String[3];\n\ttemp6[0] = temp1;\n\ttemp6[1] = temp2;\n\ttemp6[2] = temp3;\n\t\n\tString[] temp7 = new String[3];\n\ttemp7[0] = temp2;\n\ttemp7[1] = temp3;\n\ttemp7[2] = temp1;\n\t\n\tString[] temp8 = new String[3];\n\ttemp8[0] = temp2;\n\ttemp8[1] = temp3;\n\ttemp8[2] = temp1;\n\t\n\tString[] temp9 = new String[3];\n\ttemp9[0] = temp1;\n\ttemp9[1] = temp2;\n\ttemp9[2] = temp3;\n\t\n\tString[] temp10 = new String[3];\n\ttemp10[0] = temp1;\n\ttemp10[1] = temp2;\n\ttemp10[2] = temp3;\n\t\n\tString[] temp11 = new String[3];\n\ttemp11[0] = temp2;\n\ttemp11[1] = temp3;\n\ttemp11[2] = temp1;\n\t\n\tString[] temp12 = new String[3];\n\ttemp12[0] = temp1;\n\ttemp12[1] = temp2;\n\ttemp12[2] = temp3;\n\t\n\tString[] temp13 = new String[3];\n\ttemp13[0] = temp2;\n\ttemp13[1] = temp3;\n\ttemp13[2] = temp1;\n\t\n\tString[] temp14 = new String[3];\n\ttemp14[0] = temp2;\n\ttemp14[1] = temp3;\n\ttemp14[2] = temp1;\n\t\n\tString[] temp15 = new String[3];\n\ttemp15[0] = temp1;\n\ttemp15[1] = temp2;\n\ttemp15[2] = temp3;\n\t\n\tString[] temp16 = new String[3];\n\ttemp16[0] = temp1;\n\ttemp16[1] = temp2;\n\ttemp16[2] = temp3;\n\t\n\tString[] temp17 = new String[3];\n\ttemp17[0] = temp1;\n\ttemp17[1] = temp2;\n\ttemp17[2] = temp3;\n\t\n\tString[] temp18 = new String[3];\n\ttemp18[0] = temp2;\n\ttemp18[1] = temp3;\n\ttemp18[2] = temp1;\n\t\n\tString[] temp19 = new String[3];\n\ttemp19[0] = temp2;\n\ttemp19[1] = temp3;\n\ttemp19[2] = temp1;\n\t\n\tString[] temp20 = new String[3];\n\ttemp20[0] = temp2;\n\ttemp20[1] = temp3;\n\ttemp20[2] = temp1;\n\t\n\tString[] temp21 = new String[3];\n\ttemp21[0] = temp1;\n\ttemp21[1] = temp2;\n\ttemp21[", "public void overrideName(String oldName,String newName){\n\tstorage.setColumnName(oldName,newName);\n}", "public void overrideName(String oldName,String newName){\n\tthis.oldName=oldName;\n\tthis.newName=newName;\n}", "public void overrideName(String oldName,String newName){\n\t//System.out.println(\"overrideName\");\n\tthis.name = newName;\n\tif (this.name == null) {\n\t\tthis.name = oldName;\n\t}\n}", "public void overrideName(String oldName,String newName){\n\tfor(ColumnName columnName:this.columnNames){\n\t\tcolumnName.overrideName(oldName,newName);\n\t}\n}", "public void overrideName(String oldName,String newName){\n\tif(oldName.startsWith(\"_\"))\n\t\toldName = \"__\"+oldName.substring(1);\n\tif(newName.startsWith(\"_\"))\n\t\tnewName = \"__\"+newName.substring(1);\n\t\n\tif(oldName.equals(newName))\n\t\treturn;\n\t\n\tm_name.setName(oldName+\"_\"+newName);\n\tm_name.setIndex(newName.indexOf('_'));\n}", "public void overrideName(String oldName,String newName){\n\toverrideName(oldName,newName,oldName);\n}", "public void overrideName(String oldName,String newName){\n\tthis.oldName = oldName;\n\tthis.newName = newName;\n}", "public void overrideName(String oldName,String newName){\n\tColumnName.overrideName(oldName,newName);\n}"]}
{"_id": "636767e11a6d9265ec018795", "generate_results": ["public boolean isCompatible(DataTable dataset){\n    return this.getBucket().isCompatible(dataset);\n}", "public boolean isCompatible(DataTable dataset){\n    if(dataset.isCompatible(this)){\n        return true;\n    }\n    return false;\n}", "public boolean isCompatible(DataTable dataset){\n    boolean compatible = true;\n\n    if(dataset.getBucketWidth()!= this.getBucketWidth()){\n        compatible = false;\n    }\n\n    return compatible;\n}", "public boolean isCompatible(DataTable dataset){\n    \n    if (dataset.getNumRows()!= this.getNumRows()){\n        return false;\n    }\n    \n    if (dataset.getNumColumns()!= this.getNumColumns()){\n        return false;\n    }\n    \n    return true;\n}", "public boolean isCompatible(DataTable dataset){\n    \n    if(dataset instanceof Dataset)\n        return true;\n\n    return false;\n}", "public boolean isCompatible(DataTable dataset){\n    DataTable table = dataset.getDataTable();\n    if (table.getColumnCount()!= 3) return false;\n\n    String tableName = table.getColumnName(0);\n    String columnName = table.getColumnName(1);\n    String columnType = table.getColumnType(1);\n\n    // check if the table is the same.\n    if (tableName.equals(columnName)) return true;\n\n    // check if the table is the same, but the columns are the same types.\n    if (tableName.equals(columnName) && columnType.equals(columnType)) return true;\n\n    // check if the table is the same, but the columns are different types.\n    if (tableName.equals(columnName) &&!columnType.equals(columnType)) return false;\n\n    return false;\n}", "public boolean isCompatible(DataTable dataset){\n    \n    if(dataset.getBucket().getDimension()!= getDimension()) return false;\n    \n    if(!dataset.getBucket().isCompatible(getDimension())) return false;\n    \n    return true;\n}", "public boolean isCompatible(DataTable dataset){\n\t\n\treturn (dataset.getDataType() == DataTable.DATATYPE_CATEGORICAL);\n}", "public boolean isCompatible(DataTable dataset){\n\t\n\t//check all the values of the table.\n\t\n\tif(dataset.getTable().size()!=this.getTable().size()){\n\t\treturn false;\n\t}\n\t\n\t//check the values of the table.\n\t\n\tfor(int i=0;i<this.getTable().size();i++){\n\t\t\n\t\t//check the value.\n\t\t\n\t\tif(this.getTable().get(i).getValue()!=dataset.getTable().get(i).getValue())\n\t\t\treturn false;\n\t\t\n\t}\n\t\n\t//check the size of the bucket.\n\t\n\tif(this.getTable().size()==0){\n\t\treturn true;\n\t}\n\t\n\t//check the size of the bucket.\n\t\n\tif(this.getTable().size()==1){\n\t\tif(this.getTable().get(0).getValue()!=dataset.getTable().get(0).getValue()){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n\t\n}", "public boolean isCompatible(DataTable dataset){\n    return this.size() == dataset.size();\n}"]}
{"_id": "636767de1a6d9265ec018706", "generate_results": ["public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings history = new Mappings();\n\t//do a check to see if the current index is in the input mappings\n\tif (!mappings.containsKey(tableName)) return history;\n\t//get the mappings for the current index\n\tMappings current = mappings.get(tableName);\n\t//add the new mappings to the history\n\thistory.addMappings(current);\n\t//set the current index in the history\n\tcurrent.setCurrentIndex(tableName);\n\t//return the history\n\treturn history;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\t\n\t//get input mappings\n\tMap<String,String> m=mappings.get(tableName);\n\t\n\t//get mappings from input mappings\n\tMap<String,String> input=getMappingsFrom(m);\n\t\n\t//get output mappings\n\tMap<String,String> output=getMappings(tableName);\n\t\n\t//check if there is a conflict\n\tif(input.size()!=output.size()){\n\t\treturn null;\n\t}\n\t\n\t//remove input mappings\n\tfor(String inputKey:input.keySet()){\n\t\tif(input.get(inputKey)!=null){\n\t\t\toutput.remove(inputKey);\n\t\t}\n\t}\n\t\n\t//return output mappings\n\treturn output;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tString tableName2 = tableName.substring(0,tableName.length()-1);\n\tString newTableName = tableName2+\"_diff_\"+mappings.getIndexName();\n\t\n\tif(!mappings.containsKey(tableName2)){\n\t\tmappings.put(tableName2, newTableName);\n\t}\n\t\n\tMappings tmpMappings = new Mappings();\n\ttmpMappings.add(tableName2,newTableName);\n\t\n\treturn tmpMappings; \n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tif(mappings.get_source().equals(Mapping.NO_MAPPING)){\n\t\treturn mappings;\n\t}\n\tMapping mapping = mappings.get_source();\n\tString[] fields = mapping.get_field();\n\tString[] source = mappings.get_source().split(\",\");\n\tString[] source_field;\n\tString[] target = mappings.get_target().split(\",\");\n\tString[] target_field;\n\tString[] source_field_name;\n\tString[] target_field_name;\n\tString[] source_field_value;\n\tString[] target_field_value;\n\tfor(int i=0;i<fields.length;i++){\n\t\tsource_field_name = this.fieldNameToFieldName(fields[i]);\n\t\tsource_field = this.fieldNameToField(source_field_name);\n\t\ttarget_field_name = this.fieldNameToFieldName(target[i]);\n\t\ttarget_field = this.fieldNameToField(target_field_name);\n\t\tsource_field_value = this.fieldNameToFieldValue(source_field_name);\n\t\ttarget_field_value = this.fieldNameToFieldValue(target_field_name);\n\t\t\n\t\tif(source[i].equalsIgnoreCase(mapping.get_target())){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// if the source field is not in the target field, or the target field is not in the source field\n\t\tif(source_field[i] == null || target_field[i] == null){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// if the source and target fields are not the same\n\t\tif(source_field[i]!= target_field[i]){\n\t\t\tthrow new IllegalArgumentException(\"source field [\" + source_field[i] + \"] and target field [\" + target_field[i] + \"] should be the same\");\n\t\t}\n\t\t\n\t\t// the source and target fields are the same\n\t\tif(source_field_value[i]!= target_field_value[i]){\n\t\t\tthrow new IllegalArgumentException(\"source field [\" + source_field_name[i] + \"] and target field [\" + target_field_name[i] + \"] should be the same\");\n\t\t}\n\t}\n\t\n\t// return mappings with fields that exist in the input mappings\n\treturn new Mappings(mappings.get_source(),mappings.get_target());\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tmappings = mappings.diff(this);\n\tif(mappings.get(tableName)!=null){\n\t\treturn mappings;\n\t}\n\treturn null;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\t\n\tMappings result = new Mappings();\n\t\n\t//make a new array that will contain all the fields that exist in the input mappings\n\t//add the field that is not present in the input mappings\n\t//if no field is present, then add _source\n\t\n\tMappings newMapping = new Mappings();\n\t\n\t//add all the fields that are present in the mappings\n\tfor(String field : mappings.fieldSet()){\n\t\tif(mappings.get(field)==null){\n\t\t\tnewMapping.add(field);\n\t\t}\n\t}\n\t\n\t//add the _source field\n\tnewMapping.add(\"_source\");\n\t\n\t//if there is no _source field, add one\n\tif(newMapping.get(\"_source\")==null){\n\t\tnewMapping.add(\"_source\");\n\t}\n\t\n\tresult.setMapping(newMapping);\n\t\n\treturn result;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMap<String,Object> mappings2 = new HashMap<String,Object>();\n\tfor (Map.Entry<String, Object> entry : mappings.entrySet()){\n\t\tObject value = entry.getValue();\n\t\tif (value instanceof Map<?,?>) {\n\t\t\tmappings2.putAll((Map<String, Object>)value);\n\t\t} else if (value instanceof Object[]) {\n\t\t\tMappings m = new Mappings();\n\t\t\tfor (Object o : (Object[])value){\n\t\t\t\tObject o2 = null;\n\t\t\t\tif (o instanceof Map<?,?>) {\n\t\t\t\t\to2 = ((Map<String, Object>)o).get(\"_source\");\n\t\t\t\t} else {\n\t\t\t\t\to2 = mappings2.get(o);\n\t\t\t\t}\n\t\t\t\tif (o2 == null) {\n\t\t\t\t\to2 = o;\n\t\t\t\t} else {\n\t\t\t\t\tif (o2 instanceof Map<?,?>) {\n\t\t\t\t\t\to2 = ((Map<String, Object>)o2).get(\"_source\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!o2.equals(o)) {\n\t\t\t\t\t\tthrow new RuntimeException(\"Can't map different values for the same field to the same record.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm.put(entry.getKey(), o2);\n\t\t\t}\n\t\t\tmappings2.putAll(m);\n\t\t}\n\t}\n\treturn new Mappings(mappings2);\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\t\n\tMappings ret = new Mappings();\n\t\n\t// If there is no config for table, return empty mappings\n\tif(mappings.get(tableName) == null){\n\t\treturn ret;\n\t}\n\t\n\tMapping m = mappings.get(tableName);\n\t\n\t// Only get fields that are not in the input mappings\n\tfor (String f: m.getFields()){\n\t\tif(!m.getMapping().containsKey(f)){\n\t\t\tret.add(f);\n\t\t}\n\t}\n\t\n\treturn ret;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\treturn null;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings result = new Mappings();\n\tfor(String field : mappings.getFields()){\n\t\tif(!mappings.contains(field)){\n\t\t\tif(!mappings.contains(tableName + \"_\" + field)){\n\t\t\t\tresult.add(field, mappings.get(field));\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}"]}
{"_id": "636767dc1a6d9265ec0186be", "generate_results": ["/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong ret = 0;\n\tif(timeBucket == 0)\n\t\treturn 0;\n\tif(timeBucket & 1){\n\t\tret = (timeBucket & 0xffffffff) << (dayStep*8);\n\t\tret |= ((timeBucket >> 32) & 0xffffffff);\n\t}\n\treturn ret;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong timeBucketLong = 0;\n\tint i = 0;\n\tfor(i=0;i<timeBucket;i++){\n\t\ttimeBucketLong += timeBucket[i];\n\t\tif(timeBucket[i] == dayStep){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn timeBucketLong;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong ret = 0;\n\t\n\tif(timeBucket == 0){\n\t\treturn 0;\n\t}\n\t\n\tif(timeBucket > 0){\n\t\tret = timeBucket;\n\t}\n\telse if(timeBucket < 0){\n\t\tret = (1 - (timeBucket / -dayStep));\n\t}\n\t\n\treturn ret;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\t\n\tlong result = 0;\n\t\n\tif (timeBucket == 0){\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 1){\n\t\tresult = 1;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 2){\n\t\tresult = 2;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 3){\n\t\tresult = 3;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 4){\n\t\tresult = 4;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 5){\n\t\tresult = 5;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 6){\n\t\tresult = 6;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 7){\n\t\tresult = 7;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 8){\n\t\tresult = 8;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 9){\n\t\tresult = 9;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 10){\n\t\tresult = 10;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 11){\n\t\tresult = 11;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 12){\n\t\tresult = 12;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 13){\n\t\tresult = 13;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 14){\n\t\tresult = 14;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 15){\n\t\tresult = 15;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 16){\n\t\tresult = 16;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 17){\n\t\tresult = 17;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 18){\n\t\tresult = 18;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 19){\n\t\tresult = 19;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 20){\n\t\tresult = 20;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 21){\n\t\tresult = 21;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 22){\n\t\tresult = 22;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 23){\n\t\tresult = 23;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 24){\n\t\tresult = 24;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 25){\n\t\tresult = 25;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 26){\n\t\tresult = 26;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 27){\n\t\tresult = 27;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 28){\n\t\tresult = 28;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 29){\n\t\tresult = 29;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 30){\n\t\tresult = 30;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 31){\n\t\tresult = 31;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 32){\n\t\tresult = 32;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 33){\n\t\tresult = 33;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 34){\n\t\tresult = 34;\n\t\treturn result;\n\t}\n\t\n\tif (timeBucket == 35){\n\t\tresult = 35;\n\t\treturn result", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong long timeBucketLong = timeBucket;\n\tlong long timeBucketLong2 = timeBucket;\n\tlong long timeBucketLong3 = timeBucket;\n\tlong long timeBucketLong4 = timeBucket;\n\tlong long timeBucketLong5 = timeBucket;\n\tlong long timeBucketLong6 = timeBucket;\n\tlong long timeBucketLong7 = timeBucket;\n\tlong long timeBucketLong8 = timeBucket;\n\tlong long timeBucketLong9 = timeBucket;\n\tlong long timeBucketLong10 = timeBucket;\n\tlong long timeBucketLong11 = timeBucket;\n\tlong long timeBucketLong12 = timeBucket;\n\tlong long timeBucketLong13 = timeBucket;\n\tlong long timeBucketLong14 = timeBucket;\n\tlong long timeBucketLong15 = timeBucket;\n\tlong long timeBucketLong16 = timeBucket;\n\tlong long timeBucketLong17 = timeBucket;\n\tlong long timeBucketLong18 = timeBucket;\n\tlong long timeBucketLong19 = timeBucket;\n\tlong long timeBucketLong20 = timeBucket;\n\tlong long timeBucketLong21 = timeBucket;\n\tlong long timeBucketLong22 = timeBucket;\n\tlong long timeBucketLong23 = timeBucket;\n\tlong long timeBucketLong24 = timeBucket;\n\tlong long timeBucketLong25 = timeBucket;\n\tlong long timeBucketLong26 = timeBucket;\n\tlong long timeBucketLong27 = timeBucket;\n\tlong long timeBucketLong28 = timeBucket;\n\tlong long timeBucketLong29 = timeBucket;\n\tlong long timeBucketLong30 = timeBucket;\n\tlong long timeBucketLong31 = timeBucket;\n\tlong long timeBucketLong32 = timeBucket;\n\tlong long timeBucketLong33 = timeBucket;\n\tlong long timeBucketLong34 = timeBucket;\n\tlong long timeBucketLong35 = timeBucket;\n\tlong long timeBucketLong36 = timeBucket;\n\tlong long timeBucketLong37 = timeBucket;\n\tlong long timeBucketLong38 = timeBucket;\n\tlong long timeBucketLong39 = timeBucket;\n\tlong long timeBucketLong40 = timeBucket;\n\tlong long timeBucketLong41 = timeBucket;\n\tlong long timeBucketLong42 = timeBucket;\n\tlong long timeBucketLong43 = timeBucket;\n\tlong long timeBucketLong44 = timeBucket;\n\tlong long timeBucketLong45 = timeBucket;\n\tlong long timeBucketLong46 = timeBucket;\n\tlong long timeBucketLong47 = timeBucket;\n\tlong long timeBucketLong48 = timeBucket;\n\tlong long timeBucketLong49 = timeBucket;\n\tlong long timeBucketLong50 = timeBucket;\n\tlong long timeBucketLong51 = timeBucket;\n\tlong long timeBucketLong52 = timeBucket;\n\tlong long timeBucketLong53 = timeBucket;\n\tlong long timeBucketLong54 = timeBucket;\n\tlong long timeBucketLong55 = timeBucket;\n\tlong long timeBucketLong56 = timeBucket;\n\tlong long timeBucketLong57 = timeBucket;\n\tlong long timeBucketLong58 = timeBucket;\n\tlong long timeBucketLong59 = timeBucket;\n\tlong long timeBucketLong60 = timeBucket;\n\tlong long timeBucketLong61 = timeBucket;\n\tlong long timeBucketLong62 = timeBucket;\n\tlong long timeBucketLong63 = timeBucket;\n\tlong long timeBucketLong64 = timeBucket;\n\tlong long timeBucketLong65 = timeBucket;\n\tlong long timeBucketLong66 = timeBucket;\n\tlong long timeBucketLong67 = timeB", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\t\n\tlong ret = 0;\n\t\n\tif(timeBucket == 0){\n\t\treturn 0;\n\t}\n\t\n\tif(timeBucket >= 0 && timeBucket <= 7){\n\t\tret = (timeBucket + ((dayStep - 1) * 7));\n\t}\n\t\n\treturn ret;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tint result = 0;\n\tlong current = timeBucket;\n\tlong previous = timeBucket;\n\tint i = 0;\n\twhile(i < (int)dayStep){\n\t\tresult = (result<<1) + previous;\n\t\tprevious = current;\n\t\tcurrent = current/2;\n\t\ti++;\n\t}\n\treturn result;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong long t=timeBucket;\n\tlong long b=b64_compress(timeBucket);\n\tlong long t1=t;\n\tlong long t2=b;\n\tif (dayStep>0) {\n\t\tt1=(t1-dayStep)/60;\n\t\tt2=(t2-dayStep)/60;\n\t}\n\tt=t1;\n\tb=b64_compress(t);\n\treturn t2;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\tlong total = 0;\n\n\tfor(int i=0;i<dayStep;i++){\n\t\ttotal += timeBucket;\n\t\ttimeBucket = total % 3600;\n\t\ttotal = total / 3600;\n\t}\n\n\treturn timeBucket;\n}", "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n\t\n\tlong timePart = timeBucket;\n\t\n\tlong timePartTemp;\n\t\n\tif(timePart == 0){\n\t\ttimePartTemp = 1;\n\t}\n\telse{\n\t\ttimePartTemp = 0;\n\t}\n\t\n\tint index = 0;\n\t\n\tif(timePartTemp == 0){\n\t\tindex = 1;\n\t}\n\telse{\n\t\tindex = 0;\n\t}\n\t\n\t//printf(\"%d %d\\n\",timePartTemp,timePart);\n\t\n\t//first, we need to find the index of the first time part, which is timePartTemp + index\n\t//if(timePartTemp!= 0){\n\tif(timePartTemp == 1){\n\t\tindex = index + 1;\n\t}\n\t//}\n\t\n\t//second, we need to find the index of the last time part, which is timePartTemp - index\n\t//if(timePartTemp!= 0){\n\tif(timePartTemp!= 1){\n\t\tindex = index - 1;\n\t}\n\t\n\treturn timePartTemp*(index+1) + timePartTemp;\n}\n\nvoid TimeBucket::setBucketTime(long timeBucket){\n\tthis->timeBucket = compressTimeBucket(timeBucket,dayStep);\n}\n\nlong TimeBucket::getBucketTime(){\n\treturn this->timeBucket;\n}\n\nvoid TimeBucket::setBucketTime(const char* timeBucketText){\n\tthis->timeBucket = strtol(timeBucketText,NULL,10);\n}\n\nconst char* TimeBucket::getBucketTimeText(){\n\treturn strtox(this->timeBucket);\n}\n\nconst char* TimeBucket::toString(){\n\treturn this->timeBucketText;\n}\n\nvoid TimeBucket::toString(char* timeBucketText){\n\tstrncpy(timeBucketText,this->timeBucketText,this->timeBucketTextSize);\n\ttimeBucketText[this->timeBucketTextSize-1] = 0;\n}\n\nvoid TimeBucket::toString(const char* timeBucketText){\n\tstrncpy(timeBucketText,this->timeBucketText,this->timeBucketTextSize);\n\ttimeBucketText[this->timeBucketTextSize-1] = 0;\n}\n\nvoid TimeBucket::setBucketTimeText(const char* timeBucketText){\n\tthis->timeBucketText = strdup(timeBucketText);\n}\n\nvoid TimeBucket::setBucketTimeText(const char* timeBucketText){\n\tthis->timeBucketText = strdup(timeBucketText);\n}\n\nvoid TimeBucket::setBucketTimeText(const char* timeBucketText,int timeBucketTextSize){\n\tthis->timeBucketText = strdup(timeBucketText);\n\tthis->timeBucketTextSize = timeBucketTextSize;\n}\n\nvoid TimeBucket::setBucketTimeText(const char* timeBucketText,int timeBucketTextSize,char* timeBucketTextTemp){\n\tthis->timeBucketText = strdup(timeBucketText);\n\tthis->timeBucketTextSize = timeBucketTextSize;\n\t\n\tstrncpy(timeBucketTextTemp,timeBucketText,this->timeBucketTextSize);\n\ttimeBucketTextTemp[this->timeBucketTextSize-1] = 0;\n}\n\nvoid TimeBucket::setBucketTimeText(const char* timeBucketText,int timeBucketTextSize,const char* timeBucketTextTemp){\n\tthis->timeBucketText = strdup(timeBucketText);\n\tthis->timeBucketTextSize = timeBucketTextSize;\n\t\n\tstrncpy(timeBucketTextTemp,timeBucketText,this->timeBucketTextSize);\n\ttimeBucketTextTemp[this->timeBucketTextSize-1]"]}
{"_id": "636767dc1a6d9265ec0186c6", "generate_results": ["/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tboolean contains=true;\n\tfor(Field field: fields.getFields()){\n\t\tif(field.getName().equals(fieldName)){\n\t\t\tcontains=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn contains;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n    return fields.containsAllFields();\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields){\n\t\tif(!field.stored){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\t\n\tboolean result = true;\n\t\n\tif(fields.size() == 0){\n\t\treturn result;\n\t}\n\t\n\tfor(int i = 0; i < fields.size(); i++){\n\t\tif(!fields.get(i).getName().equals(properties.getProperty(fields.get(i).getName()))){\n\t\t\tresult = false;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tboolean ret = true;\n\tboolean found = false;\n\tfor (Field field : fields.getFields()) {\n\t\tif (!found) {\n\t\t\tif (field.getName().equals(this.name)) {\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){ \n    for(Field field: fields){ \n        if(!containsField(field)) return false; \n    } \n    return true; \n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tboolean all = true;\n\tfor (Field field : fields.getFields()){\n\t\tif (!fields.get(field.getName()).equals(field.getValue())){\n\t\t\tall = false;\n\t\t}\n\t}\n\treturn all;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getFields()){\n\t\tif(!field.hasValue()){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\t\n\tfor (Field field : fields.getFields()){\n\t\tif (!containsAllFields(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n\nprivate boolean containsAllFields(Fields fields){\n\tString values = fields.getValue();\n\tif(values == null || values.isEmpty())\n\t\treturn true;\n\tString[] valuesArray = values.split(\",\");\n\tfor(String value : valuesArray){\n\t\tif(!values.contains(value))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"]}
{"_id": "636767dd1a6d9265ec0186e5", "generate_results": ["public void addNewTarget(Channels channels,IConsumer consumer){\n\n    if(channels.getTarget().size()!=0){\n        throw new IllegalArgumentException(\"Target channel already has target channels.\");\n    }\n    channels.setTarget(new ArrayList<IConsumer>());\n    channels.getTarget().add(consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tthis.targetChannels = new ArrayList<Channels>();\n\tthis.targetChannels.add(channels);\n\tthis.targetChannels.add(new Channels(consumer));\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\t// TODO Auto-generated method stub\n\t\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tthis.channels = channels;\n\tthis.consumer = consumer;\n}", "public boolean addNewTarget(Channels channels,IConsumer consumer){\n\tint i=order;\n\tif(order>channels.size()){\n\t\torder=channels.size();\n\t}\n\ttarget.add(channels,consumer);\n\treturn true;\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\tthis.targetChannels.add(channels);\n\tthis.targets.add(consumer);\n\tthis.targetChannels.add(channels);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\taddTarget(channels, consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\t// Add this new target to the list of targets.\n\ttargetChannels.add(channels);\n\t// Add the consumer to the list of consumers for this target.\n\tconsumer.addConsumer(channels);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n    \n    if(channels.getTargetChannels().size()>0){\n        throw new IllegalArgumentException(\"A target channel already exists\");\n    }\n    \n    channels.addTargetChannel(new TargetChannel(consumer));\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\t\t\n\t\tif(getTargetChannels()==null){\n\t\t\tsetTargetChannels(channels);\n\t\t}\n\t\telse{\n\t\t\tgetTargetChannels().add(channels);\n\t\t}\n\t\t\n\t\tif(consumer!=null){\n\t\t\tgetConsumers().add(consumer);\n\t\t}\n\t\t\n\t}"]}
{"_id": "636767dc1a6d9265ec0186cb", "generate_results": ["public void init(){\n\tSystem.out.println(\"init config\");\n\t//config.load(new File(\"config.xml\"));\n}", "public void init(){\n    logger.info(\"initializing config\");\n    if(!checkDistPath()){\n        throw new RuntimeException(\"failed to check dist path\");\n    }\n    \n    //create config object\n    Config config = new Config();\n    \n    //set default config\n    config.set(\"checkDist\", true);\n    \n    //put config to config\n    config.put(\"checkDist\", true);\n    \n    //set default config\n    config.put(\"defaultConfig\", defaultConfig);\n    \n    //set config\n    config.put(\"dist\", \"dist/\");\n    config.put(\"web\", \"web/\");\n    config.put(\"log\", \"log/\");\n    config.put(\"log.file\", \"log/\");\n    config.put(\"log.name\", \"log/\");\n    config.put(\"log.level\", \"log/\");\n    config.put(\"log.dir\", \"log/\");\n    config.put(\"log.threads\", \"log/\");\n    config.put(\"log.format\", \"log/\");\n    config.put(\"log.level.level\", \"log/\");\n    \n    //set default config\n    config.put(\"defaultConfig\", defaultConfig);\n    \n    //set config\n    config.put(\"maxWorkerThreads\", maxWorkerThreads);\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"defaultConfig\", defaultConfig);\n    \n    //set config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.concurrency\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"maxWorkerThreads.threads\", maxWorkerThreads);\n    \n    //set default config\n    config.put(\"", "public void init(){\n    checkDist();\n}", "public void init(){\n\t//check the dist path\n\tString path = \"\";\n\tFile f = new File(\"dist\");\n\tif(f.exists()){\n\t\tpath = f.getAbsolutePath();\n\t}\n\tif(!path.endsWith(\"/\")){\n\t\tpath += \"/\";\n\t}\n\t\n\tconfig.set(\"dist\", path);\n\tconfig.set(\"check\", path);\n}", "public void init(){\n    checkDistPath();\n    \n}", "public void init(){\n\tsuper.init();\n\t\n\tif (getConfig().getString(\"config.check_path\")==null){\n\t\tgetConfig().set(\"config.check_path\", getProject().getBuildDir().getAbsolutePath() + \"/check\");\n\t}\n\t\n\tif (getConfig().getString(\"config.check_dist\")==null){\n\t\tgetConfig().set(\"config.check_dist\", getProject().getBuildDir().getAbsolutePath() + \"/check/src/test/resources/check\");\n\t}\n}", "public void init(){\n    \n    // check dist path\n    File file = new File(this.getClass().getResource(\"/\").getFile());\n    if(file.exists()){\n        System.out.println(\"check dist path\");\n        this.checkDistPath();\n    }\n    else{\n        System.out.println(\"check dist path failed\");\n        System.exit(-1);\n    }\n}", "public void init(){\n    checkDist();\n    \n    //check config\n    checkConfig();\n    \n}", "public void init(){\n\t\n\tif(!isCheckPath()){\n\t\tlogger.warn(\"check dist path is not set for this project\");\n\t\treturn;\n\t}\n\t\n\tpath = new Path(getClass().getResource(\"/\").getFile());\n\t\n\t// check if the path is not in the project classpath\n\tif(!path.isDirectory()){\n\t\tlogger.warn(\"path is not directory, path = \" + path);\n\t\treturn;\n\t}\n\t\n\t// check if the path is in the project classpath\n\tif(!path.startsWith(getClass().getResource(\"/\"))){\n\t\tlogger.warn(\"path is not in the project classpath, path = \" + path);\n\t\treturn;\n\t}\n\t\n\t// check if the path is not in the project classpath\n\tif(!path.endsWith(getClass().getResource(\"/\").getFile())){\n\t\tlogger.warn(\"path is not in the project classpath, path = \" + path);\n\t\treturn;\n\t}\n\t\n\tlogger.info(\"check path is ok\");\n}", "public void init(){\n    \n    // set default path for dist folder\n    String path = \"\";\n    try{\n        path = this.getClass().getClassLoader().getResource(\"\").getPath();\n    }\n    catch(Exception e){\n        System.err.println(\"Exception: \" + e.getMessage());\n    }\n    \n    if(!path.endsWith(File.separator))\n        path += File.separator;\n    \n    try{\n        this.config = new Config(path+\"conf/config.json\");\n    }\n    catch(Exception e){\n        System.err.println(\"Exception: \" + e.getMessage());\n    }\n    \n    // check if check dist path is valid or not\n    \n    if(this.config.isValidPath(path)){\n        \n        System.out.println(\"config file path: [\" + path + \"] is valid\");\n        \n    }\n    else{\n        \n        System.out.println(\"config file path: [\" + path + \"] is not valid\");\n        \n    }\n    \n}"]}
{"_id": "636767de1a6d9265ec018726", "generate_results": ["public List<SequenceRange> buildSequenceRanges(){\n    return null;\n}", "public List<SequenceRange> getSequenceRanges(int start, int end, int step, int startIndex, int endIndex){\n\tList<SequenceRange> result = buildSequenceRanges().subList(start, end);\n\treturn result.subList(startIndex, endIndex);\n}", "public List<SequenceRange> buildSequenceRanges(){\n    List<SequenceRange> ranges = new ArrayList<SequenceRange>();\n\n    for(int i=0; i<profileSegmentList.size(); i++){\n        SequenceRange range = new SequenceRange(profileSegmentList.get(i).getProfileName(), profileSegmentList.get(i).getStartTime(), profileSegmentList.get(i).getEndTime());\n        ranges.add(range);\n    }\n\n    return ranges;\n}", "public void buildSequenceRanges(int start, int end){\n\tList<SequenceRange> result = buildSequenceRanges();\n\t\n\tfor(int i = start; i <= end; i++){\n\t\tresult.add(new SequenceRange(i, i+1));\n\t}\n\t\n\tthis.start = start;\n\tthis.end = end;\n\t\n\tthis.sequenceRanges = result;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> result = new ArrayList<SequenceRange>();\n\n\tint current = 0;\n\n\tStringBuilder sequenceRange = new StringBuilder();\n\n\twhile (current < seqRanges.size()){\n\n\t\tSequenceRange range = seqRanges.get(current);\n\n\t\tsequenceRange.append(range.getStart());\n\n\t\tStringBuilder subSequenceRange = new StringBuilder();\n\n\t\tsubSequenceRange.append(range.getStart());\n\n\t\tint temp = current;\n\n\t\twhile (temp < range.getEnd()){\n\n\t\t\tsubSequenceRange.append(range.getEnd());\n\n\t\t\tsubSequenceRange.append(range.getEnd());\n\n\t\t\tint subCurrent = temp;\n\n\t\t\tif (subSequenceRange.length() >= sequenceRange.length()) {\n\n\t\t\t\t// range is finished\n\n\t\t\t\tresult.add(new SequenceRange(sequenceRange.toString(), subSequenceRange.toString(), true));\n\n\t\t\t\tsequenceRange = new StringBuilder();\n\n\t\t\t\tsubSequenceRange = new StringBuilder();\n\n\t\t\t\tsubCurrent = 0;\n\n\t\t\t}\n\n\t\t\ttemp++;\n\n\t\t}\n\n\t\tcurrent++;\n\n\t}\n\n\treturn result;\n\n}", "public void visit(CallExpression node) {\n        List<SequenceRange> ranges = buildSequenceRanges();\n        for (SequenceRange range : ranges) {\n            range.setLevel(Integer.parseInt(node.getText()));\n        }\n    }", "public List<SequenceRange> buildSequenceRanges(){\n  return null;\n}", "public List<SequenceRange> buildSequenceRanges(){\n    List<SequenceRange> sequenceRanges = new ArrayList<>();\n    \n    // get all the segments\n    for (Segment segment : segments.values()){\n        // if the segment has a root node, we need to start at the root\n        if (segment.getRootNode()!= null){\n            // add the first segment\n            sequenceRanges.add(new SequenceRange(segment.getRootNode().getStart(), segment.getRootNode().getEnd()));\n        }\n        // else, add the segment\n        else {\n            // add the first segment\n            sequenceRanges.add(new SequenceRange(segment.getStartNode().getStart(), segment.getStartNode().getEnd()));\n        }\n    }\n    \n    return sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n    List<SequenceRange> allSequenceRanges = new ArrayList<SequenceRange>();\n    \n    for(Profile profile : profiles){\n        for(SequenceRange range : profile.getSequenceRanges()){\n            allSequenceRanges.add(range);\n        }\n    }\n    \n    return allSequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\tsequenceRanges.add(new SequenceRange(sequenceStart, sequenceEnd));\n\tsequenceRanges.add(new SequenceRange(sequenceStart, sequenceEnd));\n\tsequenceRanges.add(new SequenceRange(sequenceStart, sequenceEnd));\n\treturn sequenceRanges;\n}"]}
{"_id": "636767e11a6d9265ec018790", "generate_results": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n    String[] array = file.getName().split(\"[.]\");\n    // TODO: get time range from file name\n    String timeRange = array[array.length - 1];\n    \n    List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n    \n    if (timeRange.equals(\"all\")) {\n        // for all time, read all thread snapshots\n        for (String threadName : file.getName().split(\"\\\\.\")) {\n            List<String> threadNames = new ArrayList<String>();\n            threadNames.add(threadName);\n            threadSnapshots.addAll(parseFromFileWithTimeRange(file,threadNames));\n        }\n    } else {\n        // for a specific time, read only a specific thread snapshot\n        int startTime = Integer.parseInt(timeRange.substring(0,timeRange.indexOf(\"_\")));\n        int endTime = Integer.parseInt(timeRange.substring(timeRange.indexOf(\"_\")+1));\n        \n        // get the thread snapshot for the specific time\n        List<ThreadSnapshot> threadSnapshotsForTimeRange = new ArrayList<ThreadSnapshot>();\n        for (String threadName : file.getName().split(\"\\\\.\")) {\n            List<String> threadNames = new ArrayList<String>();\n            threadNames.add(threadName);\n            \n            // find the thread for the specific time\n            for (int i = startTime; i <= endTime; i++) {\n                String threadNameForTime = threadName.substring(0, threadName.indexOf(\"_\"));\n                \n                // get the thread for the current time\n                ThreadSnapshot threadSnapShot = null;\n                try {\n                    threadSnapShot = ThreadSnapshot.parseFromFileWithTimeRange(file,threadNameForTime+\"_\"+i);\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n                \n                if (threadSnapShot!= null) {\n                    threadSnapshotsForTimeRange.add(threadSnapShot);\n                    \n                    // only add the thread snapshot if it is not the last thread for the specific time\n                    if (i!= endTime) {\n                        threadSnapshotsForTimeRange.add(threadSnapShot);\n                    }\n                }\n            }\n        }\n        \n        threadSnapshots.addAll(threadSnapshotsForTimeRange);\n    }\n    return threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tList<ThreadSnapshot> threads = new ArrayList<>();\n\tScanner scanner = null;\n\ttry {\n\t\tscanner = new Scanner(file);\n\t\tscanner.nextLine(); // skip first line\n\t\tscanner.nextLine(); // skip second line\n\t\twhile (scanner.hasNextLine()) {\n\t\t\tString line = scanner.nextLine();\n\t\t\tString[] fields = line.split(\",\");\n\t\t\tString time = fields[0];\n\t\t\tString threadName = fields[1];\n\t\t\tString threadId = fields[2];\n\t\t\tString threadIdAndTime = fields[3];\n\t\t\tString threadDuration = fields[4];\n\t\t\tString threadDurationWithTime = fields[5];\n\t\t\tString threadDurationWithTimeAndTime = fields[6];\n\t\t\tString threadStatus = fields[7];\n\t\t\tString threadStatusWithTime = fields[8];\n\t\t\tString threadTime = fields[9];\n\t\t\tString threadTimeWithTime = fields[10];\n\t\t\tString threadTimeWithTimeAndTime = fields[11];\n\t\t\tString cpu = fields[12];\n\t\t\tString cpuWithTime = fields[13];\n\t\t\tString cpuWithTimeAndTime = fields[14];\n\t\t\tString cpuWithTimeAndTimeAndTime = fields[15];\n\t\t\tString cpuTime = fields[16];\n\t\t\tString cpuTimeWithTime = fields[17];\n\t\t\tString cpuTimeWithTimeAndTime = fields[18];\n\t\t\tString cpuTimeWithTimeAndTimeAndTime = fields[19];\n\t\t\tString cpuExe = fields[20];\n\t\t\tString cpuExeWithTime = fields[21];\n\t\t\tString cpuExeWithTimeAndTime = fields[22];\n\t\t\tString cpuExeWithTimeAndTimeAndTime = fields[23];\n\t\t\tString cpuCpu = fields[24];\n\t\t\tString cpuCpuWithTime = fields[25];\n\t\t\tString cpuCpuWithTimeAndTime = fields[26];\n\t\t\tString cpuCpuWithTimeAndTimeAndTime = fields[27];\n\t\t\tString cpuCpuWithTimeAndTimeAndTimeWithTime = fields[28];\n\t\t\tString cpuCpuWithTimeAndTimeAndTimeWithTime = fields[29];\n\t\t\tString cpuCpuWithTimeAndTimeAndTimeAndTimeWithTime = fields[30];\n\t\t\tString cpuCpuWithTimeAndTimeAndTimeWithTimeAndTime = fields[31];\n\t\t\tString cpuExeWithTimeWithTime = fields[32];\n\t\t\tString cpuExeWithTimeWithTimeAndTime = fields[33];\n\t\t\tString cpuExeWithTimeWithTimeAndTimeAndTime = fields[34];\n\t\t\tString cpuExeWithTimeWithTimeAndTimeAndTimeWithTime = fields[35];\n\t\t\tString cpuCpuWithTimeWithTimeWithTime = fields[36];\n\t\t\tString cpuCpuWithTimeWithTimeAndTimeWithTime = fields[37];\n\t\t\tString cpuCpuWithTimeWithTimeAndTimeWithTimeAndTime = fields[38];\n\t\t\tString cpuCpuWithTimeWithTimeAndTimeWithTimeAndTimeWithTime = fields[39];\n\t\t\tString cpuWithTimeWithTime = fields[40];\n\t\t\tString cpuWithTimeWithTimeWithTimeAndTime = fields[41];\n\t\t\tString cpuWithTimeWithTimeWithTimeAndTimeAndTimeWithTime = fields[42];\n\t\t\tString cpuWithTimeWithTimeAndTimeAndTimeWithTimeWithTime = fields[43];\n\t\t\tString cpuWithTimeWithTimeAndTimeWithTimeAndTimeWithTimeWithTime = fields[44];\n\t\t\tString cpuWithTimeWithTimeAndTimeWithTimeWithTimeAndTimeWithTimeWithTime = fields[45];\n\t\t\tString cpuWithTimeWithTimeAndTimeWithTimeWithTimeAndTimeWithTimeWithTimeWithTime = fields[46];\n\t\t\tString cpuWithTimeWithTimeWithTimeAndTimeWithTimeWithTimeWithTimeWithTimeWithTime = fields[47];\n\t\t\tString cpuWithTimeWithTimeWithTimeWithTimeAndTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTime = fields[48];\n\t\t\tString cpuWithTimeWithTimeWithTimeWithTimeAndTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTime = fields[49];\n\t\t\tString cpuWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWithTimeWith", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader br = null;\n\tString line = null;\n\tStringBuilder builder = new StringBuilder();\n\ttry {\n\t\tbr = new BufferedReader(new FileReader(file));\n\t\twhile((line = br.readLine())!= null) {\n\t\t\tbuilder.append(line).append(\"\\n\");\n\t\t}\n\t} finally {\n\t\tif(br!= null) {\n\t\t\tbr.close();\n\t\t}\n\t}\n\tString[] lines = builder.toString().split(\"\\n\");\n\tfor(int i=0; i<lines.length; i++) {\n\t\tString[] line = lines[i].split(\" \");\n\t\tString startTime = line[0];\n\t\tString endTime = line[1];\n\t\tint start = Integer.parseInt(startTime);\n\t\tint end = Integer.parseInt(endTime);\n\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot(start, end);\n\t\tthreadSnapshots.add(threadSnapshot);\n\t\tfor(int j=2; j<line.length; j++) {\n\t\t\tString[] line2 = line[j].split(\" \");\n\t\t\tString startTime = line2[0];\n\t\t\tString endTime = line2[1];\n\t\t\tint start = Integer.parseInt(startTime);\n\t\t\tint end = Integer.parseInt(endTime);\n\t\t\tthreadSnapshot.addTimeRange(start, end);\n\t\t}\n\t}\n\treturn threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\t\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\t\n\tint maxThreads = 1000;\n\tint numThreads = 0;\n\tif(file!= null) {\n\t\t\n\t\tString[] lines = FileUtils.readFileToString(file).split(\"\\n\");\n\t\tfor(String line: lines) {\n\t\t\tString[] lineSplit = line.split(\" \");\n\t\t\tif(!lineSplit[0].equals(\"\")) {\n\t\t\t\tif(lineSplit[0].startsWith(\"thread\")) {\n\t\t\t\t\tnumThreads++;\n\t\t\t\t\tString[] threads = lineSplit[1].split(\",\");\n\t\t\t\t\tfor(String thread: threads) {\n\t\t\t\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\t\t\t\t\tthreadSnapshot.setThreadName(thread);\n\t\t\t\t\t\tthreadSnapshot.setStartTime(threadSplit[2].substring(0,threadSplit[2].indexOf(\" \")));\n\t\t\t\t\t\tthreadSnapshot.setEndTime(threadSplit[2].substring(threadSplit[2].indexOf(\" \")+1));\n\t\t\t\t\t\tthreadSnapshots.add(threadSnapshot);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<numThreads;i++) {\n\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\tthreadSnapshot.setThreadName(\"thread\"+i);\n\t\tthreadSnapshot.setStartTime(timeRanges.get(i).getStartTime());\n\t\tthreadSnapshot.setEndTime(timeRanges.get(i).getEndTime());\n\t\tthreadSnapshots.add(threadSnapshot);\n\t}\n\t\n\treturn threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> list = new ArrayList<ThreadSnapshot>();\n\tBufferedReader reader = null;\n\ttry {\n\t\treader = new BufferedReader(new FileReader(file));\n\t\tString line = null;\n\t\twhile ((line = reader.readLine())!= null) {\n\t\t\tif (line.startsWith(\"#\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] tokens = line.split(\" \");\n\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\t\tthreadSnapshot.setStartTime(Long.parseLong(tokens[0]));\n\t\t\tthreadSnapshot.setEndTime(Long.parseLong(tokens[1]));\n\t\t\tthreadSnapshot.setProfileName(tokens[2]);\n\t\t\tthreadSnapshot.setThreadName(tokens[3]);\n\t\t\tlist.add(threadSnapshot);\n\t\t}\n\t} finally {\n\t\tif (reader!= null) {\n\t\t\treader.close();\n\t\t}\n\t}\n\treturn list;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> list = new ArrayList<ThreadSnapshot>();\n\t\n\tBufferedReader reader = null;\n\ttry {\n\t\treader = new BufferedReader(new FileReader(file));\n\t\tString str;\n\t\twhile ((str = reader.readLine())!= null) {\n\t\t\tstr = str.trim();\n\t\t\tif (str.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\t\t\tString[] t = str.split(\",\");\n\t\t\t\n\t\t\tint start = Integer.parseInt(t[0]);\n\t\t\tint end = Integer.parseInt(t[1]);\n\t\t\t\n\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot(new ProfileAnalyzeTimeRange(end - start + 1, start, end + 1));\n\t\t\tthreadSnapshot.setTimeRange(timeRanges.get(t[0]));\n\t\t\tlist.add(threadSnapshot);\n\t\t}\n\t} finally {\n\t\tif (reader!= null) {\n\t\t\treader.close();\n\t\t}\n\t}\n\t\n\treturn list;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\t\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\t\n\tif (file.exists() && file.canRead()){\n\t\t\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(file));\n\t\t\tString line = null;\n\t\t\t\n\t\t\twhile ((line = br.readLine())!= null) {\n\t\t\t\tString[] fields = line.split(\",\");\n\t\t\t\t\n\t\t\t\tif (fields.length > 0){\n\t\t\t\t\t\n\t\t\t\t\tlong start = Long.parseLong(fields[0].trim());\n\t\t\t\t\tlong end = Long.parseLong(fields[1].trim());\n\t\t\t\t\t\n\t\t\t\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot(start,end);\n\t\t\t\t\t\n\t\t\t\t\tif (fields.length == 2){\n\t\t\t\t\t\t\n\t\t\t\t\t\tthreadSnapshot.setTimeRange(new ProfileAnalyzeTimeRange(fields[0].trim(),fields[1].trim()));\n\t\t\t\t\t}\n\t\t\t\t\telse if (fields.length == 3){\n\t\t\t\t\t\t\n\t\t\t\t\t\tthreadSnapshot.setTimeRange(new ProfileAnalyzeTimeRange(fields[0].trim(),fields[1].trim(),fields[2].trim()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthreadSnapshots.add(threadSnapshot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (br!= null) br.close();\n\t\t}\n\t}\n\t\n\treturn threadSnapshots;\n\t\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> list = new ArrayList<ThreadSnapshot>();\n\t\n\tFileInputStream fis = new FileInputStream(file);\n\tDataInputStream dis = new DataInputStream(fis);\n\t\n\tProfileAnalyzeTimeRange timeRange = null;\n\twhile (true) {\n\t\ttimeRange = new ProfileAnalyzeTimeRange();\n\t\t\n\t\t// read header\n\t\tbyte[] header = new byte[4];\n\t\tdis.readFully(header);\n\t\t\n\t\t// read time range\n\t\tint bytesRead = dis.read(header);\n\t\t\n\t\tif(bytesRead == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint start = getInt(header,0);\n\t\tint end = getInt(header,4);\n\t\t\n\t\ttimeRange.setStartTime(start);\n\t\ttimeRange.setEndTime(end);\n\t\t\n\t\t// read profile\n\t\tbyte[] profile = new byte[(end-start)*2];\n\t\tdis.readFully(profile);\n\t\t\n\t\t// parse profile\n\t\tProfileAnalyzeProfile profileAnalyze = new ProfileAnalyzeProfile();\n\t\tprofileAnalyze.parseProfile(profile);\n\t\t\n\t\t// check if it's a new profile\n\t\tif(profileAnalyze.getProfile().getId()!= profile[\"profileid\"]){\n\t\t\tlist.add(profileAnalyze);\n\t\t}\n\t\t\n\t\t// reset\n\t\tdis.reset();\n\t}\n\t\n\treturn list;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\t// read file\n\tBufferedReader br = new BufferedReader(new FileReader(file));\n\tString line;\n\twhile ((line = br.readLine())!= null) {\n\t\tString[] st = line.split(\" \");\n\t\t// load thread\n\t\tThreadSnapshot threadSnapshot = new ThreadSnapshot();\n\t\tthreadSnapshot.setThreadId(st[0]);\n\t\tthreadSnapshot.setTimeRange(new ProfileAnalyzeTimeRange(st[1],st[2]));\n\t\tthreadSnapshots.add(threadSnapshot);\n\t}\n\tbr.close();\n\t\n\treturn threadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\t\n\ttry {\n\t\tFileInputStream fis = new FileInputStream(file);\n\t\tList<String> lines = IOUtils.readLines(fis);\n\t\tint lineNumber = 0;\n\t\tfor (String line : lines) {\n\t\t\tString[] data = line.split(\"\\t\");\n\t\t\tif (data.length < 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange();\n\t\t\ttimeRange.setStartTime(Long.parseLong(data[0]));\n\t\t\ttimeRange.setEndTime(Long.parseLong(data[1]));\n\t\t\tif (timeRanges.size() < 1) {\n\t\t\t\ttimeRange.setInterval(Integer.parseInt(data[2]));\n\t\t\t} else {\n\t\t\t\ttimeRange.setInterval(Integer.parseInt(data[2]));\n\t\t\t}\n\t\t\tthreadSnapshots.add(new ThreadSnapshot(lineNumber,timeRange));\n\t\t\tlineNumber++;\n\t\t}\n\t} catch (IOException e) {\n\t\tthrow new IOException(\"Error loading thread snapshot file: \" + file.getName());\n\t}\n\t\n\treturn threadSnapshots;\n}"]}
{"_id": "636767e01a6d9265ec018764", "generate_results": ["/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject result = new JsonObject();\n\tresult.addProperty(\"name\", properties.get(0).getKey());\n\tresult.addProperty(\"value\", properties.get(0).getValue());\n\treturn result;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject root = new JsonObject();\n\troot.addProperty(\"name\", \"Process properties\");\n\troot.addProperty(\"enabled\", Boolean.TRUE);\n\troot.addProperty(\"process_type\", \"process\");\n\troot.addProperty(\"process_description\", \"process\");\n\troot.addProperty(\"process_status\", \"OK\");\n\troot.addProperty(\"process_log\", \"info\");\n\troot.addProperty(\"process_pid\", \"0\");\n\troot.addProperty(\"process_start_time\", \"0\");\n\troot.addProperty(\"process_end_time\", \"0\");\n\troot.addProperty(\"process_memory\", \"0\");\n\troot.addProperty(\"process_io_counters\", \"0\");\n\troot.addProperty(\"process_cpu_counters\", \"0\");\n\troot.addProperty(\"process_cpu_percent\", \"0\");\n\troot.addProperty(\"process_cpu_time\", \"0\");\n\troot.addProperty(\"process_cpu_usage\", \"0\");\n\troot.addProperty(\"process_cpu_percent\", \"0\");\n\troot.addProperty(\"process_cpu_time\", \"0\");\n\troot.addProperty(\"process_cpu_usage\", \"0\");\n\troot.addProperty(\"process_cpu_percent\", \"0\");\n\troot.addProperty(\"process_cpu_time\", \"0\");\n\troot.addProperty(\"process_memory\", \"0\");\n\troot.addProperty(\"process_io_counters\", \"0\");\n\troot.addProperty(\"process_io_bytes\", \"0\");\n\troot.addProperty(\"process_io_read_bytes\", \"0\");\n\troot.addProperty(\"process_io_write_bytes\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_read_bytes\", \"0\");\n\troot.addProperty(\"process_io_write_bytes\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_read_bytes\", \"0\");\n\troot.addProperty(\"process_io_write_bytes\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_read_bytes\", \"0\");\n\troot.addProperty(\"process_io_write_bytes\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"0\");\n\troot.addProperty(\"process_io_read_time\", \"0\");\n\troot.addProperty(\"process_io_write_time\", \"", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    \n    JsonObject result = new JsonObject();\n    \n    for(KeyStringValuePair property : properties){\n        \n        String key = property.getKey();\n        \n        // skip empty string properties\n        if(key.isEmpty()){\n            continue;\n        }\n        \n        JsonObject propertyValue = new JsonObject();\n        \n        // ignore properties with null values\n        if(property.getValue() == null){\n            continue;\n        }\n        \n        propertyValue.addProperty(key, property.getValue());\n        \n        result.add(key, propertyValue);\n    }\n        \n    return result;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    \n    JsonObject object = new JsonObject();\n    \n    for (KeyStringValuePair property : properties) {\n        object.addProperty(property.getKey(), property.getValue());\n    }\n    \n    return object;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\t\n\tJsonObject json = new JsonObject();\n\t\n\tfor (KeyStringValuePair p : properties) {\n\t\t\n\t\tString key = p.getKey();\n\t\t\n\t\tif (!isBlank(key)) {\n\t\t\tjson.addProperty(key, p.getValue());\n\t\t}\n\t}\n\t\n\treturn json;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject result = new JsonObject();\n\t\n\tfor (KeyStringValuePair property : properties){\n\t\tString name = property.getKeyString();\n\t\tString value = property.getValueString();\n\t\t\n\t\tresult.addProperty(name, value);\n\t}\n\t\n\treturn result;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tJsonObject result = new JsonObject();\n\t\n\tfor (KeyStringValuePair property : properties){\n\t\tString name = property.getKey();\n\t\tString value = property.getValue();\n\t\t\n\t\tif (property.getValue() == null)\n\t\t\tresult.addProperty(name, null);\n\t\telse\n\t\t\tresult.addProperty(name, value);\n\t}\n\t\n\treturn result;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject output = new JsonObject();\n    \n    for(KeyStringValuePair kv : properties){\n        output.addProperty(kv.getKey(), kv.getValue());\n    }\n    return output;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n\tif (properties == null) return null;\n\tJsonObject ret = new JsonObject();\n\tfor (KeyStringValuePair property : properties) {\n\t\tret.add(property.getKey().toString(), property.getValue());\n\t}\n\treturn ret;\n}", "/** \n * Convert process properties to source data\n */\n\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject result = new JsonObject();\n    for (KeyStringValuePair property : properties) {\n        result.add(property.getKey(), property.getValue());\n    }\n    return result;\n}"]}
{"_id": "636766a91a6d9265ec0175c2", "generate_results": ["/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n\treturn this.outputFrameStack.pop();\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n    return outputFrameStack[outputFrameStackPtr] & 0xffff;\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n\n    int value = frame_stack[top];\n\n    top = (top + 1) % frame_stack_size;\n\n    return value;\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n\tif(output.empty()){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn output.pop();\n\t}\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n    int[] ret = new int[1];\n    ret[0] = outputFrameStack[outputFrameStack.size() - 1];\n    outputFrameStack.remove(outputFrameStack.size() - 1);\n    return ret[0];\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n\tif(frameStack.size==0){\n\t\treturn -1;\n\t}\n\tint val = frameStack.pop();\n\tframeStack.push(val);\n\treturn val;\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n  int ret = stack.pop();\n  return ret;\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n\treturn frameStack.pop();\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n    if(isEmpty()){\n        throw new IllegalArgumentException(\"The internal stack is empty\");\n    }\n    int top = frame.pop();\n    if(top == -1){\n        throw new IllegalArgumentException(\"The internal stack is empty\");\n    }\n    return top;\n}", "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n\nprivate int pop(){\n    return frame[frame_pos].type;\n}"]}
{"_id": "636766aa1a6d9265ec0175ce", "generate_results": ["/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}", "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}"]}
{"_id": "636766a91a6d9265ec0175c1", "generate_results": ["/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\n\tbyte[] enlarged = new byte[size];\n\tSystem.arraycopy(this.data, 0, enlarged, 0, this.data.length);\n\tthis.data = enlarged;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n    byteVector.ensureCapacity( byteVector.length() + size );\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tif(this.size+size < this.capacity){\n\t\tthis.capacity = this.capacity*2;\n\t\tthis.buffer = new byte[this.capacity];\n\t}\n\tthis.size += size;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyte[] newArray = new byte[size];\n\tSystem.arraycopy(data, 0, newArray, 0, data.length);\n\tdata = newArray;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyteVector.ensureCapacity(byteVector.capacity() + size);\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyteVector.ensureCapacity(byteVector.size() + size);\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tthis.size += size;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tfinal byte[] newBuf = new byte[newSize + size];\n\tSystem.arraycopy(buffer, 0, newBuf, 0, buffer.length);\n\tbuffer = newBuf;\n\tnewSize += size;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyte[] newB = new byte[size];\n\tSystem.arraycopy(this,0,newB,0,size);\n\tthis = newB;\n}", "/** \n * Enlarges this byte vector so that it can receive'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n\nprivate void enlarge(final int size){\n\tbyte[] newBytes = new byte[size];\n\tSystem.arraycopy(bytes, 0, newBytes, 0, bytes.length);\n\tbytes = newBytes;\n}"]}
{"_id": "636766a91a6d9265ec0175ae", "generate_results": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteLength>this.length){\n\t\tthis.length=byteLength;\n\t}\n\tif(byteOffset>=byteArrayValue.length){\n\t\tthrow new IllegalArgumentException(\"byteArrayValue length is bigger than byte length\");\n\t}\n\tbyte[] byteArray=this.byteArray;\n\tif(byteArray==null){\n\t\tbyteArray=new byte[byteLength+1];\n\t\tSystem.arraycopy(byteArrayValue, byteOffset, byteArray, 0, byteLength);\n\t}else{\n\t\tSystem.arraycopy(byteArrayValue, byteOffset, byteArray, 0, byteLength);\n\t}\n\tbyteArray[byteLength]=0;\n\tthis.byteArray=byteArray;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteArrayValue == null){\n        return this;\n    }\n    final int length = byteLength;\n    if(byteArrayValue.length < byteOffset + length){\n        enlarge(byteArrayValue.length);\n    }\n    System.arraycopy(byteArrayValue, byteOffset, this.bytes, this.offset, length);\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteLength == 0){\n        return this;\n    }\n    int length = byteLength;\n    if(byteArrayValue.length < byteOffset + length){\n        length = byteArrayValue.length - byteOffset;\n    }\n    byteVector.size += length;\n    byteVector.data = Arrays.copyOfRange(byteVector.data, byteVector.size, byteVector.size + byteLength);\n    System.arraycopy(byteArrayValue, byteOffset, byteVector.data, byteVector.size, length);\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\tbyteArrayValue = new byte[byteLength];\n\t}\n\tif(byteLength > 0){\n\t\tSystem.arraycopy(byteArrayValue,byteOffset,byteArrayValue,0,byteLength);\n\t\tthis.byteLength = byteLength;\n\t}else{\n\t\tbyteArrayValue = null;\n\t\tthis.byteLength = 0;\n\t}\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n    if(byteArrayValue == null){\n        this.byteArrayValue = null;\n        this.byteOffset = byteOffset;\n        this.byteLength = 0;\n    }else{\n        this.byteArrayValue = byteArrayValue.clone();\n        this.byteOffset = byteOffset;\n        this.byteLength = byteLength;\n    }\n    return this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif (byteArrayValue == null){\n\t\treturn this;\n\t}\n\tint newLength = byteLength + byteOffset;\n\tif (newLength > this.byteCapacity){\n\t\tenlarge();\n\t}\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteVector, byteOffset, byteLength);\n\tbyteOffset += byteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteLength == 0){\n\t\treturn this;\n\t}\n\tfinal int byteLengthNormalized=byteLength-1;\n\tif(byteLengthNormalized < 0){\n\t\treturn this;\n\t}\n\tfinal int byteLengthNormalized2=byteLengthNormalized+1;\n\tif(byteOffset < 0){\n\t\treturn this;\n\t}\n\tfinal int byteLengthNormalized3=byteLengthNormalized2+1;\n\tif(byteOffset > byteLengthNormalized3){\n\t\treturn this;\n\t}\n\tif(byteArrayValue == null){\n\t\treturn this;\n\t}\n\tfinal int byteOffsetNormalized=byteOffset;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal int byteLengthNormalized3=byteLengthNormalized3;\n\tfinal byte[] byteArrayValueNormalized=byteArrayValue;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal int byteLengthNormalized3=byteLengthNormalized3;\n\tfinal byte[] byteArrayValueNormalized2=byteArrayValueNormalized;\n\tfinal int byteLengthNormalized3=byteLengthNormalized3;\n\tfinal byte[] byteArrayValueNormalized2=byteArrayValueNormalized2;\n\tfinal int byteLengthNormalized=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized3=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized3=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized4=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized3=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized4=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized3=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized4=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized2=byteLengthNormalized2;\n\tfinal byte[] byteArrayValueNormalized3=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized3=byteLengthNormalized3;\n\tfinal byte[] byteArrayValueNormalized4=byteArrayValueNormalized3;\n\tfinal int byteLengthNormalized4=byteLengthNormalized3;\n\tfinal byte[] byteArrayValueNormalized5=byteArrayValueNormalized4;\n\tfinal int byteLengthNormalized5=byteLengthNormalized4;\n\tfinal byte[] byteArrayValueNormalized6=byteArrayValueNormalized5;\n\tfinal int byteLengthNormalized6=byteLengthNormalized5;\n\tfinal byte[] byteArrayValueNormalized7=byteArrayValueNormalized6;\n\tfinal int byteLengthNormalized7=byteLengthNormalized6;\n\tfinal byte[] byteArrayValueNormalized8=byteArrayValueNormalized7;\n\tfinal int byteLengthNormalized8=byteLengthNormalized7;\n\tfinal byte[] byteArrayValueNormalized9=byteArrayValueNormalized8;\n\tfinal int byteLengthNormalized9=byteLengthNormalized8;\n\tfinal byte[] byteArrayValueNormalized10=byteArrayValueNormalized9;\n\tfinal int byteLengthNormalized10=byteLengthNormalized9;\n\tfinal byte[] byteArrayValueNormalized11=byteArrayValueNormalized10;\n\tfinal int byteLengthNormalized11=byteLengthNormalized10;\n\tfinal byte[] byteArrayValueNormalized12=byteArrayValueNormalized11;\n\tfinal int byteLengthNormalized12=byteLengthNormal", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\treturn putByteArray(byteArrayValue,byteOffset,byteLength,ByteVector.DEFAULT_SIZE);\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteLength > byteArrayValue.length - byteOffset)\n\t\tthrow new IllegalArgumentException(\"byteArrayValue.length - byteOffset cannot be greater than byteArrayValue.length - \"+byteOffset+\"\");\n\t\n\tbyteLength = byteArrayValue.length - byteOffset;\n\tbyteArrayValue = byteArrayValue.clone();\n\t\n\tif(byteLength > 0)\n\t\tenlarge(byteLength);\n\t\n\tint offset = byteOffset;\n\tint length = byteLength;\n\t\n\tfinal int copyLength = Math.min(byteLength, byteArrayValue.length - offset);\n\tfor(int i = 0; i < copyLength; i++){\n\t\tbyteArrayValue[offset++] = byteArrayValue[i];\n\t}\n\t\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue == null){\n\t\tbyteArrayValue = new byte[byteLength];\n\t}else if(byteArrayValue.length < byteLength){\n\t\tbyteLength = byteArrayValue.length;\n\t}\n\tfor(int i = 0 ; i < byteLength ; i++){\n\t\tbyteArrayValue[byteOffset + i] = byteArrayValue[i];\n\t}\n\tenlargeIfNeeded();\n\treturn this;\n}"]}
{"_id": "636766a81a6d9265ec017586", "generate_results": ["/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n    final int size = frame.size();\n    // if the stack is not empty\n    if(size > 0){\n        // remove the top element\n        frame.pop();\n        // set the number of elements to the number of elements\n        // before the top element\n        frameSize = frame.size();\n    }\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\t\n\twhile(elements > 0){\n\t\t\n\t\t// Find the last abstract type that is not a subclass of a superclass.\n\t\t\n\t\tAbstractType previous = null;\n\t\tfor(AbstractType t : stack){\n\t\t\t\n\t\t\tif(t instanceof AbstractType){\n\t\t\t\t\n\t\t\t\tif(((AbstractType)t).getSuperclass()!= null \n\t\t\t\t\t\t&& ((AbstractType)t).getSuperclass().getName().equals(type.getName())){\n\t\t\t\t\t\n\t\t\t\t\tprevious = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(previous!= null){\n\t\t\t\n\t\t\t// Remove this abstract type from the stack.\n\t\t\t\n\t\t\tstack.remove(previous);\n\t\t\t\n\t\t\t// Update the number of abstract types popped.\n\t\t\t\n\t\t\telements--;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\t\n\tif(elements == 0){\n\t\treturn;\n\t}\n\t\n\tfinal int last = outputFrameStack.size()-1;\n\toutputFrameStack.set(last, outputFrameStack.pop());\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\tfor(int i = 0; i < elements; i++){\n\t\tframe.pop();\n\t}\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\tif(elements == 0)\n\t\treturn;\n\t\n\tfinal Stack<AbstractType<?>> old = stack();\n\t\n\tfor(int i = 0; i < elements; i++)\n\t\told.pop();\n\t\n\tstack(old);\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\tif (outputFrameStack.isEmpty()){\n\t\treturn;\n\t}\n\n\tfinal Object[] result = outputFrameStack.pop();\n\tif (result == null){\n\t\treturn;\n\t}\n\t\n\tfinal Object[] values = (Object[]) result[1];\n\tfinal int size = values.length;\n\tfor (int i = 0; i < size; ++i){\n\t\toutputFrameStack.pop();\n\t}\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n    if(elements >= 0)\n        this.stack[this.stackTop - elements - 1] = null;\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n  \n  // get the current stack frame\n  final int frame = getFrame();\n  \n  // if there is no frame at all, there is nothing to pop\n  if(frame == 0){\n    return;\n  }\n  \n  // pop the elements from the stack frame\n  for(int i = 0; i < elements; i++){\n    \n    // pop the abstract type from the frame\n    pop();\n    \n    // pop the abstract type from the stack frame\n    pop();\n    \n  }\n  \n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\t\n\tfor(int i = 0; i < elements; i++){\n\t\t\n\t\tthis.outputFrameStack.pop();\n\t\t\n\t}\n\t\n}", "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n\nprivate void pop(final int elements){\n\ttry {\n\t\twhile(elements > 0){\n\t\t\tpush(elements);\n\t\t\telements --;\n\t\t}\n\t}\n\tcatch(final OutOfMemoryError ex){\n\t\tthrow new RuntimeException(\"OutOfMemoryError\");\n\t}\n}"]}
{"_id": "636766a81a6d9265ec017596", "generate_results": ["public ByteVector putInt(final int intValue){\n    if (size + 4 > capacity) resize(capacity << 1);\n    \n    byte[] buffer = data;\n    \n    buffer[size++] = (byte)(intValue >>> 24);\n    buffer[size++] = (byte)(intValue >>> 16);\n    buffer[size++] = (byte)(intValue >>> 8);\n    buffer[size++] = (byte)intValue;\n    \n    return this;\n}", "public ByteVector putInt(final int intValue){\n\tif(intValue < 0){\n\t\tthrow new IllegalArgumentException(\"The value of intValue must be >= 0\");\n\t}\n\n\tif(intValue == 0){\n\t\treturn this;\n\t}\n\n\t// if intValue is already the maximum value, then no need to increase the size of the byte vector\n\tif(intValue == Integer.MAX_VALUE){\n\t\treturn this;\n\t}\n\n\t// if intValue is already the minimum value, then no need to increase the size of the byte vector\n\tif(intValue == Integer.MIN_VALUE){\n\t\treturn this;\n\t}\n\n\t// if the size of the byte vector is zero, then increase the size of the byte vector\n\tif(size == 0){\n\t\tenlargeIfNecessary();\n\t\treturn this;\n\t}\n\n\t// if the size of the byte vector is greater than the value of intValue, then increase the size of the byte vector\n\tif(size > intValue){\n\t\tenlargeIfNecessary();\n\t\treturn this;\n\t}\n\n\t// otherwise, the size of the byte vector is the same as intValue, so set the size to intValue\n\t// and then set the current byte vector to the value of intValue\n\tthis.size = size;\n\tthis.data[size++] = (byte)(intValue);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n    if (intValue < 0 || intValue >= _data.length) {\n        final int newLength = _data.length + (intValue > 0? 1 : -1);\n        final byte[] newData = new byte[newLength];\n        System.arraycopy(_data, 0, newData, 0, _data.length);\n        _data = newData;\n    }\n    _data[_data.length] = (byte)intValue;\n    return this;\n}", "public ByteVector putInt(final int intValue){\n\treturn putInt(intValue & 0xFF);\n}", "public ByteVector putInt(final int intValue){\n\tif(intValue>=0){\n\t\tintValueOfThisByteVector.add(intValue);\n\t\treturn this;\n\t}\n\telse{\n\t\tintValueOfThisByteVector.add(0);\n\t\treturn this;\n\t}\n}", "public ByteVector putInt(final int intValue){\n\tfinal int index = size;\n\tif(index >= capacity){\n\t\tfinal int newCapacity = (capacity + Integer.BYTES) * 2;\n\t\tfinal byte[] newVector = new byte[newCapacity];\n\t\tSystem.arraycopy(data, 0, newVector, 0, index);\n\t\tdata = newVector;\n\t}\n\tdata[index] = (byte)intValue;\n\tsize = index + Integer.BYTES;\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n    if (length() + 4 < capacity)\n        super.putInt(intValue);\n    else\n        ensureCapacity(length() + 4);\n    buffer[offset++] = (byte)intValue;\n    buffer[offset++] = (byte)(intValue >>> 8);\n    buffer[offset++] = (byte)(intValue >>> 16);\n    buffer[offset++] = (byte)(intValue >>> 24);\n    return this;\n}", "public ByteVector putInt(final int intValue){\n    if(this.size + intValue > this.maxLength){\n        this.maxLength = this.size + intValue;\n        this.data = new byte[this.maxLength];\n    }\n    this.data[this.size] = (byte)(intValue);\n    this.size += 1;\n    return this;\n}", "public ByteVector putInt(final int intValue){\n    if(isFull()){\n        enlarge();\n        putInt(intValue);\n    }else{\n        buffer[offset+offset] = (byte)(intValue & 0xFF);\n    }\n    return this;\n}", "public ByteVector putInt(final int intValue){\n    if(intValue>0){\n        ensureCapacity(4 + 4);\n        byte[] data = this.data;\n        data[0] = 0x0;\n        data[1] = (byte)(intValue >>> 24);\n        data[2] = (byte)(intValue >>> 16);\n        data[3] = (byte)(intValue >>> 8);\n        data[4] = (byte)intValue;\n        return this;\n    }else{\n        return putInt(0);\n    }\n}"]}
{"_id": "636766a91a6d9265ec0175c4", "generate_results": ["/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tfinal String desc = descriptor.substring(0, descriptor.length()-1);\n\tfinal int stackSize = stack.size();\n\tfor(int i = stackSize-1; i >= 0; i--){\n\t\tif(stack.get(i).desc.equals(desc)){\n\t\t\tstack.remove(i);\n\t\t\tfinal int index = i;\n\t\t\tstack.get(index).index = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tthrow new IllegalArgumentException(\"The \" + descriptor + \" can't be found in any of the types in the stack.\");\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tfinal int count = m_stack.length;\n\tfor(int i = 0; i < count; i++){\n\t\tfinal String s = m_stack[i];\n\t\tif(s.equals(descriptor)){\n\t\t\tm_stack[i] = null;\n\t\t\treturn;\n\t\t}\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tfor(int i = 0; i < stack.size(); i++){\n\t\tif(stack.get(i) instanceof AbstractMethodDescriptor){\n\t\t\t((AbstractMethodDescriptor)stack.get(i)).setArgumentTypes(descriptor);\n\t\t}\n\t\telse if(stack.get(i) instanceof AbstractType){\n\t\t\t((AbstractType)stack.get(i)).setArgumentTypes(descriptor);\n\t\t}\n\t}\n\tstack.clear();\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tif(descriptor.equals(\"<init>\")){\n\t\tthrow new UnsupportedOperationException(\"Cannot pop <init> arguments from a frame stack\");\n\t}\n\t\n\tif(descriptor.equals(\"<clinit>\")){\n\t\tthrow new UnsupportedOperationException(\"Cannot pop <clinit> arguments from a frame stack\");\n\t}\n\t\n\tif(descriptor.equals(\"<dummy>\")){\n\t\tthrow new UnsupportedOperationException(\"Cannot pop <dummy> arguments from a frame stack\");\n\t}\n\t\n\tif(descriptor.equals(\"<array>\")){\n\t\tfor(int i = 0; i < stack.size() - 1; i++){\n\t\t\tstack.pop();\n\t\t}\n\t\tthrow new UnsupportedOperationException(\"Cannot pop <array> arguments from a frame stack\");\n\t}\n\t\n\tint n = stack.size();\n\t\n\tObject[] result = stack.pop();\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tresult[i] = stack.pop();\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if(descriptor!= null){\n        int index = 0;\n        while(index < frameStack.length && frameStack[index]!= null){\n            index++;\n        }\n        if(index < frameStack.length){\n            frameStack[index] = null;\n        }\n    }\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\t// if the stack is empty, we're done; otherwise, pop the first argument from the stack\n\t// and store the result\n\tif(stack.empty()){\n\t\tstack.push(descriptor);\n\t}else{\n\t\tstack.pop();\n\t\tstack.push(descriptor);\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    for(int i = 0; i < frame.getLocalVariablesCount(); i++){\n        frame.getLocalVariable(i).setDescriptor(null);\n    }\n    frame.getLocalVariablesCount() = 0;\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if (descriptor == null) return;\n    if (descriptor.equals(Type.getType(Object.class))) {\n        throw new IllegalArgumentException(\"Cannot pop object\");\n    }\n    if (descriptor.equals(Type.getType(Method.class))) {\n        throw new IllegalArgumentException(\"Cannot pop method\");\n    }\n    if (descriptor.equals(Type.getType(Field.class))) {\n        throw new IllegalArgumentException(\"Cannot pop field\");\n    }\n    for (int i = 0; i < frameStack.size() - 1; i++) {\n        Object result = frameStack.get(i);\n        if (result.getClass() == descriptor) {\n            frameStack.remove(i);\n        }\n    }\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n\tfinal int count = getFrameStack().size() - 1;\n\tfor(int i = 0; i < count; ++i){\n\t\tfinal ClassNode cn = getFrameStack().get(i);\n\t\tfinal AnnotationNode at = cn.getAnnotation(descriptor);\n\t\tif(at!= null){\n\t\t\tgetFrameStack().remove(i);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n\nprivate void pop(final String descriptor){\n    if (descriptor.equals(\"java.lang.Object\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.String\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Boolean\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Character\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Byte\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Short\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Integer\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Long\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Float\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Double\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Void\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Class\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else if (descriptor.equals(\"java.lang.Throwable\")){\n        frameStack.remove(frameStack.size() - 1);\n    } else {\n        frameStack.remove(frameStack.size() - 1);\n    }\n}"]}
{"_id": "636766a81a6d9265ec017595", "generate_results": ["/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n    byte result = 0;\n    if(byteValue1 >= 0 && byteValue2 >= 0){\n        result = byteValue1 | byteValue2;\n        byteVector.enlargeIfNeeded();\n    }else if(byteValue1 < 0){\n        result = ~byteValue1 & 0xFF;\n        byteVector.enlargeIfNeeded();\n    }else if(byteValue2 < 0){\n        result = ~byteValue2 & 0xFF;\n        byteVector.enlargeIfNeeded();\n    }\n    return result;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1!= byteValue2){\n\t\tbyteValue1 = (byte)(byteValue1 + byteValue2);\n\t\tbyteValue2 = (byte)byteValue2;\n\t\t\n\t\tbyteValue1 = (byte)(byteValue1 << 1);\n\t\tbyteValue2 = (byte)(byteValue2 << 1);\n\t\t\n\t\tbyteValue1 = (byte)(byteValue1 | byteValue2);\n\t\t\n\t\tbyteValue2 = (byte)(byteValue2 | byteValue1);\n\t}\n\t\n\tbyteValue1 = (byte)(byteValue1 << 1);\n\tbyteValue2 = (byte)(byteValue2 << 1);\n\t\n\tbyteValue1 = (byte)(byteValue1 | byteValue2);\n\t\n\treturn this;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1>=0 && byteValue1<=255){\n\t\tbyteValue1=0;\n\t}\n\tif(byteValue2>=0 && byteValue2<=255){\n\t\tbyteValue2=0;\n\t}\n\tbyteValue1=byteValue1<<8|byteValue1;\n\tbyteValue2=byteValue2<<8|byteValue2;\n\tbyteValue1+=byteValue2;\n\tbyteValue2+=byteValue1;\n\tbyteValue1=byteValue1&0xff;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|byteValue1;\n\tbyteValue1=byteValue1|byteValue2;\n\tbyteValue2=0;\n\tbyteValue2=byteValue2&0xff;\n\tbyteValue2=byteValue2|", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif (byteValue1>=255){\n\t\tbyteValue1-=256;\n\t}\n\tif (byteValue2>=255){\n\t\tbyteValue2-=256;\n\t}\n\tbyteValue1<<=8;\n\tbyteValue1|=byteValue2;\n\treturn this;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1>=0xFF && byteValue2>=0xFF){\n\t\tenlargeIfNeeded(2);\n\t\tputInt(byteValue1);\n\t\tputInt(byteValue2);\n\t\treturn this;\n\t}\n\telse{\n\t\tputInt(byteValue1);\n\t\tputInt(byteValue2);\n\t\treturn this;\n\t}\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1<0 || byteValue1>255){\n\t\tthrow new IllegalArgumentException(\"Invalid value for byte1: \"+byteValue1);\n\t}\n\tif(byteValue2<0 || byteValue2>255){\n\t\tthrow new IllegalArgumentException(\"Invalid value for byte2: \"+byteValue2);\n\t}\n\tint byteValue=byteValue1<<8|byteValue2;\n\tint newSize=size+1;\n\tif(newSize>maxSize){\n\t\tthrow new IllegalStateException(\"Possibly corrupting the byte vector\");\n\t}\n\tif(newSize>=maxSize){\n\t\tbyteValue=byteValue|(byteValue1<<8);\n\t\tbyteValue=byteValue|(byteValue2&0xff);\n\t\treturn this;\n\t}\n\tbyteValue|=0x00;\n\tbyteValue1=0x00;\n\tbyteValue2=0x00;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4;\n\tbyteValue=byteValue<<4", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tbyteValue1 >>>= 7;\n\tbyteValue2 >>>= 7;\n\tif(byteValue1 == 0){\n\t\tbyteValue1 = 1;\n\t}\n\tif(byteValue2 == 0){\n\t\tbyteValue2 = 1;\n\t}\n\tbyteValue1 |= byteValue2;\n\tbyteValue2 = byteValue1 << 7;\n\treturn this;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif (byteValue1 == byteValue2) {\n\t\treturn this;\n\t}\n\tif (byteValue1 > byteValue2) {\n\t\tint temp = byteValue1;\n\t\tbyteValue1 = byteValue2;\n\t\tbyteValue2 = temp;\n\t}\n\tif (byteValue1 == 0) {\n\t\treturn this;\n\t}\n\tbyte temp = (byte)(byteValue1 | (byteValue2 << 8));\n\tput0(temp);\n\treturn this;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\t\n\tif (byteValue1 > 255) {\n\t\tbyteValue1 = 255;\n\t}\n\tif (byteValue2 > 255) {\n\t\tbyteValue2 = 255;\n\t}\n\t\n\tbyte b = (byte)byteValue1;\n\tbyte v = (byte)byteValue2;\n\t\n\tthis.data[this.offset++] = b;\n\tthis.data[this.offset++] = v;\n\t\n\treturn this;\n}", "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1>=0xFF && byteValue2>=0xFF){\n\t\tfinal int index = byteValue1 - 0xFF;\n\t\tbyteValue1 = byteValue1 & 0xFF;\n\t\tbyteValue2 = byteValue2 & 0xFF;\n\t\tbyteValue1 = byteValue1 <<8 | byteValue2;\n\t\treturn this;\n\t}\n\telse if(byteValue1>=0x80 && byteValue2>=0x80){\n\t\tfinal int index = byteValue1 - 0x80;\n\t\tbyteValue1 = byteValue1 & 0x7F | byteValue2;\n\t\treturn this;\n\t}\n\telse{\n\t\tfinal int index = byteValue1 - 0x80;\n\t\tbyteValue1 = byteValue1 & 0x7F | byteValue2 <<7;\n\t\treturn this;\n\t}\n}"]}
{"_id": "636766a81a6d9265ec01757b", "generate_results": ["public String toString(List<JSONWriter.Feature> features){\n\t\n\tJSONWriter.Feature[] featuresArray = features.toArray(new JSONWriter.Feature[features.size()]);\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tsb.append(\"{\");\n\n\tfor(int i = 0; i < featuresArray.length; i++){\n\t\t\n\t\tif(i!= 0){\n\t\t\tsb.append(\",\");\n\t\t}\n\t\t\n\t\tsb.append(featuresArray[i].toString());\n\t}\n\t\n\tsb.append(\"}\");\n\t\n\treturn sb.toString();\n}", "/** \n * Serialize to JSON  {@link String}", "/** \n * Serialize to JSON  {@link String}", "/** \n * Serialize to JSON  {@link String}", "public String toString(JSONWriter.Feature... features, boolean jsonSerialize, boolean[] enabledFeatures){\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tif(features!= null && features.length > 0){\n\t\t\n\t\tfor(JSONWriter.Feature feature : features){\n\t\t\t\n\t\t\tif(feature == null){\n\t\t\t\t\n\t\t\t\tsb.append(\"null\");\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tsb.append(feature.toString());\n\t\t\t\t\n\t\t\t\tif(feature.jsonSerialize()){\n\t\t\t\t\t\n\t\t\t\t\tsb.append(\"{\");\n\t\t\t\t\t\n\t\t\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\t\t\t\n\t\t\t\t\tsb2.append(\"\\\"enabledFeatures\\\":\");\n\t\t\t\t\tsb2.append(enabledFeatures);\n\t\t\t\t\tsb2.append(\"}\");\n\t\t\t\t\t\n\t\t\t\t\tsb.append(sb2);\n\t\t\t\t\t\n\t\t\t\t\tsb.append(\"}\");\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\tsb.append(\"{\");\n\t\t\t\t\t\n\t\t\t\t\tsb2 = new StringBuilder();\n\t\t\t\t\t\n\t\t\t\t\tsb2.append(\"\\\"enabledFeatures\\\":\");\n\t\t\t\t\tsb2.append(enabledFeatures);\n\t\t\t\t\tsb2.append(\"}\");\n\t\t\t\t\t\n\t\t\t\t\tsb.append(sb2);\n\t\t\t\t\t\n\t\t\t\t\tsb.append(\"}\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}", "public String toString(List<JSONWriter.Feature> features, boolean includeType){\n\treturn toString(features.toArray(new JSONWriter.Feature[features.size()]));\n}", "public String toString(JSONWriter.Feature feature, String prefix, String suffix){\n\tString[] featuresArray = new String[2];\n\tfeaturesArray[0] = prefix;\n\tfeaturesArray[1] = suffix;\n\tStringWriter stringWriter = new StringWriter();\n\tJSONWriter.Feature[] featuresToBeSerialized = featuresArray;\n\tfor(int i = 0; i < featuresArray.length; i++){\n\t\tJSONWriter.Feature feature = featuresArray[i];\n\t\tif(featuresToBeSerialized!= null && feature!= null){\n\t\t\tfeature.serialize(stringWriter);\n\t\t\tfeaturesToBeSerialized = featuresToBeSerialized.clone();\n\t\t}\n\t}\n\treturn stringWriter.toString();\n}", "public String fromJSON(String content){\n\t\n\tString json = content.substring(1, content.length()-1);\n\t\n\tJSONParser parser = new JSONParser();\n\tJSONFeature feature;\n\t\n\ttry {\n\t\tfeature = parser.parseFeature(json, JSONFeature.class);\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n\t\n\treturn feature.getName();\n}", "public String toString(JSONWriter.Feature... features){\n    JSONWriter.Feature[] array = features;\n    StringBuilder strb = new StringBuilder();\n    for (int i = 0; i < array.length; i ++ ){\n        strb.append(array[i].name()).append(\"=\").append(array[i].toString(array[i]));\n        if ( i < array.length - 1 )\n            strb.append(\",\");\n    }\n    return strb.toString();\n}", "public String toString(JSONWriter.Feature... features){\n    StringBuilder buf = new StringBuilder();\n    buf.append(\"{\");\n    \n    for (int i = 0; i < features.length; i++){\n    \tbuf.append(\"\\\"\" + features[i].name() + \"\\\" : \" + features[i].enabled(true));\n    }\n    buf.append(\"}\");\n    \n    return buf.toString();\n}"]}
{"_id": "636766a81a6d9265ec01758e", "generate_results": ["public static int nextPrime(int desiredCapacity){\n\tif(desiredCapacity > 0)\n\t\treturn 2;\n\telse\n\t\treturn 1;\n}", "public static int nextPrime(int desiredCapacity) {\n    return Math.round(Math.random()*(desiredCapacity/2) + (desiredCapacity/2))/2;\n}", "public static int nextPrime(int desiredCapacity){\n\t\n\tint prime = 1;\n\t\n\twhile(prime <= desiredCapacity){\n\t\tif(prime % 2 == 0){\n\t\t\treturn prime;\n\t\t}\n\t\tprime = prime * 3;\n\t}\n\t\n\treturn 1;\n}", "public static int nextPrime(int desiredCapacity){\n\t\n\tint prime = 2;\n\t\n\twhile(prime < desiredCapacity){\n\t\tif(prime % 2 == 0){\n\t\t\tprime++;\n\t\t}\n\t\telse{\n\t\t\tprime = 1;\n\t\t}\n\t}\n\treturn prime;\n}", "public static int nextPrime(int desiredCapacity){\n\t/*\n\t * The maximum prime number is the largest prime number which is a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n\t * @param desiredCapacity the capacity desired by the user.\n\t * @return the capacity which should be used for a hashtable.\n\t */\n\t\n\tint prime = 1;\n\t\n\twhile(prime*prime <= desiredCapacity){\n\t\tprime = prime*prime + 1;\n\t}\n\t\n\treturn prime;\n}", "public static int nextPrime(int desiredCapacity){\n   return nextPrime(desiredCapacity, 0);\n}", "public static long nextPrime(int desiredCapacity){\n\tint prime = 1;\n\twhile(prime < desiredCapacity){\n\t\tif(prime%2 == 1) prime++;\n\t\telse prime++;\n\t}\n\treturn prime;\n}", "public static int nextPrime(int desiredCapacity){\n\t\n\tif(desiredCapacity == 0) return 1;\n\t\n\tint prime = 1;\n\t\n\twhile(prime < desiredCapacity){\n\t\t\n\t\tif(prime % 2 == 0){\n\t\t\t\n\t\t\tprime = prime / 2;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tprime = prime * 2;\n\t\t}\n\t}\n\t\n\treturn prime;\n\t\n}", "public static int nextPrime(int desiredCapacity){\n\tif(desiredCapacity < 1)\n\t\treturn 1;\n\tint prime = 2;\n\twhile(prime < desiredCapacity){\n\t\tif(prime * prime <= desiredCapacity)\n\t\t\treturn prime;\n\t\tprime++;\n\t}\n\treturn prime;\n}", "public static int nextPrime(int desiredCapacity){\n    return (int) (Math.pow(2, expectedPrimeSize) * Math.pow(2, desiredCapacity));\n}"]}
{"_id": "636767a61a6d9265ec0185b7", "generate_results": ["/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}", "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()}"]}
{"_id": "636767ab1a6d9265ec018676", "generate_results": ["/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n  return (c>='0' && c<='9') || (c>='a' && c<='f') || (c>='A' && c<='F');\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F');\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n    return c >= '0' && c <= '9';\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\treturn!Character.isDigit(c);\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\t// 0-9\n\tif(c >= '0' && c <= '9'){\n\t\treturn true;\n\t}\n\t// A-F\n\telse if(c >= 'A' && c <= 'F'){\n\t\treturn true;\n\t}\n\t// a-f\n\telse if(c >= 'a' && c <= 'f'){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\treturn (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\treturn (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F');\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\treturn c >= '0' && c <= '9';\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n\treturn c >= '0' && c <= '9';\n}", "/** \n * Is this a hex digit?\n */\n\nprivate static boolean isHex(final char c){\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}"]}
{"_id": "636767a41a6d9265ec018582", "generate_results": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n    int totalSize = 0;\n    if (schema.getFieldCount() > 0) {\n        for (int i=0;i<schema.getFieldCount();i++) {\n            // TODO: handle null\n            schema.getField(i).writeDelimitedTo(out,message,schema,buffer);\n            totalSize += schema.getField(i).getLength();\n        }\n    }\n    else {\n        for (int i=0;i<schema.getFieldCount();i++) {\n            schema.getField(i).writeDelimitedTo(out,message,schema,buffer);\n            totalSize += schema.getField(i).getLength();\n        }\n    }\n    return totalSize;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tif (buffer == null) {\n\t\tbuffer = new LinkedBuffer();\n\t}\n\tint written = 0;\n\twritten += schema.writeTo(out, message, buffer);\n\twritten += buffer.writeTo(out, schema, buffer);\n\treturn written;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = schema.writeDelimitedTo(out,message,buffer);\n\t//System.out.println(out.toString()+\" \"+size);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = message.length();\n\tint i = 0;\n\tint k = 0;\n\twhile(i < size) {\n\t\tk = schema.getLength(message, i);\n\t\tbyte[] bytes = new byte[k];\n\t\tint j = 0;\n\t\twhile(j < k) {\n\t\t\tbytes[j++] = (byte)(message.get(i++));\n\t\t}\n\t\tout.write(bytes);\n\t}\n\treturn k;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\t\n\tint size=0;\n\t\n\t// write the header\n\tint pos=0;\n\tbyte[] header=new byte[4];\n\theader[0]=HDR_LEN;\n\theader[1]=size;\n\theader[2]=0;\n\theader[3]=0;\n\t\n\t// write the message\n\tByteArrayOutputStream baos=new ByteArrayOutputStream();\n\t\n\t// write the header\n\tout.write(header);\n\t\n\t// write the header\n\tout.write(schema.getLength());\n\t\n\t// write the message\n\tout.write(message);\n\t\n\t// write the delimiter\n\tout.write(delimiter);\n\t\n\t// write the message\n\tout.write(message.getBytes(StandardCharsets.UTF_8));\n\t\n\t// write the trailer\n\tout.write(trailer.getBytes(StandardCharsets.UTF_8));\n\t\n\t// write the trailer\n\tout.write(buffer.toBuffer(buffer.getBufferLimit()));\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());\n\t\n\t// write the trailer\n\tout.write(buffer.getBufferLimit());", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = writeDelimitedTo(out,message,schema,buffer,0,0);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tbuffer.reset();\n\tint size = 0;\n\tif (schema!= null) {\n\t\tsize += schema.writeDelimitedTo(out, message, buffer);\n\t} else {\n\t\tsize += writeDelimitedTo(out, message, buffer);\n\t}\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\t\n\tint maxSize = 0;\n\t\n\tschema.addField(new Field<T>(\"size\"));\n\t\n\tint size = message.size();\n\t\n\tmaxSize = Math.max(maxSize, size);\n\t\n\tschema.addField(new Field<T>(\"size\"));\n\t\n\tbuffer.write(size);\n\t\n\tint offset = 0;\n\t\n\tfor(int i = 0;i < size;i++){\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t\tschema.addField(new Field<T>(\"data\"));\n\t\t\n\t}\n\t\n\treturn maxSize;\n\t\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tsize += writeDelimitedTo(out,message.getClass().getName(),schema,buffer);\n\tsize += writeDelimited(out,message,schema,buffer);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint length = writeDelimitedTo(out,schema,message.getSize(),buffer);\n\tif (length < 0)\n\t\tthrow new IOException(\"Error writing message of size \"+message.getSize());\n\treturn length;\n}"]}
{"_id": "636767a51a6d9265ec01859d", "generate_results": ["public boolean equals(final byte[] data,int offset,final int len){\n    if(data==null || offset<0 || offset>data.length-len)\n        return false;\n    final int len1=data.length;\n    if(len1<len)\n        len=len1;\n    if(len!=data.length-len)\n        return false;\n    for(int i=0;i<len1;i++){\n        if(data[i+offset]!=data[i+len])\n            return false;\n    }\n    return true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\t\n\tif(data==null)\n\t\treturn false;\n\t\n\tif(len<0)\n\t\treturn false;\n\t\n\treturn data.length==len && offset==0 && Arrays.equals(data,offset,len);\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data.length!= len){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tif(data[i+offset]!= data[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null) return false;\n\tif(data.length!=len) return false;\n\tfor(int i=0;i<len;i++)\n\t\tif(data[offset+i]!=data[i]) return false;\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\treturn Arrays.equals(data,offset,len);\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\t\n\tif(len<0){\n\t\treturn false;\n\t}\n\tif(offset+len>data.length){\n\t\treturn false;\n\t}\n\t\n\tfinal byte[] data2=data.clone();\n\t\n\tfor(int i=0;i<len;i++){\n\t\tif(data[i+offset]!=data2[i+offset]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tfor(int i=0;i<len;i++){\n\t\tif(data[offset+i]!=this.data[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\t\n\tif(data==null || offset<0 || len<0 || offset+len>data.length){\n\t\treturn false;\n\t}\n\t\n\tint i=offset;\n\t\n\twhile(i<offset+len){\n\t\tif(data[i]!=data[i+1]){\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null || data.length==0){\n\t\treturn false;\n\t}\n\tif(len==0){\n\t\treturn true;\n\t}\n\tif(data.length==len){\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(data[offset++]!=data[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\tfinal boolean isEqual = (data == null) || (len == 0) || (offset >= data.length) || (offset < 0) || (len > data.length - offset) || (len < 0);\n\treturn isEqual;\n}"]}
{"_id": "636767a41a6d9265ec01856c", "generate_results": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    if(str.length() == 0){\n        return 0;\n    }\n    int end = index + len;\n    int utf8Length = 0;\n    while(index < end){\n        if(str.charAt(index) == '\\ufffe'){\n            return utf8Length;\n        }\n        utf8Length += 1;\n        index++;\n    }\n    return utf8Length;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tif(str == null){\n\t\treturn 0;\n\t}\n\t\n\tif(index < 0 || len < 0){\n\t\treturn 0;\n\t}\n\t\n\tint ucs = 0;\n\t\n\t//compute size of utf8 string\n\tfor(int i=index;i<index+len;i++){\n\t\tif(str.charAt(i) <= 0x7f){\n\t\t\tucs += 1;\n\t\t} else {\n\t\t\tucs += 2;\n\t\t}\n\t}\n\t\n\treturn ucs;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n    int utfSize = 0;\n    for(int i=index;i<index+len;i++){\n        int c = str.charAt(i);\n        if((c>=0x80) && (c<=0xbf)){\n            utfSize++;\n        }else if(c>=0x800){\n            utfSize += 2;\n        }else if(c>=0x800){\n            utfSize += 3;\n        }else if(c>=0x800){\n            utfSize += 4;\n        }else if(c>=0x800){\n            utfSize += 5;\n        }else if(c>=0x800){\n            utfSize += 6;\n        }else if(c>=0x800){\n            utfSize += 7;\n        }else if(c>=0x800){\n            utfSize += 8;\n        }else if(c>=0x800){\n            utfSize += 9;\n        }else if(c>=0x800){\n            utfSize += 10;\n        }else if(c>=0x800){\n            utfSize += 11;\n        }else if(c>=0x800){\n            utfSize += 12;\n        }else if(c>=0x800){\n            utfSize += 13;\n        }else if(c>=0x800){\n            utfSize += 14;\n        }else if(c>=0x800){\n            utfSize += 15;\n        }else if(c>=0x800){\n            utfSize += 16;\n        }else if(c>=0x800){\n            utfSize += 17;\n        }else if(c>=0x800){\n            utfSize += 18;\n        }else if(c>=0x800){\n            utfSize += 19;\n        }else if(c>=0x800){\n            utfSize += 20;\n        }else if(c>=0x800){\n            utfSize += 21;\n        }else if(c>=0x800){\n            utfSize += 22;\n        }else if(c>=0x800){\n            utfSize += 23;\n        }else if(c>=0x800){\n            utfSize += 24;\n        }else if(c>=0x800){\n            utfSize += 25;\n        }else if(c>=0x800){\n            utfSize += 26;\n        }else if(c>=0x800){\n            utfSize += 27;\n        }else if(c>=0x800){\n            utfSize += 28;\n        }else if(c>=0x800){\n            utfSize += 29;\n        }else if(c>=0x800){\n            utfSize += 30;\n        }else if(c>=0x800){\n            utfSize += 31;\n        }else if(c>=0x800){\n            utfSize += 32;\n        }else if(c>=0x800){\n            utfSize += 33;\n        }else if(c>=0x800){\n            utfSize += 34;\n        }else if(c>=0x800){\n            utfSize += 35;\n        }else if(c>=0x800){\n            utfSize += 36;\n        }else if(c>=0x800){\n            utfSize += 37;\n        }else if(c>=0x800){\n            utfSize += 38;\n        }else if(c>=0x800){\n            utfSize += 39;\n        }else if(c>=0x800){\n            utfSize += 40;\n        }else if(c>=0x800){\n            utfSize += 41;\n        }else if(c>=0x800){\n            utfSize += 42;\n        }else if(c>=0x800){\n            utfSize += 43;\n        }else if(c>=0x800){\n            utfSize += 44;\n        }else if(c>=0x800){\n            utfSize += 45;\n        }else if(c>=0x800){\n            utfSize += 46;\n", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint utf8Size=0;\n\tint len2=len;\n\tint i=index;\n\tint j=index+len;\n\twhile(j<len2){\n\t\tfinal int c=str.charAt(i++);\n\t\tif(c<=0x80){\n\t\t\tutf8Size++;\n\t\t}else{\n\t\t\tutf8Size+=2;\n\t\t\tutf8Size+=computeUTF8Size(str,i,j-i);\n\t\t\tj+=2;\n\t\t}\n\t}\n\treturn utf8Size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  //System.out.println(\"computeUTF8Size(\"+str+\",\"+index+\",\"+len+\")\");\n  \n  int numChars = 0;\n  int numBytes = 0;\n  \n  for(int i = index;i < index + len;i++){\n    final int codePoint = str.charAt(i);\n    if(codePoint < 0x80){\n      numChars++;\n      numBytes += 1;\n    }else if(codePoint < 0x800){\n      numChars++;\n      numBytes += 2;\n    }else if(codePoint < 0x10000){\n      numChars++;\n      numBytes += 3;\n    }else{\n      numChars++;\n      numBytes += 4;\n    }\n  }\n  return numChars * numBytes;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\treturn computeUTF8Size(str,index,len,0);\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint utf8Size = 0;\n\tif(index < 0 || index > str.length() - len){\n\t\tutf8Size = 0;\n\t}else{\n\t\tutf8Size = 1;\n\t\twhile(index < str.length() && str.charAt(index) <= 0x7f){\n\t\t\tutf8Size++;\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn utf8Size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\treturn computeUTF8Size(str,index,len,0);\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tif(len<=0){\n\t\treturn 0;\n\t}\n\t\n\tfinal int len1 = len;\n\tfinal int strLen1 = str.length();\n\t\n\tfinal int off1 = index;\n\tfinal int off2 = off1+len1;\n\t\n\tfinal int off3 = off1+strLen1;\n\t\n\tif(off2>=strLen1){\n\t\treturn 0;\n\t}\n\t\n\t\n\tint c0 = str.charAt(off1);\n\tif(c0<0x80){\n\t\treturn 1;\n\t}\n\t\n\tfinal int c1 = str.charAt(off2);\n\tif(c1<0x80){\n\t\treturn 2;\n\t}\n\t\n\tfinal int c2 = str.charAt(off3);\n\t\n\tif(c2<0x80){\n\t\treturn 3;\n\t}\n\t\n\tfinal int c3 = str.charAt(off3+1);\n\t\n\tif(c2<0x800){\n\t\treturn 4;\n\t}\n\t\n\tfinal int c4 = str.charAt(off3+2);\n\t\n\tif(c2<0x10000){\n\t\treturn 5;\n\t}\n\t\n\tfinal int c5 = str.charAt(off3+3);\n\t\n\tif(c2<0x200000){\n\t\treturn 6;\n\t}\n\t\n\tfinal int c6 = str.charAt(off3+4);\n\t\n\tif(c2<0x4000000){\n\t\treturn 7;\n\t}\n\t\n\tfinal int c7 = str.charAt(off3+5);\n\t\n\tif(c2<0x80000000){\n\t\treturn 8;\n\t}\n\t\n\treturn 9;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tif (index == 0 || index > str.length() - len) {\n\t\treturn 0;\n\t}\n\t\n\tint count = 0;\n\tint result = 0;\n\tfinal char[] chars = str.toString().toCharArray();\n\tfor (int i = index; i < index + len; i++) {\n\t\tfinal int c = chars[i];\n\t\tif (c >= 0x80) {\n\t\t\tcount++;\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}"]}
{"_id": "636767ab1a6d9265ec01867b", "generate_results": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\t\n\tString s = null;\n\ttry{\n\t\ts = new String(str.toString().getBytes(\"UTF-8\"), \"UTF-8\");\n\t\tlb.append(s);\n\t}\n\tcatch(final UnsupportedEncodingException e){\n\t\tthrow new RuntimeException(e);\n\t}\n\treturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n    if(str == null)\n        return null;\n\n    int len = str.length();\n    if(session!= null)\n        return session.writeUTF(str, lb);\n\n    int charPos = 0;\n    for(char c : str.toCharArray()){\n        if(c < 0x80){\n            lb.append(chr(c));\n            continue;\n        }\n\n        if(charPos + 1 >= len){\n            lb.append(str.charAt(charPos));\n            continue;\n        }\n\n        if(c < 0x800){\n            lb.append(chr((c >> 6) & 0x1f));\n            lb.append(chr(c & 0x3f));\n            continue;\n        }\n\n        if(chr(c) == '\\n'){\n            lb.append(str.charAt(charPos));\n            lb.append(str.charAt(charPos));\n            charPos = charPos + 2;\n        }\n        else{\n            lb.append(str.charAt(charPos));\n            lb.append(chr(c));\n            charPos++;\n        }\n    }\n\n    if(charPos < len){\n        lb.append(str.charAt(charPos));\n    }\n\n    return lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n    if(str == null){\n        return lb;\n    }\n\n    final LinkedBuffer lb2=new LinkedBuffer(str.length());\n\n    final int len=str.length();\n\n    for(int i=0;i<len;i++){\n        final int b=str.charAt(i);\n        if(b==-1){\n            lb2.append(-1);\n            continue;\n        }\n\n        final byte c=b;\n        if(c<0x80){\n            lb2.append(c);\n        }\n        else if(c<0x800){\n            lb2.append((byte)((c>>6) & 0x1f | 0x80));\n            lb2.append((byte)(c & 0x3f | 0x80));\n        }\n        else if(c<0xD800){\n            lb2.append((byte)((c>>12) & 0x0F | 0x80));\n            lb2.append((byte)((c>>6) & 0x3f | 0x80));\n            lb2.append((byte)(c & 0x3f | 0x80));\n        }\n        else if(c<0xE000){\n            lb2.append((byte)((c>>0x0A) & 0x0f | 0x80));\n            lb2.append((byte)((c>>12) & 0x3f | 0x80));\n            lb2.append((byte)((c>>6) & 0x3f | 0x80));\n            lb2.append((byte)(c & 0x3f | 0x80));\n        }\n        else if(c<0xF000){\n            lb2.append((byte)((c>>0x10) & 0x3f | 0x80));\n            lb2.append((byte)((c>>12) & 0x3f | 0x80));\n            lb2.append((byte)((c>>6) & 0x3f | 0x80));\n            lb2.append((byte)(c & 0x3f | 0x80));\n        }\n        else{\n            lb2.append((byte)((c>>0xF0) & 0x0f | 0x80));\n            lb2.append((byte)((c>>12) & 0x3f | 0x80));\n            lb2.append((byte)((c>>6) & 0x3f | 0x80));\n            lb2.append((byte)(c & 0x3f | 0x80));\n        }\n    }\n\n    return lb2;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    \n    final LinkedBuffer lb2 = new LinkedBuffer();\n    \n    final int len = str.length();\n    \n    final char[] buf = new char[len];\n    \n    int pos = 0;\n    \n    for (int i = 0; i < len; i++){\n        char c = str.charAt(i);\n        if (c < 0x80){\n            buf[pos++] = (char)c;\n        }else if (c < 0x800){\n            buf[pos++] = (char)(0xc0 | (c >> 6));\n            buf[pos++] = (char)(0x80 | (c & 0x3f));\n        }else if (c < 0x10000){\n            buf[pos++] = (char)(0xe0 | (c >> 12));\n            buf[pos++] = (char)(0x80 | ((c >> 6) & 0x3f));\n            buf[pos++] = (char)(0x80 | (c & 0x3f));\n        }else{\n            buf[pos++] = (char)(0xf0 | (c >> 18));\n            buf[pos++] = (char)(0x80 | ((c >> 12) & 0x3f));\n            buf[pos++] = (char)(0x80 | ((c >> 6) & 0x3f));\n            buf[pos++] = (char)(0x80 | (c & 0x3f));\n        }\n    }\n    \n    lb2.append(buf, 0, pos);\n    \n    return lb2;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    if (str == null) return null;\n    if (str.length() == 0) return lb;\n    final int utf8len = str.length();\n    final byte[] utf8 = new byte[utf8len];\n    final int utf8pos = 0;\n    for (int i = 0; i < utf8len; i++){\n      final char c = str.charAt(i);\n      if (c > 0x7f){\n        final int c3 = (c >> 6) & 0x0f;\n        final int c4 = (c >> 3) & 0x07;\n        final int c5 = c & 0x03;\n        final int c6 = (c >> 5) & 0x0f;\n        final int c7 = (c >> 1) & 0x1f;\n        final byte[] b = new byte[8];\n        b[c3] = (byte) (c6 << 2);\n        b[c4] = (byte) (c6 << 6);\n        b[c5] = (byte) (c6 << 3);\n        b[c6] = (byte) (c6 << 5);\n        b[c7] = (byte) (c6 << 1);\n        lb.write(b);\n        utf8[utf8pos++] = (byte) (c6 | (c7 << 6));\n      }else{\n        utf8[utf8pos++] = (byte) c;\n      }\n    }\n    return lb;\n  }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\t\n\tfinal int len = str.length();\n\tfinal int n = len;\n\t\n\tif (n > 0x10ffff) {\n\t\tthrow new IllegalArgumentException(\"Too many characters\");\n\t}\n\t\n\tfinal byte[] strBytes = str.toString().getBytes( \"UTF-8\" );\n\t\n\t// Write the length of the string\n\tlb.writeShort( n );\n\t\n\t// Write the string\n\tlb.write( strBytes );\n\t\n\t// Write the last byte of the string\n\tlb.write( (byte)0 );\n\t\n\t// Write the remaining bytes of the string\n\tfor(int i=0;i<len;i++) {\n\t\tlb.write( strBytes[i] );\n\t}\n\t\n\treturn lb;\n\t\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    if(str == null) return null;\n    if(str.length() == 0) return new LinkedBuffer(lb, true);\n    final int len = str.length();\n    final int n = len;\n    lb.add(str);\n    for(int i=0;i<len;i++) {\n      final char c = str.charAt(i);\n      if(c >= 0x80) {\n        lb.add(c);\n      } else {\n        if(c < 0x0800) {\n          lb.add((char)(0xC0 | (c >> 6)));\n          lb.add((char)(0x80 | (c & 0x3F)));\n        } else if(c < 0x0800) {\n          lb.add((char)(0xE0 | (c >> 12)));\n          lb.add((char)(0x80 | ((c >> 6) & 0x3F)));\n          lb.add((char)(0x80 | (c & 0x3F)));\n        } else if(c < 0x0800) {\n          lb.add((char)(0xF0 | (c >> 18)));\n          lb.add((char)(0x80 | ((c >> 12) & 0x3F)));\n          lb.add((char)(0x80 | ((c >> 6) & 0x3F)));\n          lb.add((char)(0x80 | (c & 0x3F)));\n        } else {\n          lb.add((char)(0xF8 | (c >> 24)));\n          lb.add((char)(0x80 | ((c >> 18) & 0x3F)));\n          lb.add((char)(0x80 | ((c >> 12) & 0x3F)));\n          lb.add((char)(0x80 | ((c >> 6) & 0x3F)));\n          lb.add((char)(0x80 | (c & 0x3F)));\n        }\n      }\n    }\n    return lb;\n  }", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\t\n\tfinal char[] chars = new char[str.length()];\n\t\n\tfor( int i=0;i<str.length();i++){\n\t\tchars[i] = (char)str.charAt(i);\n\t}\n\t\n\tlb.reset();\n\t\n\tif( chars.length == 0){\n\t\treturn lb;\n\t}\n\t\n\tfinal int n = chars.length;\n\tfinal int offset = session.getIndex() + 1;\n\tfinal byte[] buffer = new byte[n + 1];\n\t\n\t//write the chars\n\tfor( int i=0;i<n;i++){\n\t\tbuffer[i] = (byte)chars[i];\n\t}\n\t\n\t//write the first n bytes\n\tfor( int i=0;i<n;i++){\n\t\tbuffer[i+offset] = (byte)chars[i];\n\t}\n\t\n\treturn lb.append(buffer,0,n);\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n    if(str == null) {\n        return null;\n    }\n    lb.append(str);\n    return lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tfinal int len = str.length();\n\tfinal int utfLen = utf8Len(str);\n\tfinal boolean unicode = utfLen > 0;\n\tfinal int pos = session.getPosition();\n\n\tfinal int newPos = session.getStart();\n\tif (pos + utfLen > len) {\n\t\tthrow new IndexOutOfBoundsException(\"writeUTF8: len=\" + len + \" pos=\" + pos + \" utfLen=\" + utfLen);\n\t}\n\t\n\tif(unicode){\n\t\tlb.appendUtf8(str);\n\t}else{\n\t\tlb.append(str, newPos, utfLen);\n\t}\n\t\n\tsession.setPosition(newPos);\n\treturn lb;\n}"]}
{"_id": "636767a41a6d9265ec018572", "generate_results": ["public long readVarint() {\n    return readRawVarint64();\n  }", "public long readRawVarint64() throws IOException {\n    return readRawVarint64(true);\n}", "public int readRawVarint64() {\n    int result = 0;\n    int shift = 0;\n    while (true) {\n      result |= (data[pos++] & 0xff) << shift;\n      shift += 7;\n      if (shift >= 64) {\n        // We've read all we could.\n        return result;\n      }\n    }\n  }", "public long readRawVarint64() throws IOException {\n    return readRawVarint64(stream);\n}", "public int readRawVarint() throws IOException {\n    byte[] buf = new byte[2];\n    int val = readRawVarint64();\n    if (val == 0) {\n        throw new EOFException(\"EOF detected\");\n    }\n    buf[0] = (byte) val;\n    return 1;\n}", "public byte[] readRawBytes() throws IOException {\n  int len = readRawVarint64();\n  if (len > 0) {\n    byte[] ret = new byte[len];\n    readRawBytes(ret, 0, ret.length);\n    return ret;\n  } else {\n    return null;\n  }\n}", "public long readRawVarint64() throws IOException {\n\tlong x = readRawVarint();\n\tif (x < 0) {\n\t\tthrow new IOException(\"Negative varint size: \" + x);\n\t}\n\treturn x;\n}", "public long readRawVarint64() throws IOException {\n    int result = 0;\n    long value = 0;\n    for (int i = 0; i < 8; i++) {\n        int b = this.read();\n        result |= (value << (7 - i));\n        value = (value << 1) | (b & 0x1);\n    }\n    return result;\n}", "public long readRawVarint64(int size) throws IOException {\n  if (size > 0) {\n    for (int i = 0; i < size; i++) {\n      int b = read();\n      result = (result << 7) + (b & 0x7f);\n      if (b >= 0x80) {\n        return result;\n      }\n    }\n  }\n  return readRawVarint64();\n}", "public long readRawVarint64() throws IOException {\n    long l = 0;\n    int i = 0;\n    while (i < 8) {\n        l = (l << 8) | (read() & 0xff);\n        i++;\n    }\n    return l;\n}"]}
{"_id": "636767aa1a6d9265ec01865a", "generate_results": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint size = 0;\n\tfor (int i = 0; i < node.buffer.length(); i++) {\n\t\tif (node.buffer[i] == LinkedBuffer.EOB) {\n\t\t\tbreak;\n\t\t}\n\t\tout.write(node.buffer[i]);\n\t\tsize += 1;\n\t}\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint remaining = node.getRemaining();\n\tint start = node.getStart();\n\tint end = node.getEnd();\n\tbyte[] buffer = node.getBuffer();\n\tint size = node.getSize();\n\t\n\tif( buffer.length > end - start ) {\n\t\tthrow new IOException(\"cannot write past end of buffer\");\n\t}\n\t\n\tint pos = start;\n\tsize = end - start;\n\t\n\twhile( remaining > 0 ) {\n\t\tint n = Math.min(remaining,size);\n\t\tout.write(buffer,pos,n);\n\t\tpos += n;\n\t\tremaining -= n;\n\t}\n\tout.write(buffer,pos,size);\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tif (node==null) {\n\t\treturn 0;\n\t}\n\tint size = 0;\n\tsize += node.size();\n\tfor (final LinkedBuffer child : node.getChildren()) {\n\t\tsize += writeTo(out,child);\n\t}\n\treturn size;\n}", "public static void writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tfinal int size = node.size();\n\tout.writeInt(size);\n\tfor(int i=0;i<size;i++) {\n\t\tnode.read(out);\n\t}\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n    final byte[] bytes=node.getBytes();\n    out.writeInt(bytes.length);\n    out.write(bytes);\n    return out.size();\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n    int size=0;\n    size+=out.writeInt(node.size());\n    size+=out.writeInt(node.count());\n    size+=out.writeInt(node.capacity());\n    size+=out.writeInt(node.capacity());\n    if(size>=0) {\n        return size;\n    }\n    //else return 0;\n    return out.size();\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\t\n\tint i = 0;\n\t\n\t// write the node.\n\t\n\tout.writeShort(node.getStart());\n\tout.writeShort(node.getEnd());\n\t\n\t// write the node.\n\t\n\tout.writeShort(node.getLength());\n\t\n\t// write the node.\n\t\n\tout.writeShort(node.getPosition());\n\t\n\t// write the node.\n\t\n\tout.writeShort(node.getPosition());\n\t\n\t// write the node.\n\t\n\tout.writeShort(node.getLength());\n\t\n\t// write the node.\n\t\n\treturn i;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n  final int size = node.getSize();\n  out.writeInt(size);\n  final byte [] data = node.getContent();\n  out.write(data);\n  return size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tfinal int off = node.offset;\n\tfinal int len = node.len;\n\tfinal int limit = node.limit;\n\tout.writeInt(off);\n\tout.writeInt(len);\n\tout.writeInt(limit);\n\treturn (len+limit);\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n  int size = 0;\n  for(int i=0;i<node.size();i++) {\n    size += node.get(i).getSize();\n  }\n  out.writeInt(size);\n  for(int i=0;i<node.size();i++) {\n    node.get(i).writeTo(out);\n  }\n  return size;\n}"]}
{"_id": "636767a31a6d9265ec018552", "generate_results": ["public String readString() throws IOException {\n    return reader.readUTF();\n}", "public String readString() throws IOException {\n\tif ((this.flags & READ_STRING_WITH_OFFSET) > 0) {\n\t\treturn super.readString();\n\t} else {\n\t\treturn this.string;\n\t}\n}", "public String readString() throws IOException {\n    return this.readString(Charset.forName(\"UTF-8\"));\n}", "public String readString() throws IOException {\n\treturn readString(0);\n}", "public long readLong(long defaultValue) throws IOException {\n    if (stream.peek() == CMD_INT) {\n        stream.readByte();\n        return stream.readLong();\n    }\n    int len = 0;\n    if (stream.peek() == CMD_LONG) {\n        len = stream.readLong();\n    } else if (stream.peek() == CMD_STRING) {\n        len = stream.readString().length();\n    }\n    if (len == 0) {\n        return defaultValue;\n    }\n    byte[] tmp = new byte[len];\n    stream.readFully(tmp);\n    return new Long(tmp);\n}", "public String readString() throws IOException { \n    \n    if (nextChar == '\"') { \n        return readString2();\n    } else { \n        return readString1();\n    }\n}", "public String readString() throws IOException {\n  if (index >= limit) {\n    throw new EOFException(\"String read past EOF\");\n  }\n\n  int i = index;\n  char c = (char) input.read();\n  if (c == '\"') {\n    return readQuotedString();\n  }\n  return c;\n}", "public String readString() throws IOException {\n    return readUTF();\n}", "public String readString() throws IOException {\n    return readString(0);\n}", "public String readString() throws IOException {\n    // TODO: implement\n    throw new UnsupportedOperationException();\n}"]}
{"_id": "636767a21a6d9265ec018517", "generate_results": ["public final byte[] toByteArray(){\n\tbyte[] bytes = new byte[len];\n\tint offset = 0;\n\t\n\tfor(int i=0;i<len;i++){\n\t\tif(i<size){\n\t\t\tbytes[offset++] = data[i];\n\t\t\tif(i<size-1){\n\t\t\t\tbytes[offset++] = data[i+1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bytes;\n}", "public final byte[] toByteArray(){\n    return data;\n}", "public final byte[] toByteArray(){\n\treturn _toByteArray();\n}", "public final byte[] toByteArray(){\n\tbyte[] b = new byte[size];\n\tread(b, 0, size);\n\treturn b;\n}", "public final byte[] toByteArray(){\n\tbyte[] buf = new byte[m_buf.length];\n\tSystem.arraycopy(m_buf, 0, buf, 0, m_buf.length);\n\treturn buf;\n}", "public final byte[] toByteArray(){\n\t\treturn new byte[] {\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00", "public final byte[] toByteArray() {\n\tfinal byte[] data = new byte[m_data.length];\n\tfor(int i = 0; i < m_data.length; i++){\n\t\tdata[i] = m_data[i];\n\t}\n\treturn data;\n}", "public final byte[] toByteArray(){\n    return buffer;\n}", "public final byte[] toByteArray(){\n\tbyte[] ret;\n\tif(this.data!= null){\n\t\tret = this.data;\n\t} else {\n\t\tret = new byte[0];\n\t}\n\treturn ret;\n}", "public final byte[] toByteArray(){\n\treturn buf;\n}"]}
{"_id": "636767a41a6d9265ec01857e", "generate_results": ["/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "public static int compareSigned(long a,long b){\n\treturn compareSigned(a,b);\n}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}", "/** \n * Compares the two specified  {@code long}"]}
{"_id": "636767aa1a6d9265ec01864a", "generate_results": ["public byte[] toByteArray(){\n    byte[] ret = new byte[length()];\n    System.arraycopy(data, 0, ret, 0, length());\n    return ret;\n}", "public byte[] toByteArray(){\n\treturn this.buffer;\n}", "public byte[] toByteArray(){return new byte[0];}", "public ByteArray toByteArray(){\n  return new ByteArray(data);\n}", "public byte[] copy(){\n\treturn fromByteArray(toByteArray());\n}", "public byte[] toByteArray(){\n\tbyte[] b = new byte[length];\n\tfor(int i=0; i < length; i++){\n\t\tb[i] = buf[i];\n\t}\n\treturn b;\n}", "public byte[] toByteArray(){\n\treturn b;\n}", "public byte[] toByteArray(){\n\tbyte[] b = new byte[len];\n\tSystem.arraycopy(buf, 0, b, 0, len);\n\treturn b;\n}", "public byte[] toByteArray(){\n    byte[] b = new byte[length()];\n    System.arraycopy(content, 0, b, 0, length());\n    return b;\n}", "public byte[] toByteArray(){\n    if (size == 0)\n        return new byte[0];\n    return new byte[size];\n}"]}
{"_id": "636767a31a6d9265ec01854f", "generate_results": ["public void readPackedField(final InputStream in) throws IOException {\n\tfieldLength = null;\n\tcheckIfPackedField();\n\tfield = (Bytes) in.readObject();\n}", "public void read(String string, int offset, int length, byte[] array, int offset, int length, byte[] array2) throws IOException {\n\tcheckIfPackedField();\n\tgetPosition(getPosition() + length);\n\tSystem.arraycopy(string.getBytes(), offset, getBuffer(), getPosition(), length);\n\tSystem.arraycopy(array, offset, getBuffer(), getPosition(), array.length);\n\tSystem.arraycopy(array2, offset, get", "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n\nprivate void checkIfPackedField() throws IOException {\n    if (!isPacked()) {\n        // clear everything\n        packedLength = 0;\n        // clear the packed length flag\n        isPacked = false;\n    }\n}", "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n\nprivate void checkIfPackedField() throws IOException {\n    if (!isPacked()) {\n        return;\n    }\n    \n    if (lengthDelimitedField) { // If this is a length-delimited field, we have to skip the field we're reading.\n        if (currentFieldLength == 0) { // We can just skip the field and move on.\n            currentFieldLength = 0;\n        } else { // We have to read the field length.\n            currentFieldLength = nextInt();\n            int numBytes = currentFieldLength - currentPos;\n            if (numBytes >= 0) {\n                length += numBytes;\n            }\n        }\n    } else { // Otherwise, we have to read the entire field.\n        currentFieldLength = nextInt();\n        length += currentFieldLength;\n    }\n}", "public void readPackedField() throws IOException, FormatException {\n\tcheckIfPackedField();\n\tif(packInfo.length == packedFieldLength) {\n\t\tpackedField = packInfo;\n\t} else {\n\t\tthrow new FormatException(\"Length-delimited packed fields are not supported anymore.\");\n\t}\n}", "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n\nprivate void checkIfPackedField() throws IOException {\n\tif (isPackedField == 0) {\n\t\tif (isDelimited) {\n\t\t\tisPackedField = true;\n\t\t\tint count = 0;\n\t\t\tint position = 0;\n\t\t\twhile (position < fieldLength) {\n\t\t\t\tif (field[position] == '\\r') {\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\t// first line\n\t\t\t\t\t\tisDelimited = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// second line\n\t\t\t\t\t\tisDelimited = true;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t} else if (field[position] == '\\n') {\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\t// first line\n\t\t\t\t\t\tisDelimited = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// second line\n\t\t\t\t\t\tisDelimited = false;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tposition++;\n\t\t\t}\n\t\t}\n\t}\n}", "public LengthDelimitedField getPackedField(int index) {\n\treturn packedFields.get(index);\n}", "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n\nprivate void checkIfPackedField() throws IOException {\n\tif (packField == null) {\n\t\tif (lengthFieldNumber == 0) {\n\t\t\tthrow new IOException(\"Packed field is not present\");\n\t\t}\n\t\tpackField = reader.readField(lengthFieldNumber);\n\t}\n}", "public void readInt(int len) throws IOException {\n\tcheckIfPackedField();\n\tfor (int i=0; i < len; i++) {\n\t\tunpackedField[i] = unpackedField[i];\n\t}\n}", "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n\nprivate void checkIfPackedField() throws IOException {\n\tif ( packedFieldLength > 0 && packedFieldLength < 10 ) {\n\t\t// This field is packed into a length-delimited field, so we can just read it.\n\t\tpackedFieldLength = 0;\n\t} else {\n\t\t// This field is not packed into a length-delimited field, so we need to read it.\n\t\tint oldLength = dataIn.readInt();\n\t\tpackedFieldLength = oldLength + 1;\n\t}\n}"]}
{"_id": "636767a81a6d9265ec0185fc", "generate_results": ["public int readTag() throws IOException {\n  return readTag(null, 0);\n}", "public int readTag() throws IOException {\n\tint tag = -1;\n\tint ch = read();\n\tif (ch == -1) {\n\t\treturn tag;\n\t}\n\tswitch (ch) {\n\tcase 'B':\n\t\ttag = readByte();\n\t\tbreak;\n\tcase 'C':\n\t\ttag = readUInt16();\n\t\tbreak;\n\tcase 'D':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'H':\n\t\ttag = readUInt16();\n\t\tbreak;\n\tcase 'I':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'L':\n\t\ttag = readUInt64();\n\t\tbreak;\n\tcase 'P':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'S':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'T':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'F':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'E':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'Z':\n\t\ttag = readUInt32();\n\t\tbreak;\n\tcase 'a':\n\t\tif (read() == 'b') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'b':\n\t\tif (read() == 'c') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'c':\n\t\tif (read() == 'd') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif (read() == 'e') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'e':\n\t\tif (read() == 'f') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tif (read() == 'g') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'g':\n\t\tif (read() == 'h') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'h':\n\t\tif (read() == 'i') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'i':\n\t\tif (read() == 'j') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'j':\n\t\tif (read() == 'k') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'k':\n\t\tif (read() == 'l') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'l':\n\t\tif (read() =='m') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase'm':\n\t\tif (read() == 'n') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tif (read() == 'o') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'o':\n\t\tif (read() == 'p') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tif (read() == 'q') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tif (read() == 'r') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\tif (read() =='s') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase's':\n\t\tif (read() == 't') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\tif (read() == 'u') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n\tcase 'u':\n\t\tif (read() == 'v') {\n\t\t\ttag = readUInt32();\n\t\t}\n\t\tbreak;\n", "public int readTag() throws IOException {\n\tif (isEmpty()) {\n\t\treturn -1;\n\t}\n\tint result = 0;\n\tint ch = read();\n\tif (ch == '0') {\n\t\tresult = 0;\n\t\tch = read();\n\t\tif (ch == 'x') {\n\t\t\tch = read();\n\t\t\tif (ch == '0' && read() == 'x') {\n\t\t\t\tresult = read();\n\t\t\t\tif (result < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (result > 127) {\n\t\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" is larger than 127\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t\t}\n\t\t} else if (ch == 'p') {\n\t\t\tresult = read();\n\t\t\tif (result == 'h') {\n\t\t\t\tresult = read();\n\t\t\t\tif (result == 'e' && read() == 'l' && read() == 'l') {\n\t\t\t\t\tresult = read();\n\t\t\t\t\tif (result == 'i' && read() == 'n' && read() == 't' && read() == 'e') {\n\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\tif (result =='s' && read() == 'e' && read() == 'r' && read() == 'o') {\n\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\tif (result >= 0x20 && result <= 0x7e) {\n\t\t\t\t\t\t\t\tresult = (result & 0x1f) << 6;\n\t\t\t\t\t\t\t\tif (result >= 0x80) {\n\t\t\t\t\t\t\t\t\tresult |= 0x100;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresult |= 0x80;\n\t\t\t\t\t\t\t\tread();\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" is larger than 127\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new InvalidProtocolBufferException(\"tag value \" + result + \" does not parse as a hex number\");\n\t\t}\n\t} else if (ch == 't') {\n\t\tresult = read();\n\t\tif (result == 'h') {\n\t\t\tresult = read();\n\t\t\tif (result == 'e' && read() == 'n' && read() == 't' && read() == 'h') {\n\t\t\t\tresult = read();\n\t\t\t\tif (result == 'a' && read() == 'b' && read() == 'r' && read() == 'i') {\n\t\t\t\t\tresult = read();\n\t\t\t\t\tif (result =='s' && read() == 'e' && read() == 'r' && read() == 'o') {\n\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\tif (result == 't' && read() == 'y' && read() == 'e') {\n\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\tif (result == 'h' && read() == 'e' && read() == 'l' && read() == 'l') {\n\t\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\t\tif (result == 'i' && read() == 'n' && read() == 't' && read() == 'e') {\n\t\t\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\t\t\tif (result =='s' && read() == 'e' && read() == 'r' && read() == 'o') {\n\t\t\t\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\t\t\t\tif (result == 'p' && read() == 'h' && read() == 'e' && read() == 'l' && read() == 'e' && read() == 'l') {\n\t\t\t\t\t\t\t\t\t\t\tresult = read();\n\t\t\t\t\t\t\t\t\t\t\tif (result == 'i' && read() == 'n' && read() =='s' && read() == 'e') {\n\t\t\t\t\t\t\t\t\t\t\t\t", "public Object readFieldObject() throws IOException {\n\tlong tag = readTag();\n\tObject value = null", "public int readTag() throws IOException {\n\tint b = read();\n\tif(b < 0 || b == 0x0)\n\t\treturn 0;\n\treturn b;\n}", "public float readFieldFloat() throws IOException {\n    int tag = readTag();\n    if (tag == -1) return -1;\n    return Float.intBitsToFloat(readInt());\n}", "public int readTagAndInt(long tag) throws IOException {\n        int tag2 = readTag();\n        if (tag2!= -1) {\n            return tag2;\n        } else {\n            return tag;\n        }\n    }", "public int readTag(int tag) throws IOException {\n    if (hasTag()) {\n        return readTag();\n    } else {\n        return in.read(buffer);\n    }\n}", "public int readTag() throws IOException {\n\tint tag = 0;\n\tint c = 0;\n\twhile(true) {\n\t\tif(c < 0) {\n\t\t\tc = read();\n\t\t}\n\t\tif(c == -1) {\n\t\t\treturn tag;\n\t\t}\n\t\t//c = (c & 0x7f) - 1;\n\t\tif(c == '\\n') {\n\t\t\tif(c == 0 && tag!= 0) {\n\t\t\t\ttag = 0;\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t\treturn tag;\n\t\t}\n\t\tif(c == '\\r') {\n\t\t\tc = read();\n\t\t\tif(c == '\\n') {\n\t\t\t\tc = 0;\n\t\t\t\tif(tag!= 0) {\n\t\t\t\t\ttag = 0;\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == '\\t') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == '=') {\n\t\t\tc = read();\n\t\t\tif(c == '\\n') {\n\t\t\t\tc = 0;\n\t\t\t\tif(tag!= 0) {\n\t\t\t\t\ttag = 0;\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == ':') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tc = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == '(') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tc = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == ')') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tc = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == '\"') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tc = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c == '\\'') {\n\t\t\ttag = (tag << 8) | (read() & 0xff);\n\t\t\tc = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t//c = read();\n\t\tif(c == '\\0') {\n\t\t\treturn tag;\n\t\t}\n\t\tif(c == '\\r') {\n\t\t\tc = read();\n\t\t\tif(c == '\\n') {\n\t\t\t\tc = 0;\n\t\t\t\tif(tag!= 0) {\n\t\t\t\t\ttag = 0;\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tthrow new IOException(\"Illegal character \" + c);\n\t}\n}", "public int read() throws IOException {\n\tint b = readTag();\n\tif (b == 0) {\n\t\treturn 0;\n\t}\n\tif (b == '\\n') {\n\t\treturn '\\n';\n\t}\n\tif (b == '\\r') {\n\t\treturn '\\r';\n\t}\n\tif (b == '\\b') {\n\t\treturn '\\b';\n\t}\n\tif (b == '\\t') {\n\t\treturn '\\t';\n\t}\n\tif (b == '=') {\n\t\treturn '=';\n\t}\n\tif (b == '>') {\n\t\treturn '>';\n\t}\n\tif (b == '<') {\n\t\treturn '<';\n\t}\n\tif (b == '@') {\n\t\treturn '@';\n\t}\n\treturn b;\n}"]}
