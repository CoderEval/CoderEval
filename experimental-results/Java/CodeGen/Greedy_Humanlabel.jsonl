{"generate_results": [{"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages.containsKey(message)){\n\t\tif(messages.get(message).getTimestamp()>timestamp){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n", "method_name": "shouldPrintMessage", "codes": ["public boolean shouldPrintMessage(int timestamp,String message){\n\tif(messages.containsKey(message)){\n\t\tif(messages.get(message).getTimestamp()>timestamp){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c73", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public Object remove(int val){\n\treturn values.remove(val);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n", "method_name": "remove", "codes": ["public Object remove(int val){\n\treturn values.remove(val);\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c74", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\tmap.put(val, val);\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \n */\n", "method_name": "insert", "codes": ["public boolean insert(int val){\n\tif(map.containsKey(val)){\n\t\treturn false;\n\t}\n\tmap.put(val, val);\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c78", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i = 0; i < array1.length; i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\tif(array1.length!= array2.length){\n\t\treturn false;\n\t}\n\tfor(int i = 0; i < array1.length; i++){\n\t\tif(array1[i]!= array2[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec017a00", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static boolean[] toPrimitive(final Boolean[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i];\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636767081a6d9265ec017989", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(Object obj){\n\tif(obj == null) return \"\";\n\tif(obj instanceof String) return (String)obj;\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n", "method_name": "toString", "codes": ["public static String toString(Object obj){\n\tif(obj == null) return \"\";\n\tif(obj instanceof String) return (String)obj;\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString(((Long)obj).longValue());\n\tif(obj instanceof Float) return Float.toString(((Float)obj).floatValue());\n\tif(obj instanceof Double) return Double.toString(((Double)obj).doubleValue());\n\tif(obj instanceof Boolean) return Boolean.toString(((Boolean)obj).booleanValue());\n\tif(obj instanceof Character) return Character.toString(((Character)obj).charValue());\n\tif(obj instanceof Byte) return Byte.toString(((Byte)obj).byteValue());\n\tif(obj instanceof Short) return Short.toString(((Short)obj).shortValue());\n\tif(obj instanceof Integer) return Integer.toString(((Integer)obj).intValue());\n\tif(obj instanceof Long) return Long.toString((("], "code_level": "self_contained", "_id": "636766f81a6d9265ec01775c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean toBoolean(Boolean bool){\n\tif(bool == null)\n\t\treturn false;\n\telse\n\t\treturn bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(Boolean bool){\n\tif(bool == null)\n\t\treturn false;\n\telse\n\t\treturn bool;\n}"], "code_level": "self_contained", "_id": "636766f91a6d9265ec01777f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null){\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Byte[] nullToEmpty(final Byte[] array){\n\tif(array == null){\n\t\treturn EMPTY_BYTE_ARRAY;\n\t}\n\treturn array;\n}"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec0179ff", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Boolean[] nullToEmpty(final Boolean[] array){\n\tif(array == null){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179e8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn null;\n\t}\n\tif(array.length==1){\n\t\treturn array[0];\n\t}\n\tif(array.length==2){\n\t\treturn new byte[]{array[0],array[1]};\n\t}\n\tif(array.length==3){\n\t\treturn new byte[]{array[0],array[1],array[2]};\n\t}\n\tif(array.length==4){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3]};\n\t}\n\tif(array.length==5){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4]};\n\t}\n\tif(array.length==6){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5]};\n\t}\n\tif(array.length==7){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6]};\n\t}\n\tif(array.length==8){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6],array[7]};\n\t}\n\tif(array.length==9){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6],array[7],array[8]};\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static byte[] toPrimitive(final Byte[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn null;\n\t}\n\tif(array.length==1){\n\t\treturn array[0];\n\t}\n\tif(array.length==2){\n\t\treturn new byte[]{array[0],array[1]};\n\t}\n\tif(array.length==3){\n\t\treturn new byte[]{array[0],array[1],array[2]};\n\t}\n\tif(array.length==4){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3]};\n\t}\n\tif(array.length==5){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4]};\n\t}\n\tif(array.length==6){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5]};\n\t}\n\tif(array.length==7){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6]};\n\t}\n\tif(array.length==8){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6],array[7]};\n\t}\n\tif(array.length==9){\n\t\treturn new byte[]{array[0],array[1],array[2],array[3],array[4],array[5],array[6],array[7],array[8]};\n\t}\n\treturn null;\n}"], "code_level": "self_contained", "_id": "636767031a6d9265ec0178e6", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String reverse(final String str){\n    return str.substring(0, str.length() - 1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse(\"\")    = \"\" StringUtils.reverse(\"bat\") = \"tab\" </pre>\n * @param str  the String to reverse, may be null\n * @return the reversed String, <code>null</code> if null String input\n */\n", "method_name": "reverse", "codes": ["public static String reverse(final String str){\n    return str.substring(0, str.length() - 1);\n}"], "code_level": "slib_runnable", "_id": "636767001a6d9265ec017873", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isDigits(String str){\n\tif(str.length() == 0) return false;\n\tfor(int i=0; i<str.length(); i++){\n\t\tif(Character.isDigit(str.charAt(i))) return true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if str contains only unicode numeric\n */\n", "method_name": "isDigits", "codes": ["public static boolean isDigits(String str){\n\tif(str.length() == 0) return false;\n\tfor(int i=0; i<str.length(); i++){\n\t\tif(Character.isDigit(str.charAt(i))) return true;\n\t}\n\treturn false;\n}"], "code_level": "slib_runnable", "_id": "636766ff1a6d9265ec01784b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str==null || str.length()==0){\n\t\treturn false;\n\t}\n\tif(suffix==null){\n\t\treturn true;\n\t}\n\tfinal int len=str.length();\n\tif(len<suffix.length()){\n\t\treturn false;\n\t}\n\tif(ignoreCase){\n\t\treturn str.toLowerCase().endsWith(suffix.toLowerCase());\n\t}\n\treturn str.endsWith(suffix);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "endsWith", "codes": ["Determines whether a character string ends with a specified suffix.\nprivate static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\tif(str==null || str.length()==0){\n\t\treturn false;\n\t}\n\tif(suffix==null){\n\t\treturn true;\n\t}\n\tfinal int len=str.length();\n\tif(len<suffix.length()){\n\t\treturn false;\n\t}\n\tif(ignoreCase){\n\t\treturn str.toLowerCase().endsWith(suffix.toLowerCase());\n\t}\n\treturn str.endsWith(suffix);\n}"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a35", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\tif(array.length == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Character[] nullToEmpty(final Character[] array){\n\tif(array == null) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\tif(array.length == 0) return EMPTY_CHARACTER_OBJECT_ARRAY;\n\treturn array;\n}"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017651", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\tif(array==null || array.length==0){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Double[] nullToEmpty(final Double[] array){\n\tif(array==null || array.length==0){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}"], "code_level": "self_contained", "_id": "636767021a6d9265ec0178bb", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isEmpty(final double[] array){\n\tif(array.length == 0)\n\t\treturn true;\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n * @param array  the array to test\n * @return <code>true</code> if the array is empty or <code>null</code>\n * @since 2.1\n */\n", "method_name": "isEmpty", "codes": ["public static boolean isEmpty(final double[] array){\n\tif(array.length == 0)\n\t\treturn true;\n\treturn false;\n}"], "code_level": "self_contained", "_id": "636766f01a6d9265ec01762e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isNotTrue(Boolean bool){\n\treturn!bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n", "method_name": "isNotTrue", "codes": ["public static boolean isNotTrue(Boolean bool){\n\treturn!bool;\n}"], "code_level": "self_contained", "_id": "636766f21a6d9265ec017677", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static double[] toPrimitive(final Double[] array){\n\tif(array == null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Double</code> array, may be <code>null</code>\n * @return a <code>double</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static double[] toPrimitive(final Double[] array){\n\tif(array == null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017842", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\tif(ch == null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>\n * @param ch  the character to convert\n * @param defaultValue  the value to use if the  Character is null\n * @return the char value of the Character or the default if null\n */\n", "method_name": "toChar", "codes": ["public static char toChar(final Character ch,final char defaultValue){\n\tif(ch == null){\n\t\treturn defaultValue;\n\t}\n\treturn ch.charValue();\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179cf", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tif(s.length() == 0) return true;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(s.charAt(i)!= '0') return false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>\n * @param s the String to check\n * @return if it is all zeros or <code>null</code>\n */\n", "method_name": "isAllZeros", "codes": ["Check whether a character string is all consist of zero. \nprivate static boolean isAllZeros(String s){\n\tif(s.length() == 0) return true;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(s.charAt(i)!= '0') return false;\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "636767081a6d9265ec0179a2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(Object object){\n\tif(object == null){\n\t\treturn null;\n\t}\n\tif(object instanceof String){\n\t\treturn (String)object;\n\t}\n\treturn object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n", "method_name": "toString", "codes": ["public static String toString(Object object){\n\tif(object == null){\n\t\treturn null;\n\t}\n\tif(object instanceof String){\n\t\treturn (String)object;\n\t}\n\treturn object.toString();\n}"], "code_level": "self_contained", "_id": "636766f21a6d9265ec01767d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Integer[] toPrimitive(final Integer[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i];\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Integer</code> array, may be <code>null</code>\n * @return an <code>int</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static Integer[] toPrimitive(final Integer[] array){\n\tif(array == null) return null;\n\tif(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i];\n\treturn result;\n}"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a2a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAsciiControl(final char ch){\n\treturn (ch >= '!' && ch <= '@') || (ch >= '?' && ch <= 'z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 32 or equals 127\n */\n", "method_name": "isAsciiControl", "codes": ["public static boolean isAsciiControl(final char ch){\n\treturn (ch >= '!' && ch <= '@') || (ch >= '?' && ch <= 'z');\n}"], "code_level": "self_contained", "_id": "636766fa1a6d9265ec01779d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\tfinal Object[] objects = new Object[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tobjects[i] = Boolean.valueOf(array[i]);\n\t}\n\treturn objects;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>boolean</code> array\n * @return a <code>Boolean</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Boolean[] toObject(final boolean[] array){\n\tfinal Object[] objects = new Object[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tobjects[i] = Boolean.valueOf(array[i]);\n\t}\n\treturn objects;\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec017796", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Short[] toObject(final short[] array){\n\tif(array == null) return null;\n\tfinal Short[] result = new Short[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Short(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>short</code> array\n * @return a <code>Short</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Short[] toObject(final short[] array){\n\tif(array == null) return null;\n\tfinal Short[] result = new Short[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Short(array[i]);\n\t}\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179f1", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char[] toPrimitive(final Character[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result = new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Character</code> array, may be <code>null</code>\n * @return a <code>char</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static char[] toPrimitive(final Character[] array){\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result = new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636766fe1a6d9265ec017838", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Integer[] toObject(final int[] array){\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  an <code>int</code> array\n * @return an <code>Integer</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Integer[] toObject(final int[] array){\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Integer(array[i]);\n\t}\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636767041a6d9265ec01790f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Double[] toObject(final double[] array){\n\tDouble[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>double</code> array\n * @return a <code>Double</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Double[] toObject(final double[] array){\n\tDouble[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a4", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str==null || prefix==null){\n\t\treturn false;\n\t}\n\tif(ignoreCase){\n\t\treturn str.startsWith(prefix);\n\t}\n\treturn str.startsWith(prefix.toLowerCase());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "startsWith", "codes": ["Return true if the given string has the specified prefix with optional cases which can be ignored,or both string and prefix are null.Otherwise return false. \nprivate static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\tif(str==null || prefix==null){\n\t\treturn false;\n\t}\n\tif(ignoreCase){\n\t\treturn str.startsWith(prefix);\n\t}\n\treturn str.startsWith(prefix.toLowerCase());\n}"], "code_level": "self_contained", "_id": "636767151a6d9265ec017b6b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Character toCharacterObject(final char ch){\n    return new Character(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n", "method_name": "toCharacterObject", "codes": ["public static Character toCharacterObject(final char ch){\n    return new Character(ch);\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01781c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if between 65 and 90 inclusive\n */\n", "method_name": "isAsciiAlphaUpper", "codes": ["public static boolean isAsciiAlphaUpper(final char ch){\n\treturn (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n}"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c1", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int length(final String str){\n\tif(str == null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n * @param str a String or <code>null</code>\n * @return String length or <code>0</code> if the String is <code>null</code>.\n * @since 2.4\n */\n", "method_name": "length", "codes": ["public static int length(final String str){\n\tif(str == null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179d9", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String base64Decode(final String s){\n    if(s==null || s.length()==0)\n        return null;\n    \n    final byte[] b = s.getBytes(\"UTF-8\");\n    final byte[] bb = new byte[b.length];\n    for(int i=0;i<b.length;i++){\n        bb[i] = (byte)b[i];\n    }\n    \n    return new String(bb);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n", "method_name": "base64Decode", "codes": ["public static String base64Decode(final String s){\n    if(s==null || s.length()==0)\n        return null;\n    \n    final byte[] b = s.getBytes(\"UTF-8\");\n    final byte[] bb = new byte[b.length];\n    for(int i=0;i<b.length;i++){\n        bb[i] = (byte)b[i];\n    }\n    \n    return new String(bb);\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017748", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null || array2 == null) return false;\n\tif(array1.length!= array2.length) return false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]) return false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final double[] array1,final double[] array2){\n\tif(array1 == null || array2 == null) return false;\n\tif(array1.length!= array2.length) return false;\n\tfor(int i=0;i<array1.length;i++){\n\t\tif(array1[i]!= array2[i]) return false;\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017663", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char[] clone(final char[] array){\n    if(array == null) return null;\n    return array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  the array to clone, may be <code>null</code>\n * @return the cloned array, <code>null</code> if <code>null</code> input\n */\n", "method_name": "clone", "codes": ["public static char[] clone(final char[] array){\n    if(array == null) return null;\n    return array.clone();\n}"], "code_level": "self_contained", "_id": "636766f31a6d9265ec01768f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAscii(final char ch){\n\tif(ch >= '0' && ch <= '7'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\\n') = true CharUtils.isAscii('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 128\n */\n", "method_name": "isAscii", "codes": ["public static boolean isAscii(final char ch){\n\tif(ch >= '0' && ch <= '7'){\n\t\treturn true;\n\t}\n\treturn false;\n}"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c3", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(final char ch){\n\tif(ch == '\\n'){\n\t\treturn \"\\n\";\n\t}\n\treturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = \" \" CharUtils.toString('A')  = \"A\" </pre>\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "method_name": "toString", "codes": ["public static String toString(final char ch){\n\tif(ch == '\\n'){\n\t\treturn \"\\n\";\n\t}\n\treturn new String(new char[]{ch});\n}"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec017a05", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n\tbyte[] newData = new byte[size];\n\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\tdata = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["Enlarge the byte vector data, by increasing it by the given size.\nprivate void enlarge(final int size){\n\tbyte[] newData = new byte[size];\n\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\tdata = newData;\n}"], "code_level": "class_runnable", "_id": "636767191a6d9265ec017c0f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tint index = typeTable.size();\n\ttypeTable.add(value);\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n", "method_name": "addType", "codes": ["Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.\nint addType(final String value){\n\tint index = typeTable.size();\n\ttypeTable.add(value);\n\treturn index;\n}"], "code_level": "project_runnable", "_id": "636766ef1a6d9265ec01761a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public long readLong(final int offset){\n  return readInt(offset);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readLong", "codes": ["public long readLong(final int offset){\n  return readInt(offset);\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01775b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tbyteArrayValue = new byte[byteOffset + byteLength];\n\t}\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteArrayValue, 0, byteLength);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tif(byteArrayValue.length < byteOffset + byteLength){\n\t\tbyteArrayValue = new byte[byteOffset + byteLength];\n\t}\n\tSystem.arraycopy(byteArrayValue, byteOffset, byteArrayValue, 0, byteLength);\n\treturn this;\n}"], "code_level": "class_runnable", "_id": "6367671a1a6d9265ec017c15", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tif(descriptor.length() == 0){\n\t\treturn;\n\t}\n\t\n\tfinal char firstChar = descriptor.charAt(0);\n\t\n\tswitch(firstChar){\n\t\tcase 'a':\n\t\t\tif(descriptor.length() == 2){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'r'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["Pop the various value according to the first character of the descriptor.\nprivate void pop(final String descriptor){\n\tif(descriptor.length() == 0){\n\t\treturn;\n\t}\n\t\n\tfinal char firstChar = descriptor.charAt(0);\n\t\n\tswitch(firstChar){\n\t\tcase 'a':\n\t\t\tif(descriptor.length() == 2){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'r'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 't'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'o'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'u'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) == 'l'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt(1) =='s'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(descriptor.charAt("], "code_level": "class_runnable", "_id": "636767021a6d9265ec0178b2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n\tif(initializedTypes.contains(abstractType)){\n\t\treturn;\n\t}\n\t\n\tinitializedTypes.add(abstractType);\n\t\n\tfinal Type type = types.get(abstractType);\n\t\n\tif(type == null){\n\t\treturn;\n\t}\n\t\n\tfinal Type initializer = type.getInitializer();\n\t\n\tif(initializer!= null){\n\t\tfinal Type[] types = initializer.getTypeArguments();\n\t\t\n\t\tfor(int i = 0; i < types.length; i++){\n\t\t\tfinal Type typeArgument = types[i];\n\t\t\t\n\t\t\tif(typeArgument.getType() == Type.ARRAY){\n\t\t\t\tfinal Type componentType = typeArgument.getTypeArgument(0).getType();\n\t\t\t\t\n\t\t\t\tif(componentType.getType() == Type.ARRAY){\n\t\t\t\t\tfinal Type componentTypeArgument = componentType.getTypeArgument(0);\n\t\t\t\t\t\n\t\t\t\t\tif(componentTypeArgument.getType() == Type.ARRAY){\n\t\t\t\t\t\tfinal Type componentTypeArgumentType = componentTypeArgument.getType();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(componentTypeArgumentType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeType = componentTypeArgumentType.getType();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(componentTypeArgumentTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeType = componentTypeArgumentTypeType.getType();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeType = componentTypeArgumentTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType(\n\t\t\t\t\t\t\t\t\t\t\ttypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType(\n\t\t\t\t\t\t\t\t\t\t\ttypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType}\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n", "method_name": "addInitializedType", "codes": ["Add abstractType to the initializations variable.\nprivate void addInitializedType(final int abstractType){\n\tif(initializedTypes.contains(abstractType)){\n\t\treturn;\n\t}\n\t\n\tinitializedTypes.add(abstractType);\n\t\n\tfinal Type type = types.get(abstractType);\n\t\n\tif(type == null){\n\t\treturn;\n\t}\n\t\n\tfinal Type initializer = type.getInitializer();\n\t\n\tif(initializer!= null){\n\t\tfinal Type[] types = initializer.getTypeArguments();\n\t\t\n\t\tfor(int i = 0; i < types.length; i++){\n\t\t\tfinal Type typeArgument = types[i];\n\t\t\t\n\t\t\tif(typeArgument.getType() == Type.ARRAY){\n\t\t\t\tfinal Type componentType = typeArgument.getTypeArgument(0).getType();\n\t\t\t\t\n\t\t\t\tif(componentType.getType() == Type.ARRAY){\n\t\t\t\t\tfinal Type componentTypeArgument = componentType.getTypeArgument(0);\n\t\t\t\t\t\n\t\t\t\t\tif(componentTypeArgument.getType() == Type.ARRAY){\n\t\t\t\t\t\tfinal Type componentTypeArgumentType = componentTypeArgument.getType();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(componentTypeArgumentType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeType = componentTypeArgumentType.getType();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(componentTypeArgumentTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeType = componentTypeArgumentTypeType.getType();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeType = componentTypeArgumentTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeType.getType() == Type.ARRAY){\n\t\t\t\t\t\t\t\t\t\t\t\tfinal Type componentTypeArgumentTypeTypeTypeTypeTypeTypeType = componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType.getType();\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tif(componentTypeArgumentTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType(\n\t\t\t\t\t\t\t\t\t\t\ttypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType(\n\t\t\t\t\t\t\t\t\t\t\ttypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeType}\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a9", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfor(int i=start;i<end;i++){\n\t\tputAbstractType(i);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n", "method_name": "putAbstractTypes", "codes": ["Add the elements indexed from start to end in currentFrame to Frame.\nprivate void putAbstractTypes(final int start,final int end){\n\tfor(int i=start;i<end;i++){\n\t\tputAbstractType(i);\n\t}\n}"], "code_level": "project_runnable", "_id": "6367670a1a6d9265ec0179dc", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public short readShort(final int offset){\n\treturn (short)classFileBuffer.getShort(offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readShort", "codes": ["public short readShort(final int offset){\n\treturn (short)classFileBuffer.getShort(offset);\n}"], "code_level": "class_runnable", "_id": "636766f21a6d9265ec017667", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if(labels[bytecodeOffset]!= null) return labels[bytecodeOffset];\n  final Label label = new Label();\n  labels[bytecodeOffset] = label;\n  return label;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n", "method_name": "readLabel", "codes": ["Return the label by the given bytecode offset if it has been created. Otherwise, creat a new label and return it.\nprotected Label readLabel(final int bytecodeOffset,final Label[] labels){\n  if(labels[bytecodeOffset]!= null) return labels[bytecodeOffset];\n  final Label label = new Label();\n  labels[bytecodeOffset] = label;\n  return label;\n}"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017853", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\treturn readUtf(constantPoolEntryIndex,charBuffer,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n", "method_name": "readUtf", "codes": ["Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.\nfinal String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\treturn readUtf(constantPoolEntryIndex,charBuffer,0);\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01782a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public int hashCode(){\n    int hash = type.hashCode();\n    if (hash == 0) {\n        hash = 1;\n    }\n    return hash;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a hash code value for this type.\n * @return a hash code value for this type.\n */\n", "method_name": "hashCode", "codes": ["public int hashCode(){\n    int hash = type.hashCode();\n    if (hash == 0) {\n        hash = 1;\n    }\n    return hash;\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017758", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = constantPool.addConstant(name, descriptor);\n\tindex = addConstant(index);\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n", "method_name": "addConstantNameAndType", "codes": ["Add constant information generated by its name and type to the constant pool and return the index of the constant.\nint addConstantNameAndType(final String name,final String descriptor){\n\tint index = constantPool.addConstant(name, descriptor);\n\tindex = addConstant(index);\n\treturn index;\n}"], "code_level": "project_runnable", "_id": "636766fe1a6d9265ec017823", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tlines.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n", "method_name": "addLineNumber", "codes": ["Add the number of lines. \nfinal void addLineNumber(final int lineNumber){\n\tlines.add(lineNumber);\n}"], "code_level": "class_runnable", "_id": "636767131a6d9265ec017b23", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOfLastSeparator(String filename){\n\tint index = filename.lastIndexOf(File.separatorChar);\n\tif(index == -1)\n\t\treturn -1;\n\treturn index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfLastSeparator", "codes": ["public static int indexOfLastSeparator(String filename){\n\tint index = filename.lastIndexOf(File.separatorChar);\n\tif(index == -1)\n\t\treturn -1;\n\treturn index;\n}"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017658", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.exists()) {\n      if (file.isFile()) {\n        file.delete();\n      } else if (file.isDirectory()) {\n        File[] files = file.listFiles();\n        for (File f : files) {\n          forceDeleteOnExit(f);\n        }\n      }\n    }\n  }", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n", "method_name": "forceDeleteOnExit", "codes": ["public static void forceDeleteOnExit(File file) throws IOException {\n    if (file.exists()) {\n      if (file.isFile()) {\n        file.delete();\n      } else if (file.isDirectory()) {\n        File[] files = file.listFiles();\n        for (File f : files) {\n          forceDeleteOnExit(f);\n        }\n      }\n    }\n  }"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017833", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOfExtension(String filename){\n\tint index = filename.lastIndexOf(extensionSeparator);\n\tif(index == -1){\n\t\treturn -1;\n\t}\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfExtension", "codes": ["public static int indexOfExtension(String filename){\n\tint index = filename.lastIndexOf(extensionSeparator);\n\tif(index == -1){\n\t\treturn -1;\n\t}\n\treturn index;\n}"], "code_level": "class_runnable", "_id": "636767061a6d9265ec01794a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public void write(byte b[]) throws IOException {\n    out.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n", "method_name": "write", "codes": ["public void write(byte b[]) throws IOException {\n    out.write(b);\n}"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179fe", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public void write(final byte b[],final int off,final int len) throws IOException {\n\tif (len > 0) {\n\t\tif (b == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tif (off < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (off + len > b.length) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (off + len > b.length) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tSystem.arraycopy(b, off, b, off, len);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.\n * @param b   the data.\n * @param off the start offset in the data.\n * @param len the number of bytes to write.\n */\n", "method_name": "write", "codes": ["public void write(final byte b[],final int off,final int len) throws IOException {\n\tif (len > 0) {\n\t\tif (b == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tif (off < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (off + len > b.length) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (off + len > b.length) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tSystem.arraycopy(b, off, b, off, len);\n\t}\n}"], "code_level": "class_runnable", "_id": "636766f91a6d9265ec01776e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n", "method_name": "write", "codes": ["public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179d8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public String toString(){\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(this.getClass().getName());\n\tsb.append(\"[\");\n\tsb.append(this.getClass().getSimpleName());\n\tsb.append(\"]\");\n\treturn sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n", "method_name": "toString", "codes": ["public String toString(){\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(this.getClass().getName());\n\tsb.append(\"[\");\n\tsb.append(this.getClass().getSimpleName());\n\tsb.append(\"]\");\n\treturn sb.toString();\n}"], "code_level": "project_runnable", "_id": "636767001a6d9265ec01787e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tif(array == null){\n\t\treturn;\n\t}\n\tint arrayLength = array.length;\n\tif(arrayLength == 0){\n\t\treturn;\n\t}\n\tint arrayStart = 0;\n\tint arrayEnd = arrayLength;\n\tif(arraySeparator == null){\n\t\tarrayStart = arrayLength;\n\t}else{\n\t\tarrayStart = arraySeparator.length();\n\t}\n\tfor(int i = arrayStart; i < arrayEnd; i++){\n\t\tbuffer.append(array[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["Append the detail of an int array to the buffer, starting with arrayStart and ending with arrayEnd, and separating with arraySeparator.\nprotected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\tif(array == null){\n\t\treturn;\n\t}\n\tint arrayLength = array.length;\n\tif(arrayLength == 0){\n\t\treturn;\n\t}\n\tint arrayStart = 0;\n\tint arrayEnd = arrayLength;\n\tif(arraySeparator == null){\n\t\tarrayStart = arrayLength;\n\t}else{\n\t\tarrayStart = arraySeparator.length();\n\t}\n\tfor(int i = arrayStart; i < arrayEnd; i++){\n\t\tbuffer.append(array[i]);\n\t}\n}"], "code_level": "class_runnable", "_id": "636767001a6d9265ec01787f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n    if(collection == null)\n        return EMPTY_STRING_ARRAY;\n    else\n        return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n", "method_name": "toNoNullStringArray", "codes": ["If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array.???\nstatic String[] toNoNullStringArray(Collection<?> collection){\n    if(collection == null)\n        return EMPTY_STRING_ARRAY;\n    else\n        return collection.toArray(new String[collection.size()]);\n}"], "code_level": "project_runnable", "_id": "636766f71a6d9265ec017730", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null){\n        REGISTRY.register(value);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n", "method_name": "register", "codes": ["Register the value in REGISTRY if the value is not null.\nstatic void register(Object value){\n    if(value!= null){\n        REGISTRY.register(value);\n    }\n}"], "code_level": "class_runnable", "_id": "636767041a6d9265ec017911", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tif(array!=null){\n\t\tbuffer.append(fieldName);\n\t\tbuffer.append(\"=\");\n\t\tbuffer.append(new String(array));\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["Append a byte array to a buffer.\nprotected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\tif(array!=null){\n\t\tbuffer.append(fieldName);\n\t\tbuffer.append(\"=\");\n\t\tbuffer.append(new String(array));\n\t}\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017821", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tif(array[i]!= null){\n\t\t\tresult[i] = array[i].toString();\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n", "method_name": "toNoNullStringArray", "codes": ["Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.\nstatic String[] toNoNullStringArray(Object[] array){\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tif(array[i]!= null){\n\t\t\tresult[i] = array[i].toString();\n\t\t}\n\t}\n\treturn result;\n}"], "code_level": "project_runnable", "_id": "636766fc1a6d9265ec0177ef", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public int read(byte[] b, int off, int len) throws IOException {\n        if (pos >= in.available()) {\n            return -1;\n        }\n        int n = in.read(b, off, len);\n        if (n == -1) {\n            pos++;\n            return -1;\n        }\n        pos += n;\n        return n;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see InputStream#available() \n */\n", "method_name": "available", "codes": ["public int read(byte[] b, int off, int len) throws IOException {\n        if (pos >= in.available()) {\n            return -1;\n        }\n        int n = in.read(b, off, len);\n        if (n == -1) {\n            pos++;\n            return -1;\n        }\n        pos += n;\n        return n;\n    }"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017641", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static <T>List<T> asList(T[] a){\n\tif(a == null)\n\t\treturn Collections.emptyList();\n\treturn Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n", "method_name": "asList", "codes": ["public static <T>List<T> asList(T[] a){\n\tif(a == null)\n\t\treturn Collections.emptyList();\n\treturn Arrays.asList(a);\n}"], "code_level": "slib_runnable", "_id": "636766f01a6d9265ec017639", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String convertHexDigit(byte b){\n\tif(b >= '0' && b <= '9'){\n\t\treturn String.format(\"%02X\", b);", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param b An ASCII encoded character 0-9 a-f A-F\n * @return The byte value of the character 0-16.\n */\n", "method_name": "convertHexDigit", "codes": ["public static String convertHexDigit(byte b){\n\tif(b >= '0' && b <= '9'){\n\t\treturn String.format(\"%02X\", b);"], "code_level": "slib_runnable", "_id": "636766f91a6d9265ec01777d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Converter lookup(final Class<?> clazz){\n\tConverter converter = null;\n\tfor (Converter c : converters) {\n\t\tif (c.getClass().equals(clazz)) {\n\t\t\tconverter = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn converter;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n", "method_name": "lookup", "codes": ["public Converter lookup(final Class<?> clazz){\n\tConverter converter = null;\n\tfor (Converter c : converters) {\n\t\tif (c.getClass().equals(clazz)) {\n\t\t\tconverter = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn converter;\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179e7", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public boolean containsKey(final Object key){\n    return map.containsKey(key);\n  }", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n", "method_name": "containsKey", "codes": ["public boolean containsKey(final Object key){\n    return map.containsKey(key);\n  }"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179f2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dest = new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\tdest[i] = src[i].toLowerCase();\n\t}\n\treturn dest;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n", "method_name": "copyStrings", "codes": ["Copy the source string and transfer each character to lowecase.\nprivate static String[] copyStrings(final String[] src){\n\tfinal String[] dest = new String[src.length];\n\tfor(int i=0;i<src.length;i++){\n\t\tdest[i] = src[i].toLowerCase();\n\t}\n\treturn dest;\n}"], "code_level": "self_contained", "_id": "636767041a6d9265ec0178f8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof String) {\n\t\treturn value;\n\t}\n\tif (value instanceof Integer) {\n\t\treturn value;\n\t}\n\tif (value instanceof Long) {\n\t\treturn value;\n\t}\n\tif (value instanceof Float) {\n\t\treturn value;\n\t}\n\tif (value instanceof Double) {\n\t\treturn value;\n\t}\n\tif (value instanceof Boolean) {\n\t\treturn value;\n\t}\n\tif (value instanceof Date) {\n\t\treturn value;\n\t}\n\tif (value instanceof Time) {\n\t\treturn value;\n\t}\n\tif (value instanceof Timestamp) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDate) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDate) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n", "method_name": "convertToType", "codes": ["If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.\n@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof String) {\n\t\treturn value;\n\t}\n\tif (value instanceof Integer) {\n\t\treturn value;\n\t}\n\tif (value instanceof Long) {\n\t\treturn value;\n\t}\n\tif (value instanceof Float) {\n\t\treturn value;\n\t}\n\tif (value instanceof Double) {\n\t\treturn value;\n\t}\n\tif (value instanceof Boolean) {\n\t\treturn value;\n\t}\n\tif (value instanceof Date) {\n\t\treturn value;\n\t}\n\tif (value instanceof Time) {\n\t\treturn value;\n\t}\n\tif (value instanceof Timestamp) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDate) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDate) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof LocalDateTime) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigInteger) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n\tif (value instanceof BigDecimal) {\n\t\treturn value;\n\t}\n"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bf", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Collection<Object> values(){\n\treturn new ArrayList<Object>(this.getBeanMap().values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n", "method_name": "values", "codes": ["public Collection<Object> values(){\n\treturn new ArrayList<Object>(this.getBeanMap().values());\n}"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec01764f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public void putAllWriteable(BeanMap map){\n\tfor(Map.Entry<String, Object> entry : map.entrySet()){\n\t\tputWriteable(entry.getKey(), entry.getValue());\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n", "method_name": "putAllWriteable", "codes": ["public void putAllWriteable(BeanMap map){\n\tfor(Map.Entry<String, Object> entry : map.entrySet()){\n\t\tputWriteable(entry.getKey(), entry.getValue());\n\t}\n}"], "code_level": "class_runnable", "_id": "636767071a6d9265ec017962", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public long contentLength(){\n\ttry{\n\t\treturn this.contentLength;\n\t}catch(NumberFormatException e){\n\t\treturn -1;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n", "method_name": "contentLength", "codes": ["public long contentLength(){\n\ttry{\n\t\treturn this.contentLength;\n\t}catch(NumberFormatException e){\n\t\treturn -1;\n\t}\n}"], "code_level": "project_runnable", "_id": "636767031a6d9265ec0178dd", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index = end;\n\twhile(index < headerPart.length() && headerPart.charAt(index)!= '\\n'){\n\t\tindex++;\n\t}\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n", "method_name": "parseEndOfLine", "codes": ["Parse the header part starting from the given end position and return the index of the enter sequence. \nprivate int parseEndOfLine(String headerPart,int end){\n\tint index = end;\n\twhile(index < headerPart.length() && headerPart.charAt(index)!= '\\n'){\n\t\tindex++;\n\t}\n\treturn index;\n}"], "code_level": "self_contained", "_id": "636767121a6d9265ec017b0a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tif(pos<0){\n\t\treturn -1;\n\t}\n\tint i=pos;\n\twhile(i>=0 && value==buffer[i]){\n\t\ti--;\n\t}\n\treturn i;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n", "method_name": "findByte", "codes": ["Searche for a byte of the specified value in the buffer, starting at the specified position.\nprotected int findByte(byte value,int pos){\n\tif(pos<0){\n\t\treturn -1;\n\t}\n\tint i=pos;\n\twhile(i>=0 && value==buffer[i]){\n\t\ti--;\n\t}\n\treturn i;\n}"], "code_level": "class_runnable", "_id": "636766ff1a6d9265ec017851", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public byte readByte() throws IOException {\n    return read(new byte[1], 0, 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n", "method_name": "readByte", "codes": ["public byte readByte() throws IOException {\n    return read(new byte[1], 0, 1);\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01774b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint i1 = 0;\n\tint i2 = 0;\n\tint i3 = 0;\n\tint i4 = 0;\n\tint i5 = 0;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\tint i9 = 0;\n\tint i10 = 0;\n\tint i11 = 0;\n\tint i12 = 0;\n\tint i13 = 0;\n\tint i14 = 0;\n\tint i15 = 0;\n\tint i16 = 0;\n\tint i17 = 0;\n\tint i18 = 0;\n\tint i19 = 0;\n\tint i20 = 0;\n\tint i21 = 0;\n\tint i22 = 0;\n\tint i23 = 0;\n\tint i24 = 0;\n\tint i25 = 0;\n\tint i26 = 0;\n\tint i27 = 0;\n\tint i28 = 0;\n\tint i29 = 0;\n\tint i30 = 0;\n\tint i31 = 0;\n\tint i32 = 0;\n\tint i33 = 0;\n\tint i34 = 0;\n\tint i35 = 0;\n\tint i36 = 0;\n\tint i37 = 0;\n\tint i38 = 0;\n\tint i39 = 0;\n\tint i40 = 0;\n\tint i41 = 0;\n\tint i42 = 0;\n\tint i43 = 0;\n\tint i44 = 0;\n\tint i45 = 0;\n\tint i46 = 0;\n\tint i47 = 0;\n\tint i48 = 0;\n\tint i49 = 0;\n\tint i50 = 0;\n\tint i51 = 0;\n\tint i52 = 0;\n\tint i53 = 0;\n\tint i54 = 0;\n\tint i55 = 0;\n\tint i56 = 0;\n\tint i57 = 0;\n\tint i58 = 0;\n\tint i59 = 0;\n\tint i60 = 0;\n\tint i61 = 0;\n\tint i62 = 0;\n\tint i63 = 0;\n\tint i64 = 0;\n\tint i65 = 0;\n\tint i66 = 0;\n\tint i67 = 0;\n\tint i68 = 0;\n\tint i69 = 0;\n\tint i70 = 0;\n\tint i71 = 0;\n\tint i72 = 0;\n\tint i73 = 0;\n\tint i74 = 0;\n\tint i75 = 0;\n\tint i76 = 0;\n\tint i77 = 0;\n\tint i78 = 0;\n\tint i79 = 0;\n\tint i80 = 0;\n\tint i81 = 0;\n\tint i82 = 0;\n\tint i83 = 0;\n\tint i84 = 0;\n\tint i85 = 0;\n\tint i86 = 0;\n\tint i87 = 0;\n\tint i88 = 0;\n\tint i89 = 0;\n\tint i90 = 0;\n\tint i91 = 0;\n\tint i92 = 0;\n\tint i93 = 0;\n\tint i94 = 0;\n\tint i95 = 0;\n\tint i96 = 0;\n\tint i97 = 0;\n\tint i98 = 0;\n\tint i99 = 0;\n\tint i100 = 0;\n\tint i101 = 0;\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n", "method_name": "parseToken", "codes": ["Parses out a token until any of the given terminators is encountered and then return the token.\nprivate String parseToken(final char[] terminators){\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint i1 = 0;\n\tint i2 = 0;\n\tint i3 = 0;\n\tint i4 = 0;\n\tint i5 = 0;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\tint i9 = 0;\n\tint i10 = 0;\n\tint i11 = 0;\n\tint i12 = 0;\n\tint i13 = 0;\n\tint i14 = 0;\n\tint i15 = 0;\n\tint i16 = 0;\n\tint i17 = 0;\n\tint i18 = 0;\n\tint i19 = 0;\n\tint i20 = 0;\n\tint i21 = 0;\n\tint i22 = 0;\n\tint i23 = 0;\n\tint i24 = 0;\n\tint i25 = 0;\n\tint i26 = 0;\n\tint i27 = 0;\n\tint i28 = 0;\n\tint i29 = 0;\n\tint i30 = 0;\n\tint i31 = 0;\n\tint i32 = 0;\n\tint i33 = 0;\n\tint i34 = 0;\n\tint i35 = 0;\n\tint i36 = 0;\n\tint i37 = 0;\n\tint i38 = 0;\n\tint i39 = 0;\n\tint i40 = 0;\n\tint i41 = 0;\n\tint i42 = 0;\n\tint i43 = 0;\n\tint i44 = 0;\n\tint i45 = 0;\n\tint i46 = 0;\n\tint i47 = 0;\n\tint i48 = 0;\n\tint i49 = 0;\n\tint i50 = 0;\n\tint i51 = 0;\n\tint i52 = 0;\n\tint i53 = 0;\n\tint i54 = 0;\n\tint i55 = 0;\n\tint i56 = 0;\n\tint i57 = 0;\n\tint i58 = 0;\n\tint i59 = 0;\n\tint i60 = 0;\n\tint i61 = 0;\n\tint i62 = 0;\n\tint i63 = 0;\n\tint i64 = 0;\n\tint i65 = 0;\n\tint i66 = 0;\n\tint i67 = 0;\n\tint i68 = 0;\n\tint i69 = 0;\n\tint i70 = 0;\n\tint i71 = 0;\n\tint i72 = 0;\n\tint i73 = 0;\n\tint i74 = 0;\n\tint i75 = 0;\n\tint i76 = 0;\n\tint i77 = 0;\n\tint i78 = 0;\n\tint i79 = 0;\n\tint i80 = 0;\n\tint i81 = 0;\n\tint i82 = 0;\n\tint i83 = 0;\n\tint i84 = 0;\n\tint i85 = 0;\n\tint i86 = 0;\n\tint i87 = 0;\n\tint i88 = 0;\n\tint i89 = 0;\n\tint i90 = 0;\n\tint i91 = 0;\n\tint i92 = 0;\n\tint i93 = 0;\n\tint i94 = 0;\n\tint i95 = 0;\n\tint i96 = 0;\n\tint i97 = 0;\n\tint i98 = 0;\n\tint i99 = 0;\n\tint i100 = 0;\n\tint i101 = 0;\n"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec01779c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a==null || b==null || a.length!=b.length)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n * @param a     The first array to compare.\n * @param b     The second array to compare.\n * @param count How many bytes should be compared.\n * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.\n */\n", "method_name": "arrayequals", "codes": ["public static boolean arrayequals(byte[] a,byte[] b,int count){\n\tif(a==null || b==null || a.length!=b.length)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "636766fd1a6d9265ec017814", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\tif(str==null || searchStr==null)\n\t\treturn INDEXNOTFOUND;\n\t\n\tint lastIndex=str.length()-searchStr.length();\n\tif(lastIndex<0)\n\t\treturn INDEXNOTFOUND;\n\t\n\tfor(int i=lastIndex;i>=0;i--){\n\t\tif(str.charAt(i)==searchStr.charAt(i))\n\t\t\treturn i;\n\t}\n\treturn INDEXNOTFOUND;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n", "method_name": "lastIndexOf", "codes": ["public static int lastIndexOf(String str,String searchStr){\n\tif(str==null || searchStr==null)\n\t\treturn INDEXNOTFOUND;\n\t\n\tint lastIndex=str.length()-searchStr.length();\n\tif(lastIndex<0)\n\t\treturn INDEXNOTFOUND;\n\t\n\tfor(int i=lastIndex;i>=0;i--){\n\t\tif(str.charAt(i)==searchStr.charAt(i))\n\t\t\treturn i;\n\t}\n\treturn INDEXNOTFOUND;\n}"], "code_level": "project_runnable", "_id": "636766f61a6d9265ec017701", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String sub(String str,int start,int end){\n\tif(str==null) return null;\n\tif(start<0) start=0;\n\tif(end<0) end=str.length();\n\tif(start>end) return null;\n\tint i=start;\n\tint j=end;\n\twhile(i<j)\n\t{\n\t\tif(str.charAt(i)==str.charAt(j))\n\t\t{\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn str.substring(i", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n", "method_name": "sub", "codes": ["public static String sub(String str,int start,int end){\n\tif(str==null) return null;\n\tif(start<0) start=0;\n\tif(end<0) end=str.length();\n\tif(start>end) return null;\n\tint i=start;\n\tint j=end;\n\twhile(i<j)\n\t{\n\t\tif(str.charAt(i)==str.charAt(j))\n\t\t{\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn str.substring(i"], "code_level": "project_runnable", "_id": "636766ff1a6d9265ec01783b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif(str==null || searchStrArray==null || searchStrArray.size()==0) return false;\n\tfor(String s : searchStrArray){\n\t\tif(str.toLowerCase().contains(s.toLowerCase())) return true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n", "method_name": "containsAnyIgnoreCase", "codes": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\tif(str==null || searchStrArray==null || searchStrArray.size()==0) return false;\n\tfor(String s : searchStrArray){\n\t\tif(str.toLowerCase().contains(s.toLowerCase())) return true;\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "6367670b1a6d9265ec017a0f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOf(String str,String searchStr){\n\tint index=0;\n\twhile(index<str.length() && index<searchStr.length()){\n\t\tif(str.charAt(index)==searchStr.charAt(index)){\n\t\t\tindex++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. \n */\n", "method_name": "indexOf", "codes": ["public static int indexOf(String str,String searchStr){\n\tint index=0;\n\twhile(index<str.length() && index<searchStr.length()){\n\t\tif(str.charAt(index)==searchStr.charAt(index)){\n\t\t\tindex++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn index;\n}"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bc", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return (c == ';' || c == ',');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n", "method_name": "isParameterSeparator", "codes": ["Check whether a character is a parameter separator. If yes, true is returned. Otherwise, false is returned.\nprivate static boolean isParameterSeparator(final char c){\n    return (c == ';' || c == ',');\n}"], "code_level": "class_runnable", "_id": "636766fc1a6d9265ec0177da", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tfinal Object[] newArray = (Object[])Array.newInstance(newArrayComponentType, array.length + 1);\n\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\tnewArray[array.length] = newArrayComponentType;\n\treturn newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "method_name": "copyArrayGrow1", "codes": ["Copy the given array and add a default value at the end.\nprivate static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\tfinal Object[] newArray = (Object[])Array.newInstance(newArrayComponentType, array.length + 1);\n\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\tnewArray[array.length] = newArrayComponentType;\n\treturn newArray;\n}"], "code_level": "slib_runnable", "_id": "636767031a6d9265ec0178ef", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String sessionId(){\n\treturn sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Session ID. \n */\n", "method_name": "sessionId", "codes": ["public static String sessionId(){\n\treturn sessionId;\n}"], "code_level": "plib_runnable", "_id": "636766fe1a6d9265ec017834", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Boolean isPartialContentResponse(){\n\treturn this.isPartialContent;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n", "method_name": "isPartialContentResponse", "codes": ["public Boolean isPartialContentResponse(){\n\treturn this.isPartialContent;\n}"], "code_level": "plib_runnable", "_id": "636766ae1a6d9265ec0175dc", "project_name": "framework-master"}
{"generate_results": [{"generate_code": "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(\"bytes \");\n\tsb.append(offset);\n\tsb.append(\"-\" + limit);\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n", "method_name": "buildContentRange", "codes": ["Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.\nprivate String buildContentRange(){\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(\"bytes \");\n\tsb.append(offset);\n\tsb.append(\"-\" + limit);\n\treturn sb.toString();\n}"], "code_level": "class_runnable", "_id": "636766ae1a6d9265ec0175d8", "project_name": "framework-master"}
{"generate_results": [{"generate_code": "Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    if (charset.equals(\"UTF-8\")){\n        return \"UTF-8\";\n    }\n    if (charset.equals(\"UTF-16\")){\n        return \"UTF-16\";\n    }\n    if (charset.equals(\"UTF-16BE\")){\n        return \"UTF-16BE\";\n    }\n    if (charset.equals(\"UTF-16LE\")){\n        return \"UTF-16LE\";\n    }\n    if (charset.equals(\"UTF-32\")){\n        return \"UTF-32\";\n    }\n    if (charset.equals(\"UTF-32BE\")){\n        return \"UTF-32BE\";\n    }\n    if (charset.equals(\"UTF-32LE\")){\n        return \"UTF-32LE\";\n    }\n    return charset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n", "method_name": "javaCharset", "codes": ["Translate a MIME standard charset name into the Java equivalent.\nprivate static String javaCharset(String charset){\n    if (charset.equals(\"UTF-8\")){\n        return \"UTF-8\";\n    }\n    if (charset.equals(\"UTF-16\")){\n        return \"UTF-16\";\n    }\n    if (charset.equals(\"UTF-16BE\")){\n        return \"UTF-16BE\";\n    }\n    if (charset.equals(\"UTF-16LE\")){\n        return \"UTF-16LE\";\n    }\n    if (charset.equals(\"UTF-32\")){\n        return \"UTF-32\";\n    }\n    if (charset.equals(\"UTF-32BE\")){\n        return \"UTF-32BE\";\n    }\n    if (charset.equals(\"UTF-32LE\")){\n        return \"UTF-32LE\";\n    }\n    return charset;\n}"], "code_level": "class_runnable", "_id": "636766f01a6d9265ec01763e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    if(node.left == null){\n        return node;\n    }\n    else{\n        TreeNode<T> temp = node.left;\n        node.left = rotateRight(node.left);\n        node.right = temp;\n        return node;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n", "method_name": "rotateRight", "codes": ["Perform a right node rotation on the AVL tree.\nprivate TreeNode<T> rotateRight(TreeNode<T> node){\n    if(node.left == null){\n        return node;\n    }\n    else{\n        TreeNode<T> temp = node.left;\n        node.left = rotateRight(node.left);\n        node.right = temp;\n        return node;\n    }\n}"], "code_level": "file_runnable", "_id": "636767441a6d9265ec017cc1", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\tV temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Swaps the two elements at the specified indices in the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param i the index of the first element\n * @param j the index of the second element\n */\n", "method_name": "swap", "codes": ["public static final <V>void swap(V[] arr,int i,int j){\n\tV temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n}"], "code_level": "self_contained", "_id": "636767551a6d9265ec017f3f", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public String get() {\n            return String.valueOf(start) + suffix + end + length + startOffset + endOffset + startIndex + startIndexOffset;\n        }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n", "method_name": "createStringSupplier", "codes": ["public String get() {\n            return String.valueOf(start) + suffix + end + length + startOffset + endOffset + startIndex + startIndexOffset;\n        }"], "code_level": "slib_runnable", "_id": "6367675c1a6d9265ec018058", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public ListNode<E> previousNode(){ return null; }", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "previousNode", "codes": ["public ListNode<E> previousNode(){ return null; }"], "code_level": "class_runnable", "_id": "636767501a6d9265ec017e86", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static long factorial(int n){\n    long result = 1;\n    for(int i = 2; i <= n; i++){\n        result *= i;\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Calculate the factorial of $n$.\n * @param n the input number\n * @return the factorial\n */\n", "method_name": "factorial", "codes": ["public static long factorial(int n){\n    long result = 1;\n    for(int i = 2; i <= n; i++){\n        result *= i;\n    }\n    return result;\n}"], "code_level": "self_contained", "_id": "636767581a6d9265ec017fc4", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tListNodeImpl<E> temp = node.next;\n\tListNodeImpl<E> temp2 = node.next.next;\n\tnode.next.next = node.next.next.next;\n\tnode.next.next.next = temp;\n\tnode.next = temp2;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n", "method_name": "unlink", "codes": ["Remove the doubly circular linked list node.If success return true,otherwise return false.\nprivate boolean unlink(ListNodeImpl<E> node){\n\tListNodeImpl<E> temp = node.next;\n\tListNodeImpl<E> temp2 = node.next.next;\n\tnode.next.next = node.next.next.next;\n\tnode.next.next.next = temp;\n\tnode.next = temp2;\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "636767631a6d9265ec018171", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\tint i=from;\n\tint j=to;\n\t\n\twhile(i<j){\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t\ti++;\n\t\tj--;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n", "method_name": "reverse", "codes": ["public static final <V>void reverse(V[] arr,int from,int to){\n\tint i=from;\n\tint j=to;\n\t\n\twhile(i<j){\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t\ti++;\n\t\tj--;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767491a6d9265ec017d90", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\tDoublyLinkedList<E> newList = new DoublyLinkedList<E>();\n\tDoublyLinkedList<E> current = list;\n\twhile(current!= null){\n\t\tnewList.addLast(current.getData());\n\t\tcurrent = current.getNext();\n\t}\n\tlist = newList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n", "method_name": "moveAllListNodes", "codes": ["Move the nodes of the given doubly linked list to a new list sequentially.\nprivate void moveAllListNodes(DoublyLinkedList<E> list){\n\tDoublyLinkedList<E> newList = new DoublyLinkedList<E>();\n\tDoublyLinkedList<E> current = list;\n\twhile(current!= null){\n\t\tnewList.addLast(current.getData());\n\t\tcurrent = current.getNext();\n\t}\n\tlist = newList;\n}"], "code_level": "class_runnable", "_id": "6367674a1a6d9265ec017da9", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<V,E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n", "method_name": "identity", "codes": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n    return new IsomorphicGraphMapping<V,E>(graph);\n}"], "code_level": "project_runnable", "_id": "6367675f1a6d9265ec0180d3", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tfor(int i=0;i<target.size();i++){\n\t\tV v=target.get(i);\n\t\tfor(int j=0;j<target.size();j++){\n\t\t\tif(resultMap.get(v.toString()+\"_\"+j.toString()).equals(v)){\n\t\t\t\ttarget.set(i,v);\n\t\t\t\ttarget.set(j,v);\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Construct a complete bipartite graph\n */\n", "method_name": "generateGraph", "codes": ["public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\tfor(int i=0;i<target.size();i++){\n\t\tV v=target.get(i);\n\t\tfor(int j=0;j<target.size();j++){\n\t\t\tif(resultMap.get(v.toString()+\"_\"+j.toString()).equals(v)){\n\t\t\t\ttarget.set(i,v);\n\t\t\t\ttarget.set(j,v);\n\t\t\t}\n\t\t}\n\t}\n}"], "code_level": "class_runnable", "_id": "636767641a6d9265ec01817d", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    if(bucket.next == NULL){\n        bucket.next = bucket.prev;\n        bucket.prev = bucket;\n    }else{\n        bucket.prev->next = bucket;\n        bucket.prev = bucket->prev;\n        bucket->prev = bucket;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n", "method_name": "insertBefore", "codes": ["Insert this bucket in the data structure before the given bucket.\nvoid insertBefore(Bucket bucket){\n    if(bucket.next == NULL){\n        bucket.next = bucket.prev;\n        bucket.prev = bucket;\n    }else{\n        bucket.prev->next = bucket;\n        bucket.prev = bucket->prev;\n        bucket->prev = bucket;\n    }\n}"], "code_level": "class_runnable", "_id": "636767531a6d9265ec017efb", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public void remove(){\n\tif(!hasNext()){\n\t\tthrow new NoSuchElementException();\n\t}\n\tvisited.add(node);\n\tnode = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n", "method_name": "hasNext", "codes": ["public void remove(){\n\tif(!hasNext()){\n\t\tthrow new NoSuchElementException();\n\t}\n\tvisited.add(node);\n\tnode = null;\n}"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f63", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    if(self->next!= NULL){\n        self->next->prev = self->prev;\n    }\n    if(self->prev!= NULL){\n        self->prev->next = self->next;\n    }\n    if(self->next == NULL){\n        self->prev = NULL;\n    }\n    if(self->prev == NULL){\n        self->next = NULL;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this bucket from the data structure.\n */\n", "method_name": "removeSelf", "codes": ["Remove the doubly linked list node that call the function.\nvoid removeSelf(){\n    if(self->next!= NULL){\n        self->next->prev = self->prev;\n    }\n    if(self->prev!= NULL){\n        self->prev->next = self->next;\n    }\n    if(self->next == NULL){\n        self->prev = NULL;\n    }\n    if(self->prev == NULL){\n        self->next = NULL;\n    }\n}"], "code_level": "class_runnable", "_id": "6367675a1a6d9265ec018010", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> vertices = new HashSet<V>();\n\tfor(Edge e : graph.getEdges()){\n\t\tif(!e.isVisited()){\n\t\t\tvertices.add(e.getSource());\n\t\t\tvertices.add(e.getTarget());\n\t\t}\n\t}\n\treturn vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n", "method_name": "initVisibleVertices", "codes": ["Compute all vertices by iterating over the edges of this graph.\nprivate Set<V> initVisibleVertices(){\n\tSet<V> vertices = new HashSet<V>();\n\tfor(Edge e : graph.getEdges()){\n\t\tif(!e.isVisited()){\n\t\t\tvertices.add(e.getSource());\n\t\t\tvertices.add(e.getTarget());\n\t\t}\n\t}\n\treturn vertices;\n}"], "code_level": "class_runnable", "_id": "6367674b1a6d9265ec017dc0", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public void removeFromTreeEdgeList(){\n\tif(this.treeEdgeList.size() == 0){\n\t\treturn;\n\t}\n\tthis.treeEdgeList.remove(this.treeEdgeList.size()-1);\n\tthis.treeEdgeList.add(this.treeEdgeList.size()-1, this.treeEdgeList.get(0));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this edge from both doubly linked lists of tree edges.\n */\n", "method_name": "removeFromTreeEdgeList", "codes": ["public void removeFromTreeEdgeList(){\n\tif(this.treeEdgeList.size() == 0){\n\t\treturn;\n\t}\n\tthis.treeEdgeList.remove(this.treeEdgeList.size()-1);\n\tthis.treeEdgeList.add(this.treeEdgeList.size()-1, this.treeEdgeList.get(0));\n}"], "code_level": "class_runnable", "_id": "6367675c1a6d9265ec01805b", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!indexedVertices.contains(sourceVertex)){\n\t\tindexedVertices.add(sourceVertex);\n\t\tindexedEdges.add(e);\n\t}\n\telse if(!indexedVertices.contains(targetVertex)){\n\t\tindexedVertices.add(targetVertex);\n\t\tindexedEdges.add(e);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n", "method_name": "addToIndex", "codes": ["Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.\nprotected void addToIndex(V sourceVertex,V targetVertex,E e){\n\tif(!indexedVertices.contains(sourceVertex)){\n\t\tindexedVertices.add(sourceVertex);\n\t\tindexedEdges.add(e);\n\t}\n\telse if(!indexedVertices.contains(targetVertex)){\n\t\tindexedVertices.add(targetVertex);\n\t\tindexedEdges.add(e);\n\t}\n}"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180fd", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tdouble x = box.getX();\n\tdouble y = box.getY();\n\tdouble width = box.getWidth();\n\tdouble height = box.getHeight", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n", "method_name": "splitAlongXAxis", "codes": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\tdouble x = box.getX();\n\tdouble y = box.getY();\n\tdouble width = box.getWidth();\n\tdouble height = box.getHeight"], "code_level": "project_runnable", "_id": "636767521a6d9265ec017ecc", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\treturn (p1.getX()==p2.getX() && p1.getY()==p2.getY());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n", "method_name": "equals", "codes": ["public static boolean equals(Point2D p1,Point2D p2){\n\treturn (p1.getX()==p2.getX() && p1.getY()==p2.getY());\n}"], "code_level": "project_runnable", "_id": "636767531a6d9265ec017ef1", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public int compare(Double o1,Double o2){\n\tif(o1==null && o2==null) return 0;\n\tif(o1==null) return -1;\n\tif(o2==null) return 1;\n\treturn o1.compareTo(o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise\n * @param o1 the first value\n * @param o2 the second value\n * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise\n */\n", "method_name": "compare", "codes": ["public int compare(Double o1,Double o2){\n\tif(o1==null && o2==null) return 0;\n\tif(o1==null) return -1;\n\tif(o2==null) return 1;\n\treturn o1.compareTo(o2);\n}"], "code_level": "slib_runnable", "_id": "6367674a1a6d9265ec017dab", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public String toString(){\n\treturn \"\";\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns a textual representation of the queue.\n * @return a textual representation of the queue.\n */\n", "method_name": "toString", "codes": ["public String toString(){\n\treturn \"\";\n}"], "code_level": "class_runnable", "_id": "6367674f1a6d9265ec017e74", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint result = 0;\n\twhile(n > 0){\n\t\tresult = (result * 2) + 1;\n\t\tn = n / 2;\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n", "method_name": "computeBinaryLog", "codes": ["Calculate the floor of the logarithmic value of the given value in base 2.\nprivate int computeBinaryLog(int n){\n\tint result = 0;\n\twhile(n > 0){\n\t\tresult = (result * 2) + 1;\n\t\tn = n / 2;\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636767431a6d9265ec017c8d", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n", "method_name": "vertexWeight", "codes": ["public double vertexWeight(Set<V> v){\n\tdouble sum = 0;\n\tfor(V v : v){\n\t\tsum += vertexWeight(v);\n\t}\n\treturn sum;\n}"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018106", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result = new HashSet<V>();\n\tfor(V v : set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n", "method_name": "intersection", "codes": ["Return the intersection between two sets.\nprivate Set<V> intersection(Set<V> set1,Set<V> set2){\n\tSet<V> result = new HashSet<V>();\n\tfor(V v : set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}"], "code_level": "slib_runnable", "_id": "636767611a6d9265ec018116", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tOuterFaceCirculator circulator = new OuterFaceCirculator(start,stop,dir);\n\treturn circulator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n", "method_name": "selectOnOuterFace", "codes": ["Find a circulator to the node that satisfies the Interface predicate.\nprivate OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\tOuterFaceCirculator circulator = new OuterFaceCirculator(start,stop,dir);\n\treturn circulator;\n}"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb6", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\treturn this.edge;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n", "method_name": "edgeToNext", "codes": ["Return the edge connecting the previously returned node with the current node.\nEdge edgeToNext(){\n\treturn this.edge;\n}"], "code_level": "class_runnable", "_id": "6367675d1a6d9265ec018082", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\t//create a new graph path\n\tGraphPath<V,E> newPath = new GraphPath<V,E>();\n\t\n\t//add all the edges in the set\n\tfor(E e : tour){\n\t\tnewPath.addEdge(e,graph.getEdge(e));\n\t}\n\t\n\treturn newPath;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n", "method_name": "edgeSetToTour", "codes": ["Convert a set representation to a graph path.\nprotected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\t\n\t//create a new graph path\n\tGraphPath<V,E> newPath = new GraphPath<V,E>();\n\t\n\t//add all the edges in the set\n\tfor(E e : tour){\n\t\tnewPath.addEdge(e,graph.getEdge(e));\n\t}\n\t\n\treturn newPath;\n}"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f7c", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor(int i=0;i<labels.size();i++){\n\t\tif(bucketsByLabel.get(labels.get(i)).size()>0){\n\t\t\tfor(int j=0;j<bucketsByLabel.get(labels.get(i)).size();j++){\n\t\t\t\tif(bucketsByLabel.get(labels.get(i)).get(j)==minLabel){\n\t\t\t\t\tbucketsByLabel.get(labels.get(i)).set(j,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n", "method_name": "reload", "codes": ["Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.\nprivate void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\tfor(int i=0;i<labels.size();i++){\n\t\tif(bucketsByLabel.get(labels.get(i)).size()>0){\n\t\t\tfor(int j=0;j<bucketsByLabel.get(labels.get(i)).size();j++){\n\t\t\t\tif(bucketsByLabel.get(labels.get(i)).get(j)==minLabel){\n\t\t\t\t\tbucketsByLabel.get(labels.get(i)).set(j,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"], "code_level": "self_contained", "_id": "636767641a6d9265ec018190", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n    return nextVertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "provideNextVertex", "codes": ["Get next vertext from a graph.\n@Override protected V provideNextVertex(){\n    return nextVertex;\n}"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018112", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tList<Pair<Integer,Integer>> list1 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list2 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list3 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list4 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list5 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list6 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list7 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list8 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list9 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list10 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list11 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list12 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list13 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list14 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list15 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list16 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list17 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list18 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list19 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list20 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list21 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list22 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list23 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list24 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list25 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list26 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list27 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list28 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list29 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list30 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list31 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list32 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list33 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list34 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list35 = new ArrayList<P", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n", "method_name": "computeGlobalSeparatorList", "codes": ["Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.\nprivate List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tList<Pair<Integer,Integer>> list1 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list2 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list3 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list4 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list5 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list6 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list7 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list8 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list9 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list10 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list11 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list12 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list13 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list14 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list15 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list16 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list17 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list18 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list19 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list20 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list21 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list22 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list23 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list24 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list25 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list26 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list27 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list28 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list29 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list30 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list31 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list32 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list33 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list34 = new ArrayList<Pair<Integer,Integer>>();\n\tList<Pair<Integer,Integer>> list35 = new ArrayList<P"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180e2", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tlong sum = 0;\n\tfor(int i = 0; i < bounds.size(); i++){\n\t\tsum += bounds.get(i);\n\t\tif(i == bounds.size() - 1){\n\t\t\tsuffixSum.add(bounds.get(i));\n\t\t}\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n", "method_name": "computeSuffixSum", "codes": ["Return a pair of the list of suffix sum and the sum of all elements of bounds.\nprivate Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tlong sum = 0;\n\tfor(int i = 0; i < bounds.size(); i++){\n\t\tsum += bounds.get(i);\n\t\tif(i == bounds.size() - 1){\n\t\t\tsuffixSum.add(bounds.get(i));\n\t\t}\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}"], "code_level": "project_runnable", "_id": "636767461a6d9265ec017d0e", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> list = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tlist.add(keys.get(i).getLowerBound());\n\t}\n\treturn list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n", "method_name": "computeLowerBounds", "codes": ["The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.\nprivate List<Integer> computeLowerBounds(List<K> keys){\n\tList<Integer> list = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tlist.add(keys.get(i).getLowerBound());\n\t}\n\treturn list;\n}"], "code_level": "class_runnable", "_id": "636767431a6d9265ec017c88", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tupperBounds.add(keys.get(i).getUpperBound());\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n", "method_name": "computeUpperBounds", "codes": ["The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.\nprivate List<Integer> computeUpperBounds(List<K> keys){\n\tList<Integer> upperBounds = new ArrayList<>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tupperBounds.add(keys.get(i).getUpperBound());\n\t}\n\treturn upperBounds;\n}"], "code_level": "class_runnable", "_id": "636767581a6d9265ec017fb4", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tfor(V vertex : vertices){\n\t\tif(!graph.containsVertex(vertex)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n", "method_name": "isClique", "codes": ["Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.\nprivate static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\tfor(V vertex : vertices){\n\t\tif(!graph.containsVertex(vertex)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "6367675f1a6d9265ec0180cf", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public int nonZeros(int row){\n\tint nz = 0;\n\tfor(int i = 0; i < row; i++){\n\t\tif(!isZero(i)){\n\t\t\tnz++;\n\t\t}\n\t}\n\treturn nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Get the number of non-zero entries of a row.\n * @param row the row\n * @return the number of non-zero entries of a row\n */\n", "method_name": "nonZeros", "codes": ["public int nonZeros(int row){\n\tint nz = 0;\n\tfor(int i = 0; i < row; i++){\n\t\tif(!isZero(i)){\n\t\t\tnz++;\n\t\t}\n\t}\n\treturn nz;\n}"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb0", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString result = input.replaceAll(\"[\\\\W]\", \"\");\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n", "method_name": "unescapeId", "codes": ["Unescape a dot identifier string.\nprivate String unescapeId(String input){\n\tString result = input.replaceAll(\"[\\\\W]\", \"\");\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636767461a6d9265ec017d17", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c = bb.get();\n\tif(c < 0x80){\n\t\tsb.append((char)c);\n\t\treturn i+1;\n\t}\n\telse if(c < 0x800){\n\t\tsb.append((char)(0xc0 | (c >> 6)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+2;\n\t}\n\telse if(c < 0x10000){\n\t\tsb.append((char)(0xe0 | (c >> 12)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+3;\n\t}\n\telse if(c < 0x200000){\n\t\tsb.append((char)(0xf0 | (c >> 18)));\n\t\tsb.append((char)(0x80 | ((c >> 12) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+4;\n\t}\n\telse{\n\t\tsb.append((char)(0xf8 | (c >> 24)));\n\t\tsb.append((char)(0x80 | ((c >> 18) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 12) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+5;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n", "method_name": "decodeOctets", "codes": ["Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character.\nprivate static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\tint c = bb.get();\n\tif(c < 0x80){\n\t\tsb.append((char)c);\n\t\treturn i+1;\n\t}\n\telse if(c < 0x800){\n\t\tsb.append((char)(0xc0 | (c >> 6)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+2;\n\t}\n\telse if(c < 0x10000){\n\t\tsb.append((char)(0xe0 | (c >> 12)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+3;\n\t}\n\telse if(c < 0x200000){\n\t\tsb.append((char)(0xf0 | (c >> 18)));\n\t\tsb.append((char)(0x80 | ((c >> 12) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+4;\n\t}\n\telse{\n\t\tsb.append((char)(0xf8 | (c >> 24)));\n\t\tsb.append((char)(0x80 | ((c >> 18) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 12) & 0x3f)));\n\t\tsb.append((char)(0x80 | ((c >> 6) & 0x3f)));\n\t\tsb.append((char)(0x80 | (c & 0x3f)));\n\t\treturn i+5;\n\t}\n}"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017457", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>();\n\tif(u.getScheme().equals(\"file\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"http\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"https\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"ftp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"gopher\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"imap\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"news\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"pop3\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"rtsp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"sftp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"smb\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"smb2\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new Path", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n", "method_name": "decodePath", "codes": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\tList<PathSegmentImpl> path = new ArrayList<PathSegmentImpl>();\n\tif(u.getScheme().equals(\"file\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"http\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"https\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"ftp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"gopher\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"imap\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"news\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"pop3\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"rtsp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"sftp\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"smb\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t}else if(u.getScheme().equals(\"smb2\")){\n\t\tpath.add(new PathSegmentImpl(u.getScheme(),u.getPath()));\n\t\tpath.add(new Path"], "code_level": "slib_runnable", "_id": "6367667f1a6d9265ec01745d", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public final MatchResult match(CharSequence uri){\n    return match(uri, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Match a URI against the pattern.\n * @param uri the uri to match against the template.\n * @return the match result, otherwise null if no match occurs.\n */\n", "method_name": "match", "codes": ["public final MatchResult match(CharSequence uri){\n    return match(uri, null);\n}"], "code_level": "project_runnable", "_id": "636766861a6d9265ec01755a", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\treturn this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Ascertain if a template variable is a member of this template.\n * @param name name The template variable.\n * @return true if the template variable is a member of the template, otherwisefalse.\n */\n", "method_name": "isTemplateVariablePresent", "codes": ["public final boolean isTemplateVariablePresent(String name){\n\treturn this.templateVariables.containsKey(name);\n}"], "code_level": "class_runnable", "_id": "636766861a6d9265ec017553", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String encodeTemplateNames(String s){\n\tStringBuffer sb = new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters names\n * @return the string with encoded template parameters names.\n */\n", "method_name": "encodeTemplateNames", "codes": ["public static String encodeTemplateNames(String s){\n\tStringBuffer sb = new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tchar c = s.charAt(i);\n\t\tif(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '{'){\n\t\t\tsb.append(\"{\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}else if(c == '}'){\n\t\t\tsb.append(\"}\");\n\t\t}"], "code_level": "self_contained", "_id": "636766801a6d9265ec017487", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    for (int i = 0; i < cpV.size(); i++) {\n        URL url = cpV.elementAt(i);\n        File f = new File(url.getFile());\n        if (f.isDirectory()) {\n            addToClassPath(cpV,f.getAbsolutePath());\n        } else {\n            File jarFile = new File(f.getAbsolutePath()+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n", "method_name": "addToClassPath", "codes": ["Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.\n@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    for (int i = 0; i < cpV.size(); i++) {\n        URL url = cpV.elementAt(i);\n        File f = new File(url.getFile());\n        if (f.isDirectory()) {\n            addToClassPath(cpV,f.getAbsolutePath());\n        } else {\n            File jarFile = new File(f.getAbsolutePath()+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META-INF\"+File.separator+\"classes\"+File.separator+\"jar\"+File.separator+\"META"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec01745c", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String capitalize(String name){\n\tString[] parts = name.split(\" \");\n\tString[] result = new String[parts.length];\n\tfor(int i = 0; i < parts.length; i++){\n\t\tresult[i] = parts[i].charAt(0).toUpperCase();\n\t}\n\treturn result[0];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reverse of Introspector.decapitalize\n */\n", "method_name": "capitalize", "codes": ["public static String capitalize(String name){\n\tString[] parts = name.split(\" \");\n\tString[] result = new String[parts.length];\n\tfor(int i = 0; i < parts.length; i++){\n\t\tresult[i] = parts[i].charAt(0).toUpperCase();\n\t}\n\treturn result[0];\n}"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174bf", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String unescapeJava(String str) throws Exception {\n    return unescapeJava(str, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n", "method_name": "unescapeJava", "codes": ["public static String unescapeJava(String str) throws Exception {\n    return unescapeJava(str, false);\n}"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec017401", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\tif(c >= '0' && c <= '9'){\n\t\treturn c - '0';\n\t}\n\tif(c >= 'a' && c <= 'f'){\n\t\treturn c - 'a' + 10;\n\t}\n\tif(c >= 'A' && c <= 'F'){\n\t\treturn c - 'A' + 10;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.\n * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.\n */\n", "method_name": "decodeHexNibble", "codes": ["Convert a hexadecimal number to binary and return its character type.\nprivate static char decodeHexNibble(final char c){\n\tif(c >= '0' && c <= '9'){\n\t\treturn c - '0';\n\t}\n\tif(c >= 'a' && c <= 'f'){\n\t\treturn c - 'a' + 10;\n\t}\n\tif(c >= 'A' && c <= 'F'){\n\t\treturn c - 'A' + 10;\n\t}\n\treturn -1;\n}"], "code_level": "slib_runnable", "_id": "636766851a6d9265ec01751b", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\tTypeVariable typeVariable = (TypeVariable) genericType;\n\t\tType[] typeArguments = typeVariable.getBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArrayType = (GenericArrayType) genericType;\n\t\tType componentType = genericArrayType.getGenericComponentType();\n\t\tClass<?> componentClass = resolveArgument(componentType,targetType);\n\t\treturn new Class<?>[1];\n\t}\n\telse if(genericType instanceof Class){\n\t\tClass<?> classType = (Class<?>) genericType;\n\t\treturn new Class<?>[]{classType};\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof WildcardType){\n\t\tWildcardType wildcardType = (WildcardType) genericType;\n\t\tType[] typeArguments = wildcardType.getUpperBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\tTypeVariable typeVariable = (TypeVariable) genericType;\n\t\tType[] typeArguments = typeVariable.getBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArrayType = (GenericArrayType) genericType;\n\t\tType componentType = genericArrayType.getGenericComponentType();\n\t\tClass<?> componentClass = resolveArgument(componentType,targetType);\n\t\treturn new Class<?>[1];\n\t}\n\telse if(genericType instanceof Class){\n\t\tClass<?> classType = (Class<?>) genericType;\n\t\treturn new Class<?>[]{classType};\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterized", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n", "method_name": "resolveArguments", "codes": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\tTypeVariable typeVariable = (TypeVariable) genericType;\n\t\tType[] typeArguments = typeVariable.getBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArrayType = (GenericArrayType) genericType;\n\t\tType componentType = genericArrayType.getGenericComponentType();\n\t\tClass<?> componentClass = resolveArgument(componentType,targetType);\n\t\treturn new Class<?>[1];\n\t}\n\telse if(genericType instanceof Class){\n\t\tClass<?> classType = (Class<?>) genericType;\n\t\treturn new Class<?>[]{classType};\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof WildcardType){\n\t\tWildcardType wildcardType = (WildcardType) genericType;\n\t\tType[] typeArguments = wildcardType.getUpperBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof TypeVariable){\n\t\tTypeVariable typeVariable = (TypeVariable) genericType;\n\t\tType[] typeArguments = typeVariable.getBounds();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\tClass<?>[] classes = new Class<?>[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tclasses[i] = resolveArgument(typeArguments[i],targetType);\n\t\t}\n\t\treturn classes;\n\t}\n\telse if(genericType instanceof GenericArrayType){\n\t\tGenericArrayType genericArrayType = (GenericArrayType) genericType;\n\t\tType componentType = genericArrayType.getGenericComponentType();\n\t\tClass<?> componentClass = resolveArgument(componentType,targetType);\n\t\treturn new Class<?>[1];\n\t}\n\telse if(genericType instanceof Class){\n\t\tClass<?> classType = (Class<?>) genericType;\n\t\treturn new Class<?>[]{classType};\n\t}\n\telse if(genericType instanceof ParameterizedType){\n\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\tType[] typeArguments = parameterized"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174b6", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.getBounds().length==0){\n\t\treturn Unknown.class;\n\t}\n\tType firstBound = typeVariable.getBounds()[0];\n\tif(firstBound.getTypeArguments().length==0){\n\t\treturn firstBound;\n\t}\n\tType firstBoundTypeArgument = firstBound.getTypeArguments()[0];\n\tif(firstBoundTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgument;\n\t}\n\tType firstBoundTypeArgumentTypeArgument = firstBoundTypeArgument.getTypeArguments()[0];\n\tif(firstBoundTypeArgumentTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgumentTypeArgument;\n\t}\n\tType firstBoundTypeArgumentTypeArgumentTypeArgument = firstBoundTypeArgumentTypeArgument.getTypeArguments()[0];\n\tif(firstBoundTypeArgumentTypeArgumentTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgumentTypeArgumentTypeArgument;\n\t}\n\treturn firstBound;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.\n */\n", "method_name": "resolveBound", "codes": ["public static Type resolveBound(TypeVariable<?> typeVariable){\n\tif(typeVariable.getBounds().length==0){\n\t\treturn Unknown.class;\n\t}\n\tType firstBound = typeVariable.getBounds()[0];\n\tif(firstBound.getTypeArguments().length==0){\n\t\treturn firstBound;\n\t}\n\tType firstBoundTypeArgument = firstBound.getTypeArguments()[0];\n\tif(firstBoundTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgument;\n\t}\n\tType firstBoundTypeArgumentTypeArgument = firstBoundTypeArgument.getTypeArguments()[0];\n\tif(firstBoundTypeArgumentTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgumentTypeArgument;\n\t}\n\tType firstBoundTypeArgumentTypeArgumentTypeArgument = firstBoundTypeArgumentTypeArgument.getTypeArguments()[0];\n\tif(firstBoundTypeArgumentTypeArgumentTypeArgument.getTypeArguments().length==0){\n\t\treturn firstBoundTypeArgumentTypeArgumentTypeArgument;\n\t}\n\treturn firstBound;\n}"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec01741d", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\tAtmosphereRequestBuilder builder = new AtmosphereRequestBuilder();\n\tbuilder.setRequest(request);\n\treturn builder.build();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n", "method_name": "wrap", "codes": ["public static AtmosphereRequest wrap(HttpServletRequest request){\n\tAtmosphereRequestBuilder builder = new AtmosphereRequestBuilder();\n\tbuilder.setRequest(request);\n\treturn builder.build();\n}"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174d2", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public void removeAtmosphereHandler(String mapping){\n\tatmosphereHandlers.remove(mapping);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Remove an  {@link AtmosphereHandler}.\n * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String,AtmosphereHandler)};\n * @return true if removed\n */\n", "method_name": "removeAtmosphereHandler", "codes": ["public void removeAtmosphereHandler(String mapping){\n\tatmosphereHandlers.remove(mapping);\n}"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017458", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif (msg instanceof BroadcastAction){\n\t\treturn null;\n\t}else{\n\t\treturn msg;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n", "method_name": "filter", "codes": ["Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. \nprotected Object filter(Object msg){\n\tif (msg instanceof BroadcastAction){\n\t\treturn null;\n\t}else{\n\t\treturn msg;\n\t}\n}"], "code_level": "project_runnable", "_id": "636766821a6d9265ec0174b3", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor(AtmosphereInterceptor interceptor : interceptorList){\n\t\tif(interceptor.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n", "method_name": "checkDuplicate", "codes": ["Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.\nprivate boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\tfor(AtmosphereInterceptor interceptor : interceptorList){\n\t\tif(interceptor.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "636766811a6d9265ec017499", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public boolean hasBytes(){\n\treturn (dataBytes!=null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * True is the body is a byte array\n * @return True is the body is a byte array\n */\n", "method_name": "hasBytes", "codes": ["public boolean hasBytes(){\n\treturn (dataBytes!=null);\n}"], "code_level": "class_runnable", "_id": "6367667c1a6d9265ec0173f7", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\treturn new Meteor(r);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n", "method_name": "lookup", "codes": ["public static Meteor lookup(HttpServletRequest r){\n\treturn new Meteor(r);\n}"], "code_level": "class_runnable", "_id": "6367667d1a6d9265ec0173ff", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn this.addEventListener(e, true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a  {@link AtmosphereResourceEventListener}.\n * @param e an instance of AtmosphereResourceEventListener\n */\n", "method_name": "addEventListener", "codes": ["public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\treturn this.addEventListener(e, true);\n}"], "code_level": "project_runnable", "_id": "6367667c1a6d9265ec0173fb", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public InputStream next() throws IOException {\n\tif (stack.size() > 0) {\n\t\treturn stack.get(stack.size() - 1);\n\t} else {\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the next  {@link java.io.File} object or {@code null} if no more files areavailable.\n */\n", "method_name": "next", "codes": ["public InputStream next() throws IOException {\n\tif (stack.size() > 0) {\n\t\treturn stack.get(stack.size() - 1);\n\t} else {\n\t\treturn null;\n\t}\n}"], "code_level": "class_runnable", "_id": "636766811a6d9265ec017496", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n    File[] files = new File(\".\").listFiles();\n    ArrayList<String> list = new ArrayList<String>();\n    for(File f : files){\n        list.add(f.getName());\n    }\n    return list.toArray(new File[list.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the class path of the current JVM instance as an array of  {@link File} objects.\n */\n", "method_name": "classPath", "codes": ["Creates an array of the file type based on all file names in java.class.path and returns the array.\nprivate static File[] classPath(){\n    File[] files = new File(\".\").listFiles();\n    ArrayList<String> list = new ArrayList<String>();\n    for(File f : files){\n        list.add(f.getName());\n    }\n    return list.toArray(new File[list.size()]);\n}"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174c9", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public void readFrom(final InputStream in) throws IOException {\n    // Read the first byte.\n    final byte b = in.read();\n    // If the byte is a '\\n' or '\\r' then read the next byte.\n    if (b == '\\n' || b == '\\r') {\n      // Read the next byte.\n      final byte c = in.read();\n      // If the byte is a '\\n' or '\\r' then read the next byte.\n      if (c == '\\n' || c == '\\r') {\n        // Read the next byte.\n        final byte d = in.read();\n        // If the byte is a '\\n' or '\\r' then read the next byte.\n        if (d == '\\n' || d == '\\r') {\n          // Read the next byte.\n          final byte e = in.read();\n          // If the byte is a '\\n' or '\\r' then read the next byte.\n          if (e == '\\n' || e == '\\r') {\n            // Read the next byte.\n            final byte f = in.read();\n            // If the byte is a '\\n' or '\\r' then read the next byte.\n            if (f == '\\n' || f == '\\r') {\n              // Read the next byte.\n              final byte g = in.read();\n              // If the byte is a '\\n' or '\\r' then read the next byte.\n              if (g == '\\n' || g == '\\r') {\n                // Read the next byte.\n                final byte h = in.read();\n                // If the byte is a '\\n' or '\\r' then read the next byte.\n                if (h == '\\n' || h == '\\r') {\n                  // Read the next byte.\n                  final byte i = in.read();\n                  // If the byte is a '\\n' or '\\r' then read the next byte.\n                  if (i == '\\n' || i == '\\r') {\n                    // Read the next byte.\n                    final byte j = in.read();\n                    // If the byte is a '\\n' or '\\r' then read the next byte.\n                    if (j == '\\n' || j == '\\r') {\n                      // Read the next byte.\n                      final byte k = in.read();\n                      // If the byte is a '\\n' or '\\r' then read the next byte.\n                      if (k == '\\n' || k == '\\r') {\n                        // Read the next byte.\n                        final byte l = in.read();\n                        // If the byte is a '\\n' or '\\r' then read the next byte.\n                        if (l == '\\n' || l == '\\r') {\n                          // Read the next byte.\n                          final byte m = in.read();\n                          // If the byte is a '\\n' or '\\r' then read the next byte.\n                          if (m == '\\n' || m == '\\r') {\n                            // Read the next byte.\n                            final byte n = in.read();\n                            // If the byte is a '\\n' or '\\r' then read the next byte.\n                            if (n == '\\n' || n == '\\r') {\n                              // Read the next byte.\n                              final byte o = in.read();\n                              // If the byte is a '\\n' or '\\r' then read the next byte.\n                              if (o == '\\n' || o == '\\r') {\n                                // Read the next byte.\n                                final byte p = in.read();\n                                // If the byte is a '\\n' or '\\r' then read the next byte.\n                                if (p == '\\n' || p == '\\r') {\n                                  // Read the next byte.\n                                  final byte q = in.read();\n                                  // If the byte is a '\\n' or '\\r' then read the next byte.\n                                  if (q == '\\n' || q == '\\r') {\n                                    // Read the next byte.\n                                    final byte r = in.read();\n                                    // If the byte is a '\\n' or '\\r' then read the next byte.\n                                    if", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n", "method_name": "readFrom", "codes": ["public void readFrom(final InputStream in) throws IOException {\n    // Read the first byte.\n    final byte b = in.read();\n    // If the byte is a '\\n' or '\\r' then read the next byte.\n    if (b == '\\n' || b == '\\r') {\n      // Read the next byte.\n      final byte c = in.read();\n      // If the byte is a '\\n' or '\\r' then read the next byte.\n      if (c == '\\n' || c == '\\r') {\n        // Read the next byte.\n        final byte d = in.read();\n        // If the byte is a '\\n' or '\\r' then read the next byte.\n        if (d == '\\n' || d == '\\r') {\n          // Read the next byte.\n          final byte e = in.read();\n          // If the byte is a '\\n' or '\\r' then read the next byte.\n          if (e == '\\n' || e == '\\r') {\n            // Read the next byte.\n            final byte f = in.read();\n            // If the byte is a '\\n' or '\\r' then read the next byte.\n            if (f == '\\n' || f == '\\r') {\n              // Read the next byte.\n              final byte g = in.read();\n              // If the byte is a '\\n' or '\\r' then read the next byte.\n              if (g == '\\n' || g == '\\r') {\n                // Read the next byte.\n                final byte h = in.read();\n                // If the byte is a '\\n' or '\\r' then read the next byte.\n                if (h == '\\n' || h == '\\r') {\n                  // Read the next byte.\n                  final byte i = in.read();\n                  // If the byte is a '\\n' or '\\r' then read the next byte.\n                  if (i == '\\n' || i == '\\r') {\n                    // Read the next byte.\n                    final byte j = in.read();\n                    // If the byte is a '\\n' or '\\r' then read the next byte.\n                    if (j == '\\n' || j == '\\r') {\n                      // Read the next byte.\n                      final byte k = in.read();\n                      // If the byte is a '\\n' or '\\r' then read the next byte.\n                      if (k == '\\n' || k == '\\r') {\n                        // Read the next byte.\n                        final byte l = in.read();\n                        // If the byte is a '\\n' or '\\r' then read the next byte.\n                        if (l == '\\n' || l == '\\r') {\n                          // Read the next byte.\n                          final byte m = in.read();\n                          // If the byte is a '\\n' or '\\r' then read the next byte.\n                          if (m == '\\n' || m == '\\r') {\n                            // Read the next byte.\n                            final byte n = in.read();\n                            // If the byte is a '\\n' or '\\r' then read the next byte.\n                            if (n == '\\n' || n == '\\r') {\n                              // Read the next byte.\n                              final byte o = in.read();\n                              // If the byte is a '\\n' or '\\r' then read the next byte.\n                              if (o == '\\n' || o == '\\r') {\n                                // Read the next byte.\n                                final byte p = in.read();\n                                // If the byte is a '\\n' or '\\r' then read the next byte.\n                                if (p == '\\n' || p == '\\r') {\n                                  // Read the next byte.\n                                  final byte q = in.read();\n                                  // If the byte is a '\\n' or '\\r' then read the next byte.\n                                  if (q == '\\n' || q == '\\r') {\n                                    // Read the next byte.\n                                    final byte r = in.read();\n                                    // If the byte is a '\\n' or '\\r' then read the next byte.\n                                    if"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017482", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    for (int i = files.length - 1; i >= 0; i--) {\n        final InputStream file = files[i];\n        try {\n            final File fileToAdd = new File(file.getPath());\n            if (fileToAdd.exists()){\n                fileToAdd.delete();\n            }\n            fileToAdd.createNewFile();\n            final FileOutputStream fos = new FileOutputStream(fileToAdd);\n            final byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = file.read(buffer))!= -1) {\n                fos.write(buffer, 0, read);\n            }\n            fos.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["Add files in the stack in reverse order.\nprivate void addReverse(final InputStream[] files){\n    for (int i = files.length - 1; i >= 0; i--) {\n        final InputStream file = files[i];\n        try {\n            final File fileToAdd = new File(file.getPath());\n            if (fileToAdd.exists()){\n                fileToAdd.delete();\n            }\n            fileToAdd.createNewFile();\n            final FileOutputStream fos = new FileOutputStream(fileToAdd);\n            final byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = file.read(buffer))!= -1) {\n                fos.write(buffer, 0, read);\n            }\n            fos.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017477", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n    for(int i = files.length - 1; i >= 0; i--){\n        files[i] = files[files.length - 1];\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["Put the given array of files into a stack in reverse order. \nprivate void addReverse(final File[] files){\n    for(int i = files.length - 1; i >= 0; i--){\n        files[i] = files[files.length - 1];\n    }\n}"], "code_level": "class_runnable", "_id": "636766831a6d9265ec0174eb", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * The last time, in milliseconds, a write operation occurred.\n * @return this\n */\n", "method_name": "lastWriteTimeStampInMilliseconds", "codes": ["public long lastWriteTimeStampInMilliseconds(){\n\treturn lastWriteTimeStamp;\n}"], "code_level": "class_runnable", "_id": "6367667e1a6d9265ec01743a", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public Action inspect(AtmosphereResource r){\n    if(r.getTransport() == null) return Action.NONE;\n    return Action.inspect(r.getTransport());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n", "method_name": "inspect", "codes": ["public Action inspect(AtmosphereResource r){\n    if(r.getTransport() == null) return Action.NONE;\n    return Action.inspect(r.getTransport());\n}"], "code_level": "project_runnable", "_id": "636766851a6d9265ec017515", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String[] trimArrayElements(String[] array){\n\tString[] result = new String[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "method_name": "trimArrayElements", "codes": ["public static String[] trimArrayElements(String[] array){\n\tString[] result = new String[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i] = array[i].trim();\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "6367676d1a6d9265ec018229", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static int nullSafeHashCode(long[] array){\n\tint hash = 0;\n\tfor(int i = 0; i < array.length; i++){\n\t\thash = hash * MULTIPLIER + array[i];\n\t}\n\treturn hash;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n", "method_name": "nullSafeHashCode", "codes": ["public static int nullSafeHashCode(long[] array){\n\tint hash = 0;\n\tfor(int i = 0; i < array.length; i++){\n\t\thash = hash * MULTIPLIER + array[i];\n\t}\n\treturn hash;\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181aa", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str==null || prefix==null) return false;\n\tif(str.length()<prefix.length()) return false;\n\treturn str.substring(0,prefix.length()).toLowerCase().startsWith(prefix.toLowerCase());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n", "method_name": "startsWithIgnoreCase", "codes": ["public static boolean startsWithIgnoreCase(String str,String prefix){\n\tif(str==null || prefix==null) return false;\n\tif(str.length()<prefix.length()) return false;\n\treturn str.substring(0,prefix.length()).toLowerCase().startsWith(prefix.toLowerCase());\n}"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181df", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\tIterator it = source.iterator();\n\tObject first = null;\n\twhile(it.hasNext()){\n\t\tObject o = it.next();\n\t\tif(o instanceof Object[]){\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor(int i = 0; i < oa.length; i++){\n\t\t\t\tif(oa[i] instanceof Object[]){\n\t\t\t\t\tObject[] oa2 = (Object[]) oa[i];\n\t\t\t\t\tif(oa2.length == 1){\n\t\t\t\t\t\tif(oa2[0] instanceof Object[]){\n\t\t\t\t\t\t\tObject[] oa3 = (Object[]) oa2[0];\n\t\t\t\t\t\t\tif(oa3.length == 1){\n\t\t\t\t\t\t\t\tif(oa3[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\tObject[] oa4 = (Object[]) oa3[0];\n\t\t\t\t\t\t\t\t\tif(oa4.length == 1){\n\t\t\t\t\t\t\t\t\t\tif(oa4[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\tObject[] oa5 = (Object[]) oa4[0];\n\t\t\t\t\t\t\t\t\t\t\tif(oa5.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\tif(oa5[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa6 = (Object[]) oa5[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa6.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa6[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa7 = (Object[]) oa6[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa7.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa7[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa8 = (Object[]) oa7[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa8.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa8[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa9 = (Object[]) oa8[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa9.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa9[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa10 = (Object[]) oa9[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa10.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa10[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa11 = (Object[]) oa10[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa11.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa11[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa12 = (Object[]) oa11[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa12.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa12[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa13 = (Object[]) oa12[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa13.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa13[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa14 = (Object[]) oa13[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa14.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa14[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa15 = (Object[]) oa14[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa15.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa15[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa16 = (Object[]) oa15[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa16.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa16[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa17 = (Object[]) oa16[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa17.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa17[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa18 = (Object[]) oa17[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa18.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa18[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa19 = (Object[]) oa18[", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "method_name": "findFirstMatch", "codes": ["public static Object findFirstMatch(Collection source,Collection candidates){\n\tIterator it = source.iterator();\n\tObject first = null;\n\twhile(it.hasNext()){\n\t\tObject o = it.next();\n\t\tif(o instanceof Object[]){\n\t\t\tObject[] oa = (Object[]) o;\n\t\t\tfor(int i = 0; i < oa.length; i++){\n\t\t\t\tif(oa[i] instanceof Object[]){\n\t\t\t\t\tObject[] oa2 = (Object[]) oa[i];\n\t\t\t\t\tif(oa2.length == 1){\n\t\t\t\t\t\tif(oa2[0] instanceof Object[]){\n\t\t\t\t\t\t\tObject[] oa3 = (Object[]) oa2[0];\n\t\t\t\t\t\t\tif(oa3.length == 1){\n\t\t\t\t\t\t\t\tif(oa3[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\tObject[] oa4 = (Object[]) oa3[0];\n\t\t\t\t\t\t\t\t\tif(oa4.length == 1){\n\t\t\t\t\t\t\t\t\t\tif(oa4[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\tObject[] oa5 = (Object[]) oa4[0];\n\t\t\t\t\t\t\t\t\t\t\tif(oa5.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\tif(oa5[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa6 = (Object[]) oa5[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa6.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa6[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa7 = (Object[]) oa6[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa7.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa7[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa8 = (Object[]) oa7[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa8.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa8[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa9 = (Object[]) oa8[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa9.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa9[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa10 = (Object[]) oa9[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa10.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa10[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa11 = (Object[]) oa10[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa11.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa11[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa12 = (Object[]) oa11[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa12.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa12[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa13 = (Object[]) oa12[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa13.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa13[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa14 = (Object[]) oa13[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa14.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa14[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa15 = (Object[]) oa14[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa15.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa15[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa16 = (Object[]) oa15[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa16.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa16[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa17 = (Object[]) oa16[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa17.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa17[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa18 = (Object[]) oa17[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa18.length == 1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(oa18[0] instanceof Object[]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject[] oa19 = (Object[]) oa18["], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181e2", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimTrailingWhitespace(String str){\n\tif(str.length() == 0){\n\t\treturn str;\n\t}\n\t\n\tint len = str.length();\n\t\n\tif(len > 0 && str.charAt(len-1) ==''){\n\t\treturn str.substring(0, len-1);\n\t}\n\t\n\treturn str;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimTrailingWhitespace", "codes": ["public static String trimTrailingWhitespace(String str){\n\tif(str.length() == 0){\n\t\treturn str;\n\t}\n\t\n\tint len = str.length();\n\t\n\tif(len > 0 && str.charAt(len-1) ==''){\n\t\treturn str.substring(0, len-1);\n\t}\n\t\n\treturn str;\n}"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181ee", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static Object quoteIfString(Object obj){\n\tif(obj instanceof String){\n\t\treturn obj;\n\t}\n\treturn quoteIf(obj);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n", "method_name": "quoteIfString", "codes": ["public static Object quoteIfString(Object obj){\n\tif(obj instanceof String){\n\t\treturn obj;\n\t}\n\treturn quoteIf(obj);\n}"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181bf", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimLeadingWhitespace(String str){\n\tif(str==null){\n\t\treturn null;\n\t}\n\tint len = str.length();\n\tif(len==0){\n\t\treturn null;\n\t}\n\tchar ch = str.charAt(0);\n\tif(ch==' '){\n\t\treturn str.substring(1);\n\t}\n\treturn str;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimLeadingWhitespace", "codes": ["public static String trimLeadingWhitespace(String str){\n\tif(str==null){\n\t\treturn null;\n\t}\n\tint len = str.length();\n\tif(len==0){\n\t\treturn null;\n\t}\n\tchar ch = str.charAt(0);\n\tif(ch==' '){\n\t\treturn str.substring(1);\n\t}\n\treturn str;\n}"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181cd", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[enumeration.size()];\n\tString string;\n\twhile(enumeration.hasMoreElements()){\n\t\tstring = enumeration.nextElement();\n\t\tstringArray[stringArray.length-1] = string;\n\t}\n\treturn stringArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n * @param enumeration the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-inEnumeration was <code>null</code>)\n */\n", "method_name": "toStringArray", "codes": ["public static String[] toStringArray(Enumeration<String> enumeration){\n\tString[] stringArray = new String[enumeration.size()];\n\tString string;\n\twhile(enumeration.hasMoreElements()){\n\t\tstring = enumeration.nextElement();\n\t\tstringArray[stringArray.length-1] = string;\n\t}\n\treturn stringArray;\n}"], "code_level": "slib_runnable", "_id": "636767691a6d9265ec0181ae", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\tString modifiedString = \"\";\n\tfor(int i=0;i<inString.length();i++){\n\t\tif(charsToDelete.charAt(i)==inString.charAt(i)){\n\t\t\tmodifiedString = modifiedString.concat(inString.charAt(i));\n\t\t}\n\t}\n\treturn modifiedString;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "method_name": "deleteAny", "codes": ["public static String deleteAny(String inString,String charsToDelete){\n\tString modifiedString = \"\";\n\tfor(int i=0;i<inString.length();i++){\n\t\tif(charsToDelete.charAt(i)==inString.charAt(i)){\n\t\t\tmodifiedString = modifiedString.concat(inString.charAt(i));\n\t\t}\n\t}\n\treturn modifiedString;\n}"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec01820b", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null) return false;\n\tif(collection.contains(element)) return true;\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n * @param collection the Collection to check\n * @param element the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "method_name": "containsInstance", "codes": ["public static boolean containsInstance(Collection collection,Object element){\n\tif(collection==null) return false;\n\tif(collection.contains(element)) return true;\n\treturn false;\n}"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018223", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length + array2.length];\n\tint i = 0;\n\tfor(int j = 0; j < array1.length; j++){\n\t\tresult[i] = array1[j];\n\t\ti++;\n\t}\n\tfor(int j = 0; j < array2.length; j++){\n\t\tresult[i] = array2[j];\n\t\ti++;\n\t}\n\treturn result[0];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "method_name": "concatenateStringArrays", "codes": ["public static String concatenateStringArrays(String[] array1,String[] array2){\n\tString[] result = new String[array1.length + array2.length];\n\tint i = 0;\n\tfor(int j = 0; j < array1.length; j++){\n\t\tresult[i] = array1[j];\n\t\ti++;\n\t}\n\tfor(int j = 0; j < array2.length; j++){\n\t\tresult[i] = array2[j];\n\t\ti++;\n\t}\n\treturn result[0];\n}"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018204", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\tif(array == null || array.length == 0){\n\t\treturn new String[]{\"\"};\n\t}\n\tString[] newArray = new String[array.length + 1];\n\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\tnewArray[array.length] = str;\n\treturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n", "method_name": "addStringToArray", "codes": ["public static String[] addStringToArray(String[] array,String str){\n\tif(array == null || array.length == 0){\n\t\treturn new String[]{\"\"};\n\t}\n\tString[] newArray = new String[array.length + 1];\n\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\tnewArray[array.length] = str;\n\treturn newArray;\n}"], "code_level": "slib_runnable", "_id": "6367676a1a6d9265ec0181d4", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\tint count=0;\n\tint i=0;\n\twhile(i<str.length()){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\tcount++;\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.\n * @param str string to search in. Return 0 if this is null.\n * @param sub string to search for. Return 0 if this is null.\n * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n */\n", "method_name": "countOccurrencesOf", "codes": ["public static int countOccurrencesOf(String str,String sub){\n\tint count=0;\n\tint i=0;\n\twhile(i<str.length()){\n\t\tif(str.charAt(i)==sub.charAt(0)){\n\t\t\tcount++;\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181dd", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String stripFilenameExtension(String path){\n\tint lastIndex = path.lastIndexOf('.');\n\tif(lastIndex == -1){\n\t\treturn path;\n\t}\n\treturn path.substring(0, lastIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n * @param path the file path (may be <code>null</code>)\n * @return the path with stripped filename extension,or <code>null</code> if none\n */\n", "method_name": "stripFilenameExtension", "codes": ["public static String stripFilenameExtension(String path){\n\tint lastIndex = path.lastIndexOf('.');\n\tif(lastIndex == -1){\n\t\treturn path;\n\t}\n\treturn path.substring(0, lastIndex);\n}"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec018220", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString result = \"\";\n\tif(str.length() > 0){\n\t\tresult = str.substring(0,str.length()-1);\n\t\tresult = result.trim();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n", "method_name": "trimLeadingCharacter", "codes": ["public static String trimLeadingCharacter(String str,char leadingCharacter){\n\tString result = \"\";\n\tif(str.length() > 0){\n\t\tresult = str.substring(0,str.length()-1);\n\t\tresult = result.trim();\n\t}\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a7", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] split(String toSplit,String delimiter){\n\tString[] split = new String[2];\n\tint index = 0;\n\tint index2 = 0;\n\tint index3 = 0;\n\tint index4 = 0;\n\tint index5 = 0;\n\tint index6 = 0;\n\tint index7 = 0;\n\tint index8 = 0;\n\tint index9 = 0;\n\tint index10 = 0;\n\tint index11 = 0;\n\tint index12 = 0;\n\tint index13 = 0;\n\tint index14 = 0;\n\tint index15 = 0;\n\tint index16 = 0;\n\tint index17 = 0;\n\tint index18 = 0;\n\tint index19 = 0;\n\tint index20 = 0;\n\tint index21 = 0;\n\tint index22 = 0;\n\tint index23 = 0;\n\tint index24 = 0;\n\tint index25 = 0;\n\tint index26 = 0;\n\tint index27 = 0;\n\tint index28 = 0;\n\tint index29 = 0;\n\tint index30 = 0;\n\tint index31 = 0;\n\tint index32 = 0;\n\tint index33 = 0;\n\tint index34 = 0;\n\tint index35 = 0;\n\tint index36 = 0;\n\tint index37 = 0;\n\tint index38 = 0;\n\tint index39 = 0;\n\tint index40 = 0;\n\tint index41 = 0;\n\tint index42 = 0;\n\tint index43 = 0;\n\tint index44 = 0;\n\tint index45 = 0;\n\tint index46 = 0;\n\tint index47 = 0;\n\tint index48 = 0;\n\tint index49 = 0;\n\tint index50 = 0;\n\tint index51 = 0;\n\tint index52 = 0;\n\tint index53 = 0;\n\tint index54 = 0;\n\tint index55 = 0;\n\tint index56 = 0;\n\tint index57 = 0;\n\tint index58 = 0;\n\tint index59 = 0;\n\tint index60 = 0;\n\tint index61 = 0;\n\tint index62 = 0;\n\tint index63 = 0;\n\tint index64 = 0;\n\tint index65 = 0;\n\tint index66 = 0;\n\tint index67 = 0;\n\tint index68 = 0;\n\tint index69 = 0;\n\tint index70 = 0;\n\tint index71 = 0;\n\tint index72 = 0;\n\tint index73 = 0;\n\tint index74 = 0;\n\tint index75 = 0;\n\tint index76 = 0;\n\tint index77 = 0;\n\tint index78 = 0;\n\tint index79 = 0;\n\tint index80 = 0;\n\tint index81 = 0;\n\tint index82 = 0;\n\tint index83 = 0;\n\tint index84 = 0;\n\tint index85 = 0;\n\tint index86 = 0;\n\tint index87 = 0;\n\tint index88 = 0;\n\tint index89 = 0;\n\tint index90 = 0;\n\tint index91 = 0;\n\tint index92 = 0;\n\tint index93 = 0;\n\tint index94 = 0;\n\tint index95 = 0;\n\tint index96 = 0;\n\tint index97 = 0;\n\tint index98 = 0;\n\tint index99 = 0;\n\tint index100 = 0;\n\tint index101 = 0;\n\tint index102 = 0;\n\tint index103 = 0;\n\tint index104 = 0;\n\tint index105 = 0;\n\tint index106 = 0;\n\tint index107 = 0;\n\tint index108 = 0;\n\tint index109 = 0;\n\tint index110 = 0;\n\tint index111 = 0;\n\tint index112 = 0;\n\tint index113 = 0;\n\tint index114 = 0;\n\tint index115 = 0;\n\tint index116 = 0;\n\tint index117 = 0;\n\tint index118 = 0;\n\tint index119 = 0;\n\tint index120 = 0;\n\tint index121 = 0;\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "method_name": "split", "codes": ["public static String[] split(String toSplit,String delimiter){\n\tString[] split = new String[2];\n\tint index = 0;\n\tint index2 = 0;\n\tint index3 = 0;\n\tint index4 = 0;\n\tint index5 = 0;\n\tint index6 = 0;\n\tint index7 = 0;\n\tint index8 = 0;\n\tint index9 = 0;\n\tint index10 = 0;\n\tint index11 = 0;\n\tint index12 = 0;\n\tint index13 = 0;\n\tint index14 = 0;\n\tint index15 = 0;\n\tint index16 = 0;\n\tint index17 = 0;\n\tint index18 = 0;\n\tint index19 = 0;\n\tint index20 = 0;\n\tint index21 = 0;\n\tint index22 = 0;\n\tint index23 = 0;\n\tint index24 = 0;\n\tint index25 = 0;\n\tint index26 = 0;\n\tint index27 = 0;\n\tint index28 = 0;\n\tint index29 = 0;\n\tint index30 = 0;\n\tint index31 = 0;\n\tint index32 = 0;\n\tint index33 = 0;\n\tint index34 = 0;\n\tint index35 = 0;\n\tint index36 = 0;\n\tint index37 = 0;\n\tint index38 = 0;\n\tint index39 = 0;\n\tint index40 = 0;\n\tint index41 = 0;\n\tint index42 = 0;\n\tint index43 = 0;\n\tint index44 = 0;\n\tint index45 = 0;\n\tint index46 = 0;\n\tint index47 = 0;\n\tint index48 = 0;\n\tint index49 = 0;\n\tint index50 = 0;\n\tint index51 = 0;\n\tint index52 = 0;\n\tint index53 = 0;\n\tint index54 = 0;\n\tint index55 = 0;\n\tint index56 = 0;\n\tint index57 = 0;\n\tint index58 = 0;\n\tint index59 = 0;\n\tint index60 = 0;\n\tint index61 = 0;\n\tint index62 = 0;\n\tint index63 = 0;\n\tint index64 = 0;\n\tint index65 = 0;\n\tint index66 = 0;\n\tint index67 = 0;\n\tint index68 = 0;\n\tint index69 = 0;\n\tint index70 = 0;\n\tint index71 = 0;\n\tint index72 = 0;\n\tint index73 = 0;\n\tint index74 = 0;\n\tint index75 = 0;\n\tint index76 = 0;\n\tint index77 = 0;\n\tint index78 = 0;\n\tint index79 = 0;\n\tint index80 = 0;\n\tint index81 = 0;\n\tint index82 = 0;\n\tint index83 = 0;\n\tint index84 = 0;\n\tint index85 = 0;\n\tint index86 = 0;\n\tint index87 = 0;\n\tint index88 = 0;\n\tint index89 = 0;\n\tint index90 = 0;\n\tint index91 = 0;\n\tint index92 = 0;\n\tint index93 = 0;\n\tint index94 = 0;\n\tint index95 = 0;\n\tint index96 = 0;\n\tint index97 = 0;\n\tint index98 = 0;\n\tint index99 = 0;\n\tint index100 = 0;\n\tint index101 = 0;\n\tint index102 = 0;\n\tint index103 = 0;\n\tint index104 = 0;\n\tint index105 = 0;\n\tint index106 = 0;\n\tint index107 = 0;\n\tint index108 = 0;\n\tint index109 = 0;\n\tint index110 = 0;\n\tint index111 = 0;\n\tint index112 = 0;\n\tint index113 = 0;\n\tint index114 = 0;\n\tint index115 = 0;\n\tint index116 = 0;\n\tint index117 = 0;\n\tint index118 = 0;\n\tint index119 = 0;\n\tint index120 = 0;\n\tint index121 = 0;\n\t"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a6", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\tStringBuilder sb = new StringBuilder();\n\tint i = 0;\n\twhile(i < path.length()){\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_2){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_3){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_4){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_5){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_6){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_7){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_8){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_9){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_10){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_11){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_12){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_13){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_14){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_15){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_16){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_17){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_18){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_19){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_20){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_21){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_22){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n * @param path the path to start from (usually a full file path)\n * @param relativePath the relative path to apply(relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "method_name": "applyRelativePath", "codes": ["public static String applyRelativePath(String path,String relativePath){\n\tStringBuilder sb = new StringBuilder();\n\tint i = 0;\n\twhile(i < path.length()){\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_2){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_3){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_4){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_5){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_6){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_7){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_8){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_9){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_10){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_11){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_12){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_13){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_14){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_15){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_16){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_17){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_18){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_19){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_20){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_21){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_22){\n\t\t\tsb.append(relativePath);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(path.charAt(i) == FOLDER_SEPARATOR_"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181ac", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>=str.length()){\n\t\treturn false;\n\t}\n\tint startIndex=index;\n\tint endIndex=index+substring.length();\n\tif(startIndex>=str.length()){\n\t\treturn false;\n\t}\n\tif(endIndex<0 || endIndex>=str.length()){\n\t\treturn false;\n\t}\n\tint start=str.charAt(startIndex);\n\tint end=str.charAt(endIndex);\n\tif(start==end){\n\t\treturn true;\n\t}\n\treturn substring.toString().indexOf(start)==0 && substring.toString().indexOf(end)==end.length();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n * @param str the original string (or StringBuilder)\n * @param index the index in the original string to start matching against\n * @param substring the substring to match at the given index\n * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n */\n", "method_name": "substringMatch", "codes": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\tif(index<0 || index>=str.length()){\n\t\treturn false;\n\t}\n\tint startIndex=index;\n\tint endIndex=index+substring.length();\n\tif(startIndex>=str.length()){\n\t\treturn false;\n\t}\n\tif(endIndex<0 || endIndex>=str.length()){\n\t\treturn false;\n\t}\n\tint start=str.charAt(startIndex);\n\tint end=str.charAt(endIndex);\n\tif(start==end){\n\t\treturn true;\n\t}\n\treturn substring.toString().indexOf(start)==0 && substring.toString().indexOf(end)==end.length();\n}"], "code_level": "slib_runnable", "_id": "6367676b1a6d9265ec0181e9", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete's the specified file if it exists \n */\n", "method_name": "deleteFile", "codes": ["Delete the given file if it exists\nprotected static void deleteFile(String fileName){\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}"], "code_level": "slib_runnable", "_id": "636767821a6d9265ec0183a0", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String format(LoggingEvent event){\n\tString result = \"\";\n\tString pattern = \"\";\n\tStringBuilder sb = new StringBuilder();\n\t\n\t//get the pattern\n\tpattern = event.getMessage().toString();\n\t\n\t//get the buffered string\n\tString buffered = event.getMessage().toString();\n\t\n\t//get the pattern converter\n\tPatternConverter pc = PatternConverter.getInstance();\n\t\n\t//convert the pattern to a string\n\tString converted = pc.convert(pattern);\n\t\n\t//convert the buffered string to a string\n\tString convertedBuffered = pc.convert(buffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConverted = pc.convert(converted);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered = pc.convert(convertedBuffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n", "method_name": "format", "codes": ["public String format(LoggingEvent event){\n\tString result = \"\";\n\tString pattern = \"\";\n\tStringBuilder sb = new StringBuilder();\n\t\n\t//get the pattern\n\tpattern = event.getMessage().toString();\n\t\n\t//get the buffered string\n\tString buffered = event.getMessage().toString();\n\t\n\t//get the pattern converter\n\tPatternConverter pc = PatternConverter.getInstance();\n\t\n\t//convert the pattern to a string\n\tString converted = pc.convert(pattern);\n\t\n\t//convert the buffered string to a string\n\tString convertedBuffered = pc.convert(buffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConverted = pc.convert(converted);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered = pc.convert(convertedBuffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n\t\n\t//convert the converted string to a string\n\tString convertedConvertedBuffered2 = pc.convert(convertedConvertedBuffered2);\n"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01830f", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    File tempFile = File.createTempFile(\"subAppend\", \".txt\");\n    try {\n        FileWriter writer = new FileWriter(tempFile);\n        writer.write(event.getMessage());\n        writer.close();\n        FileUtils.copyFile(tempFile, new File(event.getFile()));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method does actual writing\n */\n", "method_name": "subAppend", "codes": ["Write the message in the event into a temp file.\nprotected void subAppend(LoggingEvent event){\n    File tempFile = File.createTempFile(\"subAppend\", \".txt\");\n    try {\n        FileWriter writer = new FileWriter(tempFile);\n        writer.write(event.getMessage());\n        writer.close();\n        FileUtils.copyFile(tempFile, new File(event.getFile()));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static String peek(){\n\treturn stack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n", "method_name": "peek", "codes": ["public static String peek(){\n\treturn stack.peek();\n}"], "code_level": "class_runnable", "_id": "636767831a6d9265ec0183c9", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public Logger exists(String name){\n\tLogger logger = null;\n\t\n\tif(loggers.containsKey(name)){\n\t\tlogger = loggers.get(name);\n\t}\n\t\n\treturn logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.\n * @param name The name of the logger to search for.\n */\n", "method_name": "exists", "codes": ["public Logger exists(String name){\n\tLogger logger = null;\n\t\n\tif(loggers.containsKey(name)){\n\t\tlogger = loggers.get(name);\n\t}\n\t\n\treturn logger;\n}"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01832e", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String format(final LoggingEvent event){\n    return String.format(event.getMessage(), event.getLevel().name(), event.getThreadName(), event.getThreadGroupName(), event.getSourceClassName(), event.getSourceMethodName(), event.getMessage());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Formats a logging event to a writer.\n * @param event logging event to be formatted.\n */\n", "method_name": "format", "codes": ["public String format(final LoggingEvent event){\n    return String.format(event.getMessage(), event.getLevel().name(), event.getThreadName(), event.getThreadGroupName(), event.getSourceClassName(), event.getSourceMethodName(), event.getMessage());\n}"], "code_level": "project_runnable", "_id": "6367677b1a6d9265ec0182bd", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\tClass clazz = loader.loadClass(className);\n\treturn clazz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n", "method_name": "findClass", "codes": ["Find class by the given class name.\nprivate Class findClass(final String className) throws ClassNotFoundException {\n\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\tClass clazz = loader.loadClass(className);\n\treturn clazz;\n}"], "code_level": "slib_runnable", "_id": "636767791a6d9265ec018263", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void addMessage(final LogRecord lr){\n\t\n\t// Create a new LogRecord with the same parameters as the current one.\n\tLogRecord newLogRecord = new LogRecord(lr.getLoggerName(), lr.getLevel(), lr.getMessage());\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n", "method_name": "addMessage", "codes": ["public void addMessage(final LogRecord lr){\n\t\n\t// Create a new LogRecord with the same parameters as the current one.\n\tLogRecord newLogRecord = new LogRecord(lr.getLoggerName(), lr.getLevel(), lr.getMessage());\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);\n\t\n\t// Add the new record to the table.\n\ttable.add(newLogRecord);"], "code_level": "project_runnable", "_id": "636767791a6d9265ec018257", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.getViewport().setViewPosition(0,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Selects a the specified row in the specified JTable and scrolls the specified JScrollpane to the newly selected row. More importantly, the call to repaint() delayed long enough to have the table properly paint the newly selected row which may be offscre\n * @param table should belong to the specified JScrollPane\n */\n", "method_name": "selectRow", "codes": ["public static void selectRow(int row,JTable table,JScrollPane pane){\n\ttable.setRowSelectionInterval(row,row);\n\tpane.getViewport().setViewPosition(0,0);\n}"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183ff", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static void createConfigurationDirectory(){\n\tif(!new File(\"/home/johndoe/Documents/Projects/LF5/LF5\").exists()){\n\t\tSystem.out.println(\"Creating the configuration directory in /home/johndoe/Documents/Projects/LF5/LF5\");\n\t\tnew File(\"/home/johndoe/Documents/Projects/LF5/LF5\").mkdir();\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n", "method_name": "createConfigurationDirectory", "codes": ["public static void createConfigurationDirectory(){\n\tif(!new File(\"/home/johndoe/Documents/Projects/LF5/LF5\").exists()){\n\t\tSystem.out.println(\"Creating the configuration directory in /home/johndoe/Documents/Projects/LF5/LF5\");\n\t\tnew File(\"/home/johndoe/Documents/Projects/LF5/LF5\").mkdir();\n\t}\n}"], "code_level": "slib_runnable", "_id": "636767871a6d9265ec01846d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public synchronized void send(final String message){\n\tfor (final Connection c : connections){\n\t\tc.send(message);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n", "method_name": "send", "codes": ["public synchronized void send(final String message){\n\tfor (final Connection c : connections){\n\t\tc.send(message);\n\t}\n}"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec018347", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tif(!event.getLoggerName().equals(this.getLoggerName())){\n\t\treturn;\n\t}\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tsb.append(event.getMessage());\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(event.getLoggerName().equals(this.getLoggerName())){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getLoggerName());\n\t}\n\t\n\tif(event.getLevel().equals(Level.SEVERE)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"SEVERE\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.WARNING)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"WARNING\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.INFO)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"INFO\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.CONFIG)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"CONFIG\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINE)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINE\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINER)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINER\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINEST)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINEST\");\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n", "method_name": "append", "codes": ["Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.\nprotected void append(LoggingEvent event){\n\tif(!event.getLoggerName().equals(this.getLoggerName())){\n\t\treturn;\n\t}\n\t\n\tStringBuilder sb = new StringBuilder();\n\t\n\tsb.append(event.getMessage());\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(event.getLoggerName().equals(this.getLoggerName())){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getLoggerName());\n\t}\n\t\n\tif(event.getLevel().equals(Level.SEVERE)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"SEVERE\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.WARNING)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"WARNING\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.INFO)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"INFO\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.CONFIG)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"CONFIG\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINE)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINE\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINER)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINER\");\n\t}\n\t\n\tif(event.getLevel().equals(Level.FINEST)){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"FINEST\");\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getClass().getName());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\n\");\n\t\tsb.append(event.getThrowableInformation().get(0).getMessage());\n\t}\n\t\n\tif(!event.getThrowableInformation().isEmpty()){\n\t\tsb.append(\"\\"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823e", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void put(LoggingEvent o){\n    buf.put(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n", "method_name": "put", "codes": ["public void put(LoggingEvent o){\n    buf.put(o);\n}"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec01834b", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static String findAndSubst(String key,Properties props){\n\tString result=null;\n\tString value=null;\n\tString[] values=null;\n\tString[] values2=null;\n\tString[] values3=null;\n\tString[] values4=null;\n\tString[] values5=null;\n\tString[] values6=null;\n\tString[] values7=null;\n\tString[] values8=null;\n\tString[] values9=null;\n\tString[] values10=null;\n\tString[] values11=null;\n\tString[] values12=null;\n\tString[] values13=null;\n\tString[] values14=null;\n\tString[] values15=null;\n\tString[] values16=null;\n\tString[] values17=null;\n\tString[] values18=null;\n\tString[] values19=null;\n\tString[] values20=null;\n\tString[] values21=null;\n\tString[] values22=null;\n\tString[] values23=null;\n\tString[] values24=null;\n\tString[] values25=null;\n\tString[] values26=null;\n\tString[] values27=null;\n\tString[] values28=null;\n\tString[] values29=null;\n\tString[] values30=null;\n\tString[] values31=null;\n\tString[] values32=null;\n\tString[] values33=null;\n\tString[] values34=null;\n\tString[] values35=null;\n\tString[] values36=null;\n\tString[] values37=null;\n\tString[] values38=null;\n\tString[] values39=null;\n\tString[] values40=null;\n\tString[] values41=null;\n\tString[] values42=null;\n\tString[] values43=null;\n\tString[] values44=null;\n\tString[] values45=null;\n\tString[] values46=null;\n\tString[] values47=null;\n\tString[] values48=null;\n\tString[] values49=null;\n\tString[] values50=null;\n\tString[] values51=null;\n\tString[] values52=null;\n\tString[] values53=null;\n\tString[] values54=null;\n\tString[] values55=null;\n\tString[] values56=null;\n\tString[] values57=null;\n\tString[] values58=null;\n\tString[] values59=null;\n\tString[] values60=null;\n\tString[] values61=null;\n\tString[] values62=null;\n\tString[] values63=null;\n\tString[] values64=null;\n\tString[] values65=null;\n\tString[] values66=null;\n\tString[] values67=null;\n\tString[] values68=null;\n\tString[] values69=null;\n\tString[] values70=null;\n\tString[] values71=null;\n\tString[] values72=null;\n\tString[] values73=null;\n\tString[] values74=null;\n\tString[] values75=null;\n\tString[] values76=null;\n\tString[] values77=null;\n\tString[] values78=null;\n\tString[] values79=null;\n\tString[] values80=null;\n\tString[] values81=null;\n\tString[] values82=null;\n\tString[] values83=null;\n\tString[] values84=null;\n\tString[] values85=null;\n\tString[] values86=null;\n\tString[] values87=null;\n\tString[] values88=null;\n\tString[] values89=null;\n\tString[] values90=null;\n\tString[] values91=null;\n\tString[] values92=null;\n\tString[] values93=null;\n\tString[] values94=null;\n\tString[] values95=null;\n\tString[] values96=null;\n\tString[] values97=null;\n\tString[] values98=null;\n\tString[] values99=null;\n\tString[] values100=null;\n\tString[] values101=null;\n\tString[] values102=null;\n\tString[] values103=null;\n\tString[] values104=null;\n\tString[] values105=null;\n\tString[] values106=null;\n\tString[] values107=null;", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\n", "method_name": "findAndSubst", "codes": ["public static String findAndSubst(String key,Properties props){\n\tString result=null;\n\tString value=null;\n\tString[] values=null;\n\tString[] values2=null;\n\tString[] values3=null;\n\tString[] values4=null;\n\tString[] values5=null;\n\tString[] values6=null;\n\tString[] values7=null;\n\tString[] values8=null;\n\tString[] values9=null;\n\tString[] values10=null;\n\tString[] values11=null;\n\tString[] values12=null;\n\tString[] values13=null;\n\tString[] values14=null;\n\tString[] values15=null;\n\tString[] values16=null;\n\tString[] values17=null;\n\tString[] values18=null;\n\tString[] values19=null;\n\tString[] values20=null;\n\tString[] values21=null;\n\tString[] values22=null;\n\tString[] values23=null;\n\tString[] values24=null;\n\tString[] values25=null;\n\tString[] values26=null;\n\tString[] values27=null;\n\tString[] values28=null;\n\tString[] values29=null;\n\tString[] values30=null;\n\tString[] values31=null;\n\tString[] values32=null;\n\tString[] values33=null;\n\tString[] values34=null;\n\tString[] values35=null;\n\tString[] values36=null;\n\tString[] values37=null;\n\tString[] values38=null;\n\tString[] values39=null;\n\tString[] values40=null;\n\tString[] values41=null;\n\tString[] values42=null;\n\tString[] values43=null;\n\tString[] values44=null;\n\tString[] values45=null;\n\tString[] values46=null;\n\tString[] values47=null;\n\tString[] values48=null;\n\tString[] values49=null;\n\tString[] values50=null;\n\tString[] values51=null;\n\tString[] values52=null;\n\tString[] values53=null;\n\tString[] values54=null;\n\tString[] values55=null;\n\tString[] values56=null;\n\tString[] values57=null;\n\tString[] values58=null;\n\tString[] values59=null;\n\tString[] values60=null;\n\tString[] values61=null;\n\tString[] values62=null;\n\tString[] values63=null;\n\tString[] values64=null;\n\tString[] values65=null;\n\tString[] values66=null;\n\tString[] values67=null;\n\tString[] values68=null;\n\tString[] values69=null;\n\tString[] values70=null;\n\tString[] values71=null;\n\tString[] values72=null;\n\tString[] values73=null;\n\tString[] values74=null;\n\tString[] values75=null;\n\tString[] values76=null;\n\tString[] values77=null;\n\tString[] values78=null;\n\tString[] values79=null;\n\tString[] values80=null;\n\tString[] values81=null;\n\tString[] values82=null;\n\tString[] values83=null;\n\tString[] values84=null;\n\tString[] values85=null;\n\tString[] values86=null;\n\tString[] values87=null;\n\tString[] values88=null;\n\tString[] values89=null;\n\tString[] values90=null;\n\tString[] values91=null;\n\tString[] values92=null;\n\tString[] values93=null;\n\tString[] values94=null;\n\tString[] values95=null;\n\tString[] values96=null;\n\tString[] values97=null;\n\tString[] values98=null;\n\tString[] values99=null;\n\tString[] values100=null;\n\tString[] values101=null;\n\tString[] values102=null;\n\tString[] values103=null;\n\tString[] values104=null;\n\tString[] values105=null;\n\tString[] values106=null;\n\tString[] values107=null;"], "code_level": "project_runnable", "_id": "636767791a6d9265ec01826d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public boolean isAttached(Appender appender){\n\tfor(Appender appenderList : appenderListList){\n\t\tif(appenderList.getName().equals(appender.getName())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns <code>true</code> if the specified appender is in the list of attached appenders, <code>false</code> otherwise.\n * @since 1.2 \n */\n", "method_name": "isAttached", "codes": ["public boolean isAttached(Appender appender){\n\tfor(Appender appenderList : appenderListList){\n\t\tif(appenderList.getName().equals(appender.getName())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018238", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\tif(value == null || value.trim().length() == 0){\n\t\treturn dEfault;\n\t}\n\tStringTokenizer tokenizer = new StringTokenizer(value, \",\");\n\tif(tokenizer.hasMoreTokens()){\n\t\treturn Boolean.valueOf(tokenizer.nextToken());\n\t}\n\treturn dEfault;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * If <code>value</code> is \"true\", then <code>true</code> is returned. If <code>value</code> is \"false\", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  \n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(String value,boolean dEfault){\n\tif(value == null || value.trim().length() == 0){\n\t\treturn dEfault;\n\t}\n\tStringTokenizer tokenizer = new StringTokenizer(value, \",\");\n\tif(tokenizer.hasMoreTokens()){\n\t\treturn Boolean.valueOf(tokenizer.nextToken());\n\t}\n\treturn dEfault;\n}"], "code_level": "self_contained", "_id": "6367677d1a6d9265ec0182fd", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void add(LoggingEvent event){\n\tif(!buffer.isEmpty()){\n\t\tbuffer.add(event);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an <code>event</code> as the last event in the buffer.\n */\n", "method_name": "add", "codes": ["public void add(LoggingEvent event){\n\tif(!buffer.isEmpty()){\n\t\tbuffer.add(event);\n\t}\n}"], "code_level": "class_runnable", "_id": "636767841a6d9265ec0183e8", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void removeAppender(String name){\n\tif(appenders.contains(name)){\n\t\tappenders.remove(name);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the appender with the name passed as parameter form the list of appenders.  \n */\n", "method_name": "removeAppender", "codes": ["public void removeAppender(String name){\n\tif(appenders.contains(name)){\n\t\tappenders.remove(name);\n\t}\n}"], "code_level": "project_runnable", "_id": "636767861a6d9265ec01844c", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\tint ret = 0;\n\tfor (Appender appender : appenders) {\n\t\tret += appender.appendLoopOnAppender(event);\n\t}\n\treturn ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n", "method_name": "appendLoopOnAppenders", "codes": ["public int appendLoopOnAppenders(LoggingEvent event){\n\tint ret = 0;\n\tfor (Appender appender : appenders) {\n\t\tret += appender.appendLoopOnAppender(event);\n\t}\n\treturn ret;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018242", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public boolean hasThrown(){\n\treturn this.thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n", "method_name": "hasThrown", "codes": ["public boolean hasThrown(){\n\treturn this.thrown;\n}"], "code_level": "class_runnable", "_id": "636767821a6d9265ec0183ab", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint removed = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!isNodeInCategory(i)){\n\t\t\tremoved++;\n\t\t}\n\t}\n\treturn removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n", "method_name": "removeUnusedNodes", "codes": ["Remove any inactive nodes from the Category tree and return the number of removed nodes.\nprotected int removeUnusedNodes(){\n\tint removed = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!isNodeInCategory(i)){\n\t\t\tremoved++;\n\t\t}\n\t}\n\treturn removed;\n}"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec018314", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int compare(Object aObj1,Object aObj2){\n\tif(aObj1==null && aObj2==null){\n\t\treturn 0;\n\t}\n\tif(aObj1==null){\n\t\treturn -1;\n\t}\n\tif(aObj2==null){\n\t\treturn 1;\n\t}\n\tlong aTimeStamp1=((Event)aObj1).getTimeStamp();\n\tlong aTimeStamp2=((Event)aObj2).getTimeStamp();\n\tif(aTimeStamp1==aTimeStamp2){\n\t\treturn 0;\n\t}\n\tif(aTimeStamp1<aTimeStamp2){\n\t\treturn -1;\n\t}\n\treturn 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see Comparator \n */\n", "method_name": "compare", "codes": ["public int compare(Object aObj1,Object aObj2){\n\tif(aObj1==null && aObj2==null){\n\t\treturn 0;\n\t}\n\tif(aObj1==null){\n\t\treturn -1;\n\t}\n\tif(aObj2==null){\n\t\treturn 1;\n\t}\n\tlong aTimeStamp1=((Event)aObj1).getTimeStamp();\n\tlong aTimeStamp2=((Event)aObj2).getTimeStamp();\n\tif(aTimeStamp1==aTimeStamp2){\n\t\treturn 0;\n\t}\n\tif(aTimeStamp1<aTimeStamp2){\n\t\treturn -1;\n\t}\n\treturn 1;\n}"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183f2", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int decide(LoggingEvent event){\n\tString message = event.getMessage();\n\tif(message.equals(\"\")){\n\t\treturn 0;\n\t}\n\t\n\treturn 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n", "method_name": "decide", "codes": ["public int decide(LoggingEvent event){\n\tString message = event.getMessage();\n\tif(message.equals(\"\")){\n\t\treturn 0;\n\t}\n\t\n\treturn 1;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018250", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint count=0;\n\tint index=nameStart;\n\twhile(index<nameStart+count){\n\t\tif(buf.charAt(index)=='.'){\n\t\t\tbuf.deleteCharAt(index);\n\t\t\tcount--;\n\t\t}\n\t\telse{\n\t\t\tbuf.deleteCharAt(index);\n\t\t\tcount++;\n\t\t}\n\t\tindex++;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Abbreviate name.\n * @param buf buffer to append abbreviation.\n * @param nameStart start of name to abbreviate.\n */\n", "method_name": "abbreviate", "codes": ["public void abbreviate(final int nameStart,final StringBuffer buf){\n\tint count=0;\n\tint index=nameStart;\n\twhile(index<nameStart+count){\n\t\tif(buf.charAt(index)=='.'){\n\t\t\tbuf.deleteCharAt(index);\n\t\t\tcount--;\n\t\t}\n\t\telse{\n\t\t\tbuf.deleteCharAt(index);\n\t\t\tcount++;\n\t\t}\n\t\tindex++;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767861a6d9265ec018440", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String id(String entityId){\n\treturn entityId + \":\" + id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return the row id\n */\n", "method_name": "id", "codes": ["public String id(String entityId){\n\treturn entityId + \":\" + id;\n}"], "code_level": "project_runnable", "_id": "636767df1a6d9265ec01873c", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void accept(final METRICS data){\n\tif(data.getId() == null){\n\t\tif(data.getValue() == null){\n\t\t\tdata.setValue(data.getValue());\n\t\t}\n\t\telse{\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t}\n\telse{\n\t\tif(data.getValue() == null){\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t\telse{\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n", "method_name": "accept", "codes": ["public void accept(final METRICS data){\n\tif(data.getId() == null){\n\t\tif(data.getValue() == null){\n\t\t\tdata.setValue(data.getValue());\n\t\t}\n\t\telse{\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t}\n\telse{\n\t\tif(data.getValue() == null){\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t\telse{\n\t\t\tdata.setValue(data.getValue().combine(data.getValue()));\n\t\t}\n\t}\n}"], "code_level": "self_contained", "_id": "636767e11a6d9265ec018781", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(start > end){\n\t\tthrow new IllegalArgumentException(\"start must be less than end\");\n\t}\n\tif(start > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"start must be less than FETCH_DATA_DURATION\");\n\t}\n\tif(end > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"end must be less than FETCH_DATA_DURATION\");\n\t}\n\tlong startTime = start;\n\tlong endTime = end;\n\tif(startTime > endTime){\n\t\tthrow new IllegalArgumentException(\"startTime must be less than endTime\");\n\t}\n\tif(startTime > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"startTime must be less than FETCH_DATA_DURATION\");\n\t}\n\tif(endTime > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"endTime must be less than FETCH_DATA_DURATION\");\n\t}\n\ttimeRanges.add(new TimeRange(startTime,endTime));\n\treturn timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n", "method_name": "buildTimeRanges", "codes": ["Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION.\nprotected List<TimeRange> buildTimeRanges(long start,long end){\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(start > end){\n\t\tthrow new IllegalArgumentException(\"start must be less than end\");\n\t}\n\tif(start > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"start must be less than FETCH_DATA_DURATION\");\n\t}\n\tif(end > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"end must be less than FETCH_DATA_DURATION\");\n\t}\n\tlong startTime = start;\n\tlong endTime = end;\n\tif(startTime > endTime){\n\t\tthrow new IllegalArgumentException(\"startTime must be less than endTime\");\n\t}\n\tif(startTime > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"startTime must be less than FETCH_DATA_DURATION\");\n\t}\n\tif(endTime > FETCH_DATA_DURATION){\n\t\tthrow new IllegalArgumentException(\"endTime must be less than FETCH_DATA_DURATION\");\n\t}\n\ttimeRanges.add(new TimeRange(startTime,endTime));\n\treturn timeRanges;\n}"], "code_level": "self_contained", "_id": "636767df1a6d9265ec018744", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void valueAccumulation(String key,Long value){\n\tif(!this.containsKey(key)){\n\t\tthis.put(key,value);\n\t}\n\telse{\n\t\tthis.put(key,this.get(key)+value);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accumulate the value with existing value in the same given key.\n */\n", "method_name": "valueAccumulation", "codes": ["public void valueAccumulation(String key,Long value){\n\tif(!this.containsKey(key)){\n\t\tthis.put(key,value);\n\t}\n\telse{\n\t\tthis.put(key,this.get(key)+value);\n\t}\n}"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec01871c", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(timestamp<expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @param timestamp        of current time\n * @param expiredThreshold represents the duration between last update time and the time point removing from cache.\n * @return true means this metrics should be removed from cache.\n */\n", "method_name": "isExpired", "codes": ["public boolean isExpired(long timestamp,long expiredThreshold){\n\tif(timestamp<expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}"], "code_level": "class_runnable", "_id": "636767dd1a6d9265ec0186de", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tJsonObject contentJsonObject = jsonObject.getAsJsonObject(\"content\");\n\tif(contentJsonObject!= null){\n\t\tfor(String key : contentJsonObject.keySet()){\n\t\t\tcontent.put(key, contentJsonObject.get(key));\n\t\t}\n\t}\n\treturn content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build content,if it has ats someone set the ats\n */\n", "method_name": "buildContent", "codes": ["Put the \"content\" from the  jsonObject to the content.\nprivate Map<String,Object> buildContent(JsonObject jsonObject){\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tJsonObject contentJsonObject = jsonObject.getAsJsonObject(\"content\");\n\tif(contentJsonObject!= null){\n\t\tfor(String key : contentJsonObject.keySet()){\n\t\t\tcontent.put(key, contentJsonObject.get(key));\n\t\t}\n\t}\n\treturn content;\n}"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018755", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name cannot be null\");\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n", "method_name": "check", "codes": ["Check whether the key contains null.\nprivate void check(String modelName) throws IllegalStateException {\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name cannot be null\");\n    }\n}"], "code_level": "self_contained", "_id": "636767de1a6d9265ec01871e", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void overrideName(String oldName,String newName){\n\tfor(int i=0;i<this.getColumnCount();i++){\n\t\tif(this.getColumnName(i).equals(oldName)){\n\t\t\tthis.getColumnName(i).setValue(newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}\n * @param oldName to be replaced.\n * @param newName to use in the storage level.\n */\n", "method_name": "overrideName", "codes": ["public void overrideName(String oldName,String newName){\n\tfor(int i=0;i<this.getColumnCount();i++){\n\t\tif(this.getColumnName(i).equals(oldName)){\n\t\t\tthis.getColumnName(i).setValue(newName);\n\t\t}\n\t}\n}"], "code_level": "self_contained", "_id": "636767dd1a6d9265ec0186f3", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public boolean isCompatible(DataTable dataset){\n\t\n\tif(dataset.getNumBuckets()!= this.getNumBuckets()){\n\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < this.getNumBuckets(); i++){\n\t\tif(dataset.getBucket(i)!= this.getBucket(i)){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if the bucket is same.\n */\n", "method_name": "isCompatible", "codes": ["public boolean isCompatible(DataTable dataset){\n\t\n\tif(dataset.getNumBuckets()!= this.getNumBuckets()){\n\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < this.getNumBuckets(); i++){\n\t\tif(dataset.getBucket(i)!= this.getBucket(i)){\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}"], "code_level": "plib_runnable", "_id": "636767e11a6d9265ec018795", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings newMappings = new Mappings();\n\tfor(String field:mappings.getFields()){\n\t\tif(!mappings.getFields().contains(field)){\n\t\t\tnewMappings.addField(field);\n\t\t}\n\t}\n\treturn newMappings;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n", "method_name": "diffStructure", "codes": ["public Mappings diffStructure(String tableName,Mappings mappings){\n\tMappings newMappings = new Mappings();\n\tfor(String field:mappings.getFields()){\n\t\tif(!mappings.getFields().contains(field)){\n\t\t\tnewMappings.addField(field);\n\t\t}\n\t}\n\treturn newMappings;\n}"], "code_level": "plib_runnable", "_id": "636767de1a6d9265ec018706", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    long timeBucketCompressed = 0;\n    if (timeBucket == 0) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 1) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 2) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 3) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 4) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 5) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 6) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 7) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 8) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 9) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 10) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 11) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 12) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 13) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 14) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 15) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 16) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 17) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 18) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 19) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 20) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 21) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 22) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 23) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 24) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 25) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 26) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 27) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 28) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 29) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 30) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 31) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 32) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 33) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 34) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 35) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 36) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 37) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 38) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 39) {\n        return timeBucketCompressed;\n    }\n    if (", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n", "method_name": "compressTimeBucket", "codes": ["Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. For example, if dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123.\nstatic long compressTimeBucket(long timeBucket,int dayStep){\n    long timeBucketCompressed = 0;\n    if (timeBucket == 0) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 1) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 2) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 3) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 4) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 5) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 6) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 7) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 8) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 9) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 10) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 11) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 12) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 13) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 14) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 15) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 16) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 17) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 18) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 19) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 20) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 21) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 22) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 23) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 24) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 25) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 26) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 27) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 28) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 29) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 30) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 31) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 32) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 33) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 34) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 35) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 36) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 37) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 38) {\n        return timeBucketCompressed;\n    }\n    if (timeBucket == 39) {\n        return timeBucketCompressed;\n    }\n    if ("], "code_level": "project_runnable", "_id": "636767dc1a6d9265ec0186be", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getFields()){\n\t\tif(field.getName().equals(\"id\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"name\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"description\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n", "method_name": "containsAllFields", "codes": ["Check whether all fields exist in properties.\nprivate boolean containsAllFields(Fields fields){\n\tfor(Field field : fields.getFields()){\n\t\tif(field.getName().equals(\"id\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"name\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"description\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"required\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"default\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"type\")){\n\t\t\tcontinue;\n\t\t}\n\t\tif(field.getName().equals(\"value\")){\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186c6", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\tif(!consumers.contains(consumer)){\n\t\tconsumers.add(consumer);\n\t\tconsumers.addAll(channels);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a new target channels.\n */\n", "method_name": "addNewTarget", "codes": ["public void addNewTarget(Channels channels,IConsumer consumer){\n\tif(!consumers.contains(consumer)){\n\t\tconsumers.add(consumer);\n\t\tconsumers.addAll(channels);\n\t}\n}"], "code_level": "plib_runnable", "_id": "636767dd1a6d9265ec0186e5", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void init(){\n\t// TODO Auto-generated method stub\n\t\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * initialize config, such as check dist path\n */\n", "method_name": "init", "codes": ["public void init(){\n\t// TODO Auto-generated method stub\n\t\n}"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186cb", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\t\n\t//build the upper bound\n\tint upperBound = maxSequence;\n\t\n\t//build the lower bound\n\tint lowerBound = minSequence;\n\t\n\t//build the list of nodes\n\tfor(int i = 0; i < sequenceLength; i++){\n\t\tsequenceRanges.add(new SequenceRange(lowerBound, upperBound));\n\t\tlowerBound = lowerBound + SEQUENCE_RANGE_BATCH_SIZE;\n\t}\n\t\n\treturn sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build current profiles segment snapshot search sequence ranges\n */\n", "method_name": "buildSequenceRanges", "codes": ["public List<SequenceRange> buildSequenceRanges(){\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\t\n\t//build the upper bound\n\tint upperBound = maxSequence;\n\t\n\t//build the lower bound\n\tint lowerBound = minSequence;\n\t\n\t//build the list of nodes\n\tfor(int i = 0; i < sequenceLength; i++){\n\t\tsequenceRanges.add(new SequenceRange(lowerBound, upperBound));\n\t\tlowerBound = lowerBound + SEQUENCE_RANGE_BATCH_SIZE;\n\t}\n\t\n\treturn sequenceRanges;\n}"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec018726", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader reader = new BufferedReader(new FileReader(file));\n\tString line;\n\twhile ((line = reader.readLine())!= null) {\n\t\tString[] split = line.split(\"\\\\s+\");\n\t\tif (split.length < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tString threadName = split[0];\n\t\tString threadId = split[1];\n\t\tString threadSnapshot = split[2];\n\t\tif (threadName.equals(\"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(threadName,threadId,threadSnapshot);\n\t\tif (timeRanges.contains(timeRange)) {\n\t\t\tthreadSnapshots.add(new ThreadSnapshot(threadName,threadId,threadSnapshot));\n\t\t}\n\t}\n\treader.close();\n\treturn threadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * load thread snapshots in appointing time range\n */\n", "method_name": "parseFromFileWithTimeRange", "codes": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\tList<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader reader = new BufferedReader(new FileReader(file));\n\tString line;\n\twhile ((line = reader.readLine())!= null) {\n\t\tString[] split = line.split(\"\\\\s+\");\n\t\tif (split.length < 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tString threadName = split[0];\n\t\tString threadId = split[1];\n\t\tString threadSnapshot = split[2];\n\t\tif (threadName.equals(\"\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tProfileAnalyzeTimeRange timeRange = new ProfileAnalyzeTimeRange(threadName,threadId,threadSnapshot);\n\t\tif (timeRanges.contains(timeRange)) {\n\t\t\tthreadSnapshots.add(new ThreadSnapshot(threadName,threadId,threadSnapshot));\n\t\t}\n\t}\n\treader.close();\n\treturn threadSnapshots;\n}"], "code_level": "project_runnable", "_id": "636767e11a6d9265ec018790", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject json = new JsonObject();\n    for (KeyStringValuePair property : properties){\n        json.add(property.getKey(), property.getValue());\n    }\n    return json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Convert process properties to source data\n */\n", "method_name": "convertProperties", "codes": ["Convert process properties to the JsonObject.\nprivate JsonObject convertProperties(List<KeyStringValuePair> properties){\n    JsonObject json = new JsonObject();\n    for (KeyStringValuePair property : properties){\n        json.add(property.getKey(), property.getValue());\n    }\n    return json;\n}"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018764", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    int ret = 0;\n    while(!stack.empty()){\n        ret = stack.top();\n        stack.pop();\n    }\n    return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n", "method_name": "pop", "codes": ["Pop an abstract type from the output frame stack and return its value.\nprivate int pop(){\n    int ret = 0;\n    while(!stack.empty()){\n        ret = stack.top();\n        stack.pop();\n    }\n    return ret;\n}"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c2", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n", "method_name": "visitFrameStart", "codes": ["Init a currentFrame with the given offset, numLocal and numStack, return 3 finally.\nint visitFrameStart(final int offset,final int numLocal,final int numStack){\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out.println(\"offset: \"+offset);\n\t//System.out.println(\"numLocal: \"+numLocal);\n\t//System.out.println(\"numStack: \"+numStack);\n\t\n\t//System.out.println(\"visitFrameStart\");\n\t\n\t//System.out."], "code_level": "self_contained", "_id": "636766aa1a6d9265ec0175ce", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newSize = size + 1;\n\tfinal int[] newArray = new int[newSize];\n\tSystem.arraycopy(originalArray, 0, newArray, 0, originalArray.length);\n\toriginalArray = newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["Convert the original data array to a longer array.\nprivate void enlarge(final int size){\n\tfinal int newSize = size + 1;\n\tfinal int[] newArray = new int[newSize];\n\tSystem.arraycopy(originalArray, 0, newArray, 0, originalArray.length);\n\toriginalArray = newArray;\n}"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c1", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tfinal ByteVector byteVector = new ByteVector(byteLength);\n\tbyteVector.putByteArray(byteArrayValue,byteOffset,byteLength);\n\treturn byteVector;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\tfinal ByteVector byteVector = new ByteVector(byteLength);\n\tbyteVector.putByteArray(byteArrayValue,byteOffset,byteLength);\n\treturn byteVector;\n}"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175ae", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements > 0)\n\t\tstack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n", "method_name": "pop", "codes": ["Pop the given number of elements from the stack.\nprivate void pop(final int elements){\n\tif(elements > 0)\n\t\tstack.pop();\n}"], "code_level": "self_contained", "_id": "636766a81a6d9265ec017586", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public ByteVector putInt(final int intValue){\n\tbyte[] data = new byte[4];\n\tdata[0] = (byte)(intValue >> 24);\n\tdata[1] = (byte)(intValue >> 16);\n\tdata[2] = (byte)(intValue >> 8);\n\tdata[3] = (byte)(intValue);\n\treturn new ByteVector(data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n", "method_name": "putInt", "codes": ["public ByteVector putInt(final int intValue){\n\tbyte[] data = new byte[4];\n\tdata[0] = (byte)(intValue >> 24);\n\tdata[1] = (byte)(intValue >> 16);\n\tdata[2] = (byte)(intValue >> 8);\n\tdata[3] = (byte)(intValue);\n\treturn new ByteVector(data);\n}"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017596", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n    if(descriptor.length() == 1){\n        return;\n    }\n    final char first = descriptor.charAt(0);\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == '", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["Pop different value of type based on the first character of the given descriptor.\nprivate void pop(final String descriptor){\n    if(descriptor.length() == 1){\n        return;\n    }\n    final char first = descriptor.charAt(0);\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == ','){\n        return;\n    }\n    if(first == ';'){\n        return;\n    }\n    if(first == ':'){\n        return;\n    }\n    if(first == '<'){\n        return;\n    }\n    if(first == '>'){\n        return;\n    }\n    if(first == '&'){\n        return;\n    }\n    if(first == '\"'){\n        return;\n    }\n    if(first == '\\''){\n        return;\n    }\n    if(first == '('){\n        return;\n    }\n    if(first == ')'){\n        return;\n    }\n    if(first == '*'){\n        return;\n    }\n    if(first == '+'){\n        return;\n    }\n    if(first == '"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175c4", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n", "method_name": "put11", "codes": ["Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.\nfinal ByteVector put11(final int byteValue1,final int byteValue2){\n\tif(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF0);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1<=0xF8){\n\t\treturn new ByteVector(byteValue1,byteValue2,0xF8,0xF8,0xF8);\n\t}else if(byteValue1>=0xF0 && byteValue1"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017595", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n    return toString(Arrays.asList(features));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n", "method_name": "toString", "codes": ["Converts the content in JSONWriter to a string.\n@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n    return toString(Arrays.asList(features));\n}"], "code_level": "self_contained", "_id": "636766a81a6d9265ec01757b", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public static int nextPrime(int desiredCapacity){\n\tint prime = 1;\n\tfor(int i = 0; i < desiredCapacity; i++){\n\t\tprime = prime * prime;\n\t}\n\treturn prime;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n * @param desiredCapacity the capacity desired by the user.\n * @return the capacity which should be used for a hashtable.\n */\n", "method_name": "nextPrime", "codes": ["public static int nextPrime(int desiredCapacity){\n\tint prime = 1;\n\tfor(int i = 0; i < desiredCapacity; i++){\n\t\tprime = prime * prime;\n\t}\n\treturn prime;\n}"], "code_level": "slib_runnable", "_id": "636766a81a6d9265ec01758e", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    switch(c){\n        case '0':\n            return 0;\n        case '1':\n            return 1;\n        case '2':\n            return 2;\n        case '3':\n            return 3;\n        case '4':\n            return 4;\n        case '5':\n            return 5;\n        case '6':\n            return 6;\n        case '7':\n            return 7;\n        case '8':\n            return 8;\n        case '9':\n            return 9;\n        default:\n            return -1;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.\n */\n", "method_name": "digitValue", "codes": ["Obtains the number corresponding to the character c.\nprivate static int digitValue(final char c){\n    switch(c){\n        case '0':\n            return 0;\n        case '1':\n            return 1;\n        case '2':\n            return 2;\n        case '3':\n            return 3;\n        case '4':\n            return 4;\n        case '5':\n            return 5;\n        case '6':\n            return 6;\n        case '7':\n            return 7;\n        case '8':\n            return 8;\n        case '9':\n            return 9;\n        default:\n            return -1;\n    }\n}"], "code_level": "self_contained", "_id": "636767a61a6d9265ec0185b7", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Is this a hex digit?\n */\n", "method_name": "isHex", "codes": ["Return true if the given character is a hex digit,otherwise return false.\nprivate static boolean isHex(final char c){\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}"], "code_level": "self_contained", "_id": "636767ab1a6d9265ec018676", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tif(schema.getType() == Schema.Type.PROTO) {\n\t\tProtobufOutput proto = new ProtobufOutput(out);\n\t\tschema.writeTo(proto);\n\t\tsize = proto.size();\n\t} else {\n\t\tLinkedBuffer proto = new LinkedBuffer(buffer);\n\t\tschema.writeTo(proto);\n\t\tsize = proto.size();\n\t}\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n", "method_name": "writeDelimitedTo", "codes": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\tint size = 0;\n\tif(schema.getType() == Schema.Type.PROTO) {\n\t\tProtobufOutput proto = new ProtobufOutput(out);\n\t\tschema.writeTo(proto);\n\t\tsize = proto.size();\n\t} else {\n\t\tLinkedBuffer proto = new LinkedBuffer(buffer);\n\t\tschema.writeTo(proto);\n\t\tsize = proto.size();\n\t}\n\treturn size;\n}"], "code_level": "project_runnable", "_id": "636767a41a6d9265ec018582", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null || len==0){\n\t\treturn false;\n\t}\n\tif(len==data.length){\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(data[i]!=data[i+offset]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n", "method_name": "equals", "codes": ["public boolean equals(final byte[] data,int offset,final int len){\n\tif(data==null || len==0){\n\t\treturn false;\n\t}\n\tif(len==data.length){\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(data[i]!=data[i+offset]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}"], "code_level": "class_runnable", "_id": "636767a51a6d9265ec01859d", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint utf8Size = 0;\n\tint i = index;\n\twhile(i < index + len){\n\t\tfinal int codePoint = str.charAt(i);\n\t\tif(codePoint < 0x80){\n\t\t\tutf8Size++;\n\t\t}else if(codePoint < 0x800){\n\t\t\tutf8Size += 2;\n\t\t}else if(codePoint < 0x10000){\n\t\t\tutf8Size += 3;\n\t\t}else if(codePoint < 0x200000){\n\t\t\tutf8Size += 4;\n\t\t}else if(codePoint < 0x4000000){\n\t\t\tutf8Size += 5;\n\t\t}else if(codePoint < 0x80000000){\n\t\t\tutf8Size += 6;\n\t\t}else{\n\t\t\tutf8Size += 7;\n\t\t}\n\t\ti++;\n\t}\n\treturn utf8Size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n", "method_name": "computeUTF8Size", "codes": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\tint utf8Size = 0;\n\tint i = index;\n\twhile(i < index + len){\n\t\tfinal int codePoint = str.charAt(i);\n\t\tif(codePoint < 0x80){\n\t\t\tutf8Size++;\n\t\t}else if(codePoint < 0x800){\n\t\t\tutf8Size += 2;\n\t\t}else if(codePoint < 0x10000){\n\t\t\tutf8Size += 3;\n\t\t}else if(codePoint < 0x200000){\n\t\t\tutf8Size += 4;\n\t\t}else if(codePoint < 0x4000000){\n\t\t\tutf8Size += 5;\n\t\t}else if(codePoint < 0x80000000){\n\t\t\tutf8Size += 6;\n\t\t}else{\n\t\t\tutf8Size += 7;\n\t\t}\n\t\ti++;\n\t}\n\treturn utf8Size;\n}"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01856c", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(str == null) return null;\n\tfinal int len = str.length();\n\tif(len == 0) return null;\n\tfinal byte[] bytes = new byte[len];\n\tstr.getChars(0, len, bytes, 0);\n\tlb.write(bytes, 0, len);\n\treturn lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the utf8-encoded bytes from the string into the  {@link LinkedBuffer}.\n */\n", "method_name": "writeUTF8", "codes": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\tif(str == null) return null;\n\tfinal int len = str.length();\n\tif(len == 0) return null;\n\tfinal byte[] bytes = new byte[len];\n\tstr.getChars(0, len, bytes, 0);\n\tlb.write(bytes, 0, len);\n\treturn lb;\n}"], "code_level": "project_runnable", "_id": "636767ab1a6d9265ec01867b", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public long readRawVarint64() throws IOException {\n    int b = read();\n    if (b < 0) {\n      throw new EOFException();\n    }\n    long result = (long) b;\n    if (b < 0x80) {\n      return result;\n    }\n    result = result << 7;\n    result |= (long) b & 0x7F;\n    if (b < 0x800) {\n      return result;\n    }\n    result = result << 14;\n    result |= (long) b & 0x3FF;\n    if (b < 0x10000) {\n      return result;\n    }\n    result = result << 21;\n    result |= (long) b & 0x7FFF;\n    return result;\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a raw Varint from the stream.\n */\n", "method_name": "readRawVarint64", "codes": ["public long readRawVarint64() throws IOException {\n    int b = read();\n    if (b < 0) {\n      throw new EOFException();\n    }\n    long result = (long) b;\n    if (b < 0x80) {\n      return result;\n    }\n    result = result << 7;\n    result |= (long) b & 0x7F;\n    if (b < 0x800) {\n      return result;\n    }\n    result = result << 14;\n    result |= (long) b & 0x3FF;\n    if (b < 0x10000) {\n      return result;\n    }\n    result = result << 21;\n    result |= (long) b & 0x7FFF;\n    return result;\n  }"], "code_level": "class_runnable", "_id": "636767a41a6d9265ec018572", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint len=node.length();\n\tif(len==0) return 0;\n\tint i=0;\n\twhile(i<len) {\n\t\tint c=node.get(i);\n\t\tif(c==0) {\n\t\t\tout.writeByte((byte)0);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tout.writeByte((byte)c);\n\t\ti++;\n\t}\n\treturn i;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the contents of the  {@link LinkedBuffer} into the {@link DataOutput}.\n * @return the total content size of the buffer.\n */\n", "method_name": "writeTo", "codes": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\tint len=node.length();\n\tif(len==0) return 0;\n\tint i=0;\n\twhile(i<len) {\n\t\tint c=node.get(i);\n\t\tif(c==0) {\n\t\t\tout.writeByte((byte)0);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tout.writeByte((byte)c);\n\t\ti++;\n\t}\n\treturn i;\n}"], "code_level": "class_runnable", "_id": "636767aa1a6d9265ec01865a", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public String readString() throws IOException {\n    return readString(buffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n", "method_name": "readString", "codes": ["public String readString() throws IOException {\n    return readString(buffer);\n}"], "code_level": "project_runnable", "_id": "636767a31a6d9265ec018552", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public final byte[] toByteArray(){\n\tbyte[] result = new byte[length];\n\tSystem.arraycopy(buffer, 0, result, 0, length);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns a single byte array containg all the contents written to the buffer(s).\n */\n", "method_name": "toByteArray", "codes": ["public final byte[] toByteArray(){\n\tbyte[] result = new byte[length];\n\tSystem.arraycopy(buffer, 0, result, 0, length);\n\treturn result;\n}"], "code_level": "project_runnable", "_id": "636767a21a6d9265ec018517", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tif(a<b){\n\t\treturn -1;\n\t}\n\telse if(a>b){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.\n * @param a the first  {@code long} to compare\n * @param b the second  {@code long} to compare\n * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal\n */\n", "method_name": "compareSigned", "codes": ["Compare two numbers.\nprivate static int compareSigned(long a,long b){\n\tif(a<b){\n\t\treturn -1;\n\t}\n\telse if(a>b){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01857e", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public byte[] toByteArray(){\n\tbyte[] b = new byte[length];\n\tSystem.arraycopy(data, 0, b, 0, length);\n\treturn b;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Copies bytes to a  {@code byte[]}.\n */\n", "method_name": "toByteArray", "codes": ["public byte[] toByteArray(){\n\tbyte[] b = new byte[length];\n\tSystem.arraycopy(data, 0, b, 0, length);\n\treturn b;\n}"], "code_level": "self_contained", "_id": "636767aa1a6d9265ec01864a", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif (field.getType() == FieldType.BOOLEAN) {\n\t\tif (field.getValue() == true) {\n\t\t\tfield.setValue(false);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n", "method_name": "checkIfPackedField", "codes": ["Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.\nprivate void checkIfPackedField() throws IOException {\n\tif (field.getType() == FieldType.BOOLEAN) {\n\t\tif (field.getValue() == true) {\n\t\t\tfield.setValue(false);\n\t\t}\n\t}\n}"], "code_level": "class_runnable", "_id": "636767a31a6d9265ec01854f", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public int readTag() throws IOException {\n\tif (tag == 0) {\n\t\tthrow new IOException(\"Tag is not set\");\n\t}\n\treturn tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n", "method_name": "readTag", "codes": ["public int readTag() throws IOException {\n\tif (tag == 0) {\n\t\tthrow new IOException(\"Tag is not set\");\n\t}\n\treturn tag;\n}"], "code_level": "class_runnable", "_id": "636767a81a6d9265ec0185fc", "project_name": "protostuff-master"}
