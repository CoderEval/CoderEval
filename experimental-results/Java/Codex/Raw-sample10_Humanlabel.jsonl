{"generate_results": [{"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)){\n        messages.put(message,timestamp);\n        return true;\n    }\n    if(timestamp - messages.get(message) >= 10){\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message)||messages.get(message)<=timestamp-10){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)||timestamp-messages.get(message)>=10){\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(messages.containsKey(message)){\n\t\tint k = messages.get(message);\n\t\tif(timestamp - k >= 10){\n\t\t\tmessages.put(message,timestamp);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tmessages.put(message,timestamp);\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message) || timestamp-messages.get(message)>=10){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message) || timestamp-messages.get(message)>=10) {\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(messages.containsKey(message) && timestamp-messages.get(message)<10){\n\t\treturn false;\n\t}\n\tmessages.put(message,timestamp);\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)){\n        messages.put(message,timestamp);\n        return true;\n    }else{\n        int oldtimestamp=messages.get(message);\n        if(timestamp-oldtimestamp>=10){\n            messages.put(message,timestamp);\n            return true;\n        }else{\n            return false;\n        }\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message) || (timestamp - messages.get(message) >= 10)){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message)){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\telse{\n\t\tint lastTimestamp=messages.get(message);\n\t\tif(timestamp-lastTimestamp>=10){\n\t\t\tmessages.put(message,timestamp);\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns true if the message should be printed in the given timestamp, otherwise returns false. If this method returns false, the message will not be printed. The timestamp is in seconds granularity. \n */\n", "method_name": "shouldPrintMessage", "codes": ["public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)){\n        messages.put(message,timestamp);\n        return true;\n    }\n    if(timestamp - messages.get(message) >= 10){\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message)||messages.get(message)<=timestamp-10){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)||timestamp-messages.get(message)>=10){\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(messages.containsKey(message)){\n\t\tint k = messages.get(message);\n\t\tif(timestamp - k >= 10){\n\t\t\tmessages.put(message,timestamp);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tmessages.put(message,timestamp);\n\treturn true;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message) || timestamp-messages.get(message)>=10){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message) || timestamp-messages.get(message)>=10) {\n        messages.put(message,timestamp);\n        return true;\n    }\n    return false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(messages.containsKey(message) && timestamp-messages.get(message)<10){\n\t\treturn false;\n\t}\n\tmessages.put(message,timestamp);\n\treturn true;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n    if(!messages.containsKey(message)){\n        messages.put(message,timestamp);\n        return true;\n    }else{\n        int oldtimestamp=messages.get(message);\n        if(timestamp-oldtimestamp>=10){\n            messages.put(message,timestamp);\n            return true;\n        }else{\n            return false;\n        }\n    }\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message) || (timestamp - messages.get(message) >= 10)){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean shouldPrintMessage(int timestamp,String message){\n\n\tif(!messages.containsKey(message)){\n\t\tmessages.put(message,timestamp);\n\t\treturn true;\n\t}\n\telse{\n\t\tint lastTimestamp=messages.get(message);\n\t\tif(timestamp-lastTimestamp>=10){\n\t\t\tmessages.put(message,timestamp);\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c73", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public boolean remove(int val){\n\n\tif(map.containsKey(val)){\n\t\tvalues.remove(map.get(val));\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif(values.contains(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif (containsKey(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif(contains(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif(containsKey(val)){\n\t\tvalues.remove(indexOf(val));\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif (keys.contains(val)){\n\t\tvalues.remove(values.get(keys.indexOf(val)));\n\t\tkeys.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif(this.containsKey(val)){\n\t\tvalues.remove(values.indexOf(this.get(val)));\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tint[] map = new int[101];\n\tboolean removed = false;\n\tfor (int i = 0; i < values.length; i++){\n\t\tmap[values[i]]++;\n\t}\n\tif (map[val] != 0){\n\t\tremoved = true;\n\t\tint[] temp = new int[values.length - 1];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < values.length; i++){\n\t\t\tif (values[i] != val){\n\t\t\t\ttemp[k] = values[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tvalues = temp;\n\t}\n\treturn removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n\tif(map.containsKey(val)){\n\t\tvalues.remove(map.get(val));\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean remove(int val){\n\n    boolean removed = false;\n    if(keys.contains(val)){\n        int index = keys.indexOf(val);\n        keys.remove(index);\n        values.remove(index);\n        removed = true;\n    }\n    return removed;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes a value from the set. Returns true if the set contained the specified element. \n */\n", "method_name": "remove", "codes": ["public boolean remove(int val){\n\n\tif(map.containsKey(val)){\n\t\tvalues.remove(map.get(val));\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tif(values.contains(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tif (containsKey(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}", "public boolean remove(int val){\n\n\tif(contains(val)){\n\t\tvalues.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tif(containsKey(val)){\n\t\tvalues.remove(indexOf(val));\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tif (keys.contains(val)){\n\t\tvalues.remove(values.get(keys.indexOf(val)));\n\t\tkeys.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tif(this.containsKey(val)){\n\t\tvalues.remove(values.indexOf(this.get(val)));\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n\tint[] map = new int[101];\n\tboolean removed = false;\n\tfor (int i = 0; i < values.length; i++){\n\t\tmap[values[i]]++;\n\t}\n\tif (map[val] != 0){\n\t\tremoved = true;\n\t\tint[] temp = new int[values.length - 1];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < values.length; i++){\n\t\t\tif (values[i] != val){\n\t\t\t\ttemp[k] = values[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tvalues = temp;\n\t}\n\treturn removed;\n}", "public boolean remove(int val){\n\n\tif(map.containsKey(val)){\n\t\tvalues.remove(map.get(val));\n\t\tmap.remove(val);\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean remove(int val){\n\n    boolean removed = false;\n    if(keys.contains(val)){\n        int index = keys.indexOf(val);\n        keys.remove(index);\n        values.remove(index);\n        removed = true;\n    }\n    return removed;\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c74", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    else{\n        map.put(val, val);\n        return true;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    int key = val;\n    if(!this.containsKey(key)){\n        this.put(key,val);\n        return true;\n    }\n    return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val){\n\n    if (map.containsKey(val)){\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    map.put(val, val);\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    if(map.containsKey(val))\n        return false;\n    map.put(val, val);\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    map.put(val, val);\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    if(this.contains(val)){\n        return false;\n    }\n    this.map.put(val, val);\n    return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val){\n\n    if (map.containsKey(val)) {\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean insert(int val){\n\n    if (map.containsKey(val)) return false;\n    int next = map.getOrDefault(val - 1, val);\n    int prev = map.getOrDefault(val + 1, val);\n    boolean res = false;\n    if (val == next - 1 && val == prev + 1) {\n        res = true;\n        map.put(val, val);\n        map.put(prev, next);\n        map.put(next, prev);\n    } else if (val == prev + 1) {\n        res = true;\n        map.put(val, prev);\n        map.put(prev, val);\n        map.put(next, prev);\n    } else if (val == next - 1) {\n        res = true;\n        map.put(val, next);\n        map.put(prev, next);\n        map.put(next, val);\n    } else {\n        res = true;\n        map.put(val, val);\n        map.put(prev, val);\n        map.put(next, val);\n    }\n    return res;", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    else{\n        map.put(val,val);\n        return true;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \n */\n", "method_name": "insert", "codes": ["public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    else{\n        map.put(val, val);\n        return true;\n    }\n}", "public boolean insert(int val){\n\n    int key = val;\n    if(!this.containsKey(key)){\n        this.put(key,val);\n        return true;\n    }\n    return false;\n}", "public boolean insert(int val){\n\n    if (map.containsKey(val)){\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if(map.containsKey(val))\n        return false;\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if(this.contains(val)){\n        return false;\n    }\n    this.map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if (map.containsKey(val)) {\n        return false;\n    }\n    map.put(val, val);\n    return true;\n}", "public boolean insert(int val){\n\n    if (map.containsKey(val)) return false;\n    int next = map.getOrDefault(val - 1, val);\n    int prev = map.getOrDefault(val + 1, val);\n    boolean res = false;\n    if (val == next - 1 && val == prev + 1) {\n        res = true;\n        map.put(val, val);\n        map.put(prev, next);\n        map.put(next, prev);\n    } else if (val == prev + 1) {\n        res = true;\n        map.put(val, prev);\n        map.put(prev, val);\n        map.put(next, prev);\n    } else if (val == next - 1) {\n        res = true;\n        map.put(val, next);\n        map.put(prev, next);\n        map.put(next, val);\n    } else {\n        res = true;\n        map.put(val, val);\n        map.put(prev, val);\n        map.put(next, val);\n    }\n    return res;", "public boolean insert(int val){\n\n    if(map.containsKey(val)) return false;\n    else{\n        map.put(val,val);\n        return true;\n    }\n}"], "code_level": "class_runnable", "_id": "6367672d1a6d9265ec017c78", "project_name": "interviews-master"}
{"generate_results": [{"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null||array2==null){return false;}\n\treturn array1.length==array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1.length != array2.length)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1!=null&&array2!=null){\n\t\treturn array1.length==array2.length;\n\t}\n\treturn array1==null&&array2==null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length==array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn isSameLength(array1.length,array2.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}else{\n\t\treturn array2!=null&&array1.length==array2.length;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif((null==array1)||(null==array2)){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\tif(array2==null){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length == array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length==array2.length;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null||array2==null){return false;}\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1.length != array2.length)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1!=null&&array2!=null){\n\t\treturn array1.length==array2.length;\n\t}\n\treturn array1==null&&array2==null;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn isSameLength(array1.length,array2.length);\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}else{\n\t\treturn array2!=null&&array1.length==array2.length;\n\t}\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif((null==array1)||(null==array2)){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\tif(array2==null){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length == array2.length;\n}", "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n\n\treturn array1.length==array2.length;\n}"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec017a00", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n    if(array==null){\n        return null;\n    }\n    if(array.length==0){\n        return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n    }\n    final boolean[] result=new boolean[array.length];\n    for(int i=0;i<array.length;i++){\n        result[i]=array[i];\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i].booleanValue();\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}else if(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].booleanValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\treturn toPrimitive(array,false);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++) result[i]=array[i].booleanValue();\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\nif(array==null){\nreturn null;\n}else if(array.length==0){\nreturn ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n}else{\nfinal boolean[] result=new boolean[array.length];\nfor(int i=0;i<array.length;i++){\nresult[i]=array[i].booleanValue();\n}\nreturn result;\n}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].booleanValue();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i].booleanValue();\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] primitives=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tprimitives[i]=array[i].booleanValue();\n\t}\n\treturn primitives;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;++i){\n\t\tresult[i]=array[i];\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Booleans to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Boolean</code> array, may be <code>null</code>\n * @return a <code>boolean</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static boolean[] toPrimitive(final Boolean[] array){\n\n    if(array==null){\n        return null;\n    }\n    if(array.length==0){\n        return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n    }\n    final boolean[] result=new boolean[array.length];\n    for(int i=0;i<array.length;i++){\n        result[i]=array[i];\n    }\n    return result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i].booleanValue();\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}else if(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].booleanValue();\n\t}\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\treturn toPrimitive(array,false);\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++) result[i]=array[i].booleanValue();\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\nif(array==null){\nreturn null;\n}else if(array.length==0){\nreturn ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n}else{\nfinal boolean[] result=new boolean[array.length];\nfor(int i=0;i<array.length;i++){\nresult[i]=array[i].booleanValue();\n}\nreturn result;\n}\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].booleanValue();\n\t}\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result = new boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) result[i] = array[i].booleanValue();\n\treturn result;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_BOOLEAN_ARRAY;\n\t}\n\tfinal boolean[] primitives=new boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tprimitives[i]=array[i].booleanValue();\n\t}\n\treturn primitives;\n}", "public static boolean[] toPrimitive(final Boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_ARRAY;\n\tfinal boolean[] result=new boolean[array.length];\n\tfor(int i=0;i<array.length;++i){\n\t\tresult[i]=array[i];\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636767081a6d9265ec017989", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(Object obj){\n\n\treturn toString(obj, \"\");\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n\tif (obj == null)\n\t\treturn \"\";\n\treturn obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n\tif(obj==null) return \"\";\n\treturn obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n    return (obj==null) ? \"\" : obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\nif(obj==null)return \"\";\nif(obj instanceof String) return (String)obj;\nif(obj instanceof Number) return obj.toString();\nif(obj instanceof Boolean) return obj.toString();\nif(obj instanceof java.util.Date) return obj.toString();\nif(obj instanceof java.util.List) return obj.toString();\nif(obj instanceof java.util.Map) return obj.toString();\nif(obj instanceof java.util.Set) return obj.toString();\nif(obj instanceof java.util.Calendar) return obj.toString();\nif(obj instanceof java.util.UUID) return obj.toString();\nif(obj instanceof java.util.Currency) return obj.toString();\nif(obj instanceof java.util.Locale) return obj.toString();\nif(obj instanceof java.util.TimeZone) return obj.toString();\nif(obj instanceof java.util.Charset) return obj.toString();\nif(obj instanceof java.util.Properties) return obj.to", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object obj){\n\n\treturn obj == null ? \"\" : obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n\treturn toString(obj,\"\");\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n\tif(obj==null) return \"\";\n\treturn obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n    return obj == null ? \"\" : obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object obj){\n\n\treturn (obj == null) ? \"\" : obj.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n", "method_name": "toString", "codes": ["public static String toString(Object obj){\n\n\treturn toString(obj, \"\");\n}", "public static String toString(Object obj){\n\n\tif (obj == null)\n\t\treturn \"\";\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n\n\tif(obj==null) return \"\";\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n\n    return (obj==null) ? \"\" : obj.toString();\n}", "public static String toString(Object obj){\n\nif(obj==null)return \"\";\nif(obj instanceof String) return (String)obj;\nif(obj instanceof Number) return obj.toString();\nif(obj instanceof Boolean) return obj.toString();\nif(obj instanceof java.util.Date) return obj.toString();\nif(obj instanceof java.util.List) return obj.toString();\nif(obj instanceof java.util.Map) return obj.toString();\nif(obj instanceof java.util.Set) return obj.toString();\nif(obj instanceof java.util.Calendar) return obj.toString();\nif(obj instanceof java.util.UUID) return obj.toString();\nif(obj instanceof java.util.Currency) return obj.toString();\nif(obj instanceof java.util.Locale) return obj.toString();\nif(obj instanceof java.util.TimeZone) return obj.toString();\nif(obj instanceof java.util.Charset) return obj.toString();\nif(obj instanceof java.util.Properties) return obj.to", "public static String toString(Object obj){\n\n\treturn obj == null ? \"\" : obj.toString();\n}", "public static String toString(Object obj){\n\n\treturn toString(obj,\"\");\n}", "public static String toString(Object obj){\n\n\tif(obj==null) return \"\";\n\treturn obj.toString();\n}", "public static String toString(Object obj){\n\n    return obj == null ? \"\" : obj.toString();\n}", "public static String toString(Object obj){\n\n\treturn (obj == null) ? \"\" : obj.toString();\n}"], "code_level": "self_contained", "_id": "636766f81a6d9265ec01775c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn bool == null? false: bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn toBoolean(bool,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn bool!=null && bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\tif(bool == null){\n\t\treturn false;\n\t}\n\treturn bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn bool==null?false:bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn bool!=null && bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\treturn bool==null? false: bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\nreturn toBoolean(bool,false);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\tif (bool==null) return false;\n\treturn bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(Boolean bool){\n\n\tif(bool==null){\n\t\treturn false;\n\t}\n\treturn bool.booleanValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts a Boolean to a boolean handling <code>null</code> by returning <code>false</code>.</p> <pre> BooleanUtils.toBoolean(Boolean.TRUE)  = true BooleanUtils.toBoolean(Boolean.FALSE) = false BooleanUtils.toBoolean(null)          = false </pre>\n * @param bool  the boolean to convert\n * @return <code>true</code> or <code>false</code>, <code>null</code> returns <code>false</code>\n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(Boolean bool){\n\n\treturn bool == null? false: bool;\n}", "public static boolean toBoolean(Boolean bool){\n\n\treturn toBoolean(bool,false);\n}", "public static boolean toBoolean(Boolean bool){\n\n\treturn bool!=null && bool;\n}", "public static boolean toBoolean(Boolean bool){\n\n\tif(bool == null){\n\t\treturn false;\n\t}\n\treturn bool.booleanValue();\n}", "public static boolean toBoolean(Boolean bool){\n\n\treturn bool==null?false:bool;\n}", "public static boolean toBoolean(Boolean bool){\n\n\treturn bool!=null && bool.booleanValue();\n}", "public static boolean toBoolean(Boolean bool){\n\n\treturn bool==null? false: bool.booleanValue();\n}", "public static boolean toBoolean(Boolean bool){\nreturn toBoolean(bool,false);}", "public static boolean toBoolean(Boolean bool){\n\n\tif (bool==null) return false;\n\treturn bool;\n}", "public static boolean toBoolean(Boolean bool){\n\n\tif(bool==null){\n\t\treturn false;\n\t}\n\treturn bool.booleanValue();\n}"], "code_level": "self_contained", "_id": "636766f91a6d9265ec01777f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn (array==null || array.length==0)? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\nreturn array == null ? EMPTY_BYTE_OBJECT_ARRAY : array;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\tif((array==null)||(array.length==0)){\n\t\treturn EMPTY_BYTE_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array == null || array.length <= 0 ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n    if(array == null || array.length == 0){\n        return EMPTY_BYTE_OBJECT_ARRAY;\n    }\n    return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n    return isEmpty(array) ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_BYTE_OBJECT_ARRAY : array;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn (array == null || array.length == 0) ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n    return array == null ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array==null || array.length==0?EMPTY_BYTE_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn (array==null || array.length==0)? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\nreturn array == null ? EMPTY_BYTE_OBJECT_ARRAY : array;}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n\tif((array==null)||(array.length==0)){\n\t\treturn EMPTY_BYTE_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array == null || array.length <= 0 ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n    if(array == null || array.length == 0){\n        return EMPTY_BYTE_OBJECT_ARRAY;\n    }\n    return array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n    return isEmpty(array) ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_BYTE_OBJECT_ARRAY : array;\n\t}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn (array == null || array.length == 0) ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n    return array == null ? EMPTY_BYTE_OBJECT_ARRAY : array;\n}", "public static Byte[] nullToEmpty(final Byte[] array){\n\n\treturn array==null || array.length==0?EMPTY_BYTE_OBJECT_ARRAY:array;\n}"], "code_level": "self_contained", "_id": "6367670b1a6d9265ec0179ff", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn (array == null || array.length == 0) ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn array == null ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array.length==0?EMPTY_BOOLEAN_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif (array!=null && array.length>0){\n\t\treturn array;\n\t}\n\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n   if(array==null || array.length==0){return EMPTY_BOOLEAN_OBJECT_ARRAY;}\n   return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n    return array==null||array.length==0?EMPTY_BOOLEAN_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n    if(isEmpty(array)){\n        return EMPTY_BOOLEAN_OBJECT_ARRAY;\n    }\n    return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array == null || array.length == 0){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn isNullOrEmpty(array)? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array == null){return EMPTY_BOOLEAN_OBJECT_ARRAY;}\n\treturn array.length == 0 ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn (array == null || array.length == 0) ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn array == null ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array.length==0?EMPTY_BOOLEAN_OBJECT_ARRAY:array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif (array!=null && array.length>0){\n\t\treturn array;\n\t}\n\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n   if(array==null || array.length==0){return EMPTY_BOOLEAN_OBJECT_ARRAY;}\n   return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n    return array==null||array.length==0?EMPTY_BOOLEAN_OBJECT_ARRAY:array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n    if(isEmpty(array)){\n        return EMPTY_BOOLEAN_OBJECT_ARRAY;\n    }\n    return array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array == null || array.length == 0){\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\treturn isNullOrEmpty(array)? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}", "public static Boolean[] nullToEmpty(final Boolean[] array){\n\n\tif(array == null){return EMPTY_BOOLEAN_OBJECT_ARRAY;}\n\treturn array.length == 0 ? EMPTY_BOOLEAN_OBJECT_ARRAY : array;\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179e8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null) return null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0; i<array.length; i++) result[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array == null){return null;}\n\tbyte[] primitive = new byte[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tprimitive[i] = array[i].byteValue();\n\t}\n\treturn primitive;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null)return null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0; i<array.length; i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n    if (array==null)\n        return null;\n    final byte[] result=new byte[array.length];\n    for (int i=0; i<array.length; ++i)\n        result[i]=array[i].byteValue();\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null) return null;\n\tfinal byte[] result = new byte[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].byteValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\treturn toPrimitive(array,array.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\tfinal byte[] output=new byte[array.length];\n\tfor (int i=0; i<output.length; i++) output[i]=array[i];\n\treturn output;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\tfinal byte[] out=new byte[array.length];\n\tfor (int i=0; i<array.length; i++) out[i]=array[i].byteValue();\n\treturn out;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte[] toPrimitive(final Byte[] array){\n\nif(array==null)return null;\nfinal byte[] res=new byte[array.length];\nfor(int i=0;i<array.length;i++)res[i]=array[i];\nreturn res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Bytes to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Byte</code> array, may be <code>null</code>\n * @return a <code>byte</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null) return null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0; i<array.length; i++) result[i]=array[i];\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array == null){return null;}\n\tbyte[] primitive = new byte[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tprimitive[i] = array[i].byteValue();\n\t}\n\treturn primitive;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null)return null;\n\tfinal byte[] result=new byte[array.length];\n\tfor(int i=0; i<array.length; i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n    if (array==null)\n        return null;\n    final byte[] result=new byte[array.length];\n    for (int i=0; i<array.length; ++i)\n        result[i]=array[i].byteValue();\n    return result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif(array==null) return null;\n\tfinal byte[] result = new byte[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].byteValue();\n\t}\n\treturn result;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\treturn toPrimitive(array,array.length);\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\tfinal byte[] output=new byte[array.length];\n\tfor (int i=0; i<output.length; i++) output[i]=array[i];\n\treturn output;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\n\tif (array==null) return null;\n\tfinal byte[] out=new byte[array.length];\n\tfor (int i=0; i<array.length; i++) out[i]=array[i].byteValue();\n\treturn out;\n}", "public static byte[] toPrimitive(final Byte[] array){\n\nif(array==null)return null;\nfinal byte[] res=new byte[array.length];\nfor(int i=0;i<array.length;i++)res[i]=array[i];\nreturn res;\n}"], "code_level": "self_contained", "_id": "636767031a6d9265ec0178e6", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String reverse(final String str){\n\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i=str.length()-1; i>=0; i--){\n\t\tsb.append(str.charAt(i));\n\t}\n\treturn sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n\tif(str == null) return null;\n\tString rev = \"\";\n\tfor(int i = str.length()-1; i>=0; i--)\n\t\trev += str.charAt(i);\n\treturn rev;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String reverse(final String str){\n\n\tString result = \"\";\n\tint i;\n\tfor(i = str.length() - 1; i >= 0; i--){\n\t\tresult += str.charAt(i);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n    String reverse = \"\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        reverse = reverse + str.charAt(i);\n    }\n    return reverse;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n\t\tif(str.length()<=1){\n\t\t\treturn str;\n\t\t}\n\t\treturn reverse(str.substring(1))+str.charAt(0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n    String reverseString = \"\";\n    for (int i = str.length() - 1; i >= 0; i--){\n        reverseString = reverseString + str.charAt(i);\n    }\n    return reverseString;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n\tString result=\"\";\n\tfor(int i=str.length()-1;i>=0;i--){\n\t\tresult=result+str.charAt(i);\n\t}return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n\tStringBuilder builder = new StringBuilder(str);\n\treturn builder.reverse().toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n    StringBuilder sb = new StringBuilder();\n    for(int i = str.length() - 1; i >= 0; i--){\n        sb.append(str.charAt(i));\n    }\n    return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String reverse(final String str){\n\n\tString result = \"\";\n\tfor(int i = str.length()-1;i>=0;i--){\n\t\tresult = result + str.charAt(i);\n\t}\nreturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Reverses a String as per  {@link StringBuilder#reverse()}.</p> <p>A <code>null</code> String returns <code>null</code>.</p> <pre> StringUtils.reverse(null)  = null StringUtils.reverse(\"\")    = \"\" StringUtils.reverse(\"bat\") = \"tab\" </pre>\n * @param str  the String to reverse, may be null\n * @return the reversed String, <code>null</code> if null String input\n */\n", "method_name": "reverse", "codes": ["public static String reverse(final String str){\n\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i=str.length()-1; i>=0; i--){\n\t\tsb.append(str.charAt(i));\n\t}\n\treturn sb.toString();\n}", "public static String reverse(final String str){\n\n\tif(str == null) return null;\n\tString rev = \"\";\n\tfor(int i = str.length()-1; i>=0; i--)\n\t\trev += str.charAt(i);\n\treturn rev;\n}", "public static String reverse(final String str){\n\n\tString result = \"\";\n\tint i;\n\tfor(i = str.length() - 1; i >= 0; i--){\n\t\tresult += str.charAt(i);\n\t}\n\treturn result;\n}", "public static String reverse(final String str){\n\n    String reverse = \"\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        reverse = reverse + str.charAt(i);\n    }\n    return reverse;\n}", "public static String reverse(final String str){\n\n\t\tif(str.length()<=1){\n\t\t\treturn str;\n\t\t}\n\t\treturn reverse(str.substring(1))+str.charAt(0);\n}", "public static String reverse(final String str){\n\n    String reverseString = \"\";\n    for (int i = str.length() - 1; i >= 0; i--){\n        reverseString = reverseString + str.charAt(i);\n    }\n    return reverseString;\n}", "public static String reverse(final String str){\n\n\tString result=\"\";\n\tfor(int i=str.length()-1;i>=0;i--){\n\t\tresult=result+str.charAt(i);\n\t}return result;\n}", "public static String reverse(final String str){\n\n\tStringBuilder builder = new StringBuilder(str);\n\treturn builder.reverse().toString();\n}", "public static String reverse(final String str){\n\n    StringBuilder sb = new StringBuilder();\n    for(int i = str.length() - 1; i >= 0; i--){\n        sb.append(str.charAt(i));\n    }\n    return sb.toString();\n}", "public static String reverse(final String str){\n\n\tString result = \"\";\n\tfor(int i = str.length()-1;i>=0;i--){\n\t\tresult = result + str.charAt(i);\n\t}\nreturn result;\n}"], "code_level": "slib_runnable", "_id": "636767001a6d9265ec017873", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isDigits(String str){\n\n\tif(str==null || str.trim().length()==0){\n\t\treturn false;\n\t}else{\n\t\tint length=str.length();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tif(!Character.isDigit(str.charAt(i))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str){\n\n\tfor(int i=0;i<str.length();i++){\n\t\tif(!Character.isDigit(str.charAt(i))) return false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str){\n\n\t   if(isEmpty(str)){\n\t\t   return false;\n\t   }\n\t   for(int i=0;i<str.length();i++){\n\t\t   if(!Character.isDigit(str.charAt(i))){\n\t\t\t   return false;\n\t\t   }\n\t   }\n\t   return true;\n   }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str){\n\n\tif(str==null)\n\t\treturn false;\n\tif(\"\".equals(str))\n\t\treturn false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c=str.charAt(i);\n\t\tif(c<'0'||c>'9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str){\n\n\tint len = str.length();\n\tif(len == 0) return false;\n\tfor(int i = 0; i < len; i++){\n\t\tchar c = str.charAt(i);\n\t\tif(c < '0' || c > '9') return false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str){\n\n\tboolean isDigit = false;\n\tfor(int i = 0;i < str.length();i++){\n\t\tisDigit = Character.isDigit(str.charAt(i));\n\t\tif(!isDigit){\n\t\t\treturn isDigit;\n\t\t}\n\t}\n\treturn isDigit;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str){\n\n\tif(null==str || \"\".equals(str))\n\t\treturn false;\n\tchar[] array = str.toCharArray();\n\tfor (char c : array) {\n\t\tif(!isDigit(c))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean isDigits(String str){\n\n\tif(str==null||str.length()==0)\n\t\treturn false;\n\tfor(int i=0;i<str.length();i++){\n\t\tif(!Character.isDigit(str.charAt(i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str){\n\n\tif(str==null || str.length()==0) return false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c=str.charAt(i);\n\t\tif(c<'0' || c>'9') return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isDigits(String str){\n\n\tif(null == str || \"\".equals(str)) return false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c = str.charAt(i);\n\t\tif(!Character.isDigit(c))return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether the <code>String</code> contains only digit characters.</p> <p><code>Null</code> and empty String will return <code>false</code>.</p>\n * @param str  the <code>String</code> to check\n * @return <code>true</code> if str contains only unicode numeric\n */\n", "method_name": "isDigits", "codes": ["public static boolean isDigits(String str){\n\n\tif(str==null || str.trim().length()==0){\n\t\treturn false;\n\t}else{\n\t\tint length=str.length();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tif(!Character.isDigit(str.charAt(i))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}", "public static boolean isDigits(String str){\n\n\tfor(int i=0;i<str.length();i++){\n\t\tif(!Character.isDigit(str.charAt(i))) return false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\t   if(isEmpty(str)){\n\t\t   return false;\n\t   }\n\t   for(int i=0;i<str.length();i++){\n\t\t   if(!Character.isDigit(str.charAt(i))){\n\t\t\t   return false;\n\t\t   }\n\t   }\n\t   return true;\n   }", "public static boolean isDigits(String str){\n\n\tif(str==null)\n\t\treturn false;\n\tif(\"\".equals(str))\n\t\treturn false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c=str.charAt(i);\n\t\tif(c<'0'||c>'9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\tint len = str.length();\n\tif(len == 0) return false;\n\tfor(int i = 0; i < len; i++){\n\t\tchar c = str.charAt(i);\n\t\tif(c < '0' || c > '9') return false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\tboolean isDigit = false;\n\tfor(int i = 0;i < str.length();i++){\n\t\tisDigit = Character.isDigit(str.charAt(i));\n\t\tif(!isDigit){\n\t\t\treturn isDigit;\n\t\t}\n\t}\n\treturn isDigit;\n}", "public static boolean isDigits(String str){\n\n\tif(null==str || \"\".equals(str))\n\t\treturn false;\n\tchar[] array = str.toCharArray();\n\tfor (char c : array) {\n\t\tif(!isDigit(c))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\tif(str==null||str.length()==0)\n\t\treturn false;\n\tfor(int i=0;i<str.length();i++){\n\t\tif(!Character.isDigit(str.charAt(i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\tif(str==null || str.length()==0) return false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c=str.charAt(i);\n\t\tif(c<'0' || c>'9') return false;\n\t}\n\treturn true;\n}", "public static boolean isDigits(String str){\n\n\tif(null == str || \"\".equals(str)) return false;\n\tfor(int i=0;i<str.length();i++){\n\t\tchar c = str.charAt(i);\n\t\tif(!Character.isDigit(c))return false;\n\t}\n\treturn true;\n}"], "code_level": "slib_runnable", "_id": "636766ff1a6d9265ec01784b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null) return false;\n\tif(suffix.length()>str.length()) return false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\nreturn (str.length()>=suffix.length()&&str.regionMatches(ignoreCase,str.length()-suffix.length(),suffix,0,suffix.length()));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)return false;\n\tfinal int strLen=str.length();\n\tfinal int suffixLen=suffix.length();\n\tif(suffixLen>strLen)return false;\n\tfinal int pos=strLen-suffixLen;\n\tfinal String str2=str.substring(pos);\n\treturn equals(str2,suffix,ignoreCase);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null){\n\t\treturn false;\n\t}\n\tif(suffix.length()>str.length()){\n\t\treturn false;\n\t}\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)return false;\n\treturn str.regionMatches(ignoreCase,str.length()-suffix.length(),suffix,0,suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(suffix.length()>str.length())\n\t\treturn false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\nfinal int strLen=str.length();\nfinal int suffixLen=suffix.length();\nif(suffixLen>strLen)\nreturn false;\nif(suffixLen==strLen)\nreturn str.equalsIgnoreCase(suffix);\nreturn str.regionMatches(ignoreCase,strLen-suffixLen,suffix,0,suffixLen);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)\n\t\treturn str==suffix;\n\tif(suffix.length()>str.length())\n\t\treturn false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n    if(str==null||suffix==null)\n        return str==suffix;\n    if(suffix.length()>str.length())\n        return false;\n    final int strOffset=str.length()-suffix.length();\n    return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(null==str||null==suffix){return false;}\n\tfinal int strLen=str.length();\n\tfinal int suffixLen=suffix.length();\n\tif(suffixLen>strLen){return false;}\n\tfinal int strLastIndex = strLen - 1;\n\tfinal int suffixLastIndex = suffixLen - 1;\n\tfor (int i = 0; i <= suffixLastIndex; i++) {\n\t\tfinal char strChar = str.charAt(strLastIndex - i);\n\t\tfinal char suffixChar = suffix.charAt(suffixLastIndex - i);\n\t\tif (strChar != suffixChar) {\n\t\t\tif (!ignoreCase){return false;}\n\t\t\t// The same check as in String.regionMatches():\n\t\t\tif (Character.toUpperCase(strChar) != Character.toUpperCase(suffixChar)\n\t\t\t\t\t&& Character.toLowerCase(strChar) != Character.toLowerCase(suffixChar)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "endsWith", "codes": ["private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null) return false;\n\tif(suffix.length()>str.length()) return false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\nreturn (str.length()>=suffix.length()&&str.regionMatches(ignoreCase,str.length()-suffix.length(),suffix,0,suffix.length()));\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)return false;\n\tfinal int strLen=str.length();\n\tfinal int suffixLen=suffix.length();\n\tif(suffixLen>strLen)return false;\n\tfinal int pos=strLen-suffixLen;\n\tfinal String str2=str.substring(pos);\n\treturn equals(str2,suffix,ignoreCase);\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null){\n\t\treturn false;\n\t}\n\tif(suffix.length()>str.length()){\n\t\treturn false;\n\t}\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)return false;\n\treturn str.regionMatches(ignoreCase,str.length()-suffix.length(),suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(suffix.length()>str.length())\n\t\treturn false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\nfinal int strLen=str.length();\nfinal int suffixLen=suffix.length();\nif(suffixLen>strLen)\nreturn false;\nif(suffixLen==strLen)\nreturn str.equalsIgnoreCase(suffix);\nreturn str.regionMatches(ignoreCase,strLen-suffixLen,suffix,0,suffixLen);\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(str==null||suffix==null)\n\t\treturn str==suffix;\n\tif(suffix.length()>str.length())\n\t\treturn false;\n\tfinal int strOffset=str.length()-suffix.length();\n\treturn str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n    if(str==null||suffix==null)\n        return str==suffix;\n    if(suffix.length()>str.length())\n        return false;\n    final int strOffset=str.length()-suffix.length();\n    return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}", "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n\n\tif(null==str||null==suffix){return false;}\n\tfinal int strLen=str.length();\n\tfinal int suffixLen=suffix.length();\n\tif(suffixLen>strLen){return false;}\n\tfinal int strLastIndex = strLen - 1;\n\tfinal int suffixLastIndex = suffixLen - 1;\n\tfor (int i = 0; i <= suffixLastIndex; i++) {\n\t\tfinal char strChar = str.charAt(strLastIndex - i);\n\t\tfinal char suffixChar = suffix.charAt(suffixLastIndex - i);\n\t\tif (strChar != suffixChar) {\n\t\t\tif (!ignoreCase){return false;}\n\t\t\t// The same check as in String.regionMatches():\n\t\t\tif (Character.toUpperCase(strChar) != Character.toUpperCase(suffixChar)\n\t\t\t\t\t&& Character.toLowerCase(strChar) != Character.toLowerCase(suffixChar)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a35", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array==null || array.length==0)?EMPTY_CHARACTER_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\nreturn array==null||array.length==0?EMPTY_CHARACTER_OBJECT_ARRAY:array;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array==null || array.length==0? EMPTY_CHARACTER_OBJECT_ARRAY: array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\tif (array == null || array.length == 0) {\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array == null || array.length == 0 ? EMPTY_CHARACTER_OBJECT_ARRAY : array);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array==null||array.length==0? EMPTY_CHARACTER_OBJECT_ARRAY: array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_CHARACTER_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array == null) ? EMPTY_CHARACTER_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array != null && array.length != 0 ? array : EMPTY_CHARACTER_OBJECT_ARRAY;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character[] nullToEmpty(final Character[] array){\n\n\tif(array==null || array.length==0){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array==null || array.length==0)?EMPTY_CHARACTER_OBJECT_ARRAY:array;\n}", "public static Character[] nullToEmpty(final Character[] array){\nreturn array==null||array.length==0?EMPTY_CHARACTER_OBJECT_ARRAY:array;}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array==null || array.length==0? EMPTY_CHARACTER_OBJECT_ARRAY: array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\tif (array == null || array.length == 0) {\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array == null || array.length == 0 ? EMPTY_CHARACTER_OBJECT_ARRAY : array);\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array==null||array.length==0? EMPTY_CHARACTER_OBJECT_ARRAY: array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_CHARACTER_OBJECT_ARRAY : array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn (array == null) ? EMPTY_CHARACTER_OBJECT_ARRAY : array;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\treturn array != null && array.length != 0 ? array : EMPTY_CHARACTER_OBJECT_ARRAY;\n}", "public static Character[] nullToEmpty(final Character[] array){\n\n\tif(array==null || array.length==0){\n\t\treturn EMPTY_CHARACTER_OBJECT_ARRAY;\n\t}\n\treturn array;\n}"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017651", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ((array==null)||(array.length==0))?EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn emptyToNull(array,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n    if(isEmpty(array)){\n        return EMPTY_DOUBLE_OBJECT_ARRAY;\n    }\n    return array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn array==null || array.length==0 ? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n    return array==null||array.length==0? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\nreturn array==null||array.length==0?EMPTY_DOUBLE_OBJECT_ARRAY:array;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn isEmpty(array)?EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ObjectUtil.isEmpty(array)? EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ArrayUtils.nullToEmpty(array);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Defensive programming technique to change a <code>null</code> reference to an empty one.</p> <p>This method returns an empty array for a <code>null</code> input array.</p> <p>As a memory optimizing technique an empty array passed in will be overridden with the empty <code>public static</code> references in this class.</p>\n * @param array  the array to check for <code>null</code> or empty\n * @return the same array, <code>public static</code> empty array if <code>null</code> or empty input\n * @since 2.5\n */\n", "method_name": "nullToEmpty", "codes": ["public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ((array==null)||(array.length==0))?EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn emptyToNull(array,true);\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn array == null || array.length == 0 ? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n    if(isEmpty(array)){\n        return EMPTY_DOUBLE_OBJECT_ARRAY;\n    }\n    return array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn array==null || array.length==0 ? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n    return array==null||array.length==0? EMPTY_DOUBLE_OBJECT_ARRAY : array;\n}", "public static Double[] nullToEmpty(final Double[] array){\nreturn array==null||array.length==0?EMPTY_DOUBLE_OBJECT_ARRAY:array;}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn isEmpty(array)?EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ObjectUtil.isEmpty(array)? EMPTY_DOUBLE_OBJECT_ARRAY:array;\n}", "public static Double[] nullToEmpty(final Double[] array){\n\n\treturn ArrayUtils.nullToEmpty(array);\n}"], "code_level": "self_contained", "_id": "636767021a6d9265ec0178bb", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null || array.length==0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null)||(array.length==0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn array==null||array.length==0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn array == null || array.length == 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn array==null || array.length==0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn (array == null) || (array.length <= 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null||array.length==0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn array==null || array.length==0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null || array.length==0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n * @param array  the array to test\n * @return <code>true</code> if the array is empty or <code>null</code>\n * @since 2.1\n */\n", "method_name": "isEmpty", "codes": ["public static boolean isEmpty(final double[] array){\n\n\treturn (array==null || array.length==0);\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null)||(array.length==0);\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn array==null||array.length==0;\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn array == null || array.length == 0;\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn array==null || array.length==0;\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn (array == null) || (array.length <= 0);\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null||array.length==0);\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn array==null || array.length==0;\n}", "public static boolean isEmpty(final double[] array){\n\n\treturn (array==null || array.length==0);\n}"], "code_level": "self_contained", "_id": "636766f01a6d9265ec01762e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n    return ((bool != null) && !bool.booleanValue());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn (bool==null || !bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn isTrue(bool)==false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\tif(bool==null)return true;\n\treturn !bool;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isNotTrue(Boolean bool){\n\n\treturn !(bool.equals(Boolean.TRUE));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n", "method_name": "isNotTrue", "codes": ["public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n    return ((bool != null) && !bool.booleanValue());\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn (bool==null || !bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn isTrue(bool)==false;\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn !isTrue(bool);\n}", "public static boolean isNotTrue(Boolean bool){\n\n\tif(bool==null)return true;\n\treturn !bool;\n}", "public static boolean isNotTrue(Boolean bool){\n\n\treturn !(bool.equals(Boolean.TRUE));\n}"], "code_level": "self_contained", "_id": "636766f21a6d9265ec017677", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result=new double[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].doubleValue();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result=new double[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i]=array[i];\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif (array==null) {return null;}\n\tif (array.length==0){return EMPTY_DOUBLE_ARRAY;}\n\tfinal double[] result = new double[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif (array == null) {\n\t\treturn null;\n\t}else if (array.length == 0) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array == null)return null;\n\tif(array.length == 0)return EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++)result[i] = array[i].doubleValue();\n\treturn result;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array.length==0){return EMPTY_DOUBLE_ARRAY;}\n\tfinal double[] out=new double[array.length];\n\tfor(int i=0; i<array.length; i++){out[i]=array[i];}\n\treturn out;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] ret=new double[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tret[i]=array[i];\n\t}\n\treturn ret;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn EMPTY_DOUBLE_ARAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n\tif(array.length==0)return EMPTY_DOUBLE_ARAY;\n\tfinal double[] r=new double[array.length];\n\tfor(int i=0; i<r.length; i++){\n\t\tr[i]=array[i];\n\t}\n\treturn r;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static double[] toPrimitive(final Double[] array){\n\n  if(array==null){\n    return EMPTY_DOUBLE_ARAY;\n  }\n  final int len=array.length;\n  if(0==len){\n    return EMPTY_DOUBLE_ARAY;\n  }\n  final double[] ret=new double[array.length];\n  for(int i=0;i<len;i++){\n    ret[i]=array[i];\n  }\n  return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of object Doubles to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Double</code> array, may be <code>null</code>\n * @return a <code>double</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result=new double[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].doubleValue();\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result=new double[array.length];\n\tfor(int i=0; i<array.length; i++){\n\t\tresult[i]=array[i];\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif (array==null) {return null;}\n\tif (array.length==0){return EMPTY_DOUBLE_ARRAY;}\n\tfinal double[] result = new double[array.length];\n\tfor (int i=0; i<array.length; i++){\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif (array == null) {\n\t\treturn null;\n\t}else if (array.length == 0) {\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array == null)return null;\n\tif(array.length == 0)return EMPTY_DOUBLE_ARRAY;\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++)result[i] = array[i].doubleValue();\n\treturn result;\n\t}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array.length==0){return EMPTY_DOUBLE_ARRAY;}\n\tfinal double[] out=new double[array.length];\n\tfor(int i=0; i<array.length; i++){out[i]=array[i];}\n\treturn out;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array==null){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tif(array.length==0){\n\t\treturn EMPTY_DOUBLE_ARRAY;\n\t}\n\tfinal double[] ret=new double[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tret[i]=array[i];\n\t}\n\treturn ret;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn EMPTY_DOUBLE_ARAY;\n\t}\n\tfinal double[] result = new double[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].doubleValue();\n\t}\n\treturn result;\n}", "public static double[] toPrimitive(final Double[] array){\n\n\tif(array.length==0)return EMPTY_DOUBLE_ARAY;\n\tfinal double[] r=new double[array.length];\n\tfor(int i=0; i<r.length; i++){\n\t\tr[i]=array[i];\n\t}\n\treturn r;\n}", "public static double[] toPrimitive(final Double[] array){\n\n  if(array==null){\n    return EMPTY_DOUBLE_ARAY;\n  }\n  final int len=array.length;\n  if(0==len){\n    return EMPTY_DOUBLE_ARAY;\n  }\n  final double[] ret=new double[array.length];\n  for(int i=0;i<len;i++){\n    ret[i]=array[i];\n  }\n  return ret;\n}"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017842", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\nif(ch==null)return defaultValue;\nreturn ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\nreturn ch==null?defaultValue:ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null ? defaultValue : ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n\tif(ch!=null){return ch.charValue();}\n\treturn defaultValue;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\nif(ch==null){\nreturn defaultValue;\n}\nreturn ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n    if(ch==null){\n        return defaultValue;\n    }\n    return ch.charValue();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char toChar(final Character ch,final char defaultValue){\n\n  return (ch==null?defaultValue:ch.charValue());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the Character to a char handling <code>null</code>.</p> <pre> CharUtils.toChar(null, 'X') = 'X' CharUtils.toChar(' ', 'X')  = ' ' CharUtils.toChar('A', 'X')  = 'A' </pre>\n * @param ch  the character to convert\n * @param defaultValue  the value to use if the  Character is null\n * @return the char value of the Character or the default if null\n */\n", "method_name": "toChar", "codes": ["public static char toChar(final Character ch,final char defaultValue){\n\nif(ch==null)return defaultValue;\nreturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\nreturn ch==null?defaultValue:ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null ? defaultValue : ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n\tif(ch!=null){return ch.charValue();}\n\treturn defaultValue;\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n\treturn ch==null?defaultValue:ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\nif(ch==null){\nreturn defaultValue;\n}\nreturn ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n    if(ch==null){\n        return defaultValue;\n    }\n    return ch.charValue();\n}", "public static char toChar(final Character ch,final char defaultValue){\n\n  return (ch==null?defaultValue:ch.charValue());\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179cf", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static boolean isAllZeros(String s){\n\n    char[] c = s.toCharArray();\n    for(int i=0; i<c.length; i++){\n        if(c[i] != '0'){\n            return false;\n        }\n    }\n    return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tif(s==null)return false;\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)!='0')return false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tif(s == null)\n\t\treturn true;\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)!='0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n    return s.replaceAll(\"0\", \"\").length()==0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tfor (int i=0;i<s.length();i++){\n\t\tif (s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)!='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tfor(int i = 0; i < s.length(); i++)\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tfor(int i=0;i<s.length();i++)\n\t\tif(s.charAt(i)!='0')\n\t\t\treturn false;\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isAllZeros(String s){\n\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Utility method for  {@link #createNumber(String)}.</p> <p>Returns <code>true</code> if s is <code>null</code>.</p>\n * @param s the String to check\n * @return if it is all zeros or <code>null</code>\n */\n", "method_name": "isAllZeros", "codes": ["private static boolean isAllZeros(String s){\n\n    char[] c = s.toCharArray();\n    for(int i=0; i<c.length; i++){\n        if(c[i] != '0'){\n            return false;\n        }\n    }\n    return true;\n}", "private static boolean isAllZeros(String s){\n\n\tif(s==null)return false;\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)!='0')return false;\n\t}\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n\tif(s == null)\n\t\treturn true;\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)!='0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n    return s.replaceAll(\"0\", \"\").length()==0;\n}", "private static boolean isAllZeros(String s){\n\n\tfor (int i=0;i<s.length();i++){\n\t\tif (s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)!='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "private static boolean isAllZeros(String s){\n\n\tfor(int i = 0; i < s.length(); i++)\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n\tfor(int i=0;i<s.length();i++)\n\t\tif(s.charAt(i)!='0')\n\t\t\treturn false;\n\treturn true;\n}", "private static boolean isAllZeros(String s){\n\n\tfor(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i) != '0')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "636767081a6d9265ec0179a2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(Object object){\n\n\tif(object != null){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\treturn object==null?null:object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\nreturn toString(object,null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(Object object){\n\n    return object==null?null:object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n    if(object == null) return null;\n    return object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\tif(null!=object){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\treturn (object == null) ? null : object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\treturn (object==null) ? null : object.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\tif(object!=null){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(Object object){\n\n\treturn object != null ? object.toString() : null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n", "method_name": "toString", "codes": ["public static String toString(Object object){\n\n\tif(object != null){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "public static String toString(Object object){\n\n\treturn object==null?null:object.toString();\n}", "public static String toString(Object object){\n\nreturn toString(object,null);\n}", "public static String toString(Object object){\n\n    return object==null?null:object.toString();\n}", "public static String toString(Object object){\n\n    if(object == null) return null;\n    return object.toString();\n}", "public static String toString(Object object){\n\n\tif(null!=object){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "public static String toString(Object object){\n\n\treturn (object == null) ? null : object.toString();\n}", "public static String toString(Object object){\n\n\treturn (object==null) ? null : object.toString();\n}", "public static String toString(Object object){\n\n\tif(object!=null){\n\t\treturn object.toString();\n\t}\n\treturn null;\n}", "public static String toString(Object object){\n\n\treturn object != null ? object.toString() : null;\n}"], "code_level": "self_contained", "_id": "636766f21a6d9265ec01767d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal int[] ret = new int[array.length];\n\tfor(int i = 0; i < array.length; i++) ret[i] = array[i];\n\treturn ret;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n    if(array == null){\n        return null;\n    }else if(array.length == 0){\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = array[i].intValue();\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n    if(array==null)return null;\n    if(array.length==0)return ArrayUtils.EMPTY_INT_ARRAY;\n    int[] result=new int[array.length];\n    for(int i=0;i<array.length;i++){\n        result[i]=array[i].intValue();\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int length = array.length;\n\tfinal int[] result = new int[length];\n\tfor(int i=0; i<length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal int[] res=new int[array.length];\n\tfor(int i=0;i<array.length;i++)res[i]=array[i];\n\treturn res;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}else if(array.length == 0){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int[] toPrimitive(final Integer[] array){\n\n\tif(ArrayUtils.isEmpty(array)){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Converts an array of object Integers to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Integer</code> array, may be <code>null</code>\n * @return an <code>int</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal int[] ret = new int[array.length];\n\tfor(int i = 0; i < array.length; i++) ret[i] = array[i];\n\treturn ret;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n    if(array == null){\n        return null;\n    }else if(array.length == 0){\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = array[i].intValue();\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n    if(array==null)return null;\n    if(array.length==0)return ArrayUtils.EMPTY_INT_ARRAY;\n    int[] result=new int[array.length];\n    for(int i=0;i<array.length;i++){\n        result[i]=array[i].intValue();\n    }\n    return result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int length = array.length;\n\tfinal int[] result = new int[length];\n\tfor(int i=0; i<length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(isEmpty(array)){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i];\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return ArrayUtils.EMPTY_INT_ARRAY;\n\tfinal int[] res=new int[array.length];\n\tfor(int i=0;i<array.length;i++)res[i]=array[i];\n\treturn res;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}else if(array.length == 0){\n\t\treturn EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}", "public static int[] toPrimitive(final Integer[] array){\n\n\tif(ArrayUtils.isEmpty(array)){\n\t\treturn ArrayUtils.EMPTY_INT_ARRAY;\n\t}\n\tfinal int[] result = new int[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].intValue();\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "6367670c1a6d9265ec017a2a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<0x20||ch==0x7f);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n    return ch < 32 || ch == 127;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch>0&&ch<32)||ch==127;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\tif(ch>=0&&ch<=31)return true;\n\tif(ch==127)return true;\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn ch < 0x20 || ch == 0x7F;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<=0x1F)||(ch==0x7F);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<=0x1f)||(ch==0x7f);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\treturn ch<' '||ch=='\\u007f';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n\tif((ch >= '\\u0000' && ch <= '\\u001F') || (ch >= '\\u007F' && ch <= '\\u009F')){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiControl(final char ch){\n\n    return ((ch&0x007F)<0x0020);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit control.</p> <pre> CharUtils.isAsciiControl('a')  = false CharUtils.isAsciiControl('A')  = false CharUtils.isAsciiControl('3')  = false CharUtils.isAsciiControl('-')  = false CharUtils.isAsciiControl('\\n') = true CharUtils.isAsciiControl('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 32 or equals 127\n */\n", "method_name": "isAsciiControl", "codes": ["public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<0x20||ch==0x7f);\n}", "public static boolean isAsciiControl(final char ch){\n\n    return ch < 32 || ch == 127;\n}", "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch>0&&ch<32)||ch==127;\n}", "public static boolean isAsciiControl(final char ch){\n\n\tif(ch>=0&&ch<=31)return true;\n\tif(ch==127)return true;\n\treturn false;\n}", "public static boolean isAsciiControl(final char ch){\n\n\treturn ch < 0x20 || ch == 0x7F;\n}", "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<=0x1F)||(ch==0x7F);\n}", "public static boolean isAsciiControl(final char ch){\n\n\treturn (ch<=0x1f)||(ch==0x7f);\n}", "public static boolean isAsciiControl(final char ch){\n\n\treturn ch<' '||ch=='\\u007f';\n}", "public static boolean isAsciiControl(final char ch){\n\n\tif((ch >= '\\u0000' && ch <= '\\u001F') || (ch >= '\\u007F' && ch <= '\\u009F')){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean isAsciiControl(final char ch){\n\n    return ((ch&0x007F)<0x0020);\n}"], "code_level": "self_contained", "_id": "636766fa1a6d9265ec01779d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return new Boolean[0];\n\tfinal Boolean[] newArray = new Boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) newArray[i] = Boolean.valueOf(array[i]);\n\treturn newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i]?Boolean.TRUE:Boolean.FALSE;\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif (array==null)\n\t\treturn null;\n\tif (array.length==0)\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Boolean.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Boolean[] result=new Boolean[length];\n\tfor(int i=0;i<length;i++){result[i]=array[i];}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return new Boolean[0];\n\tfinal Boolean[] newArray=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)newArray[i]=array[i];\n\treturn newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Boolean[0];\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Boolean.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tfinal int length=array.length;\n\tfinal Boolean[] newArray=new Boolean[length];\n\tfor(int i=0;i<length;i++){\n\t\tnewArray[i]=Boolean.valueOf(array[i]);\n\t\t}\n\treturn newArray;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i]?Boolean.TRUE:Boolean.FALSE;\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Boolean[0];\n\tfinal Boolean[] newArray=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++) newArray[i]=Boolean.valueOf(array[i]);\n\treturn newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive booleans to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>boolean</code> array\n * @return a <code>Boolean</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Boolean[] toObject(final boolean[] array){\n\n\tif(array == null) return null;\n\tif(array.length == 0) return new Boolean[0];\n\tfinal Boolean[] newArray = new Boolean[array.length];\n\tfor(int i = 0; i < array.length; i++) newArray[i] = Boolean.valueOf(array[i]);\n\treturn newArray;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i]?Boolean.TRUE:Boolean.FALSE;\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif (array==null)\n\t\treturn null;\n\tif (array.length==0)\n\t\treturn EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Boolean.valueOf(array[i]);\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Boolean[] result=new Boolean[length];\n\tfor(int i=0;i<length;i++){result[i]=array[i];}\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return new Boolean[0];\n\tfinal Boolean[] newArray=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)newArray[i]=array[i];\n\treturn newArray;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Boolean[0];\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Boolean.valueOf(array[i]);\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tfinal int length=array.length;\n\tfinal Boolean[] newArray=new Boolean[length];\n\tfor(int i=0;i<length;i++){\n\t\tnewArray[i]=Boolean.valueOf(array[i]);\n\t\t}\n\treturn newArray;\n\t}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return EMPTY_BOOLEAN_OBJECT_ARRAY;\n\tfinal Boolean[] result=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i]?Boolean.TRUE:Boolean.FALSE;\n\t}\n\treturn result;\n}", "public static Boolean[] toObject(final boolean[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Boolean[0];\n\tfinal Boolean[] newArray=new Boolean[array.length];\n\tfor(int i=0;i<array.length;i++) newArray[i]=Boolean.valueOf(array[i]);\n\treturn newArray;\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec017796", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<result.length;i++){\n\t\tresult[i]=Short.valueOf(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Short[] result=new Short[length];\n\tfor(int i=0;i<length;i++){\n\t\tresult[i]=Short.valueOf(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Short[] result=new Short[length];\n\tfor(int i=0;i<length;i++)result[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return emptyObjectArray;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array == null) return null;\n\tfinal Short[] newArray = new Short[array.length];\n\tfor(int i = 0; i < array.length; i++) newArray[i] = array[i];\n\treturn newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=new Short(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Short[0];\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++) result[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive shorts to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>short</code> array\n * @return a <code>Short</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<result.length;i++){\n\t\tresult[i]=Short.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Short[] result=new Short[length];\n\tfor(int i=0;i<length;i++){\n\t\tresult[i]=Short.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal int length=array.length;\n\tfinal Short[] result=new Short[length];\n\tfor(int i=0;i<length;i++)result[i]=array[i];\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return emptyObjectArray;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array == null) return null;\n\tfinal Short[] newArray = new Short[array.length];\n\tfor(int i = 0; i < array.length; i++) newArray[i] = array[i];\n\treturn newArray;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=Short.valueOf(array[i]);\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)return null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=new Short(array[i]);\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "public static Short[] toObject(final short[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Short[0];\n\tfinal Short[] result=new Short[array.length];\n\tfor(int i=0;i<array.length;i++) result[i]=Short.valueOf(array[i]);\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179f1", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tif(array.length==0)\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=(array[i]==null ? 0 : array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tif(array.length==0)\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\nif(array==null){\nreturn null;\n}\nif(array.length==0){\nreturn ArrayUtils.EMPTY_CHAR_ARRAY;\n}\nfinal char[] result=new char[array.length];\nfor(int i=0;i<array.length;i++){\nresult[i]=array[i].charValue();\n}\nreturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){return null;}\n\tif(array.length==0){return ArrayUtils.EMPTY_CHAR_ARRAY;}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}//end of for\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}else if(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}else{\n\t\tfinal char[] result=new char[array.length];\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tresult[i]=array[i];\n\t\t}\n\t\treturn result;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result = new char[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].charValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=array[i].charValue();\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of object Characters to primitives.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>Character</code> array, may be <code>null</code>\n * @return a <code>char</code> array, <code>null</code> if null array input\n * @throws NullPointerException if array content is <code>null</code>\n */\n", "method_name": "toPrimitive", "codes": ["public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tif(array.length==0)\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=(array[i]==null ? 0 : array[i]);\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tif(array.length==0)\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=array[i];\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\nif(array==null){\nreturn null;\n}\nif(array.length==0){\nreturn ArrayUtils.EMPTY_CHAR_ARRAY;\n}\nfinal char[] result=new char[array.length];\nfor(int i=0;i<array.length;i++){\nresult[i]=array[i].charValue();\n}\nreturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){return null;}\n\tif(array.length==0){return ArrayUtils.EMPTY_CHAR_ARRAY;}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}//end of for\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}else if(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}else{\n\t\tfinal char[] result=new char[array.length];\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tresult[i]=array[i];\n\t\t}\n\t\treturn result;\n\t}\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array == null){\n\t\treturn null;\n\t}\n\tif(array.length == 0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result = new char[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tresult[i] = array[i].charValue();\n\t}\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return ArrayUtils.EMPTY_CHAR_ARRAY;\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=array[i].charValue();\n\treturn result;\n}", "public static char[] toPrimitive(final Character[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tif(array.length==0){\n\t\treturn ArrayUtils.EMPTY_CHAR_ARRAY;\n\t}\n\tfinal char[] result=new char[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=array[i].charValue();\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "636766fe1a6d9265ec017838", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal int length=array.length;\n\tInteger[] result=new Integer[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return new Integer[0];\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=new Integer(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n    if(array==null)\n        return null;\n    if(array.length==0)\n        return new Integer[0];\n    final Integer[] result=new Integer[array.length];\n    for(int i=0;i<array.length;i++)\n        result[i]=array[i];\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tInteger[] temp=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\ttemp[i]=Integer.valueOf(array[i]);\n\t}\n\treturn temp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)return null;\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\nif(array==null)return null;\nif(array.length==0)return new Integer[0];\nfinal Integer[] result=new Integer[array.length];\nfor(int i=0;i<array.length;i++)\nresult[i]=new Integer(array[i]);\nreturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal int length=array.length;\n\tfinal Integer[] result=new Integer[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array == null)\n\t\treturn null;\n\tif(array.length == 0)\n\t\treturn new Integer[0];\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = Integer.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Integer[] toObject(final int[] array){\n\n\tif(array==null) return null;\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){result[i]=array[i];}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive ints to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  an <code>int</code> array\n * @return an <code>Integer</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Integer[] toObject(final int[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal int length=array.length;\n\tInteger[] result=new Integer[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)return null;\n\tif(array.length==0)return new Integer[0];\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=new Integer(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n    if(array==null)\n        return null;\n    if(array.length==0)\n        return new Integer[0];\n    final Integer[] result=new Integer[array.length];\n    for(int i=0;i<array.length;i++)\n        result[i]=array[i];\n    return result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tInteger[] temp=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\ttemp[i]=Integer.valueOf(array[i]);\n\t}\n\treturn temp;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tresult[i]=Integer.valueOf(array[i]);\n\t}\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)return null;\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++)result[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\nif(array==null)return null;\nif(array.length==0)return new Integer[0];\nfinal Integer[] result=new Integer[array.length];\nfor(int i=0;i<array.length;i++)\nresult[i]=new Integer(array[i]);\nreturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tfinal int length=array.length;\n\tfinal Integer[] result=new Integer[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Integer.valueOf(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array == null)\n\t\treturn null;\n\tif(array.length == 0)\n\t\treturn new Integer[0];\n\tfinal Integer[] result = new Integer[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = Integer.valueOf(array[i]);\n\treturn result;\n}", "public static Integer[] toObject(final int[] array){\n\n\tif(array==null) return null;\n\tInteger[] result=new Integer[array.length];\n\tfor(int i=0;i<array.length;i++){result[i]=array[i];}\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636767041a6d9265ec01790f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Double[] toObject(final double[] array){\n\nif(array==null) return null;\nif(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\nfinal Double[] result=new Double[array.length];\nfor(int i=0;i<array.length;i++)\nresult[i]=new Double(array[i]);\nreturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tint length=array.length;\n\tfinal Double[] result=new Double[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Double.valueOf(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Double[0];\n\tfinal Double[] result=new Double[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=new Double(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  final int arrayLength=array.length;\n  Double[] newArray=new Double[arrayLength];\n  for(int i=0;i<arrayLength;i++)newArray[i]=Double.valueOf(array[i]);\n  return newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n\tif(array == null) return null;\n\tfinal int length = array.length;\n\tfinal Double[] result = new Double[length];\n\tfor(int i = 0; i < length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  if(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\n  final Double[] result=new Double[array.length];\n  for(int i=0;i<array.length;i++)\n    result[i]=new Double(array[i]);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  if(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\n  final Double[] result=new Double[array.length];\n  for(int i=0;i<array.length;i++)  result[i]=new Double(array[i]);\n  return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\nreturn java.util.Arrays.stream(array).mapToObj(Double::valueOf).toArray(Double[]::new);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n    if(array==null) return null;\n    if(array.length==0) return new Double[0];\n    final Double[] result=new Double[array.length];\n    for(int i=0;i<array.length;i++)\n        result[i]=new Double(array[i]);\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Double[] toObject(final double[] array){\n\n\tif (array == null)\n\t\treturn null;\n\tif(array.length == 0)\n\t\treturn new Double[0];\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = new Double(array[i]);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts an array of primitive doubles to objects.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  a <code>double</code> array\n * @return a <code>Double</code> array, <code>null</code> if null array input\n */\n", "method_name": "toObject", "codes": ["public static Double[] toObject(final double[] array){\n\nif(array==null) return null;\nif(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\nfinal Double[] result=new Double[array.length];\nfor(int i=0;i<array.length;i++)\nresult[i]=new Double(array[i]);\nreturn result;\n}", "public static Double[] toObject(final double[] array){\n\n\tif(array==null)\n\t\treturn null;\n\tint length=array.length;\n\tfinal Double[] result=new Double[length];\n\tfor(int i=0;i<length;i++)\n\t\tresult[i]=Double.valueOf(array[i]);\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\n\tif(array==null) return null;\n\tif(array.length==0) return new Double[0];\n\tfinal Double[] result=new Double[array.length];\n\tfor(int i=0;i<array.length;i++)\n\t\tresult[i]=new Double(array[i]);\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  final int arrayLength=array.length;\n  Double[] newArray=new Double[arrayLength];\n  for(int i=0;i<arrayLength;i++)newArray[i]=Double.valueOf(array[i]);\n  return newArray;\n}", "public static Double[] toObject(final double[] array){\n\n\tif(array == null) return null;\n\tfinal int length = array.length;\n\tfinal Double[] result = new Double[length];\n\tfor(int i = 0; i < length; i++){\n\t\tresult[i] = new Double(array[i]);\n\t}\n\treturn result;\n}", "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  if(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\n  final Double[] result=new Double[array.length];\n  for(int i=0;i<array.length;i++)\n    result[i]=new Double(array[i]);\n  return result;\n}", "public static Double[] toObject(final double[] array){\n\n  if(array==null) return null;\n  if(array.length==0) return EMPTY_DOUBLE_OBJECT_ARRAY;\n  final Double[] result=new Double[array.length];\n  for(int i=0;i<array.length;i++)  result[i]=new Double(array[i]);\n  return result;\n}", "public static Double[] toObject(final double[] array){\n\nreturn java.util.Arrays.stream(array).mapToObj(Double::valueOf).toArray(Double[]::new);\n}", "public static Double[] toObject(final double[] array){\n\n    if(array==null) return null;\n    if(array.length==0) return new Double[0];\n    final Double[] result=new Double[array.length];\n    for(int i=0;i<array.length;i++)\n        result[i]=new Double(array[i]);\n    return result;\n}", "public static Double[] toObject(final double[] array){\n\n\tif (array == null)\n\t\treturn null;\n\tif(array.length == 0)\n\t\treturn new Double[0];\n\tfinal Double[] result = new Double[array.length];\n\tfor(int i = 0; i < array.length; i++)\n\t\tresult[i] = new Double(array[i]);\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a4", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(str==null||prefix==null)return(str==null&&prefix==null);\nif(prefix.length()>str.length())return false;\nreturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\treturn str == null ? prefix == null : (prefix != null && (ignoreCase ? str.toLowerCase().startsWith(prefix.toLowerCase()) : str.startsWith(prefix)));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(str==null||prefix==null){\n\t\treturn (str==null&&prefix==null);\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(str==null||prefix==null)return str==null&&prefix==null;\nif(prefix.length()>str.length())return false;\nreturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(null == str || null == prefix){\nreturn(null == str && null == prefix);\n}\nif(ignoreCase){\nreturn str.regionMatches(true,0,prefix,0,prefix.length());\n}\nreturn str.startsWith(prefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(null==str||null==prefix){\n\t\treturn null==str&&null==prefix;\n\t}\n\tif(ignoreCase){\n\t\treturn str.toLowerCase().startsWith(prefix.toLowerCase());\n\t}\n\treturn str.startsWith(prefix);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif((str==null)||(prefix==null)){\n\t\treturn ((str==null)&&(prefix==null));\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(str==null||prefix==null){\n\t\treturn str==null&&prefix==null;\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\treturn startsWith(str,prefix,ignoreCase,null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n    if(null==str||null==prefix){\n        return (null==str&&null==prefix);\n    }\n    if(ignoreCase){\n        return str.toLowerCase().startsWith(prefix.toLowerCase());\n    }else{\n        return str.startsWith(prefix);\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n * @see String#startsWith(String)\n * @param str  the String to check, may be null\n * @param prefix the prefix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n", "method_name": "startsWith", "codes": ["private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(str==null||prefix==null)return(str==null&&prefix==null);\nif(prefix.length()>str.length())return false;\nreturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\treturn str == null ? prefix == null : (prefix != null && (ignoreCase ? str.toLowerCase().startsWith(prefix.toLowerCase()) : str.startsWith(prefix)));\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(str==null||prefix==null){\n\t\treturn (str==null&&prefix==null);\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(str==null||prefix==null)return str==null&&prefix==null;\nif(prefix.length()>str.length())return false;\nreturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\nif(null == str || null == prefix){\nreturn(null == str && null == prefix);\n}\nif(ignoreCase){\nreturn str.regionMatches(true,0,prefix,0,prefix.length());\n}\nreturn str.startsWith(prefix);\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(null==str||null==prefix){\n\t\treturn null==str&&null==prefix;\n\t}\n\tif(ignoreCase){\n\t\treturn str.toLowerCase().startsWith(prefix.toLowerCase());\n\t}\n\treturn str.startsWith(prefix);\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif((str==null)||(prefix==null)){\n\t\treturn ((str==null)&&(prefix==null));\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\tif(str==null||prefix==null){\n\t\treturn str==null&&prefix==null;\n\t}\n\tif(prefix.length()>str.length()){\n\t\treturn false;\n\t}\n\treturn str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n\treturn startsWith(str,prefix,ignoreCase,null);\n}", "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n\n    if(null==str||null==prefix){\n        return (null==str&&null==prefix);\n    }\n    if(ignoreCase){\n        return str.toLowerCase().startsWith(prefix.toLowerCase());\n    }else{\n        return str.startsWith(prefix);\n    }\n}"], "code_level": "self_contained", "_id": "636767151a6d9265ec017b6b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\nreturn new Character(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n\treturn new Character(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Character toCharacterObject(final char ch){\n\n\treturn new Character(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n", "method_name": "toCharacterObject", "codes": ["public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\nreturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n\treturn Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n\treturn new Character(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n    return Character.valueOf(ch);\n}", "public static Character toCharacterObject(final char ch){\n\n\treturn new Character(ch);\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01781c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn ch>='A'&&ch<='Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A'&&ch<='Z');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn ch >= 'A' && ch <= 'Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\nreturn 'A' <= ch && ch <= 'Z';}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn ch>='A' && ch<='Z';\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A')&&(ch<='Z');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A'&&ch<='Z');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn ch>='A'&&ch<='Z';\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn (ch>= 'A' && ch<='Z');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAsciiAlphaUpper(final char ch){\n\n    return ch>=0x41&&ch<=0x5A;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p> <pre> CharUtils.isAsciiAlphaUpper('a')  = false CharUtils.isAsciiAlphaUpper('A')  = true CharUtils.isAsciiAlphaUpper('3')  = false CharUtils.isAsciiAlphaUpper('-')  = false CharUtils.isAsciiAlphaUpper('\\n') = false CharUtils.isAsciiAlphaUpper('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if between 65 and 90 inclusive\n */\n", "method_name": "isAsciiAlphaUpper", "codes": ["public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn ch>='A'&&ch<='Z';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A'&&ch<='Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn ch >= 'A' && ch <= 'Z';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\nreturn 'A' <= ch && ch <= 'Z';}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn ch>='A' && ch<='Z';\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A')&&(ch<='Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn (ch>='A'&&ch<='Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n\treturn ch>='A'&&ch<='Z';\n\t}", "public static boolean isAsciiAlphaUpper(final char ch){\n\nreturn (ch>= 'A' && ch<='Z');\n}", "public static boolean isAsciiAlphaUpper(final char ch){\n\n    return ch>=0x41&&ch<=0x5A;\n}"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c1", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int length(final String str){\n\nreturn (null==str)?0:str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\treturn str==null?0:str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n    return str==null?0:str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\nif(str==null){\nreturn 0;\n}\nreturn str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\treturn str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\treturn str==null?0:str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\treturn str==null?0:str.length();\t\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\tif(str==null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\treturn str == null ? 0 : str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int length(final String str){\n\n\tif(str==null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n * @param str a String or <code>null</code>\n * @return String length or <code>0</code> if the String is <code>null</code>.\n * @since 2.4\n */\n", "method_name": "length", "codes": ["public static int length(final String str){\n\nreturn (null==str)?0:str.length();\n}", "public static int length(final String str){\n\n\treturn str==null?0:str.length();\n}", "public static int length(final String str){\n\n    return str==null?0:str.length();\n}", "public static int length(final String str){\n\nif(str==null){\nreturn 0;\n}\nreturn str.length();\n}", "public static int length(final String str){\n\n\treturn str == null ? 0 : str.length();\n}", "public static int length(final String str){\n\n\treturn str==null?0:str.length();\n}", "public static int length(final String str){\n\n\treturn str==null?0:str.length();\t\n}", "public static int length(final String str){\n\n\tif(str==null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}", "public static int length(final String str){\n\n\treturn str == null ? 0 : str.length();\n}", "public static int length(final String str){\n\n\tif(str==null){\n\t\treturn 0;\n\t}\n\treturn str.length();\n}"], "code_level": "self_contained", "_id": "6367670a1a6d9265ec0179d9", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToArray(s));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String base64Decode(final String s){\n\n\t//convert the string to bytes\n\tbyte[] bytes=s.getBytes();\n\t//get bytes' length\n\tint length=bytes.length;\n\t//if the string is null,return null\n\tif(length==0){\n\t\treturn null;\n\t}\n\t//if the string is not null,decode it to an array\n\tbyte[] decoded=base64Decode(bytes,0,length);\n\t//convert the array to string\n\ttry{\n\t\treturn new String(decoded,UTF_8);\n\t}\n\t//if the string is not UTF_8,return null\n\tcatch(UnsupportedEncodingException e){\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\tStringBuilder sb = new StringBuilder(s);\n\tStringBuilder sb2 = new StringBuilder(s);\n\tsb.delete(0,sb.length());\n\tsb2.delete(0,sb2.length());\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='='){\n\t\t\tbreak;\n\t\t}\n\t\tsb.append(s.charAt(i));\n\t}\n\tString s2 = sb.toString();\n\tsb.delete(0,sb.length());\n\tint length = s2.length();\n\tint mod = length%4;\n\tif(mod==1){\n\t\treturn null;\n\t}\n\tfor(int i=0;i<mod;i++){\n\t\tsb.append(\"=\");\n\t}\n\tsb2.append(sb.toString());\n\tbyte[] bytes = base64Decode(s2.getBytes());\n\tif(bytes==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToBytes(s),Charset.forName(\"UTF_8\"));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\treturn new String(base64Decode(s.getBytes(Charset.forName(\"UTF-8\"))));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToBytes(s), UTF_8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\ttry{\n\t\treturn new String(base64Decode(s.getBytes(\"UTF-8\")),\"UTF-8\");\n\t}catch(UnsupportedEncodingException e){\n\t\te.printStackTrace();\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\t\tif(s==null)\n\t\t\treturn null;\n\t\t\n\t\tbyte[] bs=s.getBytes(Charset.forName(\"US-ASCII\"));//the Base64 code is ASCII code.\n\t\tint len=s.length();\n\t\tint pos=0;\n\t\tbyte[] bs2=new byte[len*3/4];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint val=bs[i];\n\t\t\tif(val=='='){//'=' is padding.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(val>=0&&val<=127){\n\t\t\t\tval=table_decode[val];\n\t\t\t\tif(val==-1){//invalid character.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i%4==0){\n\t\t\t\t\tbs2[pos++]=(byte)(val<<2);\n\t\t\t\t}else if(i%4==1){", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\tfinal byte[] b = base64DecodeToByte(s);\n\treturn new String(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String base64Decode(final String s){\n\n\tbyte[] b=s.getBytes();\n\tbyte[] c=base64Decode(b);\n\treturn new String(c);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n", "method_name": "base64Decode", "codes": ["public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToArray(s));\n}", "public static String base64Decode(final String s){\n\n\t//convert the string to bytes\n\tbyte[] bytes=s.getBytes();\n\t//get bytes' length\n\tint length=bytes.length;\n\t//if the string is null,return null\n\tif(length==0){\n\t\treturn null;\n\t}\n\t//if the string is not null,decode it to an array\n\tbyte[] decoded=base64Decode(bytes,0,length);\n\t//convert the array to string\n\ttry{\n\t\treturn new String(decoded,UTF_8);\n\t}\n\t//if the string is not UTF_8,return null\n\tcatch(UnsupportedEncodingException e){\n\t\treturn null;\n\t}\n}", "public static String base64Decode(final String s){\n\n\tStringBuilder sb = new StringBuilder(s);\n\tStringBuilder sb2 = new StringBuilder(s);\n\tsb.delete(0,sb.length());\n\tsb2.delete(0,sb2.length());\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='='){\n\t\t\tbreak;\n\t\t}\n\t\tsb.append(s.charAt(i));\n\t}\n\tString s2 = sb.toString();\n\tsb.delete(0,sb.length());\n\tint length = s2.length();\n\tint mod = length%4;\n\tif(mod==1){\n\t\treturn null;\n\t}\n\tfor(int i=0;i<mod;i++){\n\t\tsb.append(\"=\");\n\t}\n\tsb2.append(sb.toString());\n\tbyte[] bytes = base64Decode(s2.getBytes());\n\tif(bytes==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\t", "public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToBytes(s),Charset.forName(\"UTF_8\"));\n}", "public static String base64Decode(final String s){\n\n\treturn new String(base64Decode(s.getBytes(Charset.forName(\"UTF-8\"))));\n}", "public static String base64Decode(final String s){\n\n\treturn new String(base64DecodeToBytes(s), UTF_8);\n}", "public static String base64Decode(final String s){\n\n\ttry{\n\t\treturn new String(base64Decode(s.getBytes(\"UTF-8\")),\"UTF-8\");\n\t}catch(UnsupportedEncodingException e){\n\t\te.printStackTrace();\n\t\treturn null;\n\t}\n}", "public static String base64Decode(final String s){\n\n\t\tif(s==null)\n\t\t\treturn null;\n\t\t\n\t\tbyte[] bs=s.getBytes(Charset.forName(\"US-ASCII\"));//the Base64 code is ASCII code.\n\t\tint len=s.length();\n\t\tint pos=0;\n\t\tbyte[] bs2=new byte[len*3/4];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint val=bs[i];\n\t\t\tif(val=='='){//'=' is padding.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(val>=0&&val<=127){\n\t\t\t\tval=table_decode[val];\n\t\t\t\tif(val==-1){//invalid character.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i%4==0){\n\t\t\t\t\tbs2[pos++]=(byte)(val<<2);\n\t\t\t\t}else if(i%4==1){", "public static String base64Decode(final String s){\n\n\tfinal byte[] b = base64DecodeToByte(s);\n\treturn new String(b);\n}", "public static String base64Decode(final String s){\n\n\tbyte[] b=s.getBytes();\n\tbyte[] c=base64Decode(b);\n\treturn new String(c);\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017748", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\tif(array2==null){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(array2==null){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tif(array1.length==array2.length){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\treturn array2!=null&&array1.length==array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}else if(array2==null){\n\t\treturn array1==null;\n\t}else{\n\t\treturn array1.length==array2.length;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn(array1==null&&array2==null)||(array1!=null&&array2!=null&&array1.length==array2.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==array2)return true;\n\tif(array1==null||array2==null)return false;\n\t\n\tint length=array1.length;\n\tif(length!=array2.length)return false;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1 == null && array2 == null){\n\t\treturn true;\n\t}else if(array1 == null && array2 != null){\n\t\treturn false;\n\t}else if(array1 != null && array2 == null){\n\t\treturn false;\n\t}else{\n\t\treturn array1.length == array2.length;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn array1==null?array2==null:array2!=null&&array1.length==array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif((array1==null&&array2!=null)||(array1!=null&&array2==null)){\n\t\treturn false;\n\t}\n\tif(array1==null&&array2==null){\n\t\treturn true;\n\t}\n\treturn array1.length==array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\tif(array2==null){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn (array1==null&&array2==null)||(array1!=null&&array2!=null&&array1.length==array2.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>\n * @param array1 the first array, may be <code>null</code>\n * @param array2 the second array, may be <code>null</code>\n * @return <code>true</code> if length of arrays matches, treating<code>null</code> as an empty array\n */\n", "method_name": "isSameLength", "codes": ["public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\tif(array2==null){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(array2==null){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tif(array1.length==array2.length){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\treturn array2!=null&&array1.length==array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}else if(array2==null){\n\t\treturn array1==null;\n\t}else{\n\t\treturn array1.length==array2.length;\n\t}\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn(array1==null&&array2==null)||(array1!=null&&array2!=null&&array1.length==array2.length);\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==array2)return true;\n\tif(array1==null||array2==null)return false;\n\t\n\tint length=array1.length;\n\tif(length!=array2.length)return false;\n\treturn true;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1 == null && array2 == null){\n\t\treturn true;\n\t}else if(array1 == null && array2 != null){\n\t\treturn false;\n\t}else if(array1 != null && array2 == null){\n\t\treturn false;\n\t}else{\n\t\treturn array1.length == array2.length;\n\t}\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn array1==null?array2==null:array2!=null&&array1.length==array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif((array1==null&&array2!=null)||(array1!=null&&array2==null)){\n\t\treturn false;\n\t}\n\tif(array1==null&&array2==null){\n\t\treturn true;\n\t}\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\tif(array1==null){\n\t\treturn array2==null;\n\t}\n\tif(array2==null){\n\t\treturn false;\n\t}\n\treturn array1.length==array2.length;\n}", "public static boolean isSameLength(final double[] array1,final double[] array2){\n\n\treturn (array1==null&&array2==null)||(array1!=null&&array2!=null&&array1.length==array2.length);\n}"], "code_level": "self_contained", "_id": "636766f11a6d9265ec017663", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static char[] clone(final char[] array){\n\n\treturn (char[])array.clone();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static char[] clone(final char[] array){\n\nif(array==null)return null;\nreturn array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array){\n\n\tfinal char[] clone=new char[array.length];\n\tSystem.arraycopy(array,0,clone,0,array.length);\n\treturn clone;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static char[] clone(final char[] array){\n\n\tif(array == null)\n\t\treturn null;\n\tfinal int length = array.length;\n\tfinal char[] copy = new char[length];\n\tSystem.arraycopy(array, 0, copy, 0, length);\n\treturn copy;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array){\n\n\treturn array==null ? null : array.clone();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static char[] clone(final char[] array){\n\n    if(array == null) return null;\n    final char[] clone = new char[array.length];\n    System.arraycopy(array,0,clone,0,array.length);\n    return clone;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static char[] clone(final char[] array){\n\n    return array.clone();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n * @param array  the array to clone, may be <code>null</code>\n * @return the cloned array, <code>null</code> if <code>null</code> input\n */\n", "method_name": "clone", "codes": ["public static char[] clone(final char[] array){\n\n\treturn (char[])array.clone();\n}", "public static char[] clone(final char[] array){\n\nif(array==null)return null;\nreturn array.clone();\n}", "public static char[] clone(final char[] array){\n\n\tfinal char[] clone=new char[array.length];\n\tSystem.arraycopy(array,0,clone,0,array.length);\n\treturn clone;\n}", "public static char[] clone(final char[] array){\n\n\tif(array == null)\n\t\treturn null;\n\tfinal int length = array.length;\n\tfinal char[] copy = new char[length];\n\tSystem.arraycopy(array, 0, copy, 0, length);\n\treturn copy;\n}", "public static char[] clone(final char[] array){\n\n\treturn array==null ? null : array.clone();\n}", "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "public static char[] clone(final char[] array){\n\n    if(array == null) return null;\n    final char[] clone = new char[array.length];\n    System.arraycopy(array,0,clone,0,array.length);\n    return clone;\n}", "public static char[] clone(final char[] array){\n\n\treturn array.clone();\n}", "public static char[] clone(final char[] array){\n\n    return array.clone();\n}"], "code_level": "self_contained", "_id": "636766f31a6d9265ec01768f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn (ch & 0x80)==0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n    return ch<128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\nreturn ch < 128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn(ch>=0x00 && ch<=0x7F);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n\treturn(ch<128);\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\nreturn ch<128;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean isAscii(final char ch){\n\n    return ch<128;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Checks whether the character is ASCII 7 bit.</p> <pre> CharUtils.isAscii('a')  = true CharUtils.isAscii('A')  = true CharUtils.isAscii('3')  = true CharUtils.isAscii('-')  = true CharUtils.isAscii('\\n') = true CharUtils.isAscii('&copy;') = false </pre>\n * @param ch  the character to check\n * @return true if less than 128\n */\n", "method_name": "isAscii", "codes": ["public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "public static boolean isAscii(final char ch){\n\n\treturn ch<128;\n}", "public static boolean isAscii(final char ch){\n\n\treturn (ch & 0x80)==0;\n}", "public static boolean isAscii(final char ch){\n\n    return ch<128;\n}", "public static boolean isAscii(final char ch){\n\nreturn ch < 128;\n}", "public static boolean isAscii(final char ch){\n\n\treturn(ch>=0x00 && ch<=0x7F);\n}", "public static boolean isAscii(final char ch){\n\n\treturn(ch<128);\n\t}", "public static boolean isAscii(final char ch){\nreturn ch<128;}", "public static boolean isAscii(final char ch){\n\n    return ch<128;\n}"], "code_level": "self_contained", "_id": "636766fb1a6d9265ec0177c3", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String toString(final char ch){\n\n\treturn toString(ch,1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\n\tfinal int size=size(ch);\n\tif (size==1)return String.valueOf(ch);\n\tfinal char[] buf=new char[size];\n\tgetChars(ch,0,size,buf,0);\n\treturn new String(buf);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\nif(ch>=0x10000){\nfinal int cp=ch-0x10000;\nreturn new String(new char[]{\n(char)(0xD800|(cp>>10)),\n(char)(0xDC00|(cp&0x3FF))\n});\n}\nreturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\n\treturn String.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\nreturn String.valueOf(ch);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String toString(final char ch){\n\n\tif(ch>=0 && ch<=255)return CHAR_STRING_ARRAY[ch];\n\treturn String.valueOf(ch);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Converts the character to a String that contains the one character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same String object each time.</p> <pre> CharUtils.toString(' ')  = \" \" CharUtils.toString('A')  = \"A\" </pre>\n * @param ch  the character to convert\n * @return a String containing the one specified character\n */\n", "method_name": "toString", "codes": ["public static String toString(final char ch){\n\n\treturn toString(ch,1);\n}", "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\n\tfinal int size=size(ch);\n\tif (size==1)return String.valueOf(ch);\n\tfinal char[] buf=new char[size];\n\tgetChars(ch,0,size,buf,0);\n\treturn new String(buf);\n}", "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\nif(ch>=0x10000){\nfinal int cp=ch-0x10000;\nreturn new String(new char[]{\n(char)(0xD800|(cp>>10)),\n(char)(0xDC00|(cp&0x3FF))\n});\n}\nreturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\n\treturn String.valueOf(ch);\n}", "public static String toString(final char ch){\n\nreturn String.valueOf(ch);\n}", "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\n\treturn new String(new char[]{ch});\n}", "public static String toString(final char ch){\n\n\tif(ch>=0 && ch<=255)return CHAR_STRING_ARRAY[ch];\n\treturn String.valueOf(ch);\n}"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec017a05", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private void enlarge(final int size){\n\n    this.size+=size;\n    this.data=Arrays.copyOf(data,size);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tbyte[] data=this.data;\n\tint len=data.length;\n\tint newcap=len+size;\n\tif(newcap<0){\n\t\tnewcap=Integer.MAX_VALUE;\n\t}\n\tthis.data=Arrays.copyOf(data, newcap);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size > 128) throw new OutOfMemoryError();\n\tbyte [] newData = new byte[this.data.length + size];\n\tSystem.arraycopy(this.data, 0, newData, 0, this.data.length);\n\tthis.data = newData;\n\tthis.pos = newData.length;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size<1) return;\n\tint newSize=data.length+size;\n\tbyte[] d=new byte[newSize];\n\tSystem.arraycopy(data,0,d,0,size());\n\tdata=d;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n    if(size < 0)\n        throw new IllegalArgumentException(\"size cannot be negative.\");\n    if(size == 0)\n        return;\n    int newSize = data.length;\n    do\n        newSize <<= 1;\n    while((newSize - data.length) < size);\n    final byte[] newData = new byte[newSize];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size<=0)return;\n\tif(this.size+size>this.data.length)\n\t\tthis.data=Arrays.copyOf(this.data, this.size+size);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tfinal int old_size=size();\n\tfinal int new_size=size+size();\n\tfinal byte[] old_data=data;\n\tfinal byte[] new_data=new byte[new_size];\n\tfor(int i=0;i<old_size;i++)new_data[i]=old_data[i];\n\tfor(int i=old_size;i<new_size;i++)new_data[i]=0;\n\tdata=new_data;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tbyte[] data=this.data;\n\tthis.data=new byte[data.length+size];\n\tSystem.arraycopy(data,0,this.data,0,data.length);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size<0) throw new IllegalArgumentException(\"size cannot be negative\");\n\tif(size==0) return;\n\tfinal int oldLen=length;\n\tlength+=size;\n\tif(length>array.length){\n\t\tfinal int oldLen2=oldLen;\n\t\tfinal int oldLen3=oldLen2;\n\t\tfinal int oldLen4=oldLen3;\n\t\tfinal int oldLen5=oldLen4;\n\t\tfinal int oldLen6=oldLen5;\n\t\tfinal int oldLen7=oldLen6;\n\t\tfinal int oldLen8=oldLen7;\n\t\tfinal int oldLen9=oldLen8;\n\t\tfinal int oldLen10=oldLen9;\n\t\tfinal int oldLen11=oldLen10;\n\t\tfinal int oldLen12=oldLen11;\n\t\tfinal int oldLen13=oldLen12;\n\t\tfinal int oldLen14=oldLen13;\n\t\tfinal int oldLen15=oldLen14;\n\t\tfinal int oldLen16=oldLen15;\n\t\tfinal int oldLen", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tfinal int newSize = this.size+size;\n\tif(newSize<=this.data.length) return;\n\tbyte[] newData = new byte[newSize];\n\tSystem.arraycopy(this.data, 0, newData, 0, this.size);\n\tthis.data = newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){\n\n    this.size+=size;\n    this.data=Arrays.copyOf(data,size);\n}", "private void enlarge(final int size){\n\n\tbyte[] data=this.data;\n\tint len=data.length;\n\tint newcap=len+size;\n\tif(newcap<0){\n\t\tnewcap=Integer.MAX_VALUE;\n\t}\n\tthis.data=Arrays.copyOf(data, newcap);\n}", "private void enlarge(final int size){\n\n\tif(size > 128) throw new OutOfMemoryError();\n\tbyte [] newData = new byte[this.data.length + size];\n\tSystem.arraycopy(this.data, 0, newData, 0, this.data.length);\n\tthis.data = newData;\n\tthis.pos = newData.length;\n}", "private void enlarge(final int size){\n\n\tif(size<1) return;\n\tint newSize=data.length+size;\n\tbyte[] d=new byte[newSize];\n\tSystem.arraycopy(data,0,d,0,size());\n\tdata=d;\n}", "private void enlarge(final int size){\n\n    if(size < 0)\n        throw new IllegalArgumentException(\"size cannot be negative.\");\n    if(size == 0)\n        return;\n    int newSize = data.length;\n    do\n        newSize <<= 1;\n    while((newSize - data.length) < size);\n    final byte[] newData = new byte[newSize];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n}", "private void enlarge(final int size){\n\n\tif(size<=0)return;\n\tif(this.size+size>this.data.length)\n\t\tthis.data=Arrays.copyOf(this.data, this.size+size);\n}", "private void enlarge(final int size){\n\n\tfinal int old_size=size();\n\tfinal int new_size=size+size();\n\tfinal byte[] old_data=data;\n\tfinal byte[] new_data=new byte[new_size];\n\tfor(int i=0;i<old_size;i++)new_data[i]=old_data[i];\n\tfor(int i=old_size;i<new_size;i++)new_data[i]=0;\n\tdata=new_data;\n}", "private void enlarge(final int size){\n\n\tbyte[] data=this.data;\n\tthis.data=new byte[data.length+size];\n\tSystem.arraycopy(data,0,this.data,0,data.length);\n}", "private void enlarge(final int size){\n\n\tif(size<0) throw new IllegalArgumentException(\"size cannot be negative\");\n\tif(size==0) return;\n\tfinal int oldLen=length;\n\tlength+=size;\n\tif(length>array.length){\n\t\tfinal int oldLen2=oldLen;\n\t\tfinal int oldLen3=oldLen2;\n\t\tfinal int oldLen4=oldLen3;\n\t\tfinal int oldLen5=oldLen4;\n\t\tfinal int oldLen6=oldLen5;\n\t\tfinal int oldLen7=oldLen6;\n\t\tfinal int oldLen8=oldLen7;\n\t\tfinal int oldLen9=oldLen8;\n\t\tfinal int oldLen10=oldLen9;\n\t\tfinal int oldLen11=oldLen10;\n\t\tfinal int oldLen12=oldLen11;\n\t\tfinal int oldLen13=oldLen12;\n\t\tfinal int oldLen14=oldLen13;\n\t\tfinal int oldLen15=oldLen14;\n\t\tfinal int oldLen16=oldLen15;\n\t\tfinal int oldLen", "private void enlarge(final int size){\n\n\tfinal int newSize = this.size+size;\n\tif(newSize<=this.data.length) return;\n\tbyte[] newData = new byte[newSize];\n\tSystem.arraycopy(this.data, 0, newData, 0, this.size);\n\tthis.data = newData;\n}"], "code_level": "class_runnable", "_id": "636767191a6d9265ec017c0f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "int addType(final String value){\n\n    if(typeTable.contains(value)){//If the type table already contains a similar type, return that type's index\n        return typeTable.indexOf(value);\n    }\n    else{//If not, add the type to the type table, and return the current size of the type table as the index of the type\n        typeTable.add(value);\n        return typeTable.size()-1;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\tint ret = 0;\n\tfor(; ret < numTypes; ret++){\n\t\tif(types[ret].equals(value)){\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif(numTypes == types.length){\n\t\ttypes = Arrays.copyOf(types, numTypes * 2);\n\t}\n\ttypes[numTypes] = value;\n\treturn numTypes++;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\tif(value == null){\n\t\treturn -1;\n\t}\n\tif(typeTable == null){\n\t\ttypeTable = new ArrayList<String>();\n\t}\n\tint index = typeTable.indexOf(value);\n\tif(index < 0){\n\t\ttypeTable.add(value);\n\t\tindex = typeTable.size() - 1;\n\t}\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\tif(value == null) throw new NullPointerException();\n\tint index = _typeTable.indexOf(value);\n\tif(index >= 0) return index;\n\tindex = _typeTable.size();\n\t_typeTable.add(value);\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\tfor(int i = 0; i < types.size(); i++){\n\t\tif(types.get(i).equals(value))\n\t\t\treturn i;\n\t}\n\ttypes.add(value);\n\treturn types.size() - 1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n    if(value==null) return -1;\n    final int size=typeTable.size();\n    for(int i=0;i<size;i++)\n        if(typeTable.get(i).equals(value))\n            return i;\n    typeTable.add(value);\n    return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\t//check if type is already in the table\n\tfor(int i=0;i<typeTable.size();i++){\n\t\tif(typeTable.get(i).equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable.add(value);\n\treturn typeTable.size()-1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\tint i;\n\tint length = typeTable.length;\n\tfor(i=0; i<length; i++){\n\t\tif (typeTable[i].equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable[length] = value;\n\treturn length;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\t//System.out.println(value);\n\tif(value.equals(\"int\")){\n\t\treturn 0;\n\t}\n\tif(value.equals(\"void\")){\n\t\treturn 1;\n\t}\n\tif(value.equals(\"boolean\")){\n\t\treturn 2;\n\t}\n\tif(value.equals(\"int[]\")){\n\t\treturn 3;\n\t}\n\tif(value.equals(\"null\")){\n\t\treturn 4;\n\t}\n\n\tfor(int i = 0; i < typeTable.size(); i++){\n\t\tif(typeTable.get(i).equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable.add(value);\n\treturn typeTable.size()-1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addType(final String value){\n\n\treturn addType(new Type(value));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n", "method_name": "addType", "codes": ["int addType(final String value){\n\n    if(typeTable.contains(value)){//If the type table already contains a similar type, return that type's index\n        return typeTable.indexOf(value);\n    }\n    else{//If not, add the type to the type table, and return the current size of the type table as the index of the type\n        typeTable.add(value);\n        return typeTable.size()-1;\n    }\n}", "int addType(final String value){\n\n\tint ret = 0;\n\tfor(; ret < numTypes; ret++){\n\t\tif(types[ret].equals(value)){\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif(numTypes == types.length){\n\t\ttypes = Arrays.copyOf(types, numTypes * 2);\n\t}\n\ttypes[numTypes] = value;\n\treturn numTypes++;\n}", "int addType(final String value){\n\n\tif(value == null){\n\t\treturn -1;\n\t}\n\tif(typeTable == null){\n\t\ttypeTable = new ArrayList<String>();\n\t}\n\tint index = typeTable.indexOf(value);\n\tif(index < 0){\n\t\ttypeTable.add(value);\n\t\tindex = typeTable.size() - 1;\n\t}\n\treturn index;\n}", "int addType(final String value){\n\n\tif(value == null) throw new NullPointerException();\n\tint index = _typeTable.indexOf(value);\n\tif(index >= 0) return index;\n\tindex = _typeTable.size();\n\t_typeTable.add(value);\n\treturn index;\n}", "int addType(final String value){\n\n\tfor(int i = 0; i < types.size(); i++){\n\t\tif(types.get(i).equals(value))\n\t\t\treturn i;\n\t}\n\ttypes.add(value);\n\treturn types.size() - 1;\n}", "int addType(final String value){\n\n    if(value==null) return -1;\n    final int size=typeTable.size();\n    for(int i=0;i<size;i++)\n        if(typeTable.get(i).equals(value))\n            return i;\n    typeTable.add(value);\n    return size;\n}", "int addType(final String value){\n\n\t//check if type is already in the table\n\tfor(int i=0;i<typeTable.size();i++){\n\t\tif(typeTable.get(i).equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable.add(value);\n\treturn typeTable.size()-1;\n}", "int addType(final String value){\n\n\tint i;\n\tint length = typeTable.length;\n\tfor(i=0; i<length; i++){\n\t\tif (typeTable[i].equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable[length] = value;\n\treturn length;\n}", "int addType(final String value){\n\n\t//System.out.println(value);\n\tif(value.equals(\"int\")){\n\t\treturn 0;\n\t}\n\tif(value.equals(\"void\")){\n\t\treturn 1;\n\t}\n\tif(value.equals(\"boolean\")){\n\t\treturn 2;\n\t}\n\tif(value.equals(\"int[]\")){\n\t\treturn 3;\n\t}\n\tif(value.equals(\"null\")){\n\t\treturn 4;\n\t}\n\n\tfor(int i = 0; i < typeTable.size(); i++){\n\t\tif(typeTable.get(i).equals(value)){\n\t\t\treturn i;\n\t\t}\n\t}\n\ttypeTable.add(value);\n\treturn typeTable.size()-1;\n}", "int addType(final String value){\n\n\treturn addType(new Type(value));\n}"], "code_level": "project_runnable", "_id": "636766ef1a6d9265ec01761a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public long readLong(final int offset){\n\n\treturn this.readUnsignedLong(offset)<<1>>1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\n\treturn ((long)(read(offset))<<56)+((long)(read(offset+1)&255)<<48)+((long)(read(offset+2)&255)<<40)+((long)(read(offset+3)&255)<<32)+((long)(read(offset+4)&255)<<24)+((read(offset+5)&255)<<16)+((read(offset+6)&255)<<8)+(read(offset+7)&255);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\nreturn readLong(offset,true);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\nlong v=0;\nfor(int i=0;i<8;i++){\nv<<=8;\nv|=readByte(offset+i);\n}\nreturn v;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readLong(final int offset){\n\n\treturn ByteArrayUtils.readLong(this.source,offset);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\n\treturn (long)readInt(offset)<<32|((long)readInt(offset+4)&0xffffffffL);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public long readLong(final int offset){\n\n\treturn readLong(offset,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\nreturn ((long)(((readInt(offset)&0xFFFFFFFFL)|(((long)readInt(offset+4))<<32))));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\n\treturn readLong(offset,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readLong(final int offset){\n\n\tif(offset<0||offset+8>length)throw new IndexOutOfBoundsException();\n\treturn(((long)bytes[offset+0]&0xff)<<56)|(((long)bytes[offset+1]&0xff)<<48)|(((long)bytes[offset+2]&0xff)<<40)|(((long)bytes[offset+3]&0xff)<<32)|(((long)bytes[offset+4]&0xff)<<24)|(((long)bytes[offset+5]&0xff)<<16)|(((long)bytes[offset+6]&0xff)<<8)|((long)bytes[offset+7]&0xff);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readLong", "codes": ["public long readLong(final int offset){\n\n\treturn this.readUnsignedLong(offset)<<1>>1;\n}", "public long readLong(final int offset){\n\n\treturn ((long)(read(offset))<<56)+((long)(read(offset+1)&255)<<48)+((long)(read(offset+2)&255)<<40)+((long)(read(offset+3)&255)<<32)+((long)(read(offset+4)&255)<<24)+((read(offset+5)&255)<<16)+((read(offset+6)&255)<<8)+(read(offset+7)&255);\n}", "public long readLong(final int offset){\nreturn readLong(offset,true);}", "public long readLong(final int offset){\n\nlong v=0;\nfor(int i=0;i<8;i++){\nv<<=8;\nv|=readByte(offset+i);\n}\nreturn v;\n}", "public long readLong(final int offset){\n\n\treturn ByteArrayUtils.readLong(this.source,offset);\n}", "public long readLong(final int offset){\n\n\treturn (long)readInt(offset)<<32|((long)readInt(offset+4)&0xffffffffL);\n}", "public long readLong(final int offset){\n\n\treturn readLong(offset,0);\n}", "public long readLong(final int offset){\n\nreturn ((long)(((readInt(offset)&0xFFFFFFFFL)|(((long)readInt(offset+4))<<32))));\n}", "public long readLong(final int offset){\n\n\treturn readLong(offset,false);\n}", "public long readLong(final int offset){\n\n\tif(offset<0||offset+8>length)throw new IndexOutOfBoundsException();\n\treturn(((long)bytes[offset+0]&0xff)<<56)|(((long)bytes[offset+1]&0xff)<<48)|(((long)bytes[offset+2]&0xff)<<40)|(((long)bytes[offset+3]&0xff)<<32)|(((long)bytes[offset+4]&0xff)<<24)|(((long)bytes[offset+5]&0xff)<<16)|(((long)bytes[offset+6]&0xff)<<8)|((long)bytes[offset+7]&0xff);\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01775b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteLength>0){\n\t\tfinal int byteVectorLength=this.length;\n\t\tsetLength(byteVectorLength+byteLength);\n\t\tSystem.arraycopy(byteArrayValue,byteOffset,this.data,byteVectorLength,byteLength);\n\t}\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int oldByteLength=byteLength();\n\tsetByteLength_(oldByteLength+byteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,bytes,oldByteLength,byteLength);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int byteCount=byteLength+byteOffset;\n\tif(byteCount>byteArrayValue.length)throw new IllegalArgumentException();\n\tif(byteCount>byteArray.length)resize(byteCount);\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteArray,0,byteLength);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nbyte[] bytes=this.bytes;\nfinal int length=this.length;\nint newLength=length+byteLength;\nif(newLength>bytes.length){\nint newSize=Math.max(newLength,Math.max(bytes.length<<1,4));\nbyte[] newBytes=new byte[newSize];\nSystem.arraycopy(bytes,0,newBytes,0,length);\nthis.bytes=bytes=newBytes;\n}\nSystem.arraycopy(byteArrayValue,byteOffset,bytes,length,byteLength);\nthis.length=newLength;\nreturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteArrayValue==null)\n\t\treturn this;\n\tif(byteLength<=0)\n\t\treturn this;\n\tif(byteOffset<0)\n\t\treturn this;\n\tif(byteLength>byteArrayValue.length-byteOffset)\n\t\treturn this;\n\tint newLength=byteLength+this.length;\n\tif(newLength>this.byteArray.length)\n\t\tthis.byteArray=Arrays.copyOf(this.byteArray,newLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.length,byteLength);\n\tthis.length=newLength;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nif(byteLength>0){\nif(byteLength>byteArrayValue.length-byteOffset)throw new IndexOutOfBoundsException();\nif(byteLength<=byteArrayValue.length){\nint newByteLength=this.byteLength+byteLength;\nif(newByteLength>this.byteArray.length)setByteArray(new byte[newByteLength]);\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.byteLength,byteLength);\nthis.byteLength+=byteLength;\n}}\nreturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newSize=length+byteLength;\n\tensureCapacity(newSize);\n\tSystem.arraycopy(byteArrayValue,byteOffset,bytes,length,byteLength);\n\tlength=newSize;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newLength=length+byteLength;\n\tif(newLength>data.length){\n\t\tint newCapacity=newLength*2;\n\t\tbyte[] newData=new byte[newCapacity];\n\t\tSystem.arraycopy(data,0,newData,0,length);\n\t\tdata=newData;\n\t}\n\tSystem.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n\tlength=newLength;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteArrayValue==null){\n\t\tthrow new NullPointerException(\"The parameter byteArrayValue can not be null !\");\n\t}\n\tif(byteArrayValue.length==0){\n\t\treturn this;\n\t}\n\tif(byteOffset<0){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteOffset can not be less than 0 !\");\n\t}\n\tif(byteLength<0){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteLength can not be less than 0 !\");\n\t}\n\tif(byteOffset+byteLength>byteArrayValue.length){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteOffset+byteLength can not be greater than the length of the parameter byteArrayValue !\");\n\t}\n\tenlargeCapacity(byteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteArray,position,byteLength);\n\tposition+=byteLength;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newCount=count+byteLength;\n\tif(newCount>buffer.length){\n\t\tenlargeBuffer(newCount);\n\t}\n\tSystem.arraycopy(byteArrayValue,byteOffset,buffer,count,byteLength);\n\tcount=newCount;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteLength>0){\n\t\tfinal int byteVectorLength=this.length;\n\t\tsetLength(byteVectorLength+byteLength);\n\t\tSystem.arraycopy(byteArrayValue,byteOffset,this.data,byteVectorLength,byteLength);\n\t}\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int oldByteLength=byteLength();\n\tsetByteLength_(oldByteLength+byteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,bytes,oldByteLength,byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int byteCount=byteLength+byteOffset;\n\tif(byteCount>byteArrayValue.length)throw new IllegalArgumentException();\n\tif(byteCount>byteArray.length)resize(byteCount);\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteArray,0,byteLength);\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nbyte[] bytes=this.bytes;\nfinal int length=this.length;\nint newLength=length+byteLength;\nif(newLength>bytes.length){\nint newSize=Math.max(newLength,Math.max(bytes.length<<1,4));\nbyte[] newBytes=new byte[newSize];\nSystem.arraycopy(bytes,0,newBytes,0,length);\nthis.bytes=bytes=newBytes;\n}\nSystem.arraycopy(byteArrayValue,byteOffset,bytes,length,byteLength);\nthis.length=newLength;\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteArrayValue==null)\n\t\treturn this;\n\tif(byteLength<=0)\n\t\treturn this;\n\tif(byteOffset<0)\n\t\treturn this;\n\tif(byteLength>byteArrayValue.length-byteOffset)\n\t\treturn this;\n\tint newLength=byteLength+this.length;\n\tif(newLength>this.byteArray.length)\n\t\tthis.byteArray=Arrays.copyOf(this.byteArray,newLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.length,byteLength);\n\tthis.length=newLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nif(byteLength>0){\nif(byteLength>byteArrayValue.length-byteOffset)throw new IndexOutOfBoundsException();\nif(byteLength<=byteArrayValue.length){\nint newByteLength=this.byteLength+byteLength;\nif(newByteLength>this.byteArray.length)setByteArray(new byte[newByteLength]);\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.byteLength,byteLength);\nthis.byteLength+=byteLength;\n}}\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newSize=length+byteLength;\n\tensureCapacity(newSize);\n\tSystem.arraycopy(byteArrayValue,byteOffset,bytes,length,byteLength);\n\tlength=newSize;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newLength=length+byteLength;\n\tif(newLength>data.length){\n\t\tint newCapacity=newLength*2;\n\t\tbyte[] newData=new byte[newCapacity];\n\t\tSystem.arraycopy(data,0,newData,0,length);\n\t\tdata=newData;\n\t}\n\tSystem.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n\tlength=newLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tif(byteArrayValue==null){\n\t\tthrow new NullPointerException(\"The parameter byteArrayValue can not be null !\");\n\t}\n\tif(byteArrayValue.length==0){\n\t\treturn this;\n\t}\n\tif(byteOffset<0){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteOffset can not be less than 0 !\");\n\t}\n\tif(byteLength<0){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteLength can not be less than 0 !\");\n\t}\n\tif(byteOffset+byteLength>byteArrayValue.length){\n\t\tthrow new ArrayIndexOutOfBoundsException(\"The parameter byteOffset+byteLength can not be greater than the length of the parameter byteArrayValue !\");\n\t}\n\tenlargeCapacity(byteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,byteArray,position,byteLength);\n\tposition+=byteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint newCount=count+byteLength;\n\tif(newCount>buffer.length){\n\t\tenlargeBuffer(newCount);\n\t}\n\tSystem.arraycopy(byteArrayValue,byteOffset,buffer,count,byteLength);\n\tcount=newCount;\n\treturn this;\n}"], "code_level": "class_runnable", "_id": "6367671a1a6d9265ec017c15", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private void pop(final String descriptor){\n\nswitch(descriptor.charAt(0)){\ncase 'C':\ncase 'S':\ncase 'I':\ncase 'Z':\ncase 'B':\ncase 'F':\nthis.stack_size--;\nbreak;\ncase 'J':\ncase 'D':\nthis.stack_size-=2;\nbreak;\ncase ')':\nthis.stack_size=this.stack_size_stack.pop();\nbreak;\ncase 'L':\nthis.stack_size--;\nbreak;\ncase '[':\nthis.stack_size--;\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='B'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='C'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='D'){\n\t\tstack.pop();\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='F'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='I'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='J'){\n\t\tstack.pop();\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='L'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='S'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='Z'){\n\t\tstack.pop();\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n    char c=descriptor.charAt(0);\n    if(c=='L'){\n        Object ref=frame.pop();\n        frame.pop();\n        frame.push(ref);\n    }else if(c=='['){\n        Object ref=frame.pop();\n        frame.pop();\n        frame.push(ref);\n    }else if(c=='D' || c=='J'){\n        frame.pop();\n        frame.pop();\n    }else{\n        frame.pop();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tfinal char c=descriptor.charAt(0);\n\tif(c=='D'||c=='J'){\n\t\tpop(2);\n\t}\n\telse if(c=='F'){\n\t\tpop(1);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch (descriptor.charAt(0)) {\n\tcase 'B':\n\tcase 'C':\n\tcase 'F':\n\tcase 'I':\n\tcase 'S':\n\tcase 'Z':\n\t\tframe.pop();\n\t\tbreak;\n\tcase 'D':\n\tcase 'J':\n\t\tframe.pop2();\n\t\tbreak;\n\tcase '[':\n\t\tframe.pop();\n\t\tbreak;\n\tcase 'L':\n\t\tframe.pop();\n\t\tbreak;\n\tdefault:\n\t\tthrow new IllegalArgumentException(\"Invalid descriptor \"+descriptor);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='L'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='['){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='Z'||descriptor.charAt(0)=='B'||descriptor.charAt(0)=='C'||descriptor.charAt(0)=='S'||descriptor.charAt(0)=='I'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='F'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='J'){\n\t\tstackPointer-=2;\n\t}\n\telse if(descriptor.charAt(0)=='D'){\n\t\tstackPointer-=2;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tfinal char ch=descriptor.charAt(0);\n\tswitch(ch){\n\t\tcase 'Z':\n\t\tcase 'C':\n\t\tcase 'B':\n\t\tcase 'S':\n\t\tcase 'I':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'J':\n\t\tcase 'D':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'B':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'C':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'D':\n\t\tthis.stack.pop();\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'F':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'I':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'J':\n\t\tthis.stack.pop();\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'L':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'S':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'Z':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase '[':\n\t\tthis.stack.pop();\n\t\tbreak;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'B':\n\tcase 'C':\n\tcase 'I':\n\tcase 'S':\n\tcase 'Z':\n\t\til.push(new InsnNode(Opcodes.POP));\n\t\tbreak;\n\tcase 'J':\n\tcase 'D':\n\t\til.push(new InsnNode(Opcodes.POP2));\n\t\tbreak;\n\tcase 'L':\n\t\til.push(new InsnNode(Opcodes.POP));\n\t\tbreak;\n\tdefault:\n\t\tthrow new IllegalStateException(\"Unknown descriptor type: \"+descriptor);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tchar c=descriptor.charAt(0);\n\tswitch(c){\n\t\tcase 'B':\n\t\tcase 'C':\n\t\tcase 'Z':\n\t\tcase 'S':\n\t\tcase 'I':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tdefault:break;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){\n\nswitch(descriptor.charAt(0)){\ncase 'C':\ncase 'S':\ncase 'I':\ncase 'Z':\ncase 'B':\ncase 'F':\nthis.stack_size--;\nbreak;\ncase 'J':\ncase 'D':\nthis.stack_size-=2;\nbreak;\ncase ')':\nthis.stack_size=this.stack_size_stack.pop();\nbreak;\ncase 'L':\nthis.stack_size--;\nbreak;\ncase '[':\nthis.stack_size--;\n}\n}", "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='B'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='C'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='D'){\n\t\tstack.pop();\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='F'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='I'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='J'){\n\t\tstack.pop();\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='L'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='S'){\n\t\tstack.pop();\n\t}else if(descriptor.charAt(0)=='Z'){\n\t\tstack.pop();\n", "private void pop(final String descriptor){\n\n    char c=descriptor.charAt(0);\n    if(c=='L'){\n        Object ref=frame.pop();\n        frame.pop();\n        frame.push(ref);\n    }else if(c=='['){\n        Object ref=frame.pop();\n        frame.pop();\n        frame.push(ref);\n    }else if(c=='D' || c=='J'){\n        frame.pop();\n        frame.pop();\n    }else{\n        frame.pop();\n    }\n}", "private void pop(final String descriptor){\n\n\tfinal char c=descriptor.charAt(0);\n\tif(c=='D'||c=='J'){\n\t\tpop(2);\n\t}\n\telse if(c=='F'){\n\t\tpop(1);\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch (descriptor.charAt(0)) {\n\tcase 'B':\n\tcase 'C':\n\tcase 'F':\n\tcase 'I':\n\tcase 'S':\n\tcase 'Z':\n\t\tframe.pop();\n\t\tbreak;\n\tcase 'D':\n\tcase 'J':\n\t\tframe.pop2();\n\t\tbreak;\n\tcase '[':\n\t\tframe.pop();\n\t\tbreak;\n\tcase 'L':\n\t\tframe.pop();\n\t\tbreak;\n\tdefault:\n\t\tthrow new IllegalArgumentException(\"Invalid descriptor \"+descriptor);\n\t}\n}", "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='L'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='['){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='Z'||descriptor.charAt(0)=='B'||descriptor.charAt(0)=='C'||descriptor.charAt(0)=='S'||descriptor.charAt(0)=='I'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='F'){\n\t\tstackPointer--;\n\t}\n\telse if(descriptor.charAt(0)=='J'){\n\t\tstackPointer-=2;\n\t}\n\telse if(descriptor.charAt(0)=='D'){\n\t\tstackPointer-=2;\n\t}\n}", "private void pop(final String descriptor){\n\n\tfinal char ch=descriptor.charAt(0);\n\tswitch(ch){\n\t\tcase 'Z':\n\t\tcase 'C':\n\t\tcase 'B':\n\t\tcase 'S':\n\t\tcase 'I':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'J':\n\t\tcase 'D':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'B':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'C':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'D':\n\t\tthis.stack.pop();\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'F':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'I':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'J':\n\t\tthis.stack.pop();\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'L':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'S':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase 'Z':\n\t\tthis.stack.pop();\n\t\tbreak;\n\tcase '[':\n\t\tthis.stack.pop();\n\t\tbreak;\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'B':\n\tcase 'C':\n\tcase 'I':\n\tcase 'S':\n\tcase 'Z':\n\t\til.push(new InsnNode(Opcodes.POP));\n\t\tbreak;\n\tcase 'J':\n\tcase 'D':\n\t\til.push(new InsnNode(Opcodes.POP2));\n\t\tbreak;\n\tcase 'L':\n\t\til.push(new InsnNode(Opcodes.POP));\n\t\tbreak;\n\tdefault:\n\t\tthrow new IllegalStateException(\"Unknown descriptor type: \"+descriptor);\n\t}\n}", "private void pop(final String descriptor){\n\n\tchar c=descriptor.charAt(0);\n\tswitch(c){\n\t\tcase 'B':\n\t\tcase 'C':\n\t\tcase 'Z':\n\t\tcase 'S':\n\t\tcase 'I':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tstack.pop();\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\tdefault:break;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767021a6d9265ec0178b2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif(initializations==null){\n\t\tinitializations=new int[]{abstractType};\n\t\treturn;\n\t}\n\tint length=initializations.length;\n\tSystem.arraycopy(initializations,0,initializations=new int[length+1],0,length);\n\tinitializations[length]=abstractType;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\t//Check that the variable is not already initialized.\n\tif(!isInitializedType(abstractType)){\n\t\tinitializations.add(abstractType);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n    if (this.initializations == null) {\n        this.initializations = new int[5];\n    } else {\n        int length = this.initializations.length;\n        System.arraycopy(\n                this.initializations,\n                0,\n                (this.initializations = new int[length + 5]),\n                0,\n                length);\n    }\n    this.initializations[this.initializationsPtr++] = abstractType;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif (initializations==null) {\n\t\tinitializations = new int[5];\n\t} else {\n\t\tif (initializationsLength >= initializations.length) {\n\t\t\tSystem.arraycopy(\n\t\t\t\tinitializations,\n\t\t\t\t0,\n\t\t\t\t(initializations = new int[initializationsLength * 2]),\n\t\t\t\t0,\n\t\t\t\tinitializationsLength);\n\t\t}\n\t}\n\tinitializations[initializationsLength++] = abstractType;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif (initializations == null) {\n\t\tinitializations = new int[2];\n\t\tinitializations[0] = 1;\n\t\tinitializations[1] = abstractType;\n\t} else {\n\t\tint length = initializations.length;\n\t\tSystem.arraycopy(\n\t\t\tinitializations,\n\t\t\t0,\n\t\t\t(initializations = new int[length + 2]),\n\t\t\t0,\n\t\t\tlength);\n\t\tinitializations[length] = 1;\n\t\tinitializations[length + 1] = abstractType;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif(initializations!=null){\n\t\tint length=initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations=new int[length+1], 0, length);\n\t\tinitializations[length]=abstractType;\n\t}else{\n\t\tinitializations=new int[]{abstractType};\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif (initializations == null){\n\t\tinitializations = new int[]{abstractType};\n\t} else {\n\t\tint length = initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations = new int[length+1], 0, length);\n\t\tinitializations[length] = abstractType;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n    if(initializations==null)\n        initializations=new int[]{abstractType};\n    else\n        initializations=Arrays.copyOf(initializations, initializations.length+1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tif(initializations != null ){\n\t\tint index = initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations = new int[index + 1], 0, index);\n\t\tinitializations[index] = abstractType;\n\t} else {\n\t\tinitializations = new int[]{abstractType};\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addInitializedType(final int abstractType){\n\n\tthis.initializations.add(abstractType);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds an abstract type to the list of types on which a constructor is invoked in the basic block.\n * @param abstractType an abstract type on a which a constructor is invoked.\n */\n", "method_name": "addInitializedType", "codes": ["private void addInitializedType(final int abstractType){\n\n\tif(initializations==null){\n\t\tinitializations=new int[]{abstractType};\n\t\treturn;\n\t}\n\tint length=initializations.length;\n\tSystem.arraycopy(initializations,0,initializations=new int[length+1],0,length);\n\tinitializations[length]=abstractType;\n}", "private void addInitializedType(final int abstractType){\n\n\t//Check that the variable is not already initialized.\n\tif(!isInitializedType(abstractType)){\n\t\tinitializations.add(abstractType);\n\t}\n}", "private void addInitializedType(final int abstractType){\n\n    if (this.initializations == null) {\n        this.initializations = new int[5];\n    } else {\n        int length = this.initializations.length;\n        System.arraycopy(\n                this.initializations,\n                0,\n                (this.initializations = new int[length + 5]),\n                0,\n                length);\n    }\n    this.initializations[this.initializationsPtr++] = abstractType;\n}", "private void addInitializedType(final int abstractType){\n\n\tif (initializations==null) {\n\t\tinitializations = new int[5];\n\t} else {\n\t\tif (initializationsLength >= initializations.length) {\n\t\t\tSystem.arraycopy(\n\t\t\t\tinitializations,\n\t\t\t\t0,\n\t\t\t\t(initializations = new int[initializationsLength * 2]),\n\t\t\t\t0,\n\t\t\t\tinitializationsLength);\n\t\t}\n\t}\n\tinitializations[initializationsLength++] = abstractType;\n}", "private void addInitializedType(final int abstractType){\n\n\tif (initializations == null) {\n\t\tinitializations = new int[2];\n\t\tinitializations[0] = 1;\n\t\tinitializations[1] = abstractType;\n\t} else {\n\t\tint length = initializations.length;\n\t\tSystem.arraycopy(\n\t\t\tinitializations,\n\t\t\t0,\n\t\t\t(initializations = new int[length + 2]),\n\t\t\t0,\n\t\t\tlength);\n\t\tinitializations[length] = 1;\n\t\tinitializations[length + 1] = abstractType;\n\t}\n}", "private void addInitializedType(final int abstractType){\n\n\tif(initializations!=null){\n\t\tint length=initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations=new int[length+1], 0, length);\n\t\tinitializations[length]=abstractType;\n\t}else{\n\t\tinitializations=new int[]{abstractType};\n\t}\n}", "private void addInitializedType(final int abstractType){\n\n\tif (initializations == null){\n\t\tinitializations = new int[]{abstractType};\n\t} else {\n\t\tint length = initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations = new int[length+1], 0, length);\n\t\tinitializations[length] = abstractType;\n\t}\n}", "private void addInitializedType(final int abstractType){\n\n    if(initializations==null)\n        initializations=new int[]{abstractType};\n    else\n        initializations=Arrays.copyOf(initializations, initializations.length+1);\n}", "private void addInitializedType(final int abstractType){\n\n\tif(initializations != null ){\n\t\tint index = initializations.length;\n\t\tSystem.arraycopy(initializations, 0, initializations = new int[index + 1], 0, index);\n\t\tinitializations[index] = abstractType;\n\t} else {\n\t\tinitializations = new int[]{abstractType};\n\t}\n}", "private void addInitializedType(final int abstractType){\n\n\tthis.initializations.add(abstractType);\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec0177a9", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i=start;i<end;i++){\n\t\tFrame.add(currentFrame.get(i));\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i = start;i <= end;i++){\n\t\tfinal Type type = currentFrame.get(i);\n\t\tswitch(type.getSort()){\n\t\t\tcase Type.OBJECT:\n\t\t\tcase Type.ARRAY:\n\t\t\tframe.put(type);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i = start; i < end; i++){\n\t\tFrame.add(currentFrame.elementAt(i));\n\t}\n\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n    for(int i=start;i<=end;i++){\n        currentFrame.put(i,currentFrame.get(i));\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n  for(int i=start;i<end;i++){\n    final AbstractType type=currentFrame[i];\n    if(type!=TOP){\n      int index;\n      if(type==INTEGER){\n        index=0;\n      }else if(type==FLOAT){\n        index=1;\n      }else if(type==LONG){\n        index=2;\n      }else if(type==DOUBLE){\n        index=3;\n      }else if(type==NULL){\n        index=4;\n      }else if(type==UNINITIALIZED_THIS){\n        index=5;\n      }else if(type==RETURN_ADDRESS){\n        index=6;\n      }else{\n        index=7;\n      }\n      frame[frameIndex++]=index;\n      if(index==7){\n        frame[frameIndex++]=type.getInternalName();\n      }\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tint index=start;\n\twhile(index<=end){\n\t\tfinal AbstractType type=currentFrame.get(index);\n\t\tframe.put(type);\n\t\tindex++;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tint i;\n\tfor(i=start;i<end;i++){\n\t\tFrame.add(currentFrame.get(i));\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\t\tfor(int i=start;i<end;i++){\n\t\t\t\tif(currentFrame.get(i)==null) continue;\n\t\t\t\tFrame.add(currentFrame.get(i));\n\t\t\t\t//System.out.println(\"Insert\"+currentFrame.get(i));\n\t\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i=start;i<=end;i++)\n\t\tcurrentFrame.add(currentFrame.get(i));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void putAbstractTypes(final int start,final int end){\n\n\t\tint index=start;\n\t\twhile(index<end){\n\t\t\tif(isDoubleWord(index)){\n\t\t\t\tputAbstractType(index,index+1);\n\t\t\t\tindex+=2;\n\t\t\t}else{\n\t\t\t\tputAbstractType(index);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n", "method_name": "putAbstractTypes", "codes": ["private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i=start;i<end;i++){\n\t\tFrame.add(currentFrame.get(i));\n\t}\n}", "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i = start;i <= end;i++){\n\t\tfinal Type type = currentFrame.get(i);\n\t\tswitch(type.getSort()){\n\t\t\tcase Type.OBJECT:\n\t\t\tcase Type.ARRAY:\n\t\t\tframe.put(type);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i = start; i < end; i++){\n\t\tFrame.add(currentFrame.elementAt(i));\n\t}\n\n}", "private void putAbstractTypes(final int start,final int end){\n\n    for(int i=start;i<=end;i++){\n        currentFrame.put(i,currentFrame.get(i));\n    }\n}", "private void putAbstractTypes(final int start,final int end){\n\n  for(int i=start;i<end;i++){\n    final AbstractType type=currentFrame[i];\n    if(type!=TOP){\n      int index;\n      if(type==INTEGER){\n        index=0;\n      }else if(type==FLOAT){\n        index=1;\n      }else if(type==LONG){\n        index=2;\n      }else if(type==DOUBLE){\n        index=3;\n      }else if(type==NULL){\n        index=4;\n      }else if(type==UNINITIALIZED_THIS){\n        index=5;\n      }else if(type==RETURN_ADDRESS){\n        index=6;\n      }else{\n        index=7;\n      }\n      frame[frameIndex++]=index;\n      if(index==7){\n        frame[frameIndex++]=type.getInternalName();\n      }\n    }\n  }\n}", "private void putAbstractTypes(final int start,final int end){\n\n\tint index=start;\n\twhile(index<=end){\n\t\tfinal AbstractType type=currentFrame.get(index);\n\t\tframe.put(type);\n\t\tindex++;\n\t}\n}", "private void putAbstractTypes(final int start,final int end){\n\n\tint i;\n\tfor(i=start;i<end;i++){\n\t\tFrame.add(currentFrame.get(i));\n\t}\n}", "private void putAbstractTypes(final int start,final int end){\n\n\t\tfor(int i=start;i<end;i++){\n\t\t\t\tif(currentFrame.get(i)==null) continue;\n\t\t\t\tFrame.add(currentFrame.get(i));\n\t\t\t\t//System.out.println(\"Insert\"+currentFrame.get(i));\n\t\t\t}\n\t}", "private void putAbstractTypes(final int start,final int end){\n\n\tfor(int i=start;i<=end;i++)\n\t\tcurrentFrame.add(currentFrame.get(i));\n}", "private void putAbstractTypes(final int start,final int end){\n\n\t\tint index=start;\n\t\twhile(index<end){\n\t\t\tif(isDoubleWord(index)){\n\t\t\t\tputAbstractType(index,index+1);\n\t\t\t\tindex+=2;\n\t\t\t}else{\n\t\t\t\tputAbstractType(index);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}"], "code_level": "project_runnable", "_id": "6367670a1a6d9265ec0179dc", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public short readShort(final int offset){\n\n\tif(offset+2>classFileBuffer.length){\n\t\tthrow new RuntimeException(\"not enough bytes in readShort\");\n\t}\n\treturn (short)(((classFileBuffer[offset]&0xFF)<<8)|(classFileBuffer[offset+1]&0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)((classFileBuffer[offset]<<8)+(classFileBuffer[offset+1]&0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset+1] & 0xFF) << 8) | (classFileBuffer[offset] & 0xFF));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short) ( (classFileBuffer[offset] << 8) | classFileBuffer[offset + 1]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset){\n\nreturn (short)((classFileBuffer[offset]&0xff)<<8|(classFileBuffer[offset+1]&0xff));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset]&0xff)<<8)|((classFileBuffer[offset+1]&0xff)));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset]&0xFF)<<8)+(classFileBuffer[offset+1]&0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)(classFileBuffer[offset]<<8|classFileBuffer[offset+1]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short) ((classFileBuffer[offset] << 8) + (classFileBuffer[offset+1] & 0xFF));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset] & 0xff) << 8) +\n\t\t\t(classFileBuffer[offset + 1] & 0xff));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Reads a signed short value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n", "method_name": "readShort", "codes": ["public short readShort(final int offset){\n\n\tif(offset+2>classFileBuffer.length){\n\t\tthrow new RuntimeException(\"not enough bytes in readShort\");\n\t}\n\treturn (short)(((classFileBuffer[offset]&0xFF)<<8)|(classFileBuffer[offset+1]&0xFF));\n}", "public short readShort(final int offset){\n\n\treturn (short)((classFileBuffer[offset]<<8)+(classFileBuffer[offset+1]&0xFF));\n}", "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset+1] & 0xFF) << 8) | (classFileBuffer[offset] & 0xFF));\n}", "public short readShort(final int offset){\n\n\treturn (short) ( (classFileBuffer[offset] << 8) | classFileBuffer[offset + 1]);\n}", "public short readShort(final int offset){\n\nreturn (short)((classFileBuffer[offset]&0xff)<<8|(classFileBuffer[offset+1]&0xff));\n}", "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset]&0xff)<<8)|((classFileBuffer[offset+1]&0xff)));\n}", "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset]&0xFF)<<8)+(classFileBuffer[offset+1]&0xFF));\n}", "public short readShort(final int offset){\n\n\treturn (short)(classFileBuffer[offset]<<8|classFileBuffer[offset+1]);\n}", "public short readShort(final int offset){\n\n\treturn (short) ((classFileBuffer[offset] << 8) + (classFileBuffer[offset+1] & 0xFF));\n}", "public short readShort(final int offset){\n\n\treturn (short)(((classFileBuffer[offset] & 0xff) << 8) +\n\t\t\t(classFileBuffer[offset + 1] & 0xff));\n}"], "code_level": "class_runnable", "_id": "636766f21a6d9265ec017667", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given offset if it has not been already created.\n * @param bytecodeOffset a bytecode offset in a method.\n * @param labels the already created labels, indexed by their offset. If a label already existsfor bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\n */\n", "method_name": "readLabel", "codes": ["protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}", "protected Label readLabel(final int bytecodeOffset,final Label[] labels){\n\n\tif(labels[bytecodeOffset]==null){\n\t\tlabels[bytecodeOffset]=new Label();\n\t}\n\treturn labels[bytecodeOffset];\n}"], "code_level": "self_contained", "_id": "636766ff1a6d9265ec017853", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=0;\n\tint readOffset=-1;\n\tint writeOffset=0;\n\tbyte[] classFileBuffer=this.referenceClass.classFileBuffer;\n\tif(constantPoolEntryIndex<=0||constantPoolEntryIndex>=this.constantPoolCount){\n\t\tthrow new IllegalArgumentException(Messages.bind(Messages.classfile_IllegalValue,new Integer(constantPoolEntryIndex)));\n\t}\n\t// read the length of the utf8 string in the constant pool\n\tint utfOffset=this.structOffset+3+2+2+(constantPoolEntryIndex-1)*2;\n\tutfLength=u2At(classFileBuffer,utfOffset);\n\treadOffset=utfOffset+2;\n\tif(charBuffer==null||charBuffer.length<utfLength){\n\t\tcharBuffer=new char[utfLength*2]; // grow\n\t}\n\t// read the utf8 bytes and convert them into unicode chars\n\tint c;\n\tfor (int i=0;i<utfLength;){\n\t\tc=classFile", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfLength=this.classFileBuffer[this.currentOffset++]&0xFF;\n\tswitch(utfLength){\n\t\tcase 0:\n\t\t\treturn null;\n\t\tcase 1:\n\t\t\treturn Utf8Constants.ONE_ZERO_CHAR_STRING;\n\t\tdefault:\n\t\t\tchar[] utfBuffer;\n\t\t\tif(charBuffer==null||utfLength>charBuffer.length){\n\t\t\t\tutfBuffer=new char[utfLength];\n\t\t\t}else{\n\t\t\t\tutfBuffer=charBuffer;\n\t\t\t}\n\t\t\tint readOffset=this.currentOffset;\n\t\t\tint writeOffset=0;\n\t\t\tint utfValue;\n\t\t\tint utfCount=0;\n\t\t\tfinal int endOffset=readOffset+utfLength;\n\t\t\twhile(readOffset<endOffset){\n\t\t\t\tutfValue=this.classFileBuffer[readOffset++]&0xFF;\n\t\t\t\tif((utfValue&0x80)!=0){\n\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=classFileBuffer[u2At(constantPoolEntryIndex)]&0xFF;\n\tint readOffset=constantPoolEntryIndex+3;\n\tint endOffset=readOffset+utfLength;\n\tif(charBuffer==null){\n\t\treturn new String(classFileBuffer,readOffset,utfLength);\n\t}\n\tint charIndex=0;\n\twhile(readOffset<endOffset){\n\t\tchar aChar=(char)u2At(readOffset);\n\t\treadOffset+=2;\n\t\tcharBuffer[charIndex++]=aChar;\n\t}\n\treturn new String(charBuffer,0,charIndex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n  if(constantPoolEntryIndex<1||constantPoolEntryIndex>=constantPoolCount){\n    throw new IllegalArgumentException(\"Invalid constant pool entry index \"+constantPoolEntryIndex);\n  }\n  if(constantPoolEntryTag[constantPoolEntryIndex]!=CONSTANT_Utf8){\n    throw new IllegalArgumentException(\"Invalid constant pool entry index \"+constantPoolEntryIndex);\n  }\n  int utf8Offset=this.constantPoolEntryOffset[constantPoolEntryIndex];\n  int utf8Length=classFileBuffer[utf8Offset++]<<8|classFileBuffer[utf8Offset++];\n  int currentChar=0;\n  for(int i=0;i<utf8Length;i++){\n    int byte1=classFileBuffer[utf8Offset++]&0xff;\n    if(byte1<128){// 0xxxxxxx\n      charBuffer[currentChar++]=(char)byte1;\n    }else if((byte1&0xe0)==0xc0){ // 110xxxxx 10xxxxxx\n      int byte2=classFileBuffer", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n    final int utf8Offset=this.constantPoolOffsets[constantPoolEntryIndex-1];\n    if(utf8Offset==0)\n        return null;\n    int length=this.classFileBuffer[utf8Offset++]&0xFF;\n    switch(length&0xC0){\n        case 0x80: // 2 bytes unsigned\n            length=((length&0x3F)<<8)+(this.classFileBuffer[utf8Offset++]&0xFF);\n            break;\n        case 0xC0: // 3 bytes unsigned\n            length=\n                ((length&0x3F)<<8)+(this.classFileBuffer[utf8Offset++]&0xFF)<<8\n                +(this.classFileBuffer[utf8Offset++]&0xFF);\n            break;\n        default:\n    }\n    char[] result=charBuffer;\n    if(result==null || result.length<length)\n        result=new char[length];\n    int readOffset=utf8Offset;\n    int writeOffset=0;\n    int numberOfBytesInBuffer", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfIndex=this.constantPoolOffsets[constantPoolEntryIndex];\n\tfinal int length=u2At(classFileBuffer,utfIndex);\n\tif(length==0) return Util.EMPTY_STRING;\n\tchar[] result=this.constantPoolCharArray[constantPoolEntryIndex];\n\tif(result==null){\n\t\tthis.constantPoolCharArray[constantPoolEntryIndex]=result=CharOperation.NO_CHAR;\n\t\tfinal int end=utfIndex+2+length;\n\t\tint charIndex=0;\n\t\tfor(int byteIndex=utfIndex+2;byteIndex<end;){\n\t\t\tint byte1=classFileBuffer[byteIndex++]&0xff;\n\t\t\tswitch(byte1>>4){\n\t\t\t\tcase 0 :\n\t\t\t\tcase 1 :\n\t\t\t\tcase 2 :\n\t\t\t\tcase 3 :\n\t\t\t\tcase 4 :\n\t\t\t\tcase 5 :\n\t\t\t\tcase 6 :\n\t\t\t\tcase 7 :\n\t\t\t\t\t//", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=constantPool[constantPoolEntryIndex];\n\tbyte[] utfBytes=new byte[utfLength];\n\tSystem.arraycopy(classFileBuffer,u4(classFileOffset+1),utfBytes,0,utfLength);\n\ttry {\n\t\treturn new String(utfBytes,Utf8Names.UTF8_ENCODING);\n\t} catch (UnsupportedEncodingException e) {\n\t\t// should never happen since UTF-8 is supported on all platforms.\n\t\te.printStackTrace();\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utf8Length=0;\n\tfinal int offset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tfinal int tag=u1[offset];\n\tif(tag!=CONSTANT_Utf8){\n\t\tthrow new IllegalArgumentException();\n\t}\n\t// read the length in the first two bytes\n\tint currentOffset=offset+1;\n\tutf8Length=u1[currentOffset++]<<8;\n\tutf8Length+=u1[currentOffset++];\n\t// read the bytes\n\tfinal int end=currentOffset+utf8Length;\n\tint charIndex=0;\n\twhile(currentOffset<end){\n\t\tfinal int byteValue=u1[currentOffset++];\n\t\tif((byteValue&0x80)==0){ // 0xxxxxxx\n\t\t\tcharBuffer[charIndex++]=(char)byteValue;\n\t\t}else{\n\t\t\tfinal int byte2=u1[currentOffset++];\n\t\t\tif((byteValue&0xE0)==0xC0){ // 110xxxxx 10xxxxxx\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfOffset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tif (utfOffset==0){\n\t\treturn null;\n\t}\n\t// Read the UTF8 entry in the classFileBuffer\n\tint utfLength=((this.classFileBuffer[utfOffset++]&0xFF)<<8)+(this.classFileBuffer[utfOffset++]&0xFF);\n\tif (charBuffer.length<utfLength)\n\t\treturn null;\n\tint c,charIndex=0;\n\twhile (utfLength>0){\n\t\tc=this.classFileBuffer[utfOffset++]&0xFF;\n\t\tutfLength--;\n\t\tswitch (c>>4){\n\t\t\tcase 0 :\n\t\t\tcase 1 :\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\tcase 6 :\n\t\t\tcase 7 :\n\t\t\t\t/* 0xxxxxxx*/\n\t\t\t\tcharBuffer[charIndex++]=(char)c;\n\t\t\tbreak;", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfOffset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tint length=(buffer[utfOffset++]&0xFF)<<8|(buffer[utfOffset++]&0xFF);\n\treturn new String(buffer,utfOffset,length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n", "method_name": "readUtf", "codes": ["final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=0;\n\tint readOffset=-1;\n\tint writeOffset=0;\n\tbyte[] classFileBuffer=this.referenceClass.classFileBuffer;\n\tif(constantPoolEntryIndex<=0||constantPoolEntryIndex>=this.constantPoolCount){\n\t\tthrow new IllegalArgumentException(Messages.bind(Messages.classfile_IllegalValue,new Integer(constantPoolEntryIndex)));\n\t}\n\t// read the length of the utf8 string in the constant pool\n\tint utfOffset=this.structOffset+3+2+2+(constantPoolEntryIndex-1)*2;\n\tutfLength=u2At(classFileBuffer,utfOffset);\n\treadOffset=utfOffset+2;\n\tif(charBuffer==null||charBuffer.length<utfLength){\n\t\tcharBuffer=new char[utfLength*2]; // grow\n\t}\n\t// read the utf8 bytes and convert them into unicode chars\n\tint c;\n\tfor (int i=0;i<utfLength;){\n\t\tc=classFile", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfLength=this.classFileBuffer[this.currentOffset++]&0xFF;\n\tswitch(utfLength){\n\t\tcase 0:\n\t\t\treturn null;\n\t\tcase 1:\n\t\t\treturn Utf8Constants.ONE_ZERO_CHAR_STRING;\n\t\tdefault:\n\t\t\tchar[] utfBuffer;\n\t\t\tif(charBuffer==null||utfLength>charBuffer.length){\n\t\t\t\tutfBuffer=new char[utfLength];\n\t\t\t}else{\n\t\t\t\tutfBuffer=charBuffer;\n\t\t\t}\n\t\t\tint readOffset=this.currentOffset;\n\t\t\tint writeOffset=0;\n\t\t\tint utfValue;\n\t\t\tint utfCount=0;\n\t\t\tfinal int endOffset=readOffset+utfLength;\n\t\t\twhile(readOffset<endOffset){\n\t\t\t\tutfValue=this.classFileBuffer[readOffset++]&0xFF;\n\t\t\t\tif((utfValue&0x80)!=0){\n\t\t", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=classFileBuffer[u2At(constantPoolEntryIndex)]&0xFF;\n\tint readOffset=constantPoolEntryIndex+3;\n\tint endOffset=readOffset+utfLength;\n\tif(charBuffer==null){\n\t\treturn new String(classFileBuffer,readOffset,utfLength);\n\t}\n\tint charIndex=0;\n\twhile(readOffset<endOffset){\n\t\tchar aChar=(char)u2At(readOffset);\n\t\treadOffset+=2;\n\t\tcharBuffer[charIndex++]=aChar;\n\t}\n\treturn new String(charBuffer,0,charIndex);\n}", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n  if(constantPoolEntryIndex<1||constantPoolEntryIndex>=constantPoolCount){\n    throw new IllegalArgumentException(\"Invalid constant pool entry index \"+constantPoolEntryIndex);\n  }\n  if(constantPoolEntryTag[constantPoolEntryIndex]!=CONSTANT_Utf8){\n    throw new IllegalArgumentException(\"Invalid constant pool entry index \"+constantPoolEntryIndex);\n  }\n  int utf8Offset=this.constantPoolEntryOffset[constantPoolEntryIndex];\n  int utf8Length=classFileBuffer[utf8Offset++]<<8|classFileBuffer[utf8Offset++];\n  int currentChar=0;\n  for(int i=0;i<utf8Length;i++){\n    int byte1=classFileBuffer[utf8Offset++]&0xff;\n    if(byte1<128){// 0xxxxxxx\n      charBuffer[currentChar++]=(char)byte1;\n    }else if((byte1&0xe0)==0xc0){ // 110xxxxx 10xxxxxx\n      int byte2=classFileBuffer", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n    final int utf8Offset=this.constantPoolOffsets[constantPoolEntryIndex-1];\n    if(utf8Offset==0)\n        return null;\n    int length=this.classFileBuffer[utf8Offset++]&0xFF;\n    switch(length&0xC0){\n        case 0x80: // 2 bytes unsigned\n            length=((length&0x3F)<<8)+(this.classFileBuffer[utf8Offset++]&0xFF);\n            break;\n        case 0xC0: // 3 bytes unsigned\n            length=\n                ((length&0x3F)<<8)+(this.classFileBuffer[utf8Offset++]&0xFF)<<8\n                +(this.classFileBuffer[utf8Offset++]&0xFF);\n            break;\n        default:\n    }\n    char[] result=charBuffer;\n    if(result==null || result.length<length)\n        result=new char[length];\n    int readOffset=utf8Offset;\n    int writeOffset=0;\n    int numberOfBytesInBuffer", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfIndex=this.constantPoolOffsets[constantPoolEntryIndex];\n\tfinal int length=u2At(classFileBuffer,utfIndex);\n\tif(length==0) return Util.EMPTY_STRING;\n\tchar[] result=this.constantPoolCharArray[constantPoolEntryIndex];\n\tif(result==null){\n\t\tthis.constantPoolCharArray[constantPoolEntryIndex]=result=CharOperation.NO_CHAR;\n\t\tfinal int end=utfIndex+2+length;\n\t\tint charIndex=0;\n\t\tfor(int byteIndex=utfIndex+2;byteIndex<end;){\n\t\t\tint byte1=classFileBuffer[byteIndex++]&0xff;\n\t\t\tswitch(byte1>>4){\n\t\t\t\tcase 0 :\n\t\t\t\tcase 1 :\n\t\t\t\tcase 2 :\n\t\t\t\tcase 3 :\n\t\t\t\tcase 4 :\n\t\t\t\tcase 5 :\n\t\t\t\tcase 6 :\n\t\t\t\tcase 7 :\n\t\t\t\t\t//", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfLength=constantPool[constantPoolEntryIndex];\n\tbyte[] utfBytes=new byte[utfLength];\n\tSystem.arraycopy(classFileBuffer,u4(classFileOffset+1),utfBytes,0,utfLength);\n\ttry {\n\t\treturn new String(utfBytes,Utf8Names.UTF8_ENCODING);\n\t} catch (UnsupportedEncodingException e) {\n\t\t// should never happen since UTF-8 is supported on all platforms.\n\t\te.printStackTrace();\n\t\treturn null;\n\t}\n}", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utf8Length=0;\n\tfinal int offset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tfinal int tag=u1[offset];\n\tif(tag!=CONSTANT_Utf8){\n\t\tthrow new IllegalArgumentException();\n\t}\n\t// read the length in the first two bytes\n\tint currentOffset=offset+1;\n\tutf8Length=u1[currentOffset++]<<8;\n\tutf8Length+=u1[currentOffset++];\n\t// read the bytes\n\tfinal int end=currentOffset+utf8Length;\n\tint charIndex=0;\n\twhile(currentOffset<end){\n\t\tfinal int byteValue=u1[currentOffset++];\n\t\tif((byteValue&0x80)==0){ // 0xxxxxxx\n\t\t\tcharBuffer[charIndex++]=(char)byteValue;\n\t\t}else{\n\t\t\tfinal int byte2=u1[currentOffset++];\n\t\t\tif((byteValue&0xE0)==0xC0){ // 110xxxxx 10xxxxxx\n", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tint utfOffset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tif (utfOffset==0){\n\t\treturn null;\n\t}\n\t// Read the UTF8 entry in the classFileBuffer\n\tint utfLength=((this.classFileBuffer[utfOffset++]&0xFF)<<8)+(this.classFileBuffer[utfOffset++]&0xFF);\n\tif (charBuffer.length<utfLength)\n\t\treturn null;\n\tint c,charIndex=0;\n\twhile (utfLength>0){\n\t\tc=this.classFileBuffer[utfOffset++]&0xFF;\n\t\tutfLength--;\n\t\tswitch (c>>4){\n\t\t\tcase 0 :\n\t\t\tcase 1 :\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\tcase 6 :\n\t\t\tcase 7 :\n\t\t\t\t/* 0xxxxxxx*/\n\t\t\t\tcharBuffer[charIndex++]=(char)c;\n\t\t\tbreak;", "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n\n\tfinal int utfOffset=this.constantPoolOffsets[constantPoolEntryIndex];\n\tint length=(buffer[utfOffset++]&0xFF)<<8|(buffer[utfOffset++]&0xFF);\n\treturn new String(buffer,utfOffset,length);\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec01782a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public int hashCode(){\n\n\tif (type==1) return hashCode(str);\n\tif (type==2) return hashCode(str);\n\tif (type==3) return hashCode(str);\n\tif (type==4) return hashCode(str);\n\tif (type==5) return hashCode(str);\n\tif (type==6) return hashCode(str);\n\treturn 0;}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n\tint result=0;\n\tresult=result*31+name.hashCode();\n\tresult=result*31+args.hashCode();\n\tresult=result*31+body==null?0:body.hashCode();\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n    return this.name().hashCode();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n    switch(type){\n        case INTEGER: return Objects.hashCode(value);\n        case FLOAT: return Float.hashCode(value);\n        case STRING: return Objects.hashCode(value);\n        case BOOLEAN: return Objects.hashCode(value);\n        case NULL: return Objects.hashCode(value);\n        case ARRAY: return Objects.hashCode(value);\n        case OBJECT: return Objects.hashCode(value);\n        default: throw new Error(\"Unknown type: \"+type);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n    return type.hashCode();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n\tint code = 0;\n\tif(this.type == null) code = 0;\n\telse if(this.type.equals(\"String\")) code = this.value.hashCode();\n\telse if(this.type.equals(\"Integer\")) code = this.value.hashCode();\n\telse if(this.type.equals(\"Double\")) code = this.value.hashCode();\n\treturn code;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n\treturn 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n\tint hash=0;\n\tfor(int i=0;i<this.length();i++){\n\t\tbyte b=this.get(i);\n\t\thash=hash*31+b;\n\t}\n\treturn hash;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\n\n\tswitch(type){\n\t\tcase tt_bool: if(bool){return 1;}else{return 0;}\n\t\tcase tt_int: return (int)int_val;\n\t\tcase tt_string: return string_val.hashCode();\n\t\tcase tt_double: return ((Double)double_val).hashCode();\n\t\tcase tt_null: return 0;\n\t\tcase tt_empty: return 0;\n\t\tcase tt_list: return list.hashCode();\n\t\tcase tt_dict: return dict.hashCode();\n\t\tdefault: return 0;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int hashCode(){\nreturn type.hashCode();}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a hash code value for this type.\n * @return a hash code value for this type.\n */\n", "method_name": "hashCode", "codes": ["@Override public int hashCode(){\n\n\tif (type==1) return hashCode(str);\n\tif (type==2) return hashCode(str);\n\tif (type==3) return hashCode(str);\n\tif (type==4) return hashCode(str);\n\tif (type==5) return hashCode(str);\n\tif (type==6) return hashCode(str);\n\treturn 0;}", "@Override public int hashCode(){\n\n\tint result=0;\n\tresult=result*31+name.hashCode();\n\tresult=result*31+args.hashCode();\n\tresult=result*31+body==null?0:body.hashCode();\n\treturn result;\n}", "@Override public int hashCode(){\n\n    return this.name().hashCode();\n}", "@Override public int hashCode(){\n\n    switch(type){\n        case INTEGER: return Objects.hashCode(value);\n        case FLOAT: return Float.hashCode(value);\n        case STRING: return Objects.hashCode(value);\n        case BOOLEAN: return Objects.hashCode(value);\n        case NULL: return Objects.hashCode(value);\n        case ARRAY: return Objects.hashCode(value);\n        case OBJECT: return Objects.hashCode(value);\n        default: throw new Error(\"Unknown type: \"+type);\n    }\n}", "@Override public int hashCode(){\n\n    return type.hashCode();\n}", "@Override public int hashCode(){\n\n\tint code = 0;\n\tif(this.type == null) code = 0;\n\telse if(this.type.equals(\"String\")) code = this.value.hashCode();\n\telse if(this.type.equals(\"Integer\")) code = this.value.hashCode();\n\telse if(this.type.equals(\"Double\")) code = this.value.hashCode();\n\treturn code;\n}", "@Override public int hashCode(){\n\n\treturn 1;\n}", "@Override public int hashCode(){\n\n\tint hash=0;\n\tfor(int i=0;i<this.length();i++){\n\t\tbyte b=this.get(i);\n\t\thash=hash*31+b;\n\t}\n\treturn hash;\n}", "@Override public int hashCode(){\n\n\tswitch(type){\n\t\tcase tt_bool: if(bool){return 1;}else{return 0;}\n\t\tcase tt_int: return (int)int_val;\n\t\tcase tt_string: return string_val.hashCode();\n\t\tcase tt_double: return ((Double)double_val).hashCode();\n\t\tcase tt_null: return 0;\n\t\tcase tt_empty: return 0;\n\t\tcase tt_list: return list.hashCode();\n\t\tcase tt_dict: return dict.hashCode();\n\t\tdefault: return 0;\n\t}\n}", "@Override public int hashCode(){\nreturn type.hashCode();}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec017758", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\tfinal int nameIndex=addConstantUtf8(name);\n\tfinal int descriptorIndex=addConstantUtf8(descriptor);\n\treturn addConstantNameAndTypeInfo(nameIndex,descriptorIndex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n    int nameIndex = addConstantUtf8(name);\n    int descIndex = addConstantUtf8(descriptor);\n    return addConstantNameAndType(nameIndex,descIndex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n    return addConstantNameAndType(name,descriptor,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstant(new ConstantNameAndType(name,descriptor));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(newNameAndType(name,descriptor));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\tint index=0;\n\tif(name!=null&&name.length()>0&&descriptor!=null&&descriptor.length()>0){\n\t\tindex=addConstantUtf8(name);\n\t\tindex=addConstantUtf8(descriptor);\n\t\tindex=addConstantNameAndType(index,index);\n\t}\n\treturn index;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(name,descriptor,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\tfinal int nameIndex=addConstantUtf8(name);\n\tfinal int descriptorIndex=addConstantUtf8(descriptor);\n\treturn addConstantNameAndType(nameIndex,descriptorIndex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n    int nameIndex=addConstantUtf8(name);\n    int descriptorIndex=addConstantUtf8(descriptor);\n    return addConstantNameAndType(nameIndex,descriptorIndex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(name,descriptor,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n", "method_name": "addConstantNameAndType", "codes": ["int addConstantNameAndType(final String name,final String descriptor){\n\n\tfinal int nameIndex=addConstantUtf8(name);\n\tfinal int descriptorIndex=addConstantUtf8(descriptor);\n\treturn addConstantNameAndTypeInfo(nameIndex,descriptorIndex);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n    int nameIndex = addConstantUtf8(name);\n    int descIndex = addConstantUtf8(descriptor);\n    return addConstantNameAndType(nameIndex,descIndex);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n    return addConstantNameAndType(name,descriptor,false);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstant(new ConstantNameAndType(name,descriptor));\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(newNameAndType(name,descriptor));\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\tint index=0;\n\tif(name!=null&&name.length()>0&&descriptor!=null&&descriptor.length()>0){\n\t\tindex=addConstantUtf8(name);\n\t\tindex=addConstantUtf8(descriptor);\n\t\tindex=addConstantNameAndType(index,index);\n\t}\n\treturn index;\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(name,descriptor,false);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\tfinal int nameIndex=addConstantUtf8(name);\n\tfinal int descriptorIndex=addConstantUtf8(descriptor);\n\treturn addConstantNameAndType(nameIndex,descriptorIndex);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n    int nameIndex=addConstantUtf8(name);\n    int descriptorIndex=addConstantUtf8(descriptor);\n    return addConstantNameAndType(nameIndex,descriptorIndex);\n}", "int addConstantNameAndType(final String name,final String descriptor){\n\n\treturn addConstantNameAndType(name,descriptor,false);\n}"], "code_level": "project_runnable", "_id": "636766fe1a6d9265ec017823", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.numberOfLines = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\t\tthis.lineNumber = lineNumber;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumberList.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\taddField(\"lineNumber\",new Integer(lineNumber));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber += lineNumber;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tlineNumbers.add(lineNumber);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tlines.add(lineNumber);\n\tnumLines++;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber = lineNumber;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumbers.add(lineNumber);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Adds a source line number corresponding to this label.\n * @param lineNumber a source line number (which should be strictly positive).\n */\n", "method_name": "addLineNumber", "codes": ["final void addLineNumber(final int lineNumber){\n\n\tthis.numberOfLines = lineNumber;\n}", "final void addLineNumber(final int lineNumber){\n\n\t\tthis.lineNumber = lineNumber;\n\t}", "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumberList.add(lineNumber);\n}", "final void addLineNumber(final int lineNumber){\n\n\taddField(\"lineNumber\",new Integer(lineNumber));\n}", "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber += lineNumber;\n}", "final void addLineNumber(final int lineNumber){\n\n\tlineNumbers.add(lineNumber);\n\t}", "final void addLineNumber(final int lineNumber){\n\n\tlines.add(lineNumber);\n\tnumLines++;\n}", "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber = lineNumber;\n}", "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumber = lineNumber;\n}", "final void addLineNumber(final int lineNumber){\n\n\tthis.lineNumbers.add(lineNumber);\n}"], "code_level": "class_runnable", "_id": "636767131a6d9265ec017b23", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOfLastSeparator(String filename){\n\n    if (filename == null) return -1;\n    int lastUnixPos = filename.lastIndexOf('/');\n    int lastWindowsPos = filename.lastIndexOf('\\\\');\n    return Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null)return -1;\n\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null)return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif (isWindowsPlatform()){\n\t\treturn indexOfLastSeparator(filename, '\\\\');\n\t}\n\treturn indexOfLastSeparator(filename, '/');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf('/');\n\tint lastWindowsPos=filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename == null) return -1;\n\tint lastUnixPos = filename.lastIndexOf('/');\n\tint lastWindowsPos = filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos, lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif (filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\nreturn indexOfLastSeparator(filename, false);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf('/');\n\tint lastWindowsPos=filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the index of the last directory separator character. <p> This method will handle a file in either Unix or Windows format. The position of the last forward or backslash is returned. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfLastSeparator", "codes": ["public static int indexOfLastSeparator(String filename){\n\n    if (filename == null) return -1;\n    int lastUnixPos = filename.lastIndexOf('/');\n    int lastWindowsPos = filename.lastIndexOf('\\\\');\n    return Math.max(lastUnixPos, lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null)return -1;\n\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null)return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif (isWindowsPlatform()){\n\t\treturn indexOfLastSeparator(filename, '\\\\');\n\t}\n\treturn indexOfLastSeparator(filename, '/');\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf('/');\n\tint lastWindowsPos=filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename == null) return -1;\n\tint lastUnixPos = filename.lastIndexOf('/');\n\tint lastWindowsPos = filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos, lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif (filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\nreturn indexOfLastSeparator(filename, false);}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf('/');\n\tint lastWindowsPos=filename.lastIndexOf('\\\\');\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}", "public static int indexOfLastSeparator(String filename){\n\n\tif(filename==null) return -1;\n\tint lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n\tint lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n\treturn Math.max(lastUnixPos,lastWindowsPos);\n}"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017658", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n\tif (file.isDirectory()) {\n\t\tdeleteDirectoryOnExit(file);\n\t} else {\n\t\tfile.deleteOnExit();\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.exists()) {\n        file.deleteOnExit();\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                forceDeleteOnExit(files[i]);\n            }\n        }\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void forceDeleteOnExit(File file) throws IOException {\n\n\tif (file.isDirectory()) {\n\t\tdeleteDirectoryOnExit(file);\n\t} else {\n\t\tfile.deleteOnExit();\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n", "method_name": "forceDeleteOnExit", "codes": ["public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n\tif (file.isDirectory()) {\n\t\tdeleteDirectoryOnExit(file);\n\t} else {\n\t\tfile.deleteOnExit();\n\t}\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.exists()) {\n        file.deleteOnExit();\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                forceDeleteOnExit(files[i]);\n            }\n        }\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n    if (file.isDirectory()) {\n        deleteDirectoryOnExit(file);\n    } else {\n        file.deleteOnExit();\n    }\n}", "public static void forceDeleteOnExit(File file) throws IOException {\n\n\tif (file.isDirectory()) {\n\t\tdeleteDirectoryOnExit(file);\n\t} else {\n\t\tfile.deleteOnExit();\n\t}\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017833", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOfExtension(String filename){\n\n  if(filename==null){\n    return -1;\n  }\n  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastDirPos=indexOfLastSeparator(filename);\n  return lastDirPos>extensionPos?-1:extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null) return -1;\n\tint extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator = indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos?-1:extensionPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos?-1:extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator = indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos ? -1 : extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos?-1:extensionPos;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastDirPos=indexOfLastSeparator(filename);\n\tif(extensionPos>lastDirPos){\n\t\treturn extensionPos;\n\t}\n\treturn -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos ? -1 : extensionPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\treturn org.apache.commons.io.FilenameUtils.indexOfExtension(filename);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null)\n\t\treturn -1;\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos?-1:extensionPos);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOfExtension(String filename){\n\n\tif(filename==null)return -1;\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastDirPos=indexOfLastDirectory(filename);\n\tif(extensionPos>lastDirPos)return extensionPos;\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n", "method_name": "indexOfExtension", "codes": ["public static int indexOfExtension(String filename){\n\n  if(filename==null){\n    return -1;\n  }\n  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastDirPos=indexOfLastSeparator(filename);\n  return lastDirPos>extensionPos?-1:extensionPos;\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null) return -1;\n\tint extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator = indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos?-1:extensionPos);\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos?-1:extensionPos;\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator = indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos ? -1 : extensionPos;\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn lastSeparator>extensionPos?-1:extensionPos;\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastDirPos=indexOfLastSeparator(filename);\n\tif(extensionPos>lastDirPos){\n\t\treturn extensionPos;\n\t}\n\treturn -1;\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null){\n\t\treturn -1;\n\t}\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos ? -1 : extensionPos);\n}", "public static int indexOfExtension(String filename){\n\n\treturn org.apache.commons.io.FilenameUtils.indexOfExtension(filename);\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null)\n\t\treturn -1;\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastSeparator=indexOfLastSeparator(filename);\n\treturn (lastSeparator>extensionPos?-1:extensionPos);\n}", "public static int indexOfExtension(String filename){\n\n\tif(filename==null)return -1;\n\tint extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n\tint lastDirPos=indexOfLastDirectory(filename);\n\tif(extensionPos>lastDirPos)return extensionPos;\n\treturn -1;\n}"], "code_level": "class_runnable", "_id": "636767061a6d9265ec01794a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public void write(byte b[]) throws IOException {\n\nout.write(b);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n\tout.write(b, 0, b.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n    String s = new String(b);\n    if (s.contains(\"\\n\")) {\n\t\ts = s.replace(\"\\n\", \" \");\n\t}\n\t\t\n    System.out.print(s);\n    printStream.print(s);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n    write(b,0,b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(byte b[]) throws IOException {\n\n    write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n", "method_name": "write", "codes": ["@Override public void write(byte b[]) throws IOException {\n\nout.write(b);\n}", "@Override public void write(byte b[]) throws IOException {\n\n\tout.write(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n    String s = new String(b);\n    if (s.contains(\"\\n\")) {\n\t\ts = s.replace(\"\\n\", \" \");\n\t}\n\t\t\n    System.out.print(s);\n    printStream.print(s);\n}", "@Override public void write(byte b[]) throws IOException {\n\n    write(b,0,b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n  write(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n\twrite(b, 0, b.length);\n}", "@Override public void write(byte b[]) throws IOException {\n\n    write(b, 0, b.length);\n}"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179fe", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfor(int i=off;i<len;i++) write(b[i]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\nif(len<=0) {\nreturn;\n}\nif(off<0||len<0||(off+len)>b.length) {\nthrow new IndexOutOfBoundsException();\n}\nif(len>=1024) {\nwrite(b);\n}\nelse {\nint i=len;\nwhile(i>0) {\nif(this.count==this.buf.length) {\nflushBuffer();\n}\nif(i>=this.buf.length) {\nwrite(b);\n}\nelse {\nSystem.arraycopy(b,off+len-i,this.buf,this.count,i);\nthis.count+=i;\n}\ni-=this.count;\n}\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n  if (off<0 || off>=b.length || off+len>b.length) throw new ArrayIndexOutOfBoundsException();\n  if (len<0) throw new IllegalArgumentException();\n  if (len==0) return;\n\n  //if (len<=8) {\n  //  for (int i=0;i<len;i++) buffer[bufpos++]=b[off+i];\n  //} else {\n  //  System.arraycopy(b,off,buffer,bufpos,len);\n  //  bufpos+=len;\n  //}\n  //if (bufpos>=BUFSIZE) {\n  //  flush();\n  //}\n\n  for (int i=0;i<len;i++) {\n    buffer[bufpos++]=b[off+i];\n    if (bufpos>=BUFSIZE) {\n      flush();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n  if(off+len>b.length) {\n   throw new IOException(\"Index out of bounds exception\");\n  }\n  for(int i=0;i<len;i++) {\n   writeByte(b[i+off]);\n  }\n }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfinal int total=len+off;\n\tfor(int i=off;i<total;i++){\n\t\twrite(b[i]);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\t\tif(off<0 || len<0 || off+len>b.length)throw new IndexOutOfBoundsException();\n\t\tif(len==0)return;\n\t\tint written=0;\n\t\twhile(written<len){\n\t\t\tfinal int size=Math.min(len-written,MAX_CHUNK_SIZE);\n\t\t\tfinal File f=new File(dir,fileName+\"_\"+fileIndex);\n\t\t\tRandomAccessFile raf=new RandomAccessFile(f,\"rw\");\n\t\t\traf.seek(raf.length());\n\t\t\traf.write(b,off+written,size);\n\t\t\traf.close();\n\t\t\twritten+=size;\n\t\t\tfileIndex++;\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\nif(len<1) return;\nensureOpen();\nif(off<0||off>b.length||len<0||off+len>b.length||off+len<0) throw new IndexOutOfBoundsException();\nif(len==1) {\nwrite(b[off]);\nreturn;\n}\nfinal int end=off+len;\nfor(int i=off;i<end;i++) write(b[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tif(closed) {\n\t\tthrow new IOException(\"Stream closed\");\n\t}\n\tif(len==0) {\n\t\treturn;\n\t}\n\tif((off<0)||(off+len>b.length)) {\n\t\tthrow new ArrayIndexOutOfBoundsException();\n\t}\n\tif(len<=buffer.length-count) {\n\t\tSystem.arraycopy(b,off,buffer,count,len);\n\t\tcount+=len;\n\t}\n\telse {\n\t\tflushBuffer();\n\t\tfinal int bLen=b.length;\n\t\tif(len>buffer.length) {\n\t\t\tsuper.write(b,off,len);\n\t\t}\n\t\telse {\n\t\t\tSystem.arraycopy(b,off,buffer,0,len);\n\t\t\tcount=len;\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfor(int i=0;i<len;i++)\n\t\twrite(b[off+i]);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tif(b==null){\n\t\tthrow new NullPointerException();\n\t}else if((off<0)||(off>b.length)||(len<0)||((off+len)>b.length)||((off+len)<0)){\n\t\tthrow new IndexOutOfBoundsException();\n\t}else if(len==0){\n\t\treturn;\n\t}\n\t\n\tsynchronized(this){\n\t\texpand(len);\n\t\tSystem.arraycopy(b,off,buf,count,len);\n\t\tcount+=len;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.\n * @param b   the data.\n * @param off the start offset in the data.\n * @param len the number of bytes to write.\n */\n", "method_name": "write", "codes": ["@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfor(int i=off;i<len;i++) write(b[i]);\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\nif(len<=0) {\nreturn;\n}\nif(off<0||len<0||(off+len)>b.length) {\nthrow new IndexOutOfBoundsException();\n}\nif(len>=1024) {\nwrite(b);\n}\nelse {\nint i=len;\nwhile(i>0) {\nif(this.count==this.buf.length) {\nflushBuffer();\n}\nif(i>=this.buf.length) {\nwrite(b);\n}\nelse {\nSystem.arraycopy(b,off+len-i,this.buf,this.count,i);\nthis.count+=i;\n}\ni-=this.count;\n}\n}\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n  if (off<0 || off>=b.length || off+len>b.length) throw new ArrayIndexOutOfBoundsException();\n  if (len<0) throw new IllegalArgumentException();\n  if (len==0) return;\n\n  //if (len<=8) {\n  //  for (int i=0;i<len;i++) buffer[bufpos++]=b[off+i];\n  //} else {\n  //  System.arraycopy(b,off,buffer,bufpos,len);\n  //  bufpos+=len;\n  //}\n  //if (bufpos>=BUFSIZE) {\n  //  flush();\n  //}\n\n  for (int i=0;i<len;i++) {\n    buffer[bufpos++]=b[off+i];\n    if (bufpos>=BUFSIZE) {\n      flush();\n    }\n  }\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n  if(off+len>b.length) {\n   throw new IOException(\"Index out of bounds exception\");\n  }\n  for(int i=0;i<len;i++) {\n   writeByte(b[i+off]);\n  }\n }", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfinal int total=len+off;\n\tfor(int i=off;i<total;i++){\n\t\twrite(b[i]);\n\t}\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\t\tif(off<0 || len<0 || off+len>b.length)throw new IndexOutOfBoundsException();\n\t\tif(len==0)return;\n\t\tint written=0;\n\t\twhile(written<len){\n\t\t\tfinal int size=Math.min(len-written,MAX_CHUNK_SIZE);\n\t\t\tfinal File f=new File(dir,fileName+\"_\"+fileIndex);\n\t\t\tRandomAccessFile raf=new RandomAccessFile(f,\"rw\");\n\t\t\traf.seek(raf.length());\n\t\t\traf.write(b,off+written,size);\n\t\t\traf.close();\n\t\t\twritten+=size;\n\t\t\tfileIndex++;\n\t\t}\n\t}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\nif(len<1) return;\nensureOpen();\nif(off<0||off>b.length||len<0||off+len>b.length||off+len<0) throw new IndexOutOfBoundsException();\nif(len==1) {\nwrite(b[off]);\nreturn;\n}\nfinal int end=off+len;\nfor(int i=off;i<end;i++) write(b[i]);\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tif(closed) {\n\t\tthrow new IOException(\"Stream closed\");\n\t}\n\tif(len==0) {\n\t\treturn;\n\t}\n\tif((off<0)||(off+len>b.length)) {\n\t\tthrow new ArrayIndexOutOfBoundsException();\n\t}\n\tif(len<=buffer.length-count) {\n\t\tSystem.arraycopy(b,off,buffer,count,len);\n\t\tcount+=len;\n\t}\n\telse {\n\t\tflushBuffer();\n\t\tfinal int bLen=b.length;\n\t\tif(len>buffer.length) {\n\t\t\tsuper.write(b,off,len);\n\t\t}\n\t\telse {\n\t\t\tSystem.arraycopy(b,off,buffer,0,len);\n\t\t\tcount=len;\n\t\t}\n\t}\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tfor(int i=0;i<len;i++)\n\t\twrite(b[off+i]);\n}", "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n\n\tif(b==null){\n\t\tthrow new NullPointerException();\n\t}else if((off<0)||(off>b.length)||(len<0)||((off+len)>b.length)||((off+len)<0)){\n\t\tthrow new IndexOutOfBoundsException();\n\t}else if(len==0){\n\t\treturn;\n\t}\n\t\n\tsynchronized(this){\n\t\texpand(len);\n\t\tSystem.arraycopy(b,off,buf,count,len);\n\t\tcount+=len;\n\t}\n}"], "code_level": "class_runnable", "_id": "636766f91a6d9265ec01776e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\t// TODO Auto-generated method stub\n\t\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\tthis.write(b,0,b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null) {\n\t\tthrow new NullPointerException(\"Byte array is null\");\n\t}\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null) throw new NullPointerException();\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\tif (isOpen) {\n\t\tfinal ByteBuffer byteBuffer;\n\t\tif (encoding == null)\n\t\t\tbyteBuffer = ByteBuffer.wrap(b);\n\t\telse\n\t\t\tbyteBuffer = encoding.encode(new String(b));\n\t\twrite(byteBuffer);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n  write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n    write(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null)\n\t\tthrow new NullPointerException(\"b\");\n\twrite(b, 0, b.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public void write(final byte[] b) throws IOException {\n\n  //System.out.println(\"write(byte[])\");\n  for(byte b2: b) write(b2);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n", "method_name": "write", "codes": ["@Override public void write(final byte[] b) throws IOException {\n\n\t// TODO Auto-generated method stub\n\t\n}", "@Override public void write(final byte[] b) throws IOException {\n\n\tthis.write(b,0,b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n  write(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null) {\n\t\tthrow new NullPointerException(\"Byte array is null\");\n\t}\n\twrite(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null) throw new NullPointerException();\n\twrite(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n\tif (isOpen) {\n\t\tfinal ByteBuffer byteBuffer;\n\t\tif (encoding == null)\n\t\t\tbyteBuffer = ByteBuffer.wrap(b);\n\t\telse\n\t\t\tbyteBuffer = encoding.encode(new String(b));\n\t\twrite(byteBuffer);\n\t}\n}", "@Override public void write(final byte[] b) throws IOException {\n\n  write(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n    write(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n\tif (b == null)\n\t\tthrow new NullPointerException(\"b\");\n\twrite(b, 0, b.length);\n}", "@Override public void write(final byte[] b) throws IOException {\n\n  //System.out.println(\"write(byte[])\");\n  for(byte b2: b) write(b2);\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179d8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public String toString(){\n\n\t//Create a new string of the required length\n\tString s = new String(buf,0,count);\n\treturn s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n    return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\treturn this.sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n  return new String(buf,0,len);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n    return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\treturn new String(this.data);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\treturn new String(getBuf(), 0, getLen());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n    return this.sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\treturn this.sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n    return s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n", "method_name": "toString", "codes": ["public String toString(){\n\n\t//Create a new string of the required length\n\tString s = new String(buf,0,count);\n\treturn s;\n}", "public String toString(){\n\n    return sb.toString();\n}", "public String toString(){\n\n\treturn this.sb.toString();\n}", "public String toString(){\n\n  return new String(buf,0,len);\n}", "public String toString(){\n\n    return sb.toString();\n}", "public String toString(){\n\n\treturn new String(this.data);\n}", "public String toString(){\n\n\treturn new String(getBuf(), 0, getLen());\n}", "public String toString(){\n\n    return this.sb.toString();\n}", "public String toString(){\n\n\treturn this.sb.toString();\n}", "public String toString(){\n\n    return s;\n}"], "code_level": "project_runnable", "_id": "636767001a6d9265ec01787e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n  buffer.append(arrayStart);\n  for(int i=0;i<array.length;i++){\n    if(i>0){\n      buffer.append(arraySeparator);\n    }\n    buffer.append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.getClass().getName());\n\tbuffer.append(\"[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(\"]\");\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\nbuffer.append(fieldName);\nbuffer.append(this.arrayStart);\nfor(int i=0;i<array.length;i++){\nif(i>0){\nbuffer.append(this.arraySeparator);\n}\nbuffer.append(array[i]);\n}\nbuffer.append(this.arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tappendDetail(buffer,fieldName,array,0,array.length-1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(arrayStart);\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0){\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t\tappendDetail(buffer,fieldName,array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.length);\n\tbuffer.append(arraySeparator);\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tbuffer.append(arraySeparator);\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.length);\n\tbuffer.append(arrayStart);\n\tfor (int i=0; i < array.length; i++) {\n\t\tif (i > 0) {\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t\tappendDetail(buffer,fieldName,array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(arrayStart);\n\tfor (int i=0;i<array.length;i++){\n\t\tif (i>0) buffer.append(arraySeparator);\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array==null?\"null\":arrayToString(array));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\nbuffer.append(fieldName);buffer.append(arrayStart);for(int i=0;i<array.length;i++){if(i>0){buffer.append(arraySeparator);}buffer.append(array[i]);}buffer.append(arrayEnd);}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n  buffer.append(arrayStart);\n  for(int i=0;i<array.length;i++){\n    if(i>0){\n      buffer.append(arraySeparator);\n    }\n    buffer.append(array[i]);\n  }\n  buffer.append(arrayEnd);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.getClass().getName());\n\tbuffer.append(\"[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(\"]\");\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\nbuffer.append(fieldName);\nbuffer.append(this.arrayStart);\nfor(int i=0;i<array.length;i++){\nif(i>0){\nbuffer.append(this.arraySeparator);\n}\nbuffer.append(array[i]);\n}\nbuffer.append(this.arrayEnd);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tappendDetail(buffer,fieldName,array,0,array.length-1);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(arrayStart);\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0){\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t\tappendDetail(buffer,fieldName,array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.length);\n\tbuffer.append(arraySeparator);\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tbuffer.append(arraySeparator);\n\t}\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array.length);\n\tbuffer.append(arrayStart);\n\tfor (int i=0; i < array.length; i++) {\n\t\tif (i > 0) {\n\t\t\tbuffer.append(arraySeparator);\n\t\t}\n\t\tappendDetail(buffer,fieldName,array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(arrayStart);\n\tfor (int i=0;i<array.length;i++){\n\t\tif (i>0) buffer.append(arraySeparator);\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(arrayEnd);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n\n\tbuffer.append(array==null?\"null\":arrayToString(array));\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\nbuffer.append(fieldName);buffer.append(arrayStart);for(int i=0;i<array.length;i++){if(i>0){buffer.append(arraySeparator);}buffer.append(array[i]);}buffer.append(arrayEnd);}"], "code_level": "class_runnable", "_id": "636767001a6d9265ec01787f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n    if(collection == null || collection.isEmpty()){\n        return EMPTY_STRING_ARRAY;\n    }\n    return collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection==null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n    if(collection == null || collection.isEmpty()){\n        return EMPTY_STRING_ARRAY;\n    }\n    return (String[]) collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif (collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toStringArray(collection);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection==null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn (String[]) collection.toArray(new String[collection.size()]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Collection<?> collection){\n\n\treturn toNoNullStringArray(collection, EMPTY_STRING_ARRAY);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Collection<?> collection){\n\n    if(collection == null || collection.isEmpty()){\n        return EMPTY_STRING_ARRAY;\n    }\n    return collection.toArray(new String[collection.size()]);\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection==null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n    if(collection == null || collection.isEmpty()){\n        return EMPTY_STRING_ARRAY;\n    }\n    return (String[]) collection.toArray(new String[collection.size()]);\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif (collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toStringArray(collection);\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection==null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn (String[]) collection.toArray(new String[collection.size()]);\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\tif(collection == null){\n\t\treturn EMPTY_STRING_ARRAY;\n\t}\n\treturn toNoNullStringArray(collection.toArray());\n}", "static String[] toNoNullStringArray(Collection<?> collection){\n\n\treturn toNoNullStringArray(collection, EMPTY_STRING_ARRAY);\n}"], "code_level": "project_runnable", "_id": "636766f71a6d9265ec017730", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "static void register(Object value){\n\n\tif(value!=null)\n\t\tREGISTRY.put(value.getClass(), value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif(value != null) REGISTRY.put(value, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n  if(value != null){\n    REGISTRY.put(value, value);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif(value != null)\n\t\tREGISTRY.put(value.getClass(), value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif(value != null){\n\t\tREGISTRY.put(value.getClass(),value);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif(value != null)\n\t\ttry{\n\t\t\tUnsafe.getUnsafe().putObject(REGISTRY, Unsafe.getUnsafe().objectFieldOffset(\n\t\t\t\t\tObject.class.getDeclaredField(\"referent\")), value);\n\t\t}catch(Exception e){\n\t\t\tthrow new InternalError(e);\n\t\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif (value != null)\n\t\tREGISTRY.put(value, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif (value == null) return;\n\tREGISTRY.add(value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n\tif(value != null){\n\t\ttry{\n\t\t\tRegistry.register(value);\n\t\t}catch(IllegalArgumentException e){\n\t\t\tLog.e(\"Register\", e.getMessage());\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static void register(Object value){\n\n    if(value != null) REGISTRY.put(value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n", "method_name": "register", "codes": ["static void register(Object value){\n\n\tif(value!=null)\n\t\tREGISTRY.put(value.getClass(), value);\n}", "static void register(Object value){\n\n\tif(value != null) REGISTRY.put(value, null);\n}", "static void register(Object value){\n\n  if(value != null){\n    REGISTRY.put(value, value);\n  }\n}", "static void register(Object value){\n\n\tif(value != null)\n\t\tREGISTRY.put(value.getClass(), value);\n}", "static void register(Object value){\n\n\tif(value != null){\n\t\tREGISTRY.put(value.getClass(),value);\n\t}\n}", "static void register(Object value){\n\n\tif(value != null)\n\t\ttry{\n\t\t\tUnsafe.getUnsafe().putObject(REGISTRY, Unsafe.getUnsafe().objectFieldOffset(\n\t\t\t\t\tObject.class.getDeclaredField(\"referent\")), value);\n\t\t}catch(Exception e){\n\t\t\tthrow new InternalError(e);\n\t\t}\n}", "static void register(Object value){\n\n\tif (value != null)\n\t\tREGISTRY.put(value, value);\n}", "static void register(Object value){\n\n\tif (value == null) return;\n\tREGISTRY.add(value);\n}", "static void register(Object value){\n\n\tif(value != null){\n\t\ttry{\n\t\t\tRegistry.register(value);\n\t\t}catch(IllegalArgumentException e){\n\t\t\tLog.e(\"Register\", e.getMessage());\n\t\t}\n\t}\n}", "static void register(Object value){\n\n    if(value != null) REGISTRY.put(value);\n}"], "code_level": "class_runnable", "_id": "636767041a6d9265ec017911", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":\");\n\tif(array==null){\n\t\tbuffer.append(\"null\");\n\t}else{\n\t\tbuffer.append('[');\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tbuffer.append(array[i]);\n\t\t\tif(i<array.length-1){\n\t\t\t\tbuffer.append(',');\n\t\t\t}\n\t\t}\n\t\tbuffer.append(']');\n\t}\n\tbuffer.append('\\n');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(array);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":byte[\");\n\tbuffer.append(array.length);\n\tbuffer.append(\"]{\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1)\n\t\t\tbuffer.append(',');\n\t}\n\tbuffer.append('}');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\": byte[\");\n\tbuffer.append(array.length);\n\tbuffer.append(']');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\"=[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(array.length==0 ? \"[empty]\" : \"[\"+array.length+\" bytes]\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName).append(\":byte[\");\n\tappendDetail(buffer,array);\n\tbuffer.append(']');\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(array.getClass().getName());\n\tbuffer.append(fieldName);\n\tbuffer.append(\":\");\n\tbuffer.append('[');\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0)\n\t\t\tbuffer.append(',');\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(']');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * <p>Append to the <code>toString</code> the detail of a <code>byte</code> array.</p>\n * @param buffer  the <code>StringBuffer</code> to populate\n * @param fieldName  the field name, typically not used as already appended\n * @param array  the array to add to the <code>toString</code>,not <code>null</code>\n */\n", "method_name": "appendDetail", "codes": ["protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":\");\n\tif(array==null){\n\t\tbuffer.append(\"null\");\n\t}else{\n\t\tbuffer.append('[');\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tbuffer.append(array[i]);\n\t\t\tif(i<array.length-1){\n\t\t\t\tbuffer.append(',');\n\t\t\t}\n\t\t}\n\t\tbuffer.append(']');\n\t}\n\tbuffer.append('\\n');\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(array);\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":byte[\");\n\tbuffer.append(array.length);\n\tbuffer.append(\"]{\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1)\n\t\t\tbuffer.append(',');\n\t}\n\tbuffer.append('}');\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\": byte[\");\n\tbuffer.append(array.length);\n\tbuffer.append(']');\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\"=[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(array.length==0 ? \"[empty]\" : \"[\"+array.length+\" bytes]\");\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName).append(\":byte[\");\n\tappendDetail(buffer,array);\n\tbuffer.append(']');\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(fieldName);\n\tbuffer.append(\":[\");\n\tfor(int i=0;i<array.length;i++){\n\t\tbuffer.append(array[i]);\n\t\tif(i<array.length-1){\n\t\t\tbuffer.append(\",\");\n\t\t}\n\t}\n\tbuffer.append(\"]\");\n}", "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n\n\tbuffer.append(array.getClass().getName());\n\tbuffer.append(fieldName);\n\tbuffer.append(\":\");\n\tbuffer.append('[');\n\tfor(int i=0;i<array.length;i++){\n\t\tif(i>0)\n\t\t\tbuffer.append(',');\n\t\tbuffer.append(array[i]);\n\t}\n\tbuffer.append(']');\n}"], "code_level": "class_runnable", "_id": "636766fe1a6d9265ec017821", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tList list = new ArrayList();\n\tfor(int i=0;i<array.length;i++){\n\t\tObject obj = array[i];\n\t\tif(obj!=null){\n\t\t\tlist.add(obj.toString());\n\t\t}\n\t}\n\treturn (String[])list.toArray(new String[]{});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tif(length==0){\n\t\tthrow new IllegalArgumentException(\"Array must not be empty\");\n\t}\n\tString[] noNullArray=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tnoNullArray[i]=String.valueOf(array[i]);\n\t}\n\treturn noNullArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0)\n\t\tthrow new IllegalArgumentException(\"The array must have at least one element.\");\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]==null)\n\t\t\tthrow new IllegalArgumentException(\"The array must not contain null element.\");\n\t\tString element=array[i].toString();\n\t\tif(element==null)\n\t\t\tthrow new IllegalArgumentException(\"The array must not contain null element.\");\n\t\tresult[i]=element;\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null){\n\t\tthrow new IllegalArgumentException(\"The given array must not be null\");\n\t}\n\tint size=array.length;\n\tif(size==0){\n\t\tthrow new IllegalArgumentException(\"The given array must not be empty\");\n\t}\n\tString[] result=new String[size];\n\tfor(int i=0;i<size;i++){\n\t\tObject object=array[i];\n\t\tresult[i]=object==null?\"\":object.toString();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0){\n\t\tthrow new IllegalArgumentException(\"the array can not be empty or null\");\n\t}\n\tString[] newArray=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnewArray[i]=array[i].toString();\n\t\t}\n\t}\n\treturn newArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tint count=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tcount++;\n\t\t}\n\t}\n\tString[] result=new String[count];\n\tint index=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tresult[index]=array[i].toString();\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]==null){\n\t\t\tthrow new IllegalArgumentException(\"The given array must not contain null elements\");\n\t\t}\n\t\tresult[i]=array[i].toString();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0){\n\t\tthrow new IllegalArgumentException(\"Array can not be null or empty\");\n\t}\n\tint noNullCount=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnoNullCount++;\n\t\t}\n\t}\n\tString[] noNullArray=new String[noNullCount];\n\tnoNullCount=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnoNullArray[noNullCount++]=array[i].toString();\n\t\t}\n\t}\n\treturn noNullArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tString[] result=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tif(array[i]==null){\n\t\t\tresult[i]=\"\";\n\t\t}else{\n\t\t\tresult[i]=array[i].toString();\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tif(length==0)\n\t\tthrow new IllegalArgumentException(\"The input array has no elements.\");\n\tString[] result=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tif(array[i]==null)\n\t\t\tthrow new IllegalArgumentException(\"The input array has null elements.\");\n\t\tresult[i]=array[i].toString();\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n", "method_name": "toNoNullStringArray", "codes": ["static String[] toNoNullStringArray(Object[] array){\n\n\tList list = new ArrayList();\n\tfor(int i=0;i<array.length;i++){\n\t\tObject obj = array[i];\n\t\tif(obj!=null){\n\t\t\tlist.add(obj.toString());\n\t\t}\n\t}\n\treturn (String[])list.toArray(new String[]{});\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tif(length==0){\n\t\tthrow new IllegalArgumentException(\"Array must not be empty\");\n\t}\n\tString[] noNullArray=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tnoNullArray[i]=String.valueOf(array[i]);\n\t}\n\treturn noNullArray;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0)\n\t\tthrow new IllegalArgumentException(\"The array must have at least one element.\");\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]==null)\n\t\t\tthrow new IllegalArgumentException(\"The array must not contain null element.\");\n\t\tString element=array[i].toString();\n\t\tif(element==null)\n\t\t\tthrow new IllegalArgumentException(\"The array must not contain null element.\");\n\t\tresult[i]=element;\n\t}\n\treturn result;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null){\n\t\tthrow new IllegalArgumentException(\"The given array must not be null\");\n\t}\n\tint size=array.length;\n\tif(size==0){\n\t\tthrow new IllegalArgumentException(\"The given array must not be empty\");\n\t}\n\tString[] result=new String[size];\n\tfor(int i=0;i<size;i++){\n\t\tObject object=array[i];\n\t\tresult[i]=object==null?\"\":object.toString();\n\t}\n\treturn result;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0){\n\t\tthrow new IllegalArgumentException(\"the array can not be empty or null\");\n\t}\n\tString[] newArray=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnewArray[i]=array[i].toString();\n\t\t}\n\t}\n\treturn newArray;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tint count=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tcount++;\n\t\t}\n\t}\n\tString[] result=new String[count];\n\tint index=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tresult[index]=array[i].toString();\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn result;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]==null){\n\t\t\tthrow new IllegalArgumentException(\"The given array must not contain null elements\");\n\t\t}\n\t\tresult[i]=array[i].toString();\n\t}\n\treturn result;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tif(array==null||array.length==0){\n\t\tthrow new IllegalArgumentException(\"Array can not be null or empty\");\n\t}\n\tint noNullCount=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnoNullCount++;\n\t\t}\n\t}\n\tString[] noNullArray=new String[noNullCount];\n\tnoNullCount=0;\n\tfor(int i=0;i<array.length;i++){\n\t\tif(array[i]!=null){\n\t\t\tnoNullArray[noNullCount++]=array[i].toString();\n\t\t}\n\t}\n\treturn noNullArray;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tString[] result=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tif(array[i]==null){\n\t\t\tresult[i]=\"\";\n\t\t}else{\n\t\t\tresult[i]=array[i].toString();\n\t\t}\n\t}\n\treturn result;\n}", "static String[] toNoNullStringArray(Object[] array){\n\n\tint length=array.length;\n\tif(length==0)\n\t\tthrow new IllegalArgumentException(\"The input array has no elements.\");\n\tString[] result=new String[length];\n\tfor(int i=0;i<length;i++){\n\t\tif(array[i]==null)\n\t\t\tthrow new IllegalArgumentException(\"The input array has null elements.\");\n\t\tresult[i]=array[i].toString();\n\t}\n\treturn result;\n}"], "code_level": "project_runnable", "_id": "636766fc1a6d9265ec0177ef", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public int available() throws IOException {\n\n    return (int)(p.length() - index);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\tif(available==-1) available=index==0?0:index-1;\n\treturn available;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\t\tif(index>=buf.length) {\n\t\t\treturn 0;\n\t\t}\n\t\telse return buf.length-index;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\nreturn 0;}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\tint available = 0;\n\tif (this.isClosed()) {\n\t\tthrow new IOException(\"InputStream is closed.\");\n\t}\n\tif (this.isEmpty()) {\n\t\treturn 0;\n\t}\n\tavailable = this.getLength() - this.index;\n\treturn available;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\tthrow new UnsupportedOperationException(\"available()\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\treturn (int) (length - ((long) index));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n    if(is==null) throw new IOException(\"InputStream not opened.\");\n    return (int)(is.length()-index);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\treturn (data.length - index);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public int available() throws IOException {\n\n\tif(index==0) return 0;\n\treturn index+1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * @see InputStream#available() \n */\n", "method_name": "available", "codes": ["@Override public int available() throws IOException {\n\n    return (int)(p.length() - index);\n}", "@Override public int available() throws IOException {\n\n\tif(available==-1) available=index==0?0:index-1;\n\treturn available;\n}", "@Override public int available() throws IOException {\n\n\t\tif(index>=buf.length) {\n\t\t\treturn 0;\n\t\t}\n\t\telse return buf.length-index;\n\t}", "@Override public int available() throws IOException {\nreturn 0;}", "@Override public int available() throws IOException {\n\n\tint available = 0;\n\tif (this.isClosed()) {\n\t\tthrow new IOException(\"InputStream is closed.\");\n\t}\n\tif (this.isEmpty()) {\n\t\treturn 0;\n\t}\n\tavailable = this.getLength() - this.index;\n\treturn available;\n}", "@Override public int available() throws IOException {\n\n\tthrow new UnsupportedOperationException(\"available()\");\n}", "@Override public int available() throws IOException {\n\n\treturn (int) (length - ((long) index));\n}", "@Override public int available() throws IOException {\n\n    if(is==null) throw new IOException(\"InputStream not opened.\");\n    return (int)(is.length()-index);\n}", "@Override public int available() throws IOException {\n\n\treturn (data.length - index);\n}", "@Override public int available() throws IOException {\n\n\tif(index==0) return 0;\n\treturn index+1;\n}"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec017641", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static <T>List<T> asList(T[] a){\n\n\treturn (a!=null)?Arrays.asList(a):Collections.emptyList();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n    if (a == null) return Collections.emptyList();\n    return Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n        if(a==null)return Collections.emptyList();\n        return Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n\tif(a==null)\n\t\treturn new ArrayList<T>(0);\n\treturn Arrays.asList(a);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n\tif(a == null)\n\t\treturn new ArrayList<T>();\n\telse\n\t\treturn Arrays.asList(a);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n\treturn a==null?Collections.<T>emptyList():Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n\treturn a==null?Collections.<T>emptyList():Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\nreturn a==null?Collections.<T>emptyList():Arrays.asList(a);}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n\tif(a==null) return new ArrayList<T>();\n\treturn Arrays.asList(a);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>List<T> asList(T[] a){\n\n   if(a==null) return Collections.emptyList();\n   return Arrays.asList(a);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Array to List. <p> Works like  {@link Arrays#asList(Object)}, but handles null arrays.\n * @return a list backed by the array.\n */\n", "method_name": "asList", "codes": ["public static <T>List<T> asList(T[] a){\n\n\treturn (a!=null)?Arrays.asList(a):Collections.emptyList();\n}", "public static <T>List<T> asList(T[] a){\n\n    if (a == null) return Collections.emptyList();\n    return Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n        if(a==null)return Collections.emptyList();\n        return Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n\tif(a==null)\n\t\treturn new ArrayList<T>(0);\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n\tif(a == null)\n\t\treturn new ArrayList<T>();\n\telse\n\t\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n\treturn a==null?Collections.<T>emptyList():Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n\treturn a==null?Collections.<T>emptyList():Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\nreturn a==null?Collections.<T>emptyList():Arrays.asList(a);}", "public static <T>List<T> asList(T[] a){\n\n\tif(a==null) return new ArrayList<T>();\n\treturn Arrays.asList(a);\n}", "public static <T>List<T> asList(T[] a){\n\n   if(a==null) return Collections.emptyList();\n   return Arrays.asList(a);\n}"], "code_level": "slib_runnable", "_id": "636766f01a6d9265ec017639", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif(b<'0') return (byte)0;\n\tif(b<='9') return (byte)(b-'0');\n\tif(b<='F') return (byte)(b-'A'+10);\n\tif(b<='f') return (byte)(b-'a'+10);\n\treturn (byte)0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9'))\n\t\treturn (byte)(b - '0');\n\tif ((b >= 'A') && (b <= 'F'))\n\t\treturn (byte)(b - 'A' + 10);\n\tif ((b >= 'a') && (b <= 'f'))\n\t\treturn (byte)(b - 'a' + 10);\n\t\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif(b<='9' && b>='0') return (byte)(b-'0');\n\tif(b<='F' && b>='A') return (byte)(b-'A'+10);\n\tif(b<='f' && b>='a') return (byte)(b-'a'+10);\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9')) return (byte)(b - '0');\n\tif ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);\n\tif ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif(b>=48 && b<=57)\n\t\treturn (byte) (b-48);\n\telse if(b>=65 && b<=70)\n\t\treturn (byte) (b-55);\n\telse if(b>=97 && b<=102)\n\t\treturn (byte) (b-87);\n\telse\n\t\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif(b>='0'&&b<='9'){\n\t\treturn (byte)(b-'0');\n\t}\n\tif(b>='A'&&b<='F'){\n\t\treturn (byte)(b-'A'+10);\n\t}\n\tif(b>='a'&&b<='f'){\n\t\treturn (byte)(b-'a'+10);\n\t}\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9')) return (byte)(b - '0');\n\tif ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);\n\tif ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);\n\t\n\tthrow new IllegalArgumentException(\"Invalid hex digit: \" + b);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n    if(b>='0' && b<='9'){\n        return (byte)(b-'0');\n    }else if(b>='a' && b<='f'){\n        return (byte)(b-'a'+10);\n    }else if(b>='A' && b<='F'){\n        return (byte)(b-'A'+10);\n    }else{\n        throw new IllegalArgumentException(\n        \"Invalid hex digit '\" + b + \"'\");\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif((b>=48)&&(b<=57)){\n\t\treturn (byte)(b-48);\n\t}else if((b>=65)&&(b<=70)){\n\t\treturn (byte)(b-55);\n\t}else if((b>=97)&&(b<=102)){\n\t\treturn (byte)(b-87);\n\t}else{\n\t\treturn 0;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static byte convertHexDigit(byte b){\n\n\tif((b >= 48)&&(b <= 57)) return (byte)(b - 48);\n\tif((b >= 65)&&(b <= 70)) return (byte)(b - 55);\n\tif((b >= 97)&&(b <= 102)) return (byte)(b - 87);\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @param b An ASCII encoded character 0-9 a-f A-F\n * @return The byte value of the character 0-16.\n */\n", "method_name": "convertHexDigit", "codes": ["public static byte convertHexDigit(byte b){\n\n\tif(b<'0') return (byte)0;\n\tif(b<='9') return (byte)(b-'0');\n\tif(b<='F') return (byte)(b-'A'+10);\n\tif(b<='f') return (byte)(b-'a'+10);\n\treturn (byte)0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9'))\n\t\treturn (byte)(b - '0');\n\tif ((b >= 'A') && (b <= 'F'))\n\t\treturn (byte)(b - 'A' + 10);\n\tif ((b >= 'a') && (b <= 'f'))\n\t\treturn (byte)(b - 'a' + 10);\n\t\n\treturn 0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif(b<='9' && b>='0') return (byte)(b-'0');\n\tif(b<='F' && b>='A') return (byte)(b-'A'+10);\n\tif(b<='f' && b>='a') return (byte)(b-'a'+10);\n\treturn 0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9')) return (byte)(b - '0');\n\tif ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);\n\tif ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);\n\treturn 0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif(b>=48 && b<=57)\n\t\treturn (byte) (b-48);\n\telse if(b>=65 && b<=70)\n\t\treturn (byte) (b-55);\n\telse if(b>=97 && b<=102)\n\t\treturn (byte) (b-87);\n\telse\n\t\treturn 0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif(b>='0'&&b<='9'){\n\t\treturn (byte)(b-'0');\n\t}\n\tif(b>='A'&&b<='F'){\n\t\treturn (byte)(b-'A'+10);\n\t}\n\tif(b>='a'&&b<='f'){\n\t\treturn (byte)(b-'a'+10);\n\t}\n\treturn 0;\n}", "public static byte convertHexDigit(byte b){\n\n\tif ((b >= '0') && (b <= '9')) return (byte)(b - '0');\n\tif ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);\n\tif ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);\n\t\n\tthrow new IllegalArgumentException(\"Invalid hex digit: \" + b);\n}", "public static byte convertHexDigit(byte b){\n\n    if(b>='0' && b<='9'){\n        return (byte)(b-'0');\n    }else if(b>='a' && b<='f'){\n        return (byte)(b-'a'+10);\n    }else if(b>='A' && b<='F'){\n        return (byte)(b-'A'+10);\n    }else{\n        throw new IllegalArgumentException(\n        \"Invalid hex digit '\" + b + \"'\");\n    }\n}", "public static byte convertHexDigit(byte b){\n\n\tif((b>=48)&&(b<=57)){\n\t\treturn (byte)(b-48);\n\t}else if((b>=65)&&(b<=70)){\n\t\treturn (byte)(b-55);\n\t}else if((b>=97)&&(b<=102)){\n\t\treturn (byte)(b-87);\n\t}else{\n\t\treturn 0;\n\t}\n}", "public static byte convertHexDigit(byte b){\n\n\tif((b >= 48)&&(b <= 57)) return (byte)(b - 48);\n\tif((b >= 65)&&(b <= 70)) return (byte)(b - 55);\n\tif((b >= 97)&&(b <= 102)) return (byte)(b - 87);\n\treturn 0;\n}"], "code_level": "slib_runnable", "_id": "636766f91a6d9265ec01777d", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tConverter converter=null;\n\tif(clazz==null) return null;\n\tif(clazz.isPrimitive()) converter=primitives.get(clazz);\n\telse converter=converters.get(clazz);\n\treturn converter;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz==null) throw new NullPointerException();\n\treturn converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tif(converters.containsKey(clazz)){\n\t\treturn converters.get(clazz);\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz==null) throw new IllegalArgumentException(\"clazz cannot be null\");\n\tfinal String name=clazz.getCanonicalName();\n\treturn converters.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tif(converters.containsKey(clazz))\n\t\treturn converters.get(clazz);\n\telse\n\t\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz == null) throw new IllegalArgumentException(\"Class must not be null.\");\n\tsynchronized(converters){\n\t\tfinal int size = converters.size();\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tfinal Converter converter = converters.get(i);\n\t\t\tif(converter.isAssignableTo(clazz)){\n\t\t\t\treturn converter;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Converter lookup(final Class<?> clazz){\n\n\tConverter converter = converters.get(clazz);\n\tif(converter == null)\n\t\treturn null;\n\treturn converter;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n", "method_name": "lookup", "codes": ["public Converter lookup(final Class<?> clazz){\n\n\tConverter converter=null;\n\tif(clazz==null) return null;\n\tif(clazz.isPrimitive()) converter=primitives.get(clazz);\n\telse converter=converters.get(clazz);\n\treturn converter;\n}", "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz==null) throw new NullPointerException();\n\treturn converters.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\n\treturn converters.get(clazz);\n}", "public Converter lookup(final Class<?> clazz){\n\n\tif(converters.containsKey(clazz)){\n\t\treturn converters.get(clazz);\n\t}\n\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz==null) throw new IllegalArgumentException(\"clazz cannot be null\");\n\tfinal String name=clazz.getCanonicalName();\n\treturn converters.get(name);\n}", "public Converter lookup(final Class<?> clazz){\n\n\tif(converters.containsKey(clazz))\n\t\treturn converters.get(clazz);\n\telse\n\t\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n\n\tif(clazz == null) throw new IllegalArgumentException(\"Class must not be null.\");\n\tsynchronized(converters){\n\t\tfinal int size = converters.size();\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tfinal Converter converter = converters.get(i);\n\t\t\tif(converter.isAssignableTo(clazz)){\n\t\t\t\treturn converter;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}", "public Converter lookup(final Class<?> clazz){\n\n\tConverter converter = converters.get(clazz);\n\tif(converter == null)\n\t\treturn null;\n\treturn converter;\n}"], "code_level": "class_runnable", "_id": "6367670a1a6d9265ec0179e7", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override public boolean containsKey(final Object key){\n\n  return key!=null && containsKey((Double)key);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n\treturn (key instanceof String)?(index((String)key)>=0):false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  if(key==null) return false;\n  final var root=this.root;\n  if(root==null) return false;\n  final var val=root.getVal();\n  if(val==EMPTY||val==TOMBSTONE) return false;\n  return val.containsKey(key);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  return key instanceof Float?containsKey(((Float)key).floatValue()):false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  final int pos=findForAdd(key);\n  return type!=0 && pos>=0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  if(key==null)throw new NullPointerException();\n  return containsKey((char)key);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  return true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\nreturn false;}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n  final int pos=find(key);\n  return pos>=0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean containsKey(final Object key){\n\n\tif(this.isEmpty())return false;\n\tint index=this.index((K)key);\n\treturn index>=0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n", "method_name": "containsKey", "codes": ["@Override public boolean containsKey(final Object key){\n\n  return key!=null && containsKey((Double)key);\n}", "@Override public boolean containsKey(final Object key){\n\n\treturn (key instanceof String)?(index((String)key)>=0):false;\n}", "@Override public boolean containsKey(final Object key){\n\n  if(key==null) return false;\n  final var root=this.root;\n  if(root==null) return false;\n  final var val=root.getVal();\n  if(val==EMPTY||val==TOMBSTONE) return false;\n  return val.containsKey(key);\n}", "@Override public boolean containsKey(final Object key){\n\n  return key instanceof Float?containsKey(((Float)key).floatValue()):false;\n}", "@Override public boolean containsKey(final Object key){\n\n  final int pos=findForAdd(key);\n  return type!=0 && pos>=0;\n}", "@Override public boolean containsKey(final Object key){\n\n  if(key==null)throw new NullPointerException();\n  return containsKey((char)key);\n}", "@Override public boolean containsKey(final Object key){\n\n  return true;\n}", "@Override public boolean containsKey(final Object key){\nreturn false;}", "@Override public boolean containsKey(final Object key){\n\n  final int pos=find(key);\n  return pos>=0;\n}", "@Override public boolean containsKey(final Object key){\n\n\tif(this.isEmpty())return false;\n\tint index=this.index((K)key);\n\treturn index>=0;\n}"], "code_level": "class_runnable", "_id": "6367670b1a6d9265ec0179f2", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static String[] copyStrings(final String[] src){\n\n  final int len = src.length;\n  final String[] dst = new String[len];\n  for(int i=0; i<len; ++i){\n    dst[i] = new String(src[i].toLowerCase());\n  }\n  return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tString[] dst = new String[src.length];\n\tfor (int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tfinal String[] dest=new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\tdest[i]=src[i].toLowerCase();\n\t}\n\treturn dest;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tString[] dst = new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\t//dst[i] = src[i].toLowerCase();\n\t\tdst[i] = src[i];\n\t}\n\treturn dst;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n    String[] copy = new String[src.length];\n    for (int i = 0; i &lt; src.length; i++){\n        copy[i] = src[i].toLowerCase();\n    }\n    return copy;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tif(src==null) return null;\n\tfinal String[] dst=new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\tdst[i]=src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n    String[] dst = new String[src.length];\n    for(int i=0;i<src.length;i++){\n        dst[i] = src[i].toLowerCase();\n    }\n    return dst;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tif(src==null)return null;\n\tfinal int len=src.length;\n\tif(len==0)return src;\n\tString[] dest=new String[len];\n\tfor(int i=0; i<len; i++){\n\t\tdest[i]=src[i].toLowerCase();\n\t}\n\treturn dest;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tString[] a = new String[src.length];\n\tfor(int i = 0; i < a.length; i++){\n\t\ta[i] = src[i].toLowerCase();\n\t}\n\treturn a;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static String[] copyStrings(final String[] src){\n\n\tString[] dest=new String[src.length];\n\tfor(int i=0;i<src.length;i++)\n\t\tdest[i]=src[i].toLowerCase();\n\treturn dest;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * This method creates a copy of the provided array, and ensures that all the strings in the newly created array contain only lower-case letters. <p> Using this method to copy string arrays means that changes to the src array do not modify the dst array.\n */\n", "method_name": "copyStrings", "codes": ["private static String[] copyStrings(final String[] src){\n\n  final int len = src.length;\n  final String[] dst = new String[len];\n  for(int i=0; i<len; ++i){\n    dst[i] = new String(src[i].toLowerCase());\n  }\n  return dst;\n}", "private static String[] copyStrings(final String[] src){\n\n\tString[] dst = new String[src.length];\n\tfor (int i = 0; i < src.length; i++){\n\t\tdst[i] = src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "private static String[] copyStrings(final String[] src){\n\n\tfinal String[] dest=new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\tdest[i]=src[i].toLowerCase();\n\t}\n\treturn dest;\n}", "private static String[] copyStrings(final String[] src){\n\n\tString[] dst = new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\t//dst[i] = src[i].toLowerCase();\n\t\tdst[i] = src[i];\n\t}\n\treturn dst;\n}", "private static String[] copyStrings(final String[] src){\n\n    String[] copy = new String[src.length];\n    for (int i = 0; i &lt; src.length; i++){\n        copy[i] = src[i].toLowerCase();\n    }\n    return copy;\n}", "private static String[] copyStrings(final String[] src){\n\n\tif(src==null) return null;\n\tfinal String[] dst=new String[src.length];\n\tfor(int i=0; i<src.length; i++){\n\t\tdst[i]=src[i].toLowerCase();\n\t}\n\treturn dst;\n}", "private static String[] copyStrings(final String[] src){\n\n    String[] dst = new String[src.length];\n    for(int i=0;i<src.length;i++){\n        dst[i] = src[i].toLowerCase();\n    }\n    return dst;\n}", "private static String[] copyStrings(final String[] src){\n\n\tif(src==null)return null;\n\tfinal int len=src.length;\n\tif(len==0)return src;\n\tString[] dest=new String[len];\n\tfor(int i=0; i<len; i++){\n\t\tdest[i]=src[i].toLowerCase();\n\t}\n\treturn dest;\n}", "private static String[] copyStrings(final String[] src){\n\n\tString[] a = new String[src.length];\n\tfor(int i = 0; i < a.length; i++){\n\t\ta[i] = src[i].toLowerCase();\n\t}\n\treturn a;\n}", "private static String[] copyStrings(final String[] src){\n\n\tString[] dest=new String[src.length];\n\tfor(int i=0;i<src.length;i++)\n\t\tdest[i]=src[i].toLowerCase();\n\treturn dest;\n}"], "code_level": "self_contained", "_id": "636767041a6d9265ec0178f8", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n        if( value == null ) {\n            return null;\n        }\n        final String stringValue = value.toString().trim();\n        if( stringValue.length() == 0 ) {\n            return getDefaultType();\n        }\n        final String[] values = stringValue.split(\":\");\n        if( values.length == 0 ) {\n            return getDefaultType();\n        }\n        return values[0];\n    }", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof String) {\n\t\tfinal String stringValue = (String) value;\n\t\tif (stringValue.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal char firstCharacter = stringValue.charAt(0);\n\t\tif (type == Character.class || type == char.class) {\n\t\t\treturn new Character(firstCharacter);\n\t\t}\n\t\treturn new Short((short) firstCharacter);\n\t}\n\treturn super.convertToType(type, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(value == null) {\n\t\treturn super.convertToType(type,value);\n\t}\n\tfinal String str = value.toString();\n\tif(str.length() == 0) {\n\t\treturn super.convertToType(type,value);\n\t}\n\treturn str.charAt(0);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tfinal String string = value.toString();\n\tif (string.length() == 0)\n\t\treturn null;\n\treturn super.convertToType(type, string.charAt(0));\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\treturn value!=null&&((String)value).length()>0?super.convertToType(type,((String)value).charAt(0)):super.convertToType(type,(Object)null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n return value==null ? null : value.toString().isEmpty() ? super.convertToType(type,value) : value.toString().charAt(0); }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\treturn super.convertToType(type, value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n  if(value instanceof String && ((String) value).length() == 0) return getDefaultType();\n  return super.convertToType(type,value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(value instanceof String)\n\t\t{final String s=(String)value;\n\t\treturn s.length()==0?type.newInstance():s.charAt(0);\n\t\t}\n\tthrow new IllegalArgumentException(\"Invalid value \"+value);\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(((String)value).length()<=0)\n\t\treturn type.newInstance();\n\tfinal Object obj=type.newInstance();\n\t((Multicast)obj).set(0,value);\n\treturn obj;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n", "method_name": "convertToType", "codes": ["@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n        if( value == null ) {\n            return null;\n        }\n        final String stringValue = value.toString().trim();\n        if( stringValue.length() == 0 ) {\n            return getDefaultType();\n        }\n        final String[] values = stringValue.split(\":\");\n        if( values.length == 0 ) {\n            return getDefaultType();\n        }\n        return values[0];\n    }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif (value == null) {\n\t\treturn null;\n\t}\n\tif (value instanceof String) {\n\t\tfinal String stringValue = (String) value;\n\t\tif (stringValue.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal char firstCharacter = stringValue.charAt(0);\n\t\tif (type == Character.class || type == char.class) {\n\t\t\treturn new Character(firstCharacter);\n\t\t}\n\t\treturn new Short((short) firstCharacter);\n\t}\n\treturn super.convertToType(type, value);\n}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(value == null) {\n\t\treturn super.convertToType(type,value);\n\t}\n\tfinal String str = value.toString();\n\tif(str.length() == 0) {\n\t\treturn super.convertToType(type,value);\n\t}\n\treturn str.charAt(0);\n\t}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tfinal String string = value.toString();\n\tif (string.length() == 0)\n\t\treturn null;\n\treturn super.convertToType(type, string.charAt(0));\n\t}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\treturn value!=null&&((String)value).length()>0?super.convertToType(type,((String)value).charAt(0)):super.convertToType(type,(Object)null);\n}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n return value==null ? null : value.toString().isEmpty() ? super.convertToType(type,value) : value.toString().charAt(0); }", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\treturn super.convertToType(type, value);\n}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n  if(value instanceof String && ((String) value).length() == 0) return getDefaultType();\n  return super.convertToType(type,value);\n}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(value instanceof String)\n\t\t{final String s=(String)value;\n\t\treturn s.length()==0?type.newInstance():s.charAt(0);\n\t\t}\n\tthrow new IllegalArgumentException(\"Invalid value \"+value);\n\t}", "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n\n\tif(((String)value).length()<=0)\n\t\treturn type.newInstance();\n\tfinal Object obj=type.newInstance();\n\t((Multicast)obj).set(0,value);\n\treturn obj;\n}"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bf", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Collection<Object> values(){\n\nreturn Collections.unmodifiableCollection(getBeanMap().values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\nreturn m.values();}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(this.methodMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(m_methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(this.methods.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(map.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(methodMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(methodMap.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\nreturn Collections.unmodifiableCollection(map.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Collection<Object> values(){\n\n    return Collections.unmodifiableCollection(map.values());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n", "method_name": "values", "codes": ["public Collection<Object> values(){\n\nreturn Collections.unmodifiableCollection(getBeanMap().values());\n}", "public Collection<Object> values(){\nreturn m.values();}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(this.methodMap.values());\n}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(m_methods.values());\n}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(this.methods.values());\n}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(map.values());\n}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(methodMap.values());\n}", "public Collection<Object> values(){\n\n\treturn Collections.unmodifiableCollection(methodMap.values());\n}", "public Collection<Object> values(){\n\nreturn Collections.unmodifiableCollection(map.values());\n}", "public Collection<Object> values(){\n\n    return Collections.unmodifiableCollection(map.values());\n}"], "code_level": "class_runnable", "_id": "636766f11a6d9265ec01764f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tBeanMap.this.putAllReadable(map);\n\tBeanMap.this.putAllWritable(map);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tFieldMap fieldMap=map.getFieldMap();\n\tfor(Field field:fieldMap.getFields()){\n\t\tif(field.isReadable()&&field.isWriteable()){\n\t\t\tPropertyDescriptor pd=field.getPropertyDescriptor();\n\t\t\tif(pd.getReadMethod()!=null&&pd.getWriteMethod()!=null){\n\t\t\t\ttry{\n\t\t\t\t\tput(field.getName(),map.get(field.getName()));\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tfor(String name:map.propertyNames()){\n\t\tPropertyMeta p=map.getPropertyMeta(name);\n\t\tif(p.isReadable() && p.isWriteable()){\n\t\t\tput(p);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tputAllReadable(map);\n\tputAllWritable(map);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\nif(map==null)return;\n\nputWritable(map.getReadable());\nputWritable(map.getWritable());\n\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\nif(map==null)throw new NullPointerException();\nif(map==this)throw new IllegalArgumentException();\nfor(Map.Entry<Object,Object> e:map.entrySet()){\nObject key=e.getKey();\nif(key==null)continue;\nObject value=e.getValue();\nif(value==null)continue;\nif(key instanceof String){\nString keyStr=(String)key;\nif(!isWritable(keyStr))continue;\nset(keyStr,value);\n}\nelse if(key instanceof Property){\nProperty prop=(Property)key;\nif(!isWritable(prop))continue;\nset(prop,value);\n}\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tputAllReadable(map);\n\tputAllWritable(map);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n    for (Iterator it=map.entrySet().iterator(); it.hasNext();) {\n        Map.Entry entry = (Map.Entry)it.next();\n        String propName = (String)entry.getKey();\n        if (containsKey(propName)) {\n            Object value = entry.getValue();\n            set(propName,value);\n        }\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tfor (Object key: map.keySet()){\n\t\tObject val = map.get(key);\n\t\tif (val != null) put(key, val);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void putAllWriteable(BeanMap map){\n\n\tif(map.isReadable()) putAllReadable(map);\n\tif(map.isWritable()) putAllWritable(map);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n", "method_name": "putAllWriteable", "codes": ["public void putAllWriteable(BeanMap map){\n\n\tBeanMap.this.putAllReadable(map);\n\tBeanMap.this.putAllWritable(map);\n}", "public void putAllWriteable(BeanMap map){\n\n\tFieldMap fieldMap=map.getFieldMap();\n\tfor(Field field:fieldMap.getFields()){\n\t\tif(field.isReadable()&&field.isWriteable()){\n\t\t\tPropertyDescriptor pd=field.getPropertyDescriptor();\n\t\t\tif(pd.getReadMethod()!=null&&pd.getWriteMethod()!=null){\n\t\t\t\ttry{\n\t\t\t\t\tput(field.getName(),map.get(field.getName()));\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\n\tfor(String name:map.propertyNames()){\n\t\tPropertyMeta p=map.getPropertyMeta(name);\n\t\tif(p.isReadable() && p.isWriteable()){\n\t\t\tput(p);\n\t\t}\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\n\tputAllReadable(map);\n\tputAllWritable(map);\n}", "public void putAllWriteable(BeanMap map){\n\nif(map==null)return;\n\nputWritable(map.getReadable());\nputWritable(map.getWritable());\n\n}", "public void putAllWriteable(BeanMap map){\n\nif(map==null)throw new NullPointerException();\nif(map==this)throw new IllegalArgumentException();\nfor(Map.Entry<Object,Object> e:map.entrySet()){\nObject key=e.getKey();\nif(key==null)continue;\nObject value=e.getValue();\nif(value==null)continue;\nif(key instanceof String){\nString keyStr=(String)key;\nif(!isWritable(keyStr))continue;\nset(keyStr,value);\n}\nelse if(key instanceof Property){\nProperty prop=(Property)key;\nif(!isWritable(prop))continue;\nset(prop,value);\n}\n}\n}", "public void putAllWriteable(BeanMap map){\n\n\tputAllReadable(map);\n\tputAllWritable(map);\n}", "public void putAllWriteable(BeanMap map){\n\n    for (Iterator it=map.entrySet().iterator(); it.hasNext();) {\n        Map.Entry entry = (Map.Entry)it.next();\n        String propName = (String)entry.getKey();\n        if (containsKey(propName)) {\n            Object value = entry.getValue();\n            set(propName,value);\n        }\n    }\n}", "public void putAllWriteable(BeanMap map){\n\n\tfor (Object key: map.keySet()){\n\t\tObject val = map.get(key);\n\t\tif (val != null) put(key, val);\n\t}\n}", "public void putAllWriteable(BeanMap map){\n\n\tif(map.isReadable()) putAllReadable(map);\n\tif(map.isWritable()) putAllWritable(map);\n}"], "code_level": "class_runnable", "_id": "636767071a6d9265ec017962", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public long contentLength(){\n\n    String contentLength=headerFields.get(\"Content-Length\");\n    if(contentLength==null){\n        return 0;\n    }\n    try{\n        return Long.parseLong(contentLength);\n    }catch(NumberFormatException e){\n        return 0;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n\tString temp;\n\tif((temp=requestHeader.get(\"Content-Length\"))!=null){\n\t\ttry{\n\t\t\treturn Long.parseLong(temp);\n\t\t}catch(NumberFormatException e){\n\t\t\treturn contentLength;\n\t\t}\n\t}else{\n\t\treturn contentLength;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\nString s=contentLengthStr();\nif(s==null)return -1;\ntry{return Long.parseLong(s);\n}catch(NumberFormatException e){return -1;}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n\tif (contentLength==-1){\n\t\tString contentLengthValue=header(\"Content-Length\");\n\t\ttry{\n\t\t\tcontentLength=Long.parseLong(contentLengthValue);\n\t\t}catch(NumberFormatException e){\n\t\t\tcontentLength=contentLengthValue.length();\n\t\t}\n\t}\n\treturn contentLength;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n\tString cl = headers.get(\"content-length\");\n\tif(cl==null)\n\t\treturn 0;\n\telse{\n\t\ttry{\n\t\t\treturn Long.parseLong(cl);\n\t\t}catch(NumberFormatException e){\n\t\t\treturn content.length;\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n\tString contentLength=getHeader(HEADER_NAME_CONTENT_LENGTH);\n\tif(contentLength==null)return -1;\n\ttry{\n\t\treturn Long.parseLong(contentLength);\n\t}catch(NumberFormatException e){\n\t\treturn -1;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n    if (contentLengthHeader==null) return contentLength;\n    try {\n        return Long.parseLong(contentLengthHeader.substring(16));\n    } catch (NumberFormatException e){\n        return contentLength;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n    String contentLength = getHeader(CONTENT_LENGTH);\n    if(contentLength == null){\n        return -1;\n    }\n    try{\n        return Long.parseLong(contentLength);\n    }catch (NumberFormatException e){\n        return -1;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n\ttry{\n\t\treturn Long.parseLong(contentLength);\n\t}catch(NumberFormatException e){\n\t\treturn content.length();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long contentLength(){\n\n    if(contentLength>0) return contentLength;\n    String contentLength=request.getHeader(\"content-length\");\n    if(contentLength==null) return 0;\n    try{\n        return Long.parseLong(contentLength);\n    }catch(NumberFormatException e){\n        this.contentLength=0;\n        return 0;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve the content length of the request.\n * @return The content length of the request.\n * @since 1.3\n */\n", "method_name": "contentLength", "codes": ["public long contentLength(){\n\n    String contentLength=headerFields.get(\"Content-Length\");\n    if(contentLength==null){\n        return 0;\n    }\n    try{\n        return Long.parseLong(contentLength);\n    }catch(NumberFormatException e){\n        return 0;\n    }\n}", "public long contentLength(){\n\n\tString temp;\n\tif((temp=requestHeader.get(\"Content-Length\"))!=null){\n\t\ttry{\n\t\t\treturn Long.parseLong(temp);\n\t\t}catch(NumberFormatException e){\n\t\t\treturn contentLength;\n\t\t}\n\t}else{\n\t\treturn contentLength;\n\t}\n}", "public long contentLength(){\n\nString s=contentLengthStr();\nif(s==null)return -1;\ntry{return Long.parseLong(s);\n}catch(NumberFormatException e){return -1;}\n}", "public long contentLength(){\n\n\tif (contentLength==-1){\n\t\tString contentLengthValue=header(\"Content-Length\");\n\t\ttry{\n\t\t\tcontentLength=Long.parseLong(contentLengthValue);\n\t\t}catch(NumberFormatException e){\n\t\t\tcontentLength=contentLengthValue.length();\n\t\t}\n\t}\n\treturn contentLength;\n}", "public long contentLength(){\n\n\tString cl = headers.get(\"content-length\");\n\tif(cl==null)\n\t\treturn 0;\n\telse{\n\t\ttry{\n\t\t\treturn Long.parseLong(cl);\n\t\t}catch(NumberFormatException e){\n\t\t\treturn content.length;\n\t\t}\n\t}\n}", "public long contentLength(){\n\n\tString contentLength=getHeader(HEADER_NAME_CONTENT_LENGTH);\n\tif(contentLength==null)return -1;\n\ttry{\n\t\treturn Long.parseLong(contentLength);\n\t}catch(NumberFormatException e){\n\t\treturn -1;\n\t}\n}", "public long contentLength(){\n\n    if (contentLengthHeader==null) return contentLength;\n    try {\n        return Long.parseLong(contentLengthHeader.substring(16));\n    } catch (NumberFormatException e){\n        return contentLength;\n    }\n}", "public long contentLength(){\n\n    String contentLength = getHeader(CONTENT_LENGTH);\n    if(contentLength == null){\n        return -1;\n    }\n    try{\n        return Long.parseLong(contentLength);\n    }catch (NumberFormatException e){\n        return -1;\n    }\n}", "public long contentLength(){\n\n\ttry{\n\t\treturn Long.parseLong(contentLength);\n\t}catch(NumberFormatException e){\n\t\treturn content.length();\n\t}\n}", "public long contentLength(){\n\n    if(contentLength>0) return contentLength;\n    String contentLength=request.getHeader(\"content-length\");\n    if(contentLength==null) return 0;\n    try{\n        return Long.parseLong(contentLength);\n    }catch(NumberFormatException e){\n        this.contentLength=0;\n        return 0;\n    }\n}"], "code_level": "project_runnable", "_id": "636767031a6d9265ec0178dd", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tfor(int i=end;i>=0;i--){\n\t\tif(headerPart.charAt(i)=='\\r'||headerPart.charAt(i)=='\\n'){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(CRLF,end+1);\n\treturn index>=0? index:headerPart.indexOf(LF,end+1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(\"\\r\\n\",end);\n\tif(index==-1)\n\t\tindex=headerPart.indexOf(\"\\n\",end);\n\treturn index;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tfor(int i=end;i>=0;i--){\n\t\tif(headerPart.charAt(i)=='\\r'&&(i==headerPart.length()-1||headerPart.charAt(i+1)=='\\n')){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint i=end;\n\twhile(i>0){\n\t\tif(headerPart.charAt(i)=='\\n'){\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\treturn i;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(13);\n\tif(index>=0)\n\t\treturn index;\n\treturn headerPart.indexOf(10);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=end;\n\twhile(index>=0){\n\t\tif(headerPart.charAt(index)=='\\n'){\n\t\t\treturn index;\n\t\t}\n\t\tindex--;\n\t}\n\treturn -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint endOfLine=headerPart.indexOf(\"\\n\",end);\n\tif(endOfLine==-1)\n\t\tthrow new IllegalArgumentException(\"No Enter sequence found!\");\n\treturn endOfLine;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\tint enter=headerPart.indexOf(\"\\r\\n\",end);\n\tif(enter==-1)enter=headerPart.indexOf(\"\\n\",end);\n\treturn enter;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int parseEndOfLine(String headerPart,int end){\n\n\twhile(end>0){\n\t\tchar c=headerPart.charAt(end);\n\t\tif(c=='\\r'||c=='\\n'){\n\t\t\treturn end;\n\t\t}\n\t\tend--;\n\t}\n\treturn end;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Skips bytes until the end of the current line.\n * @param headerPart The headers, which are being parsed.\n * @param end Index of the last byte, which has yet been processed.\n * @return Index of the \\r\\n sequence, which indicates end of line.\n */\n", "method_name": "parseEndOfLine", "codes": ["private int parseEndOfLine(String headerPart,int end){\n\n\tfor(int i=end;i>=0;i--){\n\t\tif(headerPart.charAt(i)=='\\r'||headerPart.charAt(i)=='\\n'){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(CRLF,end+1);\n\treturn index>=0? index:headerPart.indexOf(LF,end+1);\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(\"\\r\\n\",end);\n\tif(index==-1)\n\t\tindex=headerPart.indexOf(\"\\n\",end);\n\treturn index;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tfor(int i=end;i>=0;i--){\n\t\tif(headerPart.charAt(i)=='\\r'&&(i==headerPart.length()-1||headerPart.charAt(i+1)=='\\n')){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint i=end;\n\twhile(i>0){\n\t\tif(headerPart.charAt(i)=='\\n'){\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\treturn i;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=headerPart.indexOf(13);\n\tif(index>=0)\n\t\treturn index;\n\treturn headerPart.indexOf(10);\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint index=end;\n\twhile(index>=0){\n\t\tif(headerPart.charAt(index)=='\\n'){\n\t\t\treturn index;\n\t\t}\n\t\tindex--;\n\t}\n\treturn -1;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint endOfLine=headerPart.indexOf(\"\\n\",end);\n\tif(endOfLine==-1)\n\t\tthrow new IllegalArgumentException(\"No Enter sequence found!\");\n\treturn endOfLine;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\tint enter=headerPart.indexOf(\"\\r\\n\",end);\n\tif(enter==-1)enter=headerPart.indexOf(\"\\n\",end);\n\treturn enter;\n}", "private int parseEndOfLine(String headerPart,int end){\n\n\twhile(end>0){\n\t\tchar c=headerPart.charAt(end);\n\t\tif(c=='\\r'||c=='\\n'){\n\t\t\treturn end;\n\t\t}\n\t\tend--;\n\t}\n\treturn end;\n}"], "code_level": "self_contained", "_id": "636767121a6d9265ec017b0a", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "protected int findByte(byte value,int pos){\n\n\tbyte[] buf=_buf;\n\tfor(int i=pos,imax=_length;i<imax;i++)\n\t\tif(buf[i]==value)return i;\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\tfor (int i=pos;i<length;i++)\n\t\tif (buffer[i]==value) return i;\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\twhile(pos<size){\n\t\tif(buffer[pos]==value)return pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\twhile(pos<limit){\n\t\tif(bytes[pos]==value)\n\t\t\treturn pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\tint i=pos;\n\twhile(i<getSize()){\n\t\tif(getByte(i)==value)\n\t\t\treturn i;\n\t\t++i;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\nint length=buffer.length;\nfor(int i=pos;i<length;i++){\n\tif(buffer[i]==value) return i;\n}\nreturn -1;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "protected int findByte(byte value,int pos){\n\nfor(int i=pos;i<size;i++)if(data[i]==value)return i;\nreturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\tint len=length();\n\tfor(;pos<len;pos++){\n\t\tif(buffer.getByte(pos)==value) return pos;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\twhile(pos<limit){\n\t\tif(buffer[pos]==value) return pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int findByte(byte value,int pos){\n\n\tfor(int i=pos;i<size;i++)\n\t\tif(buffer[i]==value)\n\t\t\treturn i;\n\treturn -1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Searches for a byte of specified value in the <code>buffer</code>, starting at the specified <code>position</code>.\n * @param value The value to find.\n * @param pos   The starting position for searching.\n * @return The position of byte found, counting from beginning of the<code>buffer</code>, or <code>-1</code> if not found.\n */\n", "method_name": "findByte", "codes": ["protected int findByte(byte value,int pos){\n\n\tbyte[] buf=_buf;\n\tfor(int i=pos,imax=_length;i<imax;i++)\n\t\tif(buf[i]==value)return i;\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\tfor (int i=pos;i<length;i++)\n\t\tif (buffer[i]==value) return i;\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\twhile(pos<size){\n\t\tif(buffer[pos]==value)return pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\twhile(pos<limit){\n\t\tif(bytes[pos]==value)\n\t\t\treturn pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\tint i=pos;\n\twhile(i<getSize()){\n\t\tif(getByte(i)==value)\n\t\t\treturn i;\n\t\t++i;\n\t}\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\nint length=buffer.length;\nfor(int i=pos;i<length;i++){\n\tif(buffer[i]==value) return i;\n}\nreturn -1;\n}", "protected int findByte(byte value,int pos){\n\nfor(int i=pos;i<size;i++)if(data[i]==value)return i;\nreturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\tint len=length();\n\tfor(;pos<len;pos++){\n\t\tif(buffer.getByte(pos)==value) return pos;\n\t}\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\twhile(pos<limit){\n\t\tif(buffer[pos]==value) return pos;\n\t\tpos++;\n\t}\n\treturn -1;\n}", "protected int findByte(byte value,int pos){\n\n\tfor(int i=pos;i<size;i++)\n\t\tif(buffer[i]==value)\n\t\t\treturn i;\n\treturn -1;\n}"], "code_level": "class_runnable", "_id": "636766ff1a6d9265ec017851", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public byte readByte() throws IOException {\n\n    if (pos == len) {\n        readBuffer();\n    }\n    if (len == -1) {\n        throw new EOFException();\n    }\n    return buffer[pos++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\tif(!hasNext()) throw new IOException(\"No bytes remaining.\");\n\tbyte x=buffer[index];\n\tindex++;\n\treturn x;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\treturn file.readByte();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\treturn buffer[current++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\tif (bufferPosition >= bufferSize)\n\t\treadBuffer();\n\treturn buffer[bufferPosition++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\tif(currentBuffer == null) {\n\t\tcurrentBuffer = readBuffer();\n\t\tif(currentBuffer == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tcurrentBufferIndex = 0;\n\t}\n\tbyte b = currentBuffer[currentBufferIndex];\n\tcurrentBufferIndex++;\n\tif(currentBufferIndex >= currentBuffer.length) {\n\t\tcurrentBuffer = null;\n\t}\n\treturn b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n    if (bufferPointer == bytesRead)\n        fillBuffer();\n    return buffer[bufferPointer++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\treturn (byte)read();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\tint b = read();\n\tif (b < 0) throw new EOFException(\"Unexpected end of file\");\n\treturn (byte)b;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public byte readByte() throws IOException {\n\n\tcurrentBuffer = readInternal();\n\tif (currentBuffer == null) {\n\t\tthrow new EOFException();\n\t}\n\tif (currentBuffer.length == 0) {\n\t\tthrow new EOFException();\n\t}\n\treturn currentBuffer[currentBufferOffset++];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n", "method_name": "readByte", "codes": ["public byte readByte() throws IOException {\n\n    if (pos == len) {\n        readBuffer();\n    }\n    if (len == -1) {\n        throw new EOFException();\n    }\n    return buffer[pos++];\n}", "public byte readByte() throws IOException {\n\n\tif(!hasNext()) throw new IOException(\"No bytes remaining.\");\n\tbyte x=buffer[index];\n\tindex++;\n\treturn x;\n}", "public byte readByte() throws IOException {\n\n\treturn file.readByte();\n}", "public byte readByte() throws IOException {\n\n\treturn buffer[current++];\n}", "public byte readByte() throws IOException {\n\n\tif (bufferPosition >= bufferSize)\n\t\treadBuffer();\n\treturn buffer[bufferPosition++];\n}", "public byte readByte() throws IOException {\n\n\tif(currentBuffer == null) {\n\t\tcurrentBuffer = readBuffer();\n\t\tif(currentBuffer == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tcurrentBufferIndex = 0;\n\t}\n\tbyte b = currentBuffer[currentBufferIndex];\n\tcurrentBufferIndex++;\n\tif(currentBufferIndex >= currentBuffer.length) {\n\t\tcurrentBuffer = null;\n\t}\n\treturn b;\n}", "public byte readByte() throws IOException {\n\n    if (bufferPointer == bytesRead)\n        fillBuffer();\n    return buffer[bufferPointer++];\n}", "public byte readByte() throws IOException {\n\n\treturn (byte)read();\n}", "public byte readByte() throws IOException {\n\n\tint b = read();\n\tif (b < 0) throw new EOFException(\"Unexpected end of file\");\n\treturn (byte)b;\n}", "public byte readByte() throws IOException {\n\n\tcurrentBuffer = readInternal();\n\tif (currentBuffer == null) {\n\t\tthrow new EOFException();\n\t}\n\tif (currentBuffer.length == 0) {\n\t\tthrow new EOFException();\n\t}\n\treturn currentBuffer[currentBufferOffset++];\n}"], "code_level": "class_runnable", "_id": "636766f81a6d9265ec01774b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private String parseToken(final char[] terminators){\n\n\tchar[] token = new char[0];\n\tboolean done = false;\n\twhile(!done){\n\t\tchar current = next();\n\t\twhile(!isTerminator(current, terminators))\n\t\t\ttoken = append(token, current);\n\t\tif(isTerminator(current, terminators))\n\t\t\tdone = true;\n\t}\n\treturn new String(token);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tfinal StringBuilder sb=new StringBuilder();\n\ttry{\n\t\twhile(true){\n\t\t\tfinal char c=read();\n\t\t\tif(c==0)throw new RuntimeException(\"Unexpected end of stream\");\n\t\t\tif(c=='\\\\'){\n\t\t\t\tsb.append(c);\n\t\t\t\tsb.append(read());\n\t\t\t}else{\n\t\t\t\tfor(char t:terminators){\n\t\t\t\t\tif(c==t){\n\t\t\t\t\t\tunread(c);\n\t\t\t\t\t\treturn sb.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t}catch(IOException ex){\n\t\tthrow new RuntimeException(\"Unexpected error\",ex);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n    int current = this.read();\n    if(current == -1)\n        return null;\n    final StringBuilder buffer = new StringBuilder();\n    while(current != -1){\n        final char c = (char)current;\n        if(Character.isWhitespace(c)){\n            this.unread(c);\n            return buffer.toString();\n        }\n        else{\n            final boolean terminator = false;\n            for(int i=0; i<terminators.length; i++){\n                if(c == terminators[i]){\n                    terminator = true;\n                    break;\n                }\n            }\n            if(terminator){\n                this.unread(c);\n                return buffer.toString();\n            }\n            else\n                buffer.append(c);\n        }\n        current = this.read();\n    }\n    return buffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tfinal StringBuilder b = new StringBuilder();\n\tint ch;\n\twhile((ch=parseChar())!=NO_CHAR && !isTerminator(ch,terminators)){\n\t\tb.append((char)ch);\n\t}\n\tpushBack(ch);\n\treturn b.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tint index = 0;\n\tint start = this.pos;\n\twhile(this.pos < this.length){\n\t\tfinal char c = this.chars[this.pos];\n\t\tif(isTerminator(c, terminators)){\n\t\t\tbreak;\n\t\t}\n\t\tthis.pos++;\n\t\tindex++;\n\t}\n\tif(index == 0){\n\t\treturn null;\n\t}\n\treturn new String(this.chars, start, index);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tString token = \"\";\n\tchar c;\n\tfor (int i = 0; i < terminators.length; i++)\n\t\tterminators[i] = Character.toLowerCase(terminators[i]);\n\twhile (index < input.length() && !isTerminator(c = input.charAt(index), terminators)){\n\t\ttoken += c;\n\t\tindex++;\n\t}\n\treturn token;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tStringBuilder result=new StringBuilder();\n\tfor(int i=currentIndex;i<string.length();i++){\n\t\tchar c=string.charAt(i);\n\t\tfor(char terminator:terminators){\n\t\t\tif(c==terminator)\n\t\t\t\treturn result.toString();\n\t\t}\n\t\tresult.append(c);\n\t\tcurrentIndex++;\n\t}\n\treturn result.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n  if(currentPos==length)throw new IllegalStateException(\"No more characters to parse.\");\n  int startPos=currentPos;\n  while(currentPos<length){\n    if(isTerminator(terminators))break;\n    currentPos++;\n  }\n  return new String(chars,startPos,currentPos-startPos);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\t\tint start = i;\n\t\twhile(i < line.length()){\n\t\t\tif(contains(line.charAt(i),terminators)){\n\t\t\t\treturn line.substring(start,i);\t\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn line.substring(start,i);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String parseToken(final char[] terminators){\n\n\tint start=offset,end=offset;\n\tboolean found=false;\n\twhile(!found){\n\t\tif(offset>=length)\n\t\t\tbreak;\n\t\tchar c=data[offset++];\n\t\tif(Character.isWhitespace(c))\n\t\t\tcontinue;\n\t\tif(c=='<'&&offset<length&&data[offset]=='!'){\n\t\t\tparseComment();\n\t\t\tcontinue;\n\t\t}\n\t\tend=offset;\n\t\tfor(int i=0;i<terminators.length;i++)\n\t\t\tif(c==terminators[i]){\n\t\t\t\tfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn new String(data,start,end-start);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n", "method_name": "parseToken", "codes": ["private String parseToken(final char[] terminators){\n\n\tchar[] token = new char[0];\n\tboolean done = false;\n\twhile(!done){\n\t\tchar current = next();\n\t\twhile(!isTerminator(current, terminators))\n\t\t\ttoken = append(token, current);\n\t\tif(isTerminator(current, terminators))\n\t\t\tdone = true;\n\t}\n\treturn new String(token);\n}", "private String parseToken(final char[] terminators){\n\n\tfinal StringBuilder sb=new StringBuilder();\n\ttry{\n\t\twhile(true){\n\t\t\tfinal char c=read();\n\t\t\tif(c==0)throw new RuntimeException(\"Unexpected end of stream\");\n\t\t\tif(c=='\\\\'){\n\t\t\t\tsb.append(c);\n\t\t\t\tsb.append(read());\n\t\t\t}else{\n\t\t\t\tfor(char t:terminators){\n\t\t\t\t\tif(c==t){\n\t\t\t\t\t\tunread(c);\n\t\t\t\t\t\treturn sb.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t}catch(IOException ex){\n\t\tthrow new RuntimeException(\"Unexpected error\",ex);\n\t}\n}", "private String parseToken(final char[] terminators){\n\n    int current = this.read();\n    if(current == -1)\n        return null;\n    final StringBuilder buffer = new StringBuilder();\n    while(current != -1){\n        final char c = (char)current;\n        if(Character.isWhitespace(c)){\n            this.unread(c);\n            return buffer.toString();\n        }\n        else{\n            final boolean terminator = false;\n            for(int i=0; i<terminators.length; i++){\n                if(c == terminators[i]){\n                    terminator = true;\n                    break;\n                }\n            }\n            if(terminator){\n                this.unread(c);\n                return buffer.toString();\n            }\n            else\n                buffer.append(c);\n        }\n        current = this.read();\n    }\n    return buffer.toString();\n}", "private String parseToken(final char[] terminators){\n\n\tfinal StringBuilder b = new StringBuilder();\n\tint ch;\n\twhile((ch=parseChar())!=NO_CHAR && !isTerminator(ch,terminators)){\n\t\tb.append((char)ch);\n\t}\n\tpushBack(ch);\n\treturn b.toString();\n}", "private String parseToken(final char[] terminators){\n\n\tint index = 0;\n\tint start = this.pos;\n\twhile(this.pos < this.length){\n\t\tfinal char c = this.chars[this.pos];\n\t\tif(isTerminator(c, terminators)){\n\t\t\tbreak;\n\t\t}\n\t\tthis.pos++;\n\t\tindex++;\n\t}\n\tif(index == 0){\n\t\treturn null;\n\t}\n\treturn new String(this.chars, start, index);\n}", "private String parseToken(final char[] terminators){\n\n\tString token = \"\";\n\tchar c;\n\tfor (int i = 0; i < terminators.length; i++)\n\t\tterminators[i] = Character.toLowerCase(terminators[i]);\n\twhile (index < input.length() && !isTerminator(c = input.charAt(index), terminators)){\n\t\ttoken += c;\n\t\tindex++;\n\t}\n\treturn token;\n}", "private String parseToken(final char[] terminators){\n\n\tStringBuilder result=new StringBuilder();\n\tfor(int i=currentIndex;i<string.length();i++){\n\t\tchar c=string.charAt(i);\n\t\tfor(char terminator:terminators){\n\t\t\tif(c==terminator)\n\t\t\t\treturn result.toString();\n\t\t}\n\t\tresult.append(c);\n\t\tcurrentIndex++;\n\t}\n\treturn result.toString();\n}", "private String parseToken(final char[] terminators){\n\n  if(currentPos==length)throw new IllegalStateException(\"No more characters to parse.\");\n  int startPos=currentPos;\n  while(currentPos<length){\n    if(isTerminator(terminators))break;\n    currentPos++;\n  }\n  return new String(chars,startPos,currentPos-startPos);\n}", "private String parseToken(final char[] terminators){\n\n\t\tint start = i;\n\t\twhile(i < line.length()){\n\t\t\tif(contains(line.charAt(i),terminators)){\n\t\t\t\treturn line.substring(start,i);\t\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn line.substring(start,i);\n\t}", "private String parseToken(final char[] terminators){\n\n\tint start=offset,end=offset;\n\tboolean found=false;\n\twhile(!found){\n\t\tif(offset>=length)\n\t\t\tbreak;\n\t\tchar c=data[offset++];\n\t\tif(Character.isWhitespace(c))\n\t\t\tcontinue;\n\t\tif(c=='<'&&offset<length&&data[offset]=='!'){\n\t\t\tparseComment();\n\t\t\tcontinue;\n\t\t}\n\t\tend=offset;\n\t\tfor(int i=0;i<terminators.length;i++)\n\t\t\tif(c==terminators[i]){\n\t\t\t\tfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn new String(data,start,end-start);\n}"], "code_level": "class_runnable", "_id": "636766fa1a6d9265ec01779c", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null&&b==null)return true;\n\tif(a==null||b==null)return false;\n\tif(a.length<count||b.length<count)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(count==0)return true;\n\tif(a==null)return b==null;\n\tif(b==null)return false;\n\tif(count>a.length)return false;\n\tif(count>b.length)return false;\n\tfor(int i=0;i<count;i++)if(a[i]!=b[i])return false;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null && b==null) return true;\n\tif(a==null || b==null) return false;\n\tif(a.length<count || b.length<count) return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]) return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==b)return true;\n\tif(a==null||b==null)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(count==0)\n\t\treturn true;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null){\n\t\treturn b==null;\n\t}\n\tif(b==null){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==b)\n\t\treturn true;\n\tif(a==null||b==null)\n\t\treturn false;\n\tif(count<0)\n\t\tthrow new IllegalArgumentException(\"Negative Array Size Exception\");\n\tfor(int i=0;i<count;i++)\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null||b==null||count<0)return false;\n\tif(a==b)return true;\n\tif(a.length<count||b.length<count)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null||b==null||a.length<count||b.length<count)\n\t\treturn false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n * @param a     The first array to compare.\n * @param b     The second array to compare.\n * @param count How many bytes should be compared.\n * @return <code>true</code> if <code>count</code> first bytes in arrays<code>a</code> and <code>b</code> are equal.\n */\n", "method_name": "arrayequals", "codes": ["public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null&&b==null)return true;\n\tif(a==null||b==null)return false;\n\tif(a.length<count||b.length<count)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(count==0)return true;\n\tif(a==null)return b==null;\n\tif(b==null)return false;\n\tif(count>a.length)return false;\n\tif(count>b.length)return false;\n\tfor(int i=0;i<count;i++)if(a[i]!=b[i])return false;\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null && b==null) return true;\n\tif(a==null || b==null) return false;\n\tif(a.length<count || b.length<count) return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]) return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==b)return true;\n\tif(a==null||b==null)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(count==0)\n\t\treturn true;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null){\n\t\treturn b==null;\n\t}\n\tif(b==null){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==b)\n\t\treturn true;\n\tif(a==null||b==null)\n\t\treturn false;\n\tif(count<0)\n\t\tthrow new IllegalArgumentException(\"Negative Array Size Exception\");\n\tfor(int i=0;i<count;i++)\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null||b==null||count<0)return false;\n\tif(a==b)return true;\n\tif(a.length<count||b.length<count)return false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])return false;\n\t}\n\treturn true;\n}", "public static boolean arrayequals(byte[] a,byte[] b,int count){\n\n\tif(a==null||b==null||a.length<count||b.length<count)\n\t\treturn false;\n\tfor(int i=0;i<count;i++){\n\t\tif(a[i]!=b[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}"], "code_level": "self_contained", "_id": "636766fd1a6d9265ec017814", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null)\n\t\treturn INDEXNOTFOUND;\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null || searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null || searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null) return INDEXNOTFOUND;\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int lastIndexOf(String str,String searchStr){\n\n\treturn str.lastIndexOf(searchStr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n", "method_name": "lastIndexOf", "codes": ["public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null)\n\t\treturn INDEXNOTFOUND;\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null || searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null || searchStr==null){\n\t\treturn INDEXNOTFOUND;\n\t}\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null) return INDEXNOTFOUND;\n\treturn str.lastIndexOf(searchStr);\n}", "public static int lastIndexOf(String str,String searchStr){\n\n\treturn str.lastIndexOf(searchStr);\n}"], "code_level": "project_runnable", "_id": "636766f61a6d9265ec017701", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(str==null){return null;}\n\tint len=str.length();\n\tif(end>len){end=len;}\n\tif(start<0){start=0;}\n\tif(end<start){end=start;}\n\treturn str.substring(start,end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(str==null)return \"\";\n\tif(start>str.length())start=str.length();\n\tif(end>str.length())end=str.length();\n\tif(start<0)start=0;\n\tif(end<0)end=0;\n\treturn str.substring(start,end);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\treturn sub(str,start,end,null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(isEmpty(str))return str;\n\tif(start<0)start=0;\n\tif(end>=str.length())return str.substring(start);\n\treturn str.substring(start,end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(end<0)end=str.length()+end; //count from the right\n\tif(start<0)start=str.length()+start; //count from the right\n\tif(end>str.length())end=str.length();\n\tif(start>str.length())start=str.length();\n\tif(end<start)end=start;\n\treturn str.substring(start,end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(start<0)start=0;\n\tif(end>str.length())end=str.length();\n\treturn str.substring(start,end);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(start<0){\n\t\tstart=0;\n\t}\n\tif(end>str.length()){\n\t\tend=str.length();\n\t}\n\tif(start>end){\n\t\tstart=end;\n\t}\n\treturn str.substring(start,end);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(end<0)end=str.length()+end; //Negative ends mean starting at the end of the String\n\tif(start<0)start=str.length()+start;\n\tif(end>str.length())end=str.length();\n\tif(start>str.length())start=str.length();\n\tif(start>end)return \"\";\n\treturn str.substring(start,end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(start>str.length())return \"\";\n\tif(end>str.length())end=str.length();\n\treturn str.substring(start,end);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String sub(String str,int start,int end){\n\n\ttry{\n\t\treturn str.substring(start,end);\n\t}catch(Exception e){\n\t\treturn str;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n", "method_name": "sub", "codes": ["public static String sub(String str,int start,int end){\n\n\tif(str==null){return null;}\n\tint len=str.length();\n\tif(end>len){end=len;}\n\tif(start<0){start=0;}\n\tif(end<start){end=start;}\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(str==null)return \"\";\n\tif(start>str.length())start=str.length();\n\tif(end>str.length())end=str.length();\n\tif(start<0)start=0;\n\tif(end<0)end=0;\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\treturn sub(str,start,end,null);\n}", "public static String sub(String str,int start,int end){\n\n\tif(isEmpty(str))return str;\n\tif(start<0)start=0;\n\tif(end>=str.length())return str.substring(start);\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(end<0)end=str.length()+end; //count from the right\n\tif(start<0)start=str.length()+start; //count from the right\n\tif(end>str.length())end=str.length();\n\tif(start>str.length())start=str.length();\n\tif(end<start)end=start;\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(start<0)start=0;\n\tif(end>str.length())end=str.length();\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(start<0){\n\t\tstart=0;\n\t}\n\tif(end>str.length()){\n\t\tend=str.length();\n\t}\n\tif(start>end){\n\t\tstart=end;\n\t}\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(end<0)end=str.length()+end; //Negative ends mean starting at the end of the String\n\tif(start<0)start=str.length()+start;\n\tif(end>str.length())end=str.length();\n\tif(start>str.length())start=str.length();\n\tif(start>end)return \"\";\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\tif(str==null)return null;\n\tif(start>str.length())return \"\";\n\tif(end>str.length())end=str.length();\n\treturn str.substring(start,end);\n}", "public static String sub(String str,int start,int end){\n\n\ttry{\n\t\treturn str.substring(start,end);\n\t}catch(Exception e){\n\t\treturn str;\n\t}\n}"], "code_level": "project_runnable", "_id": "636766ff1a6d9265ec01783b", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str==null||searchStrArray==null) return false;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(containsIgnoreCase(str,searchStrArray.get(i))){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str==null||str.isEmpty()||searchStrArray==null||searchStrArray.isEmpty())return false;\n\tfor(String s:searchStrArray){\n\t\tif(str.toLowerCase().contains(s.toLowerCase()))return true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tfor(String searchStr:searchStrArray){\n\t\tif (containsIgnoreCase(str, searchStr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str.length()==0||searchStrArray.size()==0)\n\t\treturn false;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(containsIgnoreCase(str,(String)searchStrArray.get(i)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\treturn containsAnyIgnoreCase(str,searchStrArray,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(StringUtil.isEmpty(str) || searchStrArray==null)\n\t\treturn false;\n\t\n\tString lowerStr=str.toLowerCase();\n\tfor(String searchStr:searchStrArray){\n\t\tif(lowerStr.contains(searchStr.toLowerCase()))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(isEmpty(str)||isEmpty(searchStrArray)){\n\t\treturn false;\n\t}\n\tfor(String searchStr:searchStrArray){\n\t\tif(str.toLowerCase().contains(searchStr.toLowerCase())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\nif(str==null||searchStrArray==null||searchStrArray.size()==0) return false;\nfor(String searchStr:searchStrArray){\nif(str.toLowerCase().indexOf(searchStr.toLowerCase())>=0) return true;\n}\nreturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(searchStrArray==null||searchStrArray.isEmpty())\n\t\treturn true;\n\tif(str==null||str.isEmpty())\n\t\treturn false;\n\tfor(String searchStr:searchStrArray){\n\t\tif(containsIgnoreCase(str,searchStr))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tfor(String searchStr:searchStrArray){\n\t\tif(containsIgnoreCase(str,searchStr)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n", "method_name": "containsAnyIgnoreCase", "codes": ["public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str==null||searchStrArray==null) return false;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(containsIgnoreCase(str,searchStrArray.get(i))){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str==null||str.isEmpty()||searchStrArray==null||searchStrArray.isEmpty())return false;\n\tfor(String s:searchStrArray){\n\t\tif(str.toLowerCase().contains(s.toLowerCase()))return true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tfor(String searchStr:searchStrArray){\n\t\tif (containsIgnoreCase(str, searchStr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(str.length()==0||searchStrArray.size()==0)\n\t\treturn false;\n\tfor(int i=0;i<searchStrArray.size();i++){\n\t\tif(containsIgnoreCase(str,(String)searchStrArray.get(i)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\treturn containsAnyIgnoreCase(str,searchStrArray,true);\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(StringUtil.isEmpty(str) || searchStrArray==null)\n\t\treturn false;\n\t\n\tString lowerStr=str.toLowerCase();\n\tfor(String searchStr:searchStrArray){\n\t\tif(lowerStr.contains(searchStr.toLowerCase()))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(isEmpty(str)||isEmpty(searchStrArray)){\n\t\treturn false;\n\t}\n\tfor(String searchStr:searchStrArray){\n\t\tif(str.toLowerCase().contains(searchStr.toLowerCase())){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\nif(str==null||searchStrArray==null||searchStrArray.size()==0) return false;\nfor(String searchStr:searchStrArray){\nif(str.toLowerCase().indexOf(searchStr.toLowerCase())>=0) return true;\n}\nreturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tif(searchStrArray==null||searchStrArray.isEmpty())\n\t\treturn true;\n\tif(str==null||str.isEmpty())\n\t\treturn false;\n\tfor(String searchStr:searchStrArray){\n\t\tif(containsIgnoreCase(str,searchStr))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n\n\tfor(String searchStr:searchStrArray){\n\t\tif(containsIgnoreCase(str,searchStr)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "6367670b1a6d9265ec017a0f", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static int indexOf(String str,String searchStr){\n\n    return str.indexOf(searchStr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null) return -1;\n\treturn str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n    return indexOf(str,searchStr,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n    return str.indexOf(searchStr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\treturn str.indexOf(searchStr);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\nreturn indexOf(str,searchStr,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null)\n\t\treturn -1;\n\treturn str.indexOf(searchStr);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds the first index within a String, handling <code>null</code>. This method uses  {@link String#indexOf(String)}. \n */\n", "method_name": "indexOf", "codes": ["public static int indexOf(String str,String searchStr){\n\n    return str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n}", "public static int indexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null) return -1;\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n\t}", "public static int indexOf(String str,String searchStr){\n\n    return indexOf(str,searchStr,0);\n}", "public static int indexOf(String str,String searchStr){\n\n    return str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\nreturn indexOf(str,searchStr,0);\n}", "public static int indexOf(String str,String searchStr){\n\n\tif(str==null||searchStr==null)\n\t\treturn -1;\n\treturn str.indexOf(searchStr);\n}", "public static int indexOf(String str,String searchStr){\n\n\treturn indexOf(str,searchStr,0);\n}"], "code_level": "project_runnable", "_id": "636767021a6d9265ec0178bc", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static boolean isParameterSeparator(final char c){\nreturn (c == ',');}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ' ') || (c == ',');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn c==',' || c==';';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\tif(c=='#' || c=='&'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\nreturn c==','||c==';';}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\tassert c != 0 : \"Precondition violation - argument 'c' must not be NULL!\";\n\treturn c == ',';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',') || (c == ';') || (c == ':') || (c == ' ') || (c == '\\n') || (c == '\\r') || (c == '\\t') || (c == '\\f') || (c == '\\b');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static boolean isParameterSeparator(final char c){\n\n\treturn c == ',';\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Determine whether a parameter name ends at the current position, that is, whether the given character qualifies as a separator. \n */\n", "method_name": "isParameterSeparator", "codes": ["private static boolean isParameterSeparator(final char c){\nreturn (c == ',');}", "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ' ') || (c == ',');\n}", "private static boolean isParameterSeparator(final char c){\n\n\treturn c==',' || c==';';\n}", "private static boolean isParameterSeparator(final char c){\n\n\tif(c=='#' || c=='&'){\n\t\treturn true;\n\t}\n\treturn false;\n}", "private static boolean isParameterSeparator(final char c){\n\nreturn c==','||c==';';}", "private static boolean isParameterSeparator(final char c){\n\n\tassert c != 0 : \"Precondition violation - argument 'c' must not be NULL!\";\n\treturn c == ',';\n}", "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',');\n}", "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',') || (c == ';') || (c == ':') || (c == ' ') || (c == '\\n') || (c == '\\r') || (c == '\\t') || (c == '\\f') || (c == '\\b');\n}", "private static boolean isParameterSeparator(final char c){\n\n\treturn (c == ',');\n}", "private static boolean isParameterSeparator(final char c){\n\n\treturn c == ',';\n}"], "code_level": "class_runnable", "_id": "636766fc1a6d9265ec0177da", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=Array.getLength(array);\nObject newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=gwt.reflect.shared.Reflection.getLength(array);\nObject newArray=java.lang.reflect.Array.newInstance(newArrayComponentType,arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nreturn newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\n\tif(isEmpty(array)){\n\t\treturn Array.newInstance(newArrayComponentType, 1);\n\t}\n\tObject result=Array.newInstance(array.getClass().getComponentType(), Array.getLength(array)+1);\n\tSystem.arraycopy(array, 0, result, 0, Array.getLength(array));\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=getLength(array);\nObject newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nObject newArray=Array.newInstance(newArrayComponentType,Array.getLength(array)+1);\nSystem.arraycopy(array,0,newArray,0,Array.getLength(array));\nreturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength = Array.getLength(array);\nObject newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength+1);\nSystem.arraycopy(array, 0, newArray, 0, arrayLength);\nArray.set(newArray, arrayLength, newArrayComponentType.cast(Array.get(array, 0)));\nreturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nfinal int arrayLength=(array!=null)?Array.getLength(array):0;\nfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nif(arrayLength>0){System.arraycopy(array,0,newArray,0,arrayLength);}\nArray.set(newArray,arrayLength,newArrayComponentType.getComponentType().newInstance());\nreturn newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nif(array!=null){\nfinal int arrayLength=Array.getLength(array);\nfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}\nreturn Array.newInstance(newArrayComponentType,1);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=java.lang.reflect.Array.getLength(array);\nObject newArray=java.lang.reflect.Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\njava.lang.reflect.Array.set(newArray,arrayLength,newArrayComponentType.getComponentType().getName());\nreturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\n\tif(isEmpty(array)){\n\t\treturn Array.newInstance(newArrayComponentType,1);\n\t}\n\tfinal int arrayLength=Array.getLength(array);\n\tfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\n\tSystem.arraycopy(array,0,newArray,0,arrayLength);\n\treturn newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a copy of the given array of size 1 greater than the argument. The last value of the array is left to the default value.\n * @param array The array to copy, must not be <code>null</code>.\n * @param newArrayComponentType If <code>array</code> is <code>null</code>, create asize 1 array of this type.\n * @return A new copy of the array of size 1 greater than the input.\n */\n", "method_name": "copyArrayGrow1", "codes": ["private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=Array.getLength(array);\nObject newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=gwt.reflect.shared.Reflection.getLength(array);\nObject newArray=java.lang.reflect.Array.newInstance(newArrayComponentType,arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\n\tif(isEmpty(array)){\n\t\treturn Array.newInstance(newArrayComponentType, 1);\n\t}\n\tObject result=Array.newInstance(array.getClass().getComponentType(), Array.getLength(array)+1);\n\tSystem.arraycopy(array, 0, result, 0, Array.getLength(array));\n\treturn result;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=getLength(array);\nObject newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nObject newArray=Array.newInstance(newArrayComponentType,Array.getLength(array)+1);\nSystem.arraycopy(array,0,newArray,0,Array.getLength(array));\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength = Array.getLength(array);\nObject newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength+1);\nSystem.arraycopy(array, 0, newArray, 0, arrayLength);\nArray.set(newArray, arrayLength, newArrayComponentType.cast(Array.get(array, 0)));\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nfinal int arrayLength=(array!=null)?Array.getLength(array):0;\nfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nif(arrayLength>0){System.arraycopy(array,0,newArray,0,arrayLength);}\nArray.set(newArray,arrayLength,newArrayComponentType.getComponentType().newInstance());\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nif(array!=null){\nfinal int arrayLength=Array.getLength(array);\nfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\nArray.set(newArray,arrayLength,newArrayComponentType.cast(Array.get(array,0)));\nreturn newArray;\n}\nreturn Array.newInstance(newArrayComponentType,1);\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\nint arrayLength=java.lang.reflect.Array.getLength(array);\nObject newArray=java.lang.reflect.Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\nSystem.arraycopy(array,0,newArray,0,arrayLength);\njava.lang.reflect.Array.set(newArray,arrayLength,newArrayComponentType.getComponentType().getName());\nreturn newArray;\n}", "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n\n\tif(isEmpty(array)){\n\t\treturn Array.newInstance(newArrayComponentType,1);\n\t}\n\tfinal int arrayLength=Array.getLength(array);\n\tfinal Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength+1);\n\tSystem.arraycopy(array,0,newArray,0,arrayLength);\n\treturn newArray;\n}"], "code_level": "slib_runnable", "_id": "636767031a6d9265ec0178ef", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public static String sessionId(){\n\n\t\treturn sessionId;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n\tString sessionId = \"\";\n\tHttpServletRequest request = getCurrentRequest();\n\t\n\tif(request != null){\n\t\tsessionId = request.getSession().getId();\n\t}\n\treturn sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n    return session().getId();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n\treturn (String)play.mvc.Scope.Session.current().get(\"sessionId\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n  return sessionId(true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n    return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n\treturn (String) request().getSession().getAttribute(\"sessionId\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n\tString sessionId = null;\n\tif(sessionId != null){\n\t\treturn sessionId;\n\t}\n\treturn sessionId();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n    return sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String sessionId(){\n\n\treturn sessionId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Session ID. \n */\n", "method_name": "sessionId", "codes": ["public static String sessionId(){\n\n\t\treturn sessionId;\n\t}", "public static String sessionId(){\n\n\tString sessionId = \"\";\n\tHttpServletRequest request = getCurrentRequest();\n\t\n\tif(request != null){\n\t\tsessionId = request.getSession().getId();\n\t}\n\treturn sessionId;\n}", "public static String sessionId(){\n\n    return session().getId();\n}", "public static String sessionId(){\n\n\treturn (String)play.mvc.Scope.Session.current().get(\"sessionId\");\n}", "public static String sessionId(){\n\n  return sessionId(true);\n}", "public static String sessionId(){\n\n    return sessionId;\n}", "public static String sessionId(){\n\n\treturn (String) request().getSession().getAttribute(\"sessionId\");\n}", "public static String sessionId(){\n\n\tString sessionId = null;\n\tif(sessionId != null){\n\t\treturn sessionId;\n\t}\n\treturn sessionId();\n}", "public static String sessionId(){\n\n    return sessionId;\n}", "public static String sessionId(){\n\n\treturn sessionId;\n}"], "code_level": "plib_runnable", "_id": "636766fe1a6d9265ec017834", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "public Boolean isPartialContentResponse(){\n\n  return getActual().getStatusCode().equals(HttpStatus.PARTIAL_CONTENT);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n\treturn response.getStatusCode() == 206;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n\tBoolean flag=false;\n\tif(this.statusCode==206)\n\t\tflag=true;\n\treturn flag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n  return getHttpResponse()\n      .then()\n      .statusCode(HttpStatus.SC_PARTIAL_CONTENT);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n    if(this.getResponseCode()==HttpURLConnection.HTTP_PARTIAL){\n        return true;\n    }\n    return false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\nreturn getResponse().getStatusCode()==206;}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n        return getWrappedObject().getStatusCode()==HttpStatus.SC_PARTIAL_CONTENT;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n\treturn getStatusCode() == 206;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\nreturn getActualResponse().getStatusCode().equals(HttpStatus.PARTIAL_CONTENT);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Boolean isPartialContentResponse(){\n\n\treturn this.getStatusCode().equals(\"206\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n", "method_name": "isPartialContentResponse", "codes": ["public Boolean isPartialContentResponse(){\n\n  return getActual().getStatusCode().equals(HttpStatus.PARTIAL_CONTENT);\n}", "public Boolean isPartialContentResponse(){\n\n\treturn response.getStatusCode() == 206;\n}", "public Boolean isPartialContentResponse(){\n\n\tBoolean flag=false;\n\tif(this.statusCode==206)\n\t\tflag=true;\n\treturn flag;\n}", "public Boolean isPartialContentResponse(){\n\n  return getHttpResponse()\n      .then()\n      .statusCode(HttpStatus.SC_PARTIAL_CONTENT);\n}", "public Boolean isPartialContentResponse(){\n\n    if(this.getResponseCode()==HttpURLConnection.HTTP_PARTIAL){\n        return true;\n    }\n    return false;\n}", "public Boolean isPartialContentResponse(){\nreturn getResponse().getStatusCode()==206;}", "public Boolean isPartialContentResponse(){\n\n        return getWrappedObject().getStatusCode()==HttpStatus.SC_PARTIAL_CONTENT;\n    }", "public Boolean isPartialContentResponse(){\n\n\treturn getStatusCode() == 206;\n}", "public Boolean isPartialContentResponse(){\n\nreturn getActualResponse().getStatusCode().equals(HttpStatus.PARTIAL_CONTENT);\n}", "public Boolean isPartialContentResponse(){\n\n\treturn this.getStatusCode().equals(\"206\");\n}"], "code_level": "plib_runnable", "_id": "636766ae1a6d9265ec0175dc", "project_name": "framework-master"}
{"generate_results": [{"generate_code": "private String buildContentRange(){\n\n\tif(limit>0){\n\t\treturn String.format(\"bytes %d-%d/%d\",offset,limit-1,count);\n\t}else{\n\t\treturn String.format(\"bytes %d-%d/%d\",offset,count-1,count);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tStringBuilder builder=new StringBuilder();\n\tbuilder.append(\"bytes \");\n\tbuilder.append(offset);\n\tbuilder.append(\"-\");\n\tif(limit==0){\n\t\tbuilder.append(count-1);\n\t}else{\n\t\tbuilder.append(limit);\n\t}\n\tbuilder.append(\"/\");\n\tbuilder.append(count);\n\treturn builder.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tStringBuilder sb=new StringBuilder();\n\tif(limit==0){\n\t\tsb.append(offset).append(\"-\").append(count-1).append(\"/\").append(count);\n\t}else{\n\t\tsb.append(offset).append(\"-\").append(offset+limit-1).append(\"/\").append(count);\n\t}\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\nString contentRange=\"\";\nif(offset==0&&limit==0){\nString countStr=getCount()+\"\";\ncontentRange=\"items \"+countStr+\"/\"+countStr;\n}else{\nlimit=(limit==0?count-offset:limit);\ncontentRange=\"items \"+offset+\"-\"+(offset+limit-1)+\"/\"+count;\n}\nreturn contentRange;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tif(limit==0)\n\t\treturn offset + \"-\" + (count-1) + \"/\" + count;\n\telse\n\t\treturn offset + \"-\" + (limit-1) + \"/\" + count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tif(limit==0)\n\t\treturn \"bytes \"+offset+\"-\";\n\telse if(count==0)\n\t\treturn \"bytes */0\";\n\telse\n\t\treturn \"bytes \"+offset+\"-\"+limit+\"/\"+count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\t\tif(limit==0){\n\t\t\treturn \"items \"+offset+\"-\"+(count-1)+\"/\"+count;\n\t\t}\n\t\telse{\n\t\t\treturn \"items \"+offset+\"-\"+(offset+limit-1)+\"/\"+count;\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(String.valueOf(offset));\n\tsb.append(\":\");\n\tsb.append(String.valueOf(limit));\n\tsb.append(\"/\");\n\tsb.append(String.valueOf(count));\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tStringBuffer buf=new StringBuffer();\n\tbuf.append(\"bytes \").append(offset).append(\"-\").append(limit).append(\"/\").append(count);\n\treturn buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String buildContentRange(){\n\n\tlong upper = limit==0?count-1:limit-1;\n\treturn String.format(\"items %d-%d/%d\",offset,upper,count);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n", "method_name": "buildContentRange", "codes": ["private String buildContentRange(){\n\n\tif(limit>0){\n\t\treturn String.format(\"bytes %d-%d/%d\",offset,limit-1,count);\n\t}else{\n\t\treturn String.format(\"bytes %d-%d/%d\",offset,count-1,count);\n\t}\n}", "private String buildContentRange(){\n\n\tStringBuilder builder=new StringBuilder();\n\tbuilder.append(\"bytes \");\n\tbuilder.append(offset);\n\tbuilder.append(\"-\");\n\tif(limit==0){\n\t\tbuilder.append(count-1);\n\t}else{\n\t\tbuilder.append(limit);\n\t}\n\tbuilder.append(\"/\");\n\tbuilder.append(count);\n\treturn builder.toString();\n}", "private String buildContentRange(){\n\n\tStringBuilder sb=new StringBuilder();\n\tif(limit==0){\n\t\tsb.append(offset).append(\"-\").append(count-1).append(\"/\").append(count);\n\t}else{\n\t\tsb.append(offset).append(\"-\").append(offset+limit-1).append(\"/\").append(count);\n\t}\n\treturn sb.toString();\n}", "private String buildContentRange(){\n\nString contentRange=\"\";\nif(offset==0&&limit==0){\nString countStr=getCount()+\"\";\ncontentRange=\"items \"+countStr+\"/\"+countStr;\n}else{\nlimit=(limit==0?count-offset:limit);\ncontentRange=\"items \"+offset+\"-\"+(offset+limit-1)+\"/\"+count;\n}\nreturn contentRange;\n}", "private String buildContentRange(){\n\n\tif(limit==0)\n\t\treturn offset + \"-\" + (count-1) + \"/\" + count;\n\telse\n\t\treturn offset + \"-\" + (limit-1) + \"/\" + count;\n}", "private String buildContentRange(){\n\n\tif(limit==0)\n\t\treturn \"bytes \"+offset+\"-\";\n\telse if(count==0)\n\t\treturn \"bytes */0\";\n\telse\n\t\treturn \"bytes \"+offset+\"-\"+limit+\"/\"+count;\n}", "private String buildContentRange(){\n\n\t\tif(limit==0){\n\t\t\treturn \"items \"+offset+\"-\"+(count-1)+\"/\"+count;\n\t\t}\n\t\telse{\n\t\t\treturn \"items \"+offset+\"-\"+(offset+limit-1)+\"/\"+count;\n\t\t}\n\t}", "private String buildContentRange(){\n\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(String.valueOf(offset));\n\tsb.append(\":\");\n\tsb.append(String.valueOf(limit));\n\tsb.append(\"/\");\n\tsb.append(String.valueOf(count));\n\treturn sb.toString();\n}", "private String buildContentRange(){\n\n\tStringBuffer buf=new StringBuffer();\n\tbuf.append(\"bytes \").append(offset).append(\"-\").append(limit).append(\"/\").append(count);\n\treturn buf.toString();\n}", "private String buildContentRange(){\n\n\tlong upper = limit==0?count-1:limit-1;\n\treturn String.format(\"items %d-%d/%d\",offset,upper,count);\n}"], "code_level": "class_runnable", "_id": "636766ae1a6d9265ec0175d8", "project_name": "framework-master"}
{"generate_results": [{"generate_code": "private static String javaCharset(String charset){\n\nif(charset==null)return null;\nif(charset.equalsIgnoreCase(\"ISO-8859-1\"))return \"ISO8859_1\";\nelse if(charset.equalsIgnoreCase(\"UTF-8\"))return \"UTF8\";\nelse if(charset.equalsIgnoreCase(\"US-ASCII\"))return \"ASCII\";\nelse if(charset.equalsIgnoreCase(\"UTF-16\"))return \"Unicode\";\nelse if(charset.equalsIgnoreCase(\"UTF-16BE\"))return \"UnicodeBigUnmarked\";\nelse if(charset.equalsIgnoreCase(\"UTF-16LE\"))return \"UnicodeLittleUnmarked\";\nelse if(charset.equalsIgnoreCase(\"UTF-32\"))return \"UTF_32\";\nelse if(charset.equalsIgnoreCase(\"UTF-32BE\"))return \"UTF_32BE\";\nelse if(charset.equalsIgnoreCase(\"UTF-32LE\"))return \"UTF_32LE\";\nelse return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tif(charset.equalsIgnoreCase(\"US-ASCII\")) return \"ASCII\";\n\tif(charset.equalsIgnoreCase(\"ISO-8859-1\")) return \"ISO8859_1\";\n\tif(charset.equalsIgnoreCase(\"UTF-8\")) return \"UTF8\";\n\tif(charset.equalsIgnoreCase(\"UTF-16\")) return \"UTF-16\";\n\tif(charset.equalsIgnoreCase(\"UTF-16BE\")) return \"UnicodeBig\";\n\tif(charset.equalsIgnoreCase(\"UTF-16LE\")) return \"UnicodeLittle\";\n\telse return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tif(charset.toLowerCase().equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.toLowerCase().equals(\"iso-8859-1\")) return \"8859_1\";\n\treturn charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tcharset=charset.toLowerCase();\n\tif(charset.equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.equals(\"us-ascii\")) return \"ASCII\";\n\tif(charset.equals(\"iso-8859-1\")) return \"ISO8859_1\";\n\tif(charset.equals(\"iso-8859-2\")) return \"ISO8859_2\";\n\tif(charset.equals(\"iso-8859-3\")) return \"ISO8859_3\";\n\tif(charset.equals(\"iso-8859-4\")) return \"ISO8859_4\";\n\tif(charset.equals(\"iso-8859-5\")) return \"ISO8859_5\";\n\tif(charset.equals(\"iso-8859-6\")) return \"ISO8859_6\";\n\tif(charset.equals(\"iso-8859-7\")) return \"ISO8859_7\";\n\tif(charset.equals(\"iso-8859-8\"))", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tif(charset==null){\n\t\treturn null;\n\t}\n\tif(charset.equals(\"utf-8\")){\n\t\treturn \"UTF8\";\n\t}\n\tif(charset.equals(\"iso-8859-1\")){\n\t\treturn \"ISO8859_1\";\n\t}\n\tif(charset.equals(\"iso-8859-2\")){\n\t\treturn \"ISO8859_2\";\n\t}\n\tif(charset.equals(\"iso-8859-3\")){\n\t\treturn \"ISO8859_3\";\n\t}\n\tif(charset.equals(\"iso-8859-4\")){\n\t\treturn \"ISO8859_4\";\n\t}\n\tif(charset.equals(\"iso-8859-5\")){\n\t\treturn \"ISO8859_5\";\n\t}\n\tif(charset.equals(\"iso-8859-6\")){\n\t\treturn \"ISO8859_6\";\n\t}\n\tif(charset.equals(\"iso", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tcharset=charset.toLowerCase();\n\tif(charset.equals(\"us-ascii\")) return \"ASCII\";\n\tif(charset.equals(\"iso-8859-1\")) return \"ISO-8859-1\";\n\tif(charset.equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.equals(\"utf-16\")) return \"Unicode\";\n\tif(charset.equals(\"utf-16be\")) return \"UnicodeBigUnmarked\";\n\tif(charset.equals(\"utf-16le\")) return \"UnicodeLittleUnmarked\";\n\tthrow new IllegalArgumentException(\"unknown charset: \"+charset);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tif(charset==null) return null;\n\tcharset=charset.toLowerCase();\n\tif(\"utf-8\".equals(charset)) return \"UTF-8\";\n\tif(\"utf8\".equals(charset)) return \"UTF-8\";\n\tif(\"iso-8859-1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso8859-1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso8859_1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso-8859-2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso8859-2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso8859_2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso-8859-3\".equals(charset)) return \"ISO-8859-3\";\n\tif", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n    if (charset.equals(\"B\")) return \"US-ASCII\";\n    else if (charset.equals(\"H\")) return \"ISO-8859-1\";\n    else return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n\tif (charset.equalsIgnoreCase(\"utf-8\")) return \"UTF8\";\n\treturn charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static String javaCharset(String charset){\n\n  if(charset.equals(\"iso-8859-1\")) return\"ISO8859_1\";\n  if(charset.equals(\"us-ascii\")) return\"US-ASCII\";\n  return charset;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n", "method_name": "javaCharset", "codes": ["private static String javaCharset(String charset){\n\nif(charset==null)return null;\nif(charset.equalsIgnoreCase(\"ISO-8859-1\"))return \"ISO8859_1\";\nelse if(charset.equalsIgnoreCase(\"UTF-8\"))return \"UTF8\";\nelse if(charset.equalsIgnoreCase(\"US-ASCII\"))return \"ASCII\";\nelse if(charset.equalsIgnoreCase(\"UTF-16\"))return \"Unicode\";\nelse if(charset.equalsIgnoreCase(\"UTF-16BE\"))return \"UnicodeBigUnmarked\";\nelse if(charset.equalsIgnoreCase(\"UTF-16LE\"))return \"UnicodeLittleUnmarked\";\nelse if(charset.equalsIgnoreCase(\"UTF-32\"))return \"UTF_32\";\nelse if(charset.equalsIgnoreCase(\"UTF-32BE\"))return \"UTF_32BE\";\nelse if(charset.equalsIgnoreCase(\"UTF-32LE\"))return \"UTF_32LE\";\nelse return charset;\n}", "private static String javaCharset(String charset){\n\n\tif(charset.equalsIgnoreCase(\"US-ASCII\")) return \"ASCII\";\n\tif(charset.equalsIgnoreCase(\"ISO-8859-1\")) return \"ISO8859_1\";\n\tif(charset.equalsIgnoreCase(\"UTF-8\")) return \"UTF8\";\n\tif(charset.equalsIgnoreCase(\"UTF-16\")) return \"UTF-16\";\n\tif(charset.equalsIgnoreCase(\"UTF-16BE\")) return \"UnicodeBig\";\n\tif(charset.equalsIgnoreCase(\"UTF-16LE\")) return \"UnicodeLittle\";\n\telse return charset;\n}", "private static String javaCharset(String charset){\n\n\tif(charset.toLowerCase().equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.toLowerCase().equals(\"iso-8859-1\")) return \"8859_1\";\n\treturn charset;\n}", "private static String javaCharset(String charset){\n\n\tcharset=charset.toLowerCase();\n\tif(charset.equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.equals(\"us-ascii\")) return \"ASCII\";\n\tif(charset.equals(\"iso-8859-1\")) return \"ISO8859_1\";\n\tif(charset.equals(\"iso-8859-2\")) return \"ISO8859_2\";\n\tif(charset.equals(\"iso-8859-3\")) return \"ISO8859_3\";\n\tif(charset.equals(\"iso-8859-4\")) return \"ISO8859_4\";\n\tif(charset.equals(\"iso-8859-5\")) return \"ISO8859_5\";\n\tif(charset.equals(\"iso-8859-6\")) return \"ISO8859_6\";\n\tif(charset.equals(\"iso-8859-7\")) return \"ISO8859_7\";\n\tif(charset.equals(\"iso-8859-8\"))", "private static String javaCharset(String charset){\n\n\tif(charset==null){\n\t\treturn null;\n\t}\n\tif(charset.equals(\"utf-8\")){\n\t\treturn \"UTF8\";\n\t}\n\tif(charset.equals(\"iso-8859-1\")){\n\t\treturn \"ISO8859_1\";\n\t}\n\tif(charset.equals(\"iso-8859-2\")){\n\t\treturn \"ISO8859_2\";\n\t}\n\tif(charset.equals(\"iso-8859-3\")){\n\t\treturn \"ISO8859_3\";\n\t}\n\tif(charset.equals(\"iso-8859-4\")){\n\t\treturn \"ISO8859_4\";\n\t}\n\tif(charset.equals(\"iso-8859-5\")){\n\t\treturn \"ISO8859_5\";\n\t}\n\tif(charset.equals(\"iso-8859-6\")){\n\t\treturn \"ISO8859_6\";\n\t}\n\tif(charset.equals(\"iso", "private static String javaCharset(String charset){\n\n\tcharset=charset.toLowerCase();\n\tif(charset.equals(\"us-ascii\")) return \"ASCII\";\n\tif(charset.equals(\"iso-8859-1\")) return \"ISO-8859-1\";\n\tif(charset.equals(\"utf-8\")) return \"UTF8\";\n\tif(charset.equals(\"utf-16\")) return \"Unicode\";\n\tif(charset.equals(\"utf-16be\")) return \"UnicodeBigUnmarked\";\n\tif(charset.equals(\"utf-16le\")) return \"UnicodeLittleUnmarked\";\n\tthrow new IllegalArgumentException(\"unknown charset: \"+charset);\n}", "private static String javaCharset(String charset){\n\n\tif(charset==null) return null;\n\tcharset=charset.toLowerCase();\n\tif(\"utf-8\".equals(charset)) return \"UTF-8\";\n\tif(\"utf8\".equals(charset)) return \"UTF-8\";\n\tif(\"iso-8859-1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso8859-1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso8859_1\".equals(charset)) return \"ISO-8859-1\";\n\tif(\"iso-8859-2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso8859-2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso8859_2\".equals(charset)) return \"ISO-8859-2\";\n\tif(\"iso-8859-3\".equals(charset)) return \"ISO-8859-3\";\n\tif", "private static String javaCharset(String charset){\n\n    if (charset.equals(\"B\")) return \"US-ASCII\";\n    else if (charset.equals(\"H\")) return \"ISO-8859-1\";\n    else return charset;\n}", "private static String javaCharset(String charset){\n\n\tif (charset.equalsIgnoreCase(\"utf-8\")) return \"UTF8\";\n\treturn charset;\n}", "private static String javaCharset(String charset){\n\n  if(charset.equals(\"iso-8859-1\")) return\"ISO8859_1\";\n  if(charset.equals(\"us-ascii\")) return\"US-ASCII\";\n  return charset;\n}"], "code_level": "class_runnable", "_id": "636766f01a6d9265ec01763e", "project_name": "hasor-master"}
{"generate_results": [{"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> nodeLeft = node.left;\n    node.left = nodeLeft.right;\n    nodeLeft.right = node;\n    node.height = Math.max(height(node.left), height(node.right)) + 1;\n    nodeLeft.height = Math.max(height(nodeLeft.left), height(nodeLeft.right)) + 1;\n    return nodeLeft;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> newRoot = node.left;\n\tnode.left = newRoot.right;\n\tnewRoot.right = node;\n\tnode.height = 1 + max(getHeight(node.left), getHeight(node.right));\n\tnewRoot.height = 1 + max(getHeight(newRoot.left), getHeight(newRoot.right));\n\treturn newRoot;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> leftChild = node.getLeft();\n    node.setLeft(leftChild.getRight());\n    leftChild.setRight(node);\n    return leftChild;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> temp = node.getLeft();\n\tnode.setLeft(temp.getRight());\n\ttemp.setRight(node);\n\tnode.setHeight(Math.max(height(node.getLeft()), height(node.getRight()))+1);\n\ttemp.setHeight(Math.max(height(temp.getLeft()), height(temp.getRight()))+1);\n\treturn temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> tempLeft = node.left;\n\tnode.left = tempLeft.right;\n\ttempLeft.right = node;\n\tnode.height = Math.max(height(node.left), height(node.right)) + 1;\n\ttempLeft.height = Math.max(height(tempLeft.left), node.height) + 1;\n\treturn tempLeft;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> temp = node.left;\n\tnode.left = temp.right;\n\ttemp.right = node;\n\tnode.height = Math.max(height(node.left), height(node.right)) + 1;\n\ttemp.height = Math.max(height(temp.left), node.height) + 1;\n\treturn temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> left = node.left;\n\tTreeNode<T> left_right = left.right;\n\tleft.right = node;\n\tnode.left = left_right;\n\t\n\tnode.height = Math.max(height(node.left), height(node.right)) +1;\n\tleft.height = Math.max(height(left.left), height(left.right)) +1;\n\t\n\treturn left;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> left = node.getLeft();\n\tnode.setLeft(left.getRight());\n\tleft.setRight(node);\n\treturn left;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> left = node.left;\n    node.left = left.right;\n    left.right = node;\n    fixHeight(node);\n    fixHeight(left);\n    return left;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> nodeL = node.left;\n    TreeNode<T> nodeLR = nodeL.right;\n    nodeL.right = node;\n    node.left = nodeLR;\n    node.height = Math.max(node.left.height, node.right.height) + 1;\n    nodeL.height = Math.max(nodeL.left.height, nodeL.right.height) + 1;\n    return nodeL;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n", "method_name": "rotateRight", "codes": ["private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> nodeLeft = node.left;\n    node.left = nodeLeft.right;\n    nodeLeft.right = node;\n    node.height = Math.max(height(node.left), height(node.right)) + 1;\n    nodeLeft.height = Math.max(height(nodeLeft.left), height(nodeLeft.right)) + 1;\n    return nodeLeft;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> newRoot = node.left;\n\tnode.left = newRoot.right;\n\tnewRoot.right = node;\n\tnode.height = 1 + max(getHeight(node.left), getHeight(node.right));\n\tnewRoot.height = 1 + max(getHeight(newRoot.left), getHeight(newRoot.right));\n\treturn newRoot;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> leftChild = node.getLeft();\n    node.setLeft(leftChild.getRight());\n    leftChild.setRight(node);\n    return leftChild;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> temp = node.getLeft();\n\tnode.setLeft(temp.getRight());\n\ttemp.setRight(node);\n\tnode.setHeight(Math.max(height(node.getLeft()), height(node.getRight()))+1);\n\ttemp.setHeight(Math.max(height(temp.getLeft()), height(temp.getRight()))+1);\n\treturn temp;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> tempLeft = node.left;\n\tnode.left = tempLeft.right;\n\ttempLeft.right = node;\n\tnode.height = Math.max(height(node.left), height(node.right)) + 1;\n\ttempLeft.height = Math.max(height(tempLeft.left), node.height) + 1;\n\treturn tempLeft;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> temp = node.left;\n\tnode.left = temp.right;\n\ttemp.right = node;\n\tnode.height = Math.max(height(node.left), height(node.right)) + 1;\n\ttemp.height = Math.max(height(temp.left), node.height) + 1;\n\treturn temp;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> left = node.left;\n\tTreeNode<T> left_right = left.right;\n\tleft.right = node;\n\tnode.left = left_right;\n\t\n\tnode.height = Math.max(height(node.left), height(node.right)) +1;\n\tleft.height = Math.max(height(left.left), height(left.right)) +1;\n\t\n\treturn left;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n\tTreeNode<T> left = node.getLeft();\n\tnode.setLeft(left.getRight());\n\tleft.setRight(node);\n\treturn left;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> left = node.left;\n    node.left = left.right;\n    left.right = node;\n    fixHeight(node);\n    fixHeight(left);\n    return left;\n}", "private TreeNode<T> rotateRight(TreeNode<T> node){\n\n    TreeNode<T> nodeL = node.left;\n    TreeNode<T> nodeLR = nodeL.right;\n    nodeL.right = node;\n    node.left = nodeLR;\n    node.height = Math.max(node.left.height, node.right.height) + 1;\n    nodeL.height = Math.max(nodeL.left.height, nodeL.right.height) + 1;\n    return nodeL;\n}"], "code_level": "file_runnable", "_id": "636767441a6d9265ec017cc1", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tif(!ArrayUtils.exists(arr,i)||!ArrayUtils.exists(arr,j))\n\t\treturn;\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV tmp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n    V tmp=arr[i];\n    arr[i]=arr[j];\n    arr[j]=tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV swap = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = swap;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tif(i==j)\n\t\treturn;\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV t=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=t;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void swap(V[] arr,int i,int j){\n\n    V tmp=arr[i];\n    arr[i]=arr[j];\n    arr[j]=tmp;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Swaps the two elements at the specified indices in the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param i the index of the first element\n * @param j the index of the second element\n */\n", "method_name": "swap", "codes": ["public static final <V>void swap(V[] arr,int i,int j){\n\n\tif(!ArrayUtils.exists(arr,i)||!ArrayUtils.exists(arr,j))\n\t\treturn;\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV tmp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=tmp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n    V tmp=arr[i];\n    arr[i]=arr[j];\n    arr[j]=tmp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV swap = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = swap;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tif(i==j)\n\t\treturn;\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV t=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=t;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n\tV temp=arr[i];\n\tarr[i]=arr[j];\n\tarr[j]=temp;\n}", "public static final <V>void swap(V[] arr,int i,int j){\n\n    V tmp=arr[i];\n    arr[i]=arr[j];\n    arr[j]=tmp;\n}"], "code_level": "self_contained", "_id": "636767551a6d9265ec017f3f", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>) (Object) createIntegerSupplier(start);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn ()->String.valueOf(start++);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\tif(start<0)throw new IllegalArgumentException();\n\treturn createStringSupplier(Integer.toString(start));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\nreturn new StringSupplier(start);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n    int[] i = {start};\n    return () -> Integer.toString(i[0]++);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\tint[] counter = new int[]{start};\n\treturn ()->String.valueOf(counter[0]++);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n        return (Supplier<String>)stringSupplier.get(start);\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n    return (Supplier<String>)(Supplier)createIntSupplier(start).map(Object::toString);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>)(Object)new IntSupplier(){\n\t\tprivate int i=start;\n\t\t@Override public int getAsInt(){\n\t\t\treturn i++;\n\t\t}\n\t};\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>)createStringSupplier(start);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n", "method_name": "createStringSupplier", "codes": ["@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>) (Object) createIntegerSupplier(start);\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn ()->String.valueOf(start++);\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\tif(start<0)throw new IllegalArgumentException();\n\treturn createStringSupplier(Integer.toString(start));\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\nreturn new StringSupplier(start);}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n    int[] i = {start};\n    return () -> Integer.toString(i[0]++);\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\tint[] counter = new int[]{start};\n\treturn ()->String.valueOf(counter[0]++);\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n        return (Supplier<String>)stringSupplier.get(start);\n    }", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n    return (Supplier<String>)(Supplier)createIntSupplier(start).map(Object::toString);\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>)(Object)new IntSupplier(){\n\t\tprivate int i=start;\n\t\t@Override public int getAsInt(){\n\t\t\treturn i++;\n\t\t}\n\t};\n}", "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n\n\treturn (Supplier<String>)createStringSupplier(start);\n}"], "code_level": "slib_runnable", "_id": "6367675c1a6d9265ec018058", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@Override public ListNode<E> previousNode(){\n\n\treturn prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\tif(this.prev == null)\n\t\tthrow new NoSuchElementException();\n\telse\n\t\treturn this.prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\treturn prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\treturn previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\treturn this.prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\tif(previous==null){\n\t\treturn null;\n\t}\n\treturn previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\tif (hasPrevious()){\n\t\treturn previous;\n\t}\n\tthrow new NoSuchElementException();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\nreturn prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n  return previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public ListNode<E> previousNode(){\n\n\treturn this.previous;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "previousNode", "codes": ["@Override public ListNode<E> previousNode(){\n\n\treturn prev;\n}", "@Override public ListNode<E> previousNode(){\n\n\tif(this.prev == null)\n\t\tthrow new NoSuchElementException();\n\telse\n\t\treturn this.prev;\n}", "@Override public ListNode<E> previousNode(){\n\n\treturn prev;\n}", "@Override public ListNode<E> previousNode(){\n\n\treturn previous;\n}", "@Override public ListNode<E> previousNode(){\n\n\treturn this.prev;\n}", "@Override public ListNode<E> previousNode(){\n\n\tif(previous==null){\n\t\treturn null;\n\t}\n\treturn previous;\n}", "@Override public ListNode<E> previousNode(){\n\n\tif (hasPrevious()){\n\t\treturn previous;\n\t}\n\tthrow new NoSuchElementException();\n}", "@Override public ListNode<E> previousNode(){\n\nreturn prev;\n}", "@Override public ListNode<E> previousNode(){\n\n  return previous;\n}", "@Override public ListNode<E> previousNode(){\n\n\treturn this.previous;\n}"], "code_level": "class_runnable", "_id": "636767501a6d9265ec017e86", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static long factorial(int n){\n\n    if (n&lt;=1)\n        return 1;\n    else\n        return n*factorial(n-1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static long factorial(int n){\n\n    if(n==0){\n        return 1;\n    }\n    else{\n        return n*factorial(n-1);\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n    long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n    if(n == 0){\n        return 1;\n    }\n    return n * factorial(n - 1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n    long fact = 1;\n    for (int i = 1; i <= n; i++){\n        fact *= i;\n    }\n    return fact;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n    long result = 1;\n    while(n &gt; 0){\n        result *= n;\n        n--;\n    }\n    return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static long factorial(int n){\n\n    if(n < 0){\n        throw new IllegalArgumentException(\"n cannot be negative\");\n    }\n    long result = 1;\n    while(n > 1){\n        result *= n;\n        n--;\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n\n\n    if(n &lt; 0) throw new IllegalArgumentException(\"Number must be non-negative\");\n    if(n &lt;= 1) return 1L;\n    else return n * factorial(n - 1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static long factorial(int n){\n\n    long f = 1;\n    for(int i = 1; i <= n; i++){\n        f *= i;\n    }\n    return f;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static long factorial(int n){\n\n    if(n==0)\n        return 1;\n    else\n        return n*factorial(n-1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Calculate the factorial of $n$.\n * @param n the input number\n * @return the factorial\n */\n", "method_name": "factorial", "codes": ["public static long factorial(int n){\n\n    if (n&lt;=1)\n        return 1;\n    else\n        return n*factorial(n-1);\n}", "public static long factorial(int n){\n\n    if(n==0){\n        return 1;\n    }\n    else{\n        return n*factorial(n-1);\n    }\n}", "public static long factorial(int n){\n\n    long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}", "public static long factorial(int n){\n\n    if(n == 0){\n        return 1;\n    }\n    return n * factorial(n - 1);\n}", "public static long factorial(int n){\n\n    long fact = 1;\n    for (int i = 1; i <= n; i++){\n        fact *= i;\n    }\n    return fact;\n}", "public static long factorial(int n){\n\n    long result = 1;\n    while(n &gt; 0){\n        result *= n;\n        n--;\n    }\n    return result;\n}", "public static long factorial(int n){\n\n    if(n < 0){\n        throw new IllegalArgumentException(\"n cannot be negative\");\n    }\n    long result = 1;\n    while(n > 1){\n        result *= n;\n        n--;\n    }\n    return result;\n}", "public static long factorial(int n){\n\n\n\n    if(n &lt; 0) throw new IllegalArgumentException(\"Number must be non-negative\");\n    if(n &lt;= 1) return 1L;\n    else return n * factorial(n - 1);\n}", "public static long factorial(int n){\n\n    long f = 1;\n    for(int i = 1; i <= n; i++){\n        f *= i;\n    }\n    return f;\n}", "public static long factorial(int n){\n\n    if(n==0)\n        return 1;\n    else\n        return n*factorial(n-1);\n}"], "code_level": "self_contained", "_id": "636767581a6d9265ec017fc4", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null) return false;\n\tif(node.prev==node) return false;\n\tnode.prev.next=node.next;\n\tnode.next.prev=node.prev;\n\tnode.next=node;\n\tnode.prev=node;\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)\n\t   return false;\n\tif(node.previous==null&&node.next==null)\n\t   return false;\n\tListNodeImpl<E> pre=node.previous;\n\tListNodeImpl<E> next=node.next;\n\tpre.next=next;\n\tnext.previous=pre;\n\tnode.previous=null;\n\tnode.next=null;\n\tsize--;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tboolean result=false;\n\tif(node != null){\n\t\tListNodeImpl<E> prev=node.previous;\n\t\tListNodeImpl<E> next=node.next;\n\t\tprev.next=next;\n\t\tnext.previous=prev;\n\t\tresult=true;\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\t//If node is null,just return false.\n\tif(node==null)\n\t\treturn false;\n\t\n\t//If node is the only node,just set head and tail to null.\n\tif(node==head&&node==tail){\n\t\thead=null;\n\t\ttail=null;\n\t\treturn true;\n\t}\n\t\n\t//If node is the head,just update head to next.\n\tif(node==head){\n\t\thead=node.next;\n\t\thead.prev=tail;\n\t\ttail.next=head;\n\t\treturn true;\n\t}\n\t\n\t//If node is the tail,just update tail to prev.\n\tif(node==tail){\n\t\ttail=node.prev;\n\t\thead.prev=tail;\n\t\ttail.next=head;\n\t\treturn true;\n\t}\n\t\n\t//If node is in the middle,just update prev and next.\n\tnode.prev.next=node.next;\n\tnode.next.prev=node.prev;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node!=null){\n\t\tnode.prev.next=node.next;\n\t\tnode.next.prev=node.prev;\n\t\tnode.prev=null;\n\t\tnode.next=null;\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node == null) return false;\n\tfinal ListNodeImpl<E> next = node.next;\n\tfinal ListNodeImpl<E> prev = node.prev;\n\tif(next == null) return false;\n\tif(prev == null) return false;\n\tif(node == next) return false;\n\tif(node == prev) return false;\n\tif(node == head) return false;\n\tif(node == tail) return false;\n\tif(head == tail) return false;\n\tnext.prev = prev;\n\tprev.next = next;\n\tnode.next = null;\n\tnode.prev = null;\n\tsize--;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)\n\t\treturn false;\n\tListNodeImpl<E> prev=node.prev;\n\tListNodeImpl<E> next=node.next;\n\tprev.next=next;\n\tnext.prev=prev;\n\tnode.prev=node.next=null;\n\tsize--;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)return false;\n\tif(node==first){\n\t\tif(node==last){\n\t\t\tfirst=null;\n\t\t\tlast=null;\n\t\t}else{\n\t\t\tListNodeImpl<E> nextNode=node.next;\n\t\t\tfirst=nextNode;\n\t\t\tnextNode.prev=null;\n\t\t}\n\t}else if(node==last){\n\t\tListNodeImpl<E> prevNode=node.prev;\n\t\tlast=prevNode;\n\t\tprevNode.next=null;\n\t}else{\n\t\tListNodeImpl<E> prevNode=node.prev;\n\t\tListNodeImpl<E> nextNode=node.next;\n\t\tprevNode.next=nextNode;\n\t\tnextNode.prev=prevNode;\n\t}\n\tsize--;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node == null) return false;\n\tListNodeImpl<E> prev = node.prev;\n\tListNodeImpl<E> next = node.next;\n\tif(prev != null && next != null){\n\t\tprev.next = next;\n\t\tnext.prev = prev;\n\t\tsize--;\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean unlink(ListNodeImpl<E> node){\n\nif(node==null) return false;\nif(node==node.next)\t{\nnode.next=null;\nnode.prev=null;\n\treturn true;\n}\nnode.prev.next=node.next;\nnode.next.prev=node.prev;\nnode.next=null;\nnode.prev=null;\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n", "method_name": "unlink", "codes": ["private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null) return false;\n\tif(node.prev==node) return false;\n\tnode.prev.next=node.next;\n\tnode.next.prev=node.prev;\n\tnode.next=node;\n\tnode.prev=node;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)\n\t   return false;\n\tif(node.previous==null&&node.next==null)\n\t   return false;\n\tListNodeImpl<E> pre=node.previous;\n\tListNodeImpl<E> next=node.next;\n\tpre.next=next;\n\tnext.previous=pre;\n\tnode.previous=null;\n\tnode.next=null;\n\tsize--;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tboolean result=false;\n\tif(node != null){\n\t\tListNodeImpl<E> prev=node.previous;\n\t\tListNodeImpl<E> next=node.next;\n\t\tprev.next=next;\n\t\tnext.previous=prev;\n\t\tresult=true;\n\t}\n\treturn result;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\t//If node is null,just return false.\n\tif(node==null)\n\t\treturn false;\n\t\n\t//If node is the only node,just set head and tail to null.\n\tif(node==head&&node==tail){\n\t\thead=null;\n\t\ttail=null;\n\t\treturn true;\n\t}\n\t\n\t//If node is the head,just update head to next.\n\tif(node==head){\n\t\thead=node.next;\n\t\thead.prev=tail;\n\t\ttail.next=head;\n\t\treturn true;\n\t}\n\t\n\t//If node is the tail,just update tail to prev.\n\tif(node==tail){\n\t\ttail=node.prev;\n\t\thead.prev=tail;\n\t\ttail.next=head;\n\t\treturn true;\n\t}\n\t\n\t//If node is in the middle,just update prev and next.\n\tnode.prev.next=node.next;\n\tnode.next.prev=node.prev;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node!=null){\n\t\tnode.prev.next=node.next;\n\t\tnode.next.prev=node.prev;\n\t\tnode.prev=null;\n\t\tnode.next=null;\n\t\treturn true;\n\t}\n\treturn false;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node == null) return false;\n\tfinal ListNodeImpl<E> next = node.next;\n\tfinal ListNodeImpl<E> prev = node.prev;\n\tif(next == null) return false;\n\tif(prev == null) return false;\n\tif(node == next) return false;\n\tif(node == prev) return false;\n\tif(node == head) return false;\n\tif(node == tail) return false;\n\tif(head == tail) return false;\n\tnext.prev = prev;\n\tprev.next = next;\n\tnode.next = null;\n\tnode.prev = null;\n\tsize--;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)\n\t\treturn false;\n\tListNodeImpl<E> prev=node.prev;\n\tListNodeImpl<E> next=node.next;\n\tprev.next=next;\n\tnext.prev=prev;\n\tnode.prev=node.next=null;\n\tsize--;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node==null)return false;\n\tif(node==first){\n\t\tif(node==last){\n\t\t\tfirst=null;\n\t\t\tlast=null;\n\t\t}else{\n\t\t\tListNodeImpl<E> nextNode=node.next;\n\t\t\tfirst=nextNode;\n\t\t\tnextNode.prev=null;\n\t\t}\n\t}else if(node==last){\n\t\tListNodeImpl<E> prevNode=node.prev;\n\t\tlast=prevNode;\n\t\tprevNode.next=null;\n\t}else{\n\t\tListNodeImpl<E> prevNode=node.prev;\n\t\tListNodeImpl<E> nextNode=node.next;\n\t\tprevNode.next=nextNode;\n\t\tnextNode.prev=prevNode;\n\t}\n\tsize--;\n\treturn true;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\n\tif(node == null) return false;\n\tListNodeImpl<E> prev = node.prev;\n\tListNodeImpl<E> next = node.next;\n\tif(prev != null && next != null){\n\t\tprev.next = next;\n\t\tnext.prev = prev;\n\t\tsize--;\n\t\treturn true;\n\t}\n\treturn false;\n}", "private boolean unlink(ListNodeImpl<E> node){\n\nif(node==null) return false;\nif(node==node.next)\t{\nnode.next=null;\nnode.prev=null;\n\treturn true;\n}\nnode.prev.next=node.next;\nnode.next.prev=node.prev;\nnode.next=null;\nnode.prev=null;\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "636767631a6d9265ec018171", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\nfor(int i=from,j=to-1;i<j;i++,j--){V temp=arr[i];arr[i]=arr[j];arr[j]=temp;}}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,j=to-1;i<j;i++,j--)\n\t\tswap(arr,i,j);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(;from<to;from++,to--){\n\t\tswap(arr,from,to);\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\twhile(from<to){\n\t\tV e=arr[from];\n\t\tarr[from]=arr[to];\n\t\tarr[to]=e;\n\t\tfrom++;\n\t\tto--;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,mid=from+to>>1,j=to-1;i<mid;i++,j--){\n\t\tV tmp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=tmp;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n    for(int i=from,j=to-1;i<j;i++,j--){\n        V tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n    int i=from,mid=(from+to)/2,j=to-1;\n    while(i<mid){\n        V temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n        ++i;\n        --j;\n    }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tto--;\n\twhile(from<to){\n\t\tV tmp=arr[from];\n\t\tarr[from++]=arr[to];\n\t\tarr[to--]=tmp;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=0;i<(to-from)/2;++i){\n\t\tV t=arr[i+from];\n\t\tarr[i+from]=arr[to-i-1];\n\t\tarr[to-i-1]=t;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,j=to-1;i<j;i++,j--){\n\t\tV tmp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=tmp;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n", "method_name": "reverse", "codes": ["public static final <V>void reverse(V[] arr,int from,int to){\nfor(int i=from,j=to-1;i<j;i++,j--){V temp=arr[i];arr[i]=arr[j];arr[j]=temp;}}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,j=to-1;i<j;i++,j--)\n\t\tswap(arr,i,j);\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(;from<to;from++,to--){\n\t\tswap(arr,from,to);\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\twhile(from<to){\n\t\tV e=arr[from];\n\t\tarr[from]=arr[to];\n\t\tarr[to]=e;\n\t\tfrom++;\n\t\tto--;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,mid=from+to>>1,j=to-1;i<mid;i++,j--){\n\t\tV tmp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=tmp;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n    for(int i=from,j=to-1;i<j;i++,j--){\n        V tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n    int i=from,mid=(from+to)/2,j=to-1;\n    while(i<mid){\n        V temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n        ++i;\n        --j;\n    }\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tto--;\n\twhile(from<to){\n\t\tV tmp=arr[from];\n\t\tarr[from++]=arr[to];\n\t\tarr[to--]=tmp;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=0;i<(to-from)/2;++i){\n\t\tV t=arr[i+from];\n\t\tarr[i+from]=arr[to-i-1];\n\t\tarr[to-i-1]=t;\n\t}\n}", "public static final <V>void reverse(V[] arr,int from,int to){\n\n\tfor(int i=from,j=to-1;i<j;i++,j--){\n\t\tV tmp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=tmp;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767491a6d9265ec017d90", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    if(list.size() == 0){\n        return;\n    }\n    int i = 0;\n    while(i < list.size()){\n        E element = list.get(i);\n        if(element != null){\n            this.add((E)element);\n            i++;\n        }\n    }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tlist.setHead(null);\n\tlist.setTail(null);\n\tlist.setSize(0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tif(list.isEmpty()) return;\n\tDoublyLinkedNode<E> node = list.getLastNode();\n\tdo{\n\t\tinsertFirst(node.getItem());\n\t\tnode = node.getPrevious();\n\t}while(node != null);\n\tlist.clear();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    DoublyLinkedList<E>.Node<E> temp = list.head;\n    while(temp != null){\n        this.addLast(temp.data);\n        temp = temp.next;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    Node<E> current = list.getFirst();\n    while (current != null){\n        addLast(current.getElement());\n        current = current.getNext();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tListNode<E> finger = list.head;\n\twhile (finger != null){\n\t\tthis.addLast(finger.element);\n\t\tfinger = finger.next;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    \n    Node<E> temp = list.head;\n    Node<E> temp2 = head;\n    if(list.head == null){\n        return;\n    }\n    else{\n        while(temp != null){\n            temp2.next = temp;\n            temp.previous = temp2;\n            temp = temp.next;\n            temp2 = temp2.next;\n        }\n    }\n    if(head == null){\n        head = list.head;\n        tail = list.tail;\n    }\n    else{\n        tail = list.tail;\n    }\n    list.head = null;\n    list.tail = null;\n    \n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tif(list.getSize()>0){\n\t\tif(list.getSize()==1){\n\t\t\tlist.getFirstNode().setPrev(null);\n\t\t\tlist.getFirstNode().setNext(null);\n\t\t}else{\n\t\t\tDoublyLinkedListNode<E> currentNode=list.getFirstNode();\n\t\t\twhile(currentNode.getNext()!=null){\n\t\t\t\tcurrentNode.setPrev(null);\n\t\t\t\tcurrentNode.setNext(null);\n\t\t\t\tcurrentNode=currentNode.getNext();\n\t\t\t}\n\t\t\tcurrentNode.setPrev(null);\n\t\t\tcurrentNode.setNext(null);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    for (Node<E> node = list.getFirstNode(); node != null; node = node.getNextNode()){\n        addLast(node.getData());\n    }\n    list.clear();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\t//is the list empty\n\tif(list.size==0){\n\t\t//the list is empty\n\t\treturn;\n\t}\n\t//the list is not empty\n\t//get the first node of the list\n\tDoublyLinkedListNode<E> node=list.head;\n\t//loop through the list\n\twhile(node!=null){\n\t\t//move the node to the new list\n\t\tmoveNode(node);\n\t\t//get the next node\n\t\tnode=node.next;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n", "method_name": "moveAllListNodes", "codes": ["private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    if(list.size() == 0){\n        return;\n    }\n    int i = 0;\n    while(i < list.size()){\n        E element = list.get(i);\n        if(element != null){\n            this.add((E)element);\n            i++;\n        }\n    }\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tlist.setHead(null);\n\tlist.setTail(null);\n\tlist.setSize(0);\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tif(list.isEmpty()) return;\n\tDoublyLinkedNode<E> node = list.getLastNode();\n\tdo{\n\t\tinsertFirst(node.getItem());\n\t\tnode = node.getPrevious();\n\t}while(node != null);\n\tlist.clear();\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    DoublyLinkedList<E>.Node<E> temp = list.head;\n    while(temp != null){\n        this.addLast(temp.data);\n        temp = temp.next;\n    }\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    Node<E> current = list.getFirst();\n    while (current != null){\n        addLast(current.getElement());\n        current = current.getNext();\n    }\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tListNode<E> finger = list.head;\n\twhile (finger != null){\n\t\tthis.addLast(finger.element);\n\t\tfinger = finger.next;\n\t}\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    \n    Node<E> temp = list.head;\n    Node<E> temp2 = head;\n    if(list.head == null){\n        return;\n    }\n    else{\n        while(temp != null){\n            temp2.next = temp;\n            temp.previous = temp2;\n            temp = temp.next;\n            temp2 = temp2.next;\n        }\n    }\n    if(head == null){\n        head = list.head;\n        tail = list.tail;\n    }\n    else{\n        tail = list.tail;\n    }\n    list.head = null;\n    list.tail = null;\n    \n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\tif(list.getSize()>0){\n\t\tif(list.getSize()==1){\n\t\t\tlist.getFirstNode().setPrev(null);\n\t\t\tlist.getFirstNode().setNext(null);\n\t\t}else{\n\t\t\tDoublyLinkedListNode<E> currentNode=list.getFirstNode();\n\t\t\twhile(currentNode.getNext()!=null){\n\t\t\t\tcurrentNode.setPrev(null);\n\t\t\t\tcurrentNode.setNext(null);\n\t\t\t\tcurrentNode=currentNode.getNext();\n\t\t\t}\n\t\t\tcurrentNode.setPrev(null);\n\t\t\tcurrentNode.setNext(null);\n\t\t}\n\t}\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n    for (Node<E> node = list.getFirstNode(); node != null; node = node.getNextNode()){\n        addLast(node.getData());\n    }\n    list.clear();\n}", "private void moveAllListNodes(DoublyLinkedList<E> list){\n\n\t//is the list empty\n\tif(list.size==0){\n\t\t//the list is empty\n\t\treturn;\n\t}\n\t//the list is not empty\n\t//get the first node of the list\n\tDoublyLinkedListNode<E> node=list.head;\n\t//loop through the list\n\twhile(node!=null){\n\t\t//move the node to the new list\n\t\tmoveNode(node);\n\t\t//get the next node\n\t\tnode=node.next;\n\t}\n}"], "code_level": "class_runnable", "_id": "6367674a1a6d9265ec017da9", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<V,E>(graph,graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\tHashMap<V,V> vertices=new HashMap<>();\n\tfor(V v:graph.vertexSet())\n\t\tvertices.put(v,v);\n\tHashMap<E,E> edges=new HashMap<>();\n\tfor(E e:graph.edgeSet())\n\t\tedges.put(e,e);\n\treturn new IsomorphicGraphMapping<>(vertices,edges);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph,graph,new HashMap<V,V>(),new HashMap<E,E>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph,graph,Collections.<V,V>emptyMap());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<>(graph,graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<>(graph,graph,new HashMap<>(),new HashMap<>());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<V,E>(graph,new HashMap<V,V>());\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n  return new IsomorphicGraphMapping<>(graph);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(\n\t\tnew IdentityGraphMapping<V,E>(graph),\n\t\tnew HashMap<V,V>(),\n\t\tnew HashMap<E,E>()\n\t);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n", "method_name": "identity", "codes": ["public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<V,E>(graph,graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\tHashMap<V,V> vertices=new HashMap<>();\n\tfor(V v:graph.vertexSet())\n\t\tvertices.put(v,v);\n\tHashMap<E,E> edges=new HashMap<>();\n\tfor(E e:graph.edgeSet())\n\t\tedges.put(e,e);\n\treturn new IsomorphicGraphMapping<>(vertices,edges);\n\t}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph,graph,new HashMap<V,V>(),new HashMap<E,E>());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(graph,graph,Collections.<V,V>emptyMap());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<>(graph,graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<>(graph,graph,new HashMap<>(),new HashMap<>());\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n    return new IsomorphicGraphMapping<V,E>(graph,new HashMap<V,V>());\n  }", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n  return new IsomorphicGraphMapping<>(graph);\n}", "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n\n\treturn new IsomorphicGraphMapping<V,E>(\n\t\tnew IdentityGraphMapping<V,E>(graph),\n\t\tnew HashMap<V,V>(),\n\t\tnew HashMap<E,E>()\n\t);\n}"], "code_level": "project_runnable", "_id": "6367675f1a6d9265ec0180d3", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif (resultMap==null)throw new NullPointerException();\n\tSet<V> A=this.getPartition(0).getVertices();\n\tSet<V> B=this.getPartition(1).getVertices();\n\tif (A.size()==0||B.size()==0) return;\n\tfor (V a:A){\n\t\tfor (V b:B){\n\t\t\tE e=target.addEdge(a,b);\n\t\t\tif (e!=null) resultMap.put(edgeName(a,b),e);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(this.getPartitionA().size()!=this.getPartitionB().size()){\n\t\tthrow new IllegalArgumentException(\"Partition sizes must be equal to generate a complete bipartite graph.\");\n\t}\n\t\n\tfor(V vertexA:this.getPartitionA()){\n\t\tresultMap.put(vertexA.toString(), vertexA);\n\t\ttarget.addVertex(vertexA);\n\t}\n\t\n\tfor(V vertexB:this.getPartitionB()){\n\t\tresultMap.put(vertexB.toString(), vertexB);\n\t\ttarget.addVertex(vertexB);\n\t}\n\t\n\tfor(V vertexA:this.getPartitionA()){\n\t\tfor(V vertexB:this.getPartitionB()){\n\t\t\ttarget.addEdge(this.createEdge(vertexA, vertexB));\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(resultMap==null){\n\t\tresultMap=new HashMap<String,V>();\n\t}\n\tint i=0;\n\tfor(String a:A){\n\t\tfor(String b:B){\n\t\t\tString aName=this.aPrefix+a+this.vSeparator+b;\n\t\t\tString bName=this.bPrefix+a+this.vSeparator+b;\n\t\t\tV aVertex=Graphs.addVertex(target,aName);\n\t\t\tV bVertex=Graphs.addVertex(target,bName);\n\t\t\tresultMap.put(aName,aVertex);\n\t\t\tresultMap.put(bName,bVertex);\n\t\t\tGraphs.addEdge(target,aVertex,bVertex);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\t List<V> A=partitions.get(0),B=partitions.get(1);\n\t for(V a:A){\n\t\t for(V b:B){\n\t\t\t V a1=resultMap.get(a.toString()),b1=resultMap.get(b.toString());\n\t\t\t target.addEdge(factory.createEdge(a1,b1),a1,b1);\n\t\t }\n\t }\n }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tresultMap.clear();\n\ttarget.setVertices(generateVertices(resultMap));\n\ttarget.setEdges(generateEdges());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tfor(V v: A)\n\t\tfor(V w: B)\n\t\t\ttarget.addEdge(target.getEdgeFactory().createEdge(v,w));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\t\tif(this.A.isEmpty()||this.B.isEmpty()){return;}\n\t\tIterator<V> itA=this.A.iterator();\n\t\twhile(itA.hasNext()){\n\t\t\tV a=itA.next();\n\t\t\tIterator<V> itB=this.B.iterator();\n\t\t\twhile(itB.hasNext()){\n\t\t\t\tV b=itB.next();\n\t\t\t\ttarget.addEdge(a,b);\n\t\t\t}\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n  if(target==null)throw new IllegalArgumentException(\"completeBipartiteGraph(): target graph must not be null\");\n  if(target.getEdgeFactory()==null)throw new IllegalArgumentException(\"completeBipartiteGraph(): target graph must have a non-null edge factory\");\n  HashSet<V> A=new HashSet<V>(numVerticesA);\n  HashSet<V> B=new HashSet<V>(numVerticesB);\n  while(A.size()<numVerticesA){\n    V v=resultMap.get(String.format(\"A%d\",A.size()+1));\n    if(v==null){\n      v=target.addVertex();\n      resultMap.put(String.format(\"A%d\",A.size()+1),v);\n    }\n    A.add(v);\n  }\n  while(B.size()<numVerticesB){\n    V v=resultMap.get(String.format(\"B%d\",B.size()+1));\n    if(v==null){\n      v=target.add", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tint sizeA = size[0],sizeB = size[1];\n\tint i = 0,j = 0;\n\tV[] a = (V[]) new Object[sizeA],b = (V[]) new Object[sizeB];\n\tfor(String key : resultMap.keySet()){\n\t\tif(i < sizeA){\n\t\t\ta[i++] = resultMap.get(key);\n\t\t}\n\t\telse{\n\t\t\tb[j++] = resultMap.get(key);\n\t\t}\n\t}\n\tfor(i = 0;i < sizeA;i++){\n\t\tfor(j = 0;j < sizeB;j++){\n\t\t\ttarget.addEdge(target.getEdgeFactory().createEdge(a[i],b[j]));\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(target==null)throw new IllegalArgumentException(\"target graph is null\");\n\tif(resultMap==null)throw new IllegalArgumentException(\"result map is null\");\n\tif(resultMap.containsKey(\"A\")||resultMap.containsKey(\"B\"))throw new IllegalArgumentException(\"result map is not empty\");\n\tif(A.isEmpty()||B.isEmpty())throw new IllegalArgumentException(\"one of the partitions is empty\");\n\tint n=A.size();\n\tint m=B.size();\n\tMap<Integer,V> map=new HashMap<Integer,V>();\n\tfor(int i=0;i<n;i++){\n\t\tV vertex=target.addVertex();\n\t\tmap.put(i,vertex);\n\t\tresultMap.put(\"A\"+i,vertex);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tV vertex=target.addVertex();\n\t\tmap.put(n+i,vertex);\n\t\tresultMap.put(\"B\"+i", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Construct a complete bipartite graph\n */\n", "method_name": "generateGraph", "codes": ["@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif (resultMap==null)throw new NullPointerException();\n\tSet<V> A=this.getPartition(0).getVertices();\n\tSet<V> B=this.getPartition(1).getVertices();\n\tif (A.size()==0||B.size()==0) return;\n\tfor (V a:A){\n\t\tfor (V b:B){\n\t\t\tE e=target.addEdge(a,b);\n\t\t\tif (e!=null) resultMap.put(edgeName(a,b),e);\n\t\t}\n\t}\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(this.getPartitionA().size()!=this.getPartitionB().size()){\n\t\tthrow new IllegalArgumentException(\"Partition sizes must be equal to generate a complete bipartite graph.\");\n\t}\n\t\n\tfor(V vertexA:this.getPartitionA()){\n\t\tresultMap.put(vertexA.toString(), vertexA);\n\t\ttarget.addVertex(vertexA);\n\t}\n\t\n\tfor(V vertexB:this.getPartitionB()){\n\t\tresultMap.put(vertexB.toString(), vertexB);\n\t\ttarget.addVertex(vertexB);\n\t}\n\t\n\tfor(V vertexA:this.getPartitionA()){\n\t\tfor(V vertexB:this.getPartitionB()){\n\t\t\ttarget.addEdge(this.createEdge(vertexA, vertexB));\n\t\t}\n\t}\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(resultMap==null){\n\t\tresultMap=new HashMap<String,V>();\n\t}\n\tint i=0;\n\tfor(String a:A){\n\t\tfor(String b:B){\n\t\t\tString aName=this.aPrefix+a+this.vSeparator+b;\n\t\t\tString bName=this.bPrefix+a+this.vSeparator+b;\n\t\t\tV aVertex=Graphs.addVertex(target,aName);\n\t\t\tV bVertex=Graphs.addVertex(target,bName);\n\t\t\tresultMap.put(aName,aVertex);\n\t\t\tresultMap.put(bName,bVertex);\n\t\t\tGraphs.addEdge(target,aVertex,bVertex);\n\t\t}\n\t}\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\t List<V> A=partitions.get(0),B=partitions.get(1);\n\t for(V a:A){\n\t\t for(V b:B){\n\t\t\t V a1=resultMap.get(a.toString()),b1=resultMap.get(b.toString());\n\t\t\t target.addEdge(factory.createEdge(a1,b1),a1,b1);\n\t\t }\n\t }\n }", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tresultMap.clear();\n\ttarget.setVertices(generateVertices(resultMap));\n\ttarget.setEdges(generateEdges());\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tfor(V v: A)\n\t\tfor(V w: B)\n\t\t\ttarget.addEdge(target.getEdgeFactory().createEdge(v,w));\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\t\tif(this.A.isEmpty()||this.B.isEmpty()){return;}\n\t\tIterator<V> itA=this.A.iterator();\n\t\twhile(itA.hasNext()){\n\t\t\tV a=itA.next();\n\t\t\tIterator<V> itB=this.B.iterator();\n\t\t\twhile(itB.hasNext()){\n\t\t\t\tV b=itB.next();\n\t\t\t\ttarget.addEdge(a,b);\n\t\t\t}\n\t\t}\n\t}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n  if(target==null)throw new IllegalArgumentException(\"completeBipartiteGraph(): target graph must not be null\");\n  if(target.getEdgeFactory()==null)throw new IllegalArgumentException(\"completeBipartiteGraph(): target graph must have a non-null edge factory\");\n  HashSet<V> A=new HashSet<V>(numVerticesA);\n  HashSet<V> B=new HashSet<V>(numVerticesB);\n  while(A.size()<numVerticesA){\n    V v=resultMap.get(String.format(\"A%d\",A.size()+1));\n    if(v==null){\n      v=target.addVertex();\n      resultMap.put(String.format(\"A%d\",A.size()+1),v);\n    }\n    A.add(v);\n  }\n  while(B.size()<numVerticesB){\n    V v=resultMap.get(String.format(\"B%d\",B.size()+1));\n    if(v==null){\n      v=target.add", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tint sizeA = size[0],sizeB = size[1];\n\tint i = 0,j = 0;\n\tV[] a = (V[]) new Object[sizeA],b = (V[]) new Object[sizeB];\n\tfor(String key : resultMap.keySet()){\n\t\tif(i < sizeA){\n\t\t\ta[i++] = resultMap.get(key);\n\t\t}\n\t\telse{\n\t\t\tb[j++] = resultMap.get(key);\n\t\t}\n\t}\n\tfor(i = 0;i < sizeA;i++){\n\t\tfor(j = 0;j < sizeB;j++){\n\t\t\ttarget.addEdge(target.getEdgeFactory().createEdge(a[i],b[j]));\n\t\t}\n\t}\n}", "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n\n\tif(target==null)throw new IllegalArgumentException(\"target graph is null\");\n\tif(resultMap==null)throw new IllegalArgumentException(\"result map is null\");\n\tif(resultMap.containsKey(\"A\")||resultMap.containsKey(\"B\"))throw new IllegalArgumentException(\"result map is not empty\");\n\tif(A.isEmpty()||B.isEmpty())throw new IllegalArgumentException(\"one of the partitions is empty\");\n\tint n=A.size();\n\tint m=B.size();\n\tMap<Integer,V> map=new HashMap<Integer,V>();\n\tfor(int i=0;i<n;i++){\n\t\tV vertex=target.addVertex();\n\t\tmap.put(i,vertex);\n\t\tresultMap.put(\"A\"+i,vertex);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tV vertex=target.addVertex();\n\t\tmap.put(n+i,vertex);\n\t\tresultMap.put(\"B\"+i"], "code_level": "class_runnable", "_id": "636767641a6d9265ec01817d", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "void insertBefore(Bucket bucket){\n\n\tif (this.before!=null){\n\t\tthis.before.after = this;\n\t}\n\tthis.after = bucket;\n\tbucket.before = this;\n\tif (bucket.isHead){\n\t    this.isHead = true;\n\t    bucket.isHead = false;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\t\n\tbucket.previous.next = this;\n\tthis.next = bucket;\n\tthis.previous = bucket.previous;\n\tbucket.previous = this;\n\t\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tif(bucket.previous!=null){\n\t\tbucket.previous.next=this;\t\n\t}\n\tthis.next=bucket;\n\tthis.previous=bucket.previous;\n\tbucket.previous=this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tbucket.link = this;\n\tif(previous == null)\n\t    previous = bucket;\n\telse{\n\t    previous.link = bucket;\n\t    bucket.previous = previous;\n\t}\n\tprevious = bucket;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tbucket->previous = currentBucket;\n\tbucket->next = currentBucket->next;\n\tcurrentBucket->next->previous = bucket;\n\tcurrentBucket->next = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tif(!bucket){\n\t\tinsertAfter(NULL);\n\t\treturn;\n\t}\n\tif(!bucket->prev){\n\t\tinsertAfter(NULL);\n\t\treturn;\n\t}\n\tBucket newBucket = malloc(sizeof(struct bucket));\n\tnewBucket->value = value;\n\tnewBucket->prev = bucket->prev;\n\tnewBucket->next = bucket;\n\tbucket->prev->next = newBucket;\n\tbucket->prev = newBucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tbucket.prev = this.prev;\n\tbucket.next = this;\n\tthis.prev.next = bucket;\n\tthis.prev = bucket;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tif(!bucket)\n\t\treturn;\n\n\tBucket prev = bucket->prev;\n\tif(prev)\n\t\tprev->next = this;\n\tthis->prev = prev;\n\tthis->next = bucket;\n\tbucket->prev = this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n  bucket.previous.next = this;\n  next = bucket;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void insertBefore(Bucket bucket){\n\n\tif(bucket == NULL) return;\n\tif(bucket->prev == NULL) return;\n\t\n\tbucket->prev->next = bucket->next;\n\tif(bucket->next == NULL) bucket->prev->next = NULL;\n\telse bucket->next->prev = bucket->prev;\n\tbucket->prev = NULL;\n\tbucket->next = NULL;\n\t\n\tif(bucket->prev == NULL){\n\t\tbucket->next = head;\n\t\tif(head != NULL) head->prev = bucket;\n\t\thead = bucket;\n\t}\n\telse{\n\t\tbucket->next = bucket->prev->next;\n\t\tbucket->prev->next = bucket;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Inserts this bucket in the data structure before the  {@code bucket}.\n * @param bucket the bucket, that will be the next to this bucket.\n */\n", "method_name": "insertBefore", "codes": ["void insertBefore(Bucket bucket){\n\n\tif (this.before!=null){\n\t\tthis.before.after = this;\n\t}\n\tthis.after = bucket;\n\tbucket.before = this;\n\tif (bucket.isHead){\n\t    this.isHead = true;\n\t    bucket.isHead = false;\n\t}\n}", "void insertBefore(Bucket bucket){\n\n\t\n\tbucket.previous.next = this;\n\tthis.next = bucket;\n\tthis.previous = bucket.previous;\n\tbucket.previous = this;\n\t\n}", "void insertBefore(Bucket bucket){\n\n\tif(bucket.previous!=null){\n\t\tbucket.previous.next=this;\t\n\t}\n\tthis.next=bucket;\n\tthis.previous=bucket.previous;\n\tbucket.previous=this;\n}", "void insertBefore(Bucket bucket){\n\n\tbucket.link = this;\n\tif(previous == null)\n\t    previous = bucket;\n\telse{\n\t    previous.link = bucket;\n\t    bucket.previous = previous;\n\t}\n\tprevious = bucket;\n    }", "void insertBefore(Bucket bucket){\n\n\tbucket->previous = currentBucket;\n\tbucket->next = currentBucket->next;\n\tcurrentBucket->next->previous = bucket;\n\tcurrentBucket->next = bucket;\n}", "void insertBefore(Bucket bucket){\n\n\tif(!bucket){\n\t\tinsertAfter(NULL);\n\t\treturn;\n\t}\n\tif(!bucket->prev){\n\t\tinsertAfter(NULL);\n\t\treturn;\n\t}\n\tBucket newBucket = malloc(sizeof(struct bucket));\n\tnewBucket->value = value;\n\tnewBucket->prev = bucket->prev;\n\tnewBucket->next = bucket;\n\tbucket->prev->next = newBucket;\n\tbucket->prev = newBucket;\n}", "void insertBefore(Bucket bucket){\n\n\tbucket.prev = this.prev;\n\tbucket.next = this;\n\tthis.prev.next = bucket;\n\tthis.prev = bucket;\n}", "void insertBefore(Bucket bucket){\n\n\tif(!bucket)\n\t\treturn;\n\n\tBucket prev = bucket->prev;\n\tif(prev)\n\t\tprev->next = this;\n\tthis->prev = prev;\n\tthis->next = bucket;\n\tbucket->prev = this;\n}", "void insertBefore(Bucket bucket){\n\n  bucket.previous.next = this;\n  next = bucket;\n}", "void insertBefore(Bucket bucket){\n\n\tif(bucket == NULL) return;\n\tif(bucket->prev == NULL) return;\n\t\n\tbucket->prev->next = bucket->next;\n\tif(bucket->next == NULL) bucket->prev->next = NULL;\n\telse bucket->next->prev = bucket->prev;\n\tbucket->prev = NULL;\n\tbucket->next = NULL;\n\t\n\tif(bucket->prev == NULL){\n\t\tbucket->next = head;\n\t\tif(head != NULL) head->prev = bucket;\n\t\thead = bucket;\n\t}\n\telse{\n\t\tbucket->next = bucket->prev->next;\n\t\tbucket->prev->next = bucket;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767531a6d9265ec017efb", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@Override public boolean hasNext(){\n\n\t\treturn !visited[current];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\tfor(int i = 0; i < vMap.size(); i++){\n\t\tif(!vMap.get(i).isVisited()){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\tif(currentIndex<vertices.size())\n\t\treturn true;\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\t\tif(this.isEmpty()){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=0; i<this.getSize(); i++){\n\t\t\tif(this.getVertex(i).isVisited()==false){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n    if(this.stack.isEmpty())\n        return false;\n    else\n        return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\tif (next == null){\n\t\tnext = next();\n\t}\n\treturn next != null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\treturn !vertexStack.empty();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n \n\treturn unvisited.size() > 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\treturn (unvisited.size()>0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public boolean hasNext(){\n\n\treturn unvisited.size()>0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n", "method_name": "hasNext", "codes": ["@Override public boolean hasNext(){\n\n\t\treturn !visited[current];\n}", "@Override public boolean hasNext(){\n\n\tfor(int i = 0; i < vMap.size(); i++){\n\t\tif(!vMap.get(i).isVisited()){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "@Override public boolean hasNext(){\n\n\tif(currentIndex<vertices.size())\n\t\treturn true;\n\treturn false;\n}", "@Override public boolean hasNext(){\n\n\t\tif(this.isEmpty()){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=0; i<this.getSize(); i++){\n\t\t\tif(this.getVertex(i).isVisited()==false){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "@Override public boolean hasNext(){\n\n    if(this.stack.isEmpty())\n        return false;\n    else\n        return true;\n}", "@Override public boolean hasNext(){\n\n\tif (next == null){\n\t\tnext = next();\n\t}\n\treturn next != null;\n}", "@Override public boolean hasNext(){\n\n\treturn !vertexStack.empty();\n}", "@Override public boolean hasNext(){\n \n\treturn unvisited.size() > 0;\n}", "@Override public boolean hasNext(){\n\n\treturn (unvisited.size()>0);\n}", "@Override public boolean hasNext(){\n\n\treturn unvisited.size()>0;\n}"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f63", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "void removeSelf(){\n\n\tif(prev != NULL) prev->next = next;\n\tif(next != NULL) next->prev = prev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n\tif(this==NULL) return;\n\tif(this->prev==NULL){\n\t\tthis->next->prev=NULL;\n\t}\n\telse if(this->next==NULL){\n\t\tthis->prev->next=NULL;\n\t}\n\telse{\n\t\tthis->prev->next=this->next;\n\t\tthis->next->prev=this->prev;\n\t}\n\tfree(this);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n    //If node is head, then change head\n    if (this == head){\n        head = head->next;\n    }\n    //If node is tail, then change tail\n    if (this == tail){\n        tail = tail->prev;\n    }\n    //If node is not head or tail, then change the previous and next nodes\n    if (this != head && this != tail){\n        this->next->prev = this->prev;\n        this->prev->next = this->next;\n    }\n    //If node is the only node in list, then change head and tail\n    if (this == head && this == tail){\n        head = NULL;\n        tail = NULL;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n\tif (this->prev == NULL && this->next == NULL){\n\t\treturn;\n\t}\n\telse if (this->prev == NULL){\n\t\tthis->next->prev = NULL;\n\t}\n\telse if (this->next == NULL){\n\t\tthis->prev->next = NULL;\n\t}\n\telse{\n\t\tthis->prev->next = this->next;\n\t\tthis->next->prev = this->prev;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n\tif(this->prev == NULL && this->next == NULL){\n\t\tfree(this);\n\t\tthis = NULL;\n\t}\n\telse if(this->prev == NULL){\n\t\tthis->next->prev = NULL;\n\t\tthis = this->next;\n\t\tfree(this->prev);\n\t}\n\telse if(this->next == NULL){\n\t\tthis->prev->next = NULL;\n\t\tthis = this->prev;\n\t\tfree(this->next);\n\t}\n\telse{\n\t\tthis->prev->next = this->next;\n\t\tthis->next->prev = this->prev;\n\t\tstruct Node *temp = this;\n\t\tthis = this->next;\n\t\tfree(temp);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n\tif(this.prev != null){\n\t\tthis.prev.next=this.next;\n\t\tif(this.next != null){\n\t\t\tthis.next.prev=this.prev;\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "void removeSelf(){\n\n    if(prevPtr != NULL){\n        prevPtr->nextPtr = nextPtr;\n    }\n    if(nextPtr != NULL){\n        nextPtr->prevPtr = prevPtr;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n\tif (!_parent)\n\t\treturn;\n\tif (_parent->_firstChild == this)\n\t\t_parent->_firstChild = _next;\n\tif (_parent->_lastChild == this)\n\t\t_parent->_lastChild = _prev;\n\tif (_next)\n\t\t_next->_prev = _prev;\n\tif (_prev)\n\t\t_prev->_next = _next;\n\t_parent = 0;\n\t_next = 0;\n\t_prev = 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n    if(prev != NULL) {\n        prev->next = next;\n    }\n    if(next != NULL) {\n        next->prev = prev;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "void removeSelf(){\n\n    //If it's the head node\n    if(prev == NULL){\n        head = next;\n        if(next != NULL) next->prev = NULL;\n    }else{\n        prev->next = next;\n        if(next != NULL) next->prev = prev;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this bucket from the data structure.\n */\n", "method_name": "removeSelf", "codes": ["void removeSelf(){\n\n\tif(prev != NULL) prev->next = next;\n\tif(next != NULL) next->prev = prev;\n}", "void removeSelf(){\n\n\tif(this==NULL) return;\n\tif(this->prev==NULL){\n\t\tthis->next->prev=NULL;\n\t}\n\telse if(this->next==NULL){\n\t\tthis->prev->next=NULL;\n\t}\n\telse{\n\t\tthis->prev->next=this->next;\n\t\tthis->next->prev=this->prev;\n\t}\n\tfree(this);\n}", "void removeSelf(){\n\n    //If node is head, then change head\n    if (this == head){\n        head = head->next;\n    }\n    //If node is tail, then change tail\n    if (this == tail){\n        tail = tail->prev;\n    }\n    //If node is not head or tail, then change the previous and next nodes\n    if (this != head && this != tail){\n        this->next->prev = this->prev;\n        this->prev->next = this->next;\n    }\n    //If node is the only node in list, then change head and tail\n    if (this == head && this == tail){\n        head = NULL;\n        tail = NULL;\n    }\n}", "void removeSelf(){\n\n\tif (this->prev == NULL && this->next == NULL){\n\t\treturn;\n\t}\n\telse if (this->prev == NULL){\n\t\tthis->next->prev = NULL;\n\t}\n\telse if (this->next == NULL){\n\t\tthis->prev->next = NULL;\n\t}\n\telse{\n\t\tthis->prev->next = this->next;\n\t\tthis->next->prev = this->prev;\n\t}\n}", "void removeSelf(){\n\n\tif(this->prev == NULL && this->next == NULL){\n\t\tfree(this);\n\t\tthis = NULL;\n\t}\n\telse if(this->prev == NULL){\n\t\tthis->next->prev = NULL;\n\t\tthis = this->next;\n\t\tfree(this->prev);\n\t}\n\telse if(this->next == NULL){\n\t\tthis->prev->next = NULL;\n\t\tthis = this->prev;\n\t\tfree(this->next);\n\t}\n\telse{\n\t\tthis->prev->next = this->next;\n\t\tthis->next->prev = this->prev;\n\t\tstruct Node *temp = this;\n\t\tthis = this->next;\n\t\tfree(temp);\n\t}\n}", "void removeSelf(){\n\n\tif(this.prev != null){\n\t\tthis.prev.next=this.next;\n\t\tif(this.next != null){\n\t\t\tthis.next.prev=this.prev;\n\t\t}\n\t}\n}", "void removeSelf(){\n\n    if(prevPtr != NULL){\n        prevPtr->nextPtr = nextPtr;\n    }\n    if(nextPtr != NULL){\n        nextPtr->prevPtr = prevPtr;\n    }\n}", "void removeSelf(){\n\n\tif (!_parent)\n\t\treturn;\n\tif (_parent->_firstChild == this)\n\t\t_parent->_firstChild = _next;\n\tif (_parent->_lastChild == this)\n\t\t_parent->_lastChild = _prev;\n\tif (_next)\n\t\t_next->_prev = _prev;\n\tif (_prev)\n\t\t_prev->_next = _next;\n\t_parent = 0;\n\t_next = 0;\n\t_prev = 0;\n}", "void removeSelf(){\n\n    if(prev != NULL) {\n        prev->next = next;\n    }\n    if(next != NULL) {\n        next->prev = prev;\n    }\n}", "void removeSelf(){\n\n    //If it's the head node\n    if(prev == NULL){\n        head = next;\n        if(next != NULL) next->prev = NULL;\n    }else{\n        prev->next = next;\n        if(next != NULL) next->prev = prev;\n    }\n}"], "code_level": "class_runnable", "_id": "6367675a1a6d9265ec018010", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private Set<V> initVisibleVertices(){\n\n    Set<V> vertices = new HashSet<V>();\n    for(E edge : edges){\n        vertices.add(edge.getFrom());\n        vertices.add(edge.getTo());\n    }\n    return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> result = new HashSet<V>();\n\tfor (E e : initVisibleEdges()){\n\t\tresult.add(source(e));\n\t\tresult.add(target(e));\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n    Set<V> v = new HashSet<>();\n    for(E e : this.getEdges()){\n        v.add(e.getSource());\n        v.add(e.getDestination());\n    }\n    return v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n    Set<V> vertices = new HashSet<>();\n    for(E edge:this.edges){\n        vertices.add(edge.getSource());\n        vertices.add(edge.getTarget());\n    }\n    return vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tHashSet<V> result=new HashSet<V>();\n\tIterator<E> iterator=this.edges.iterator();\n\twhile (iterator.hasNext()){\n\t\tE e=iterator.next();\n\t\tresult.add(e.getSource());\n\t\tresult.add(e.getTarget());\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor(E e : this.getEdges()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> visibleVertices=new HashSet<V>();\n\tfor(E e:getEdges()){\n\t\tvisibleVertices.add(getSourceVertex(e));\n\t\tvisibleVertices.add(getTargetVertex(e));\n\t}\n\treturn visibleVertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor(E edge : this.getEdges()){\n\t\tvertices.add(this.getSource(edge));\n\t\tvertices.add(this.getDest(edge));\n\t}\n\treturn vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor (E e : edgeSet()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices=new HashSet<V>(edgeSet().size());\n\tfor(Edge<V,E> e:edgeSet()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n", "method_name": "initVisibleVertices", "codes": ["private Set<V> initVisibleVertices(){\n\n    Set<V> vertices = new HashSet<V>();\n    for(E edge : edges){\n        vertices.add(edge.getFrom());\n        vertices.add(edge.getTo());\n    }\n    return vertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> result = new HashSet<V>();\n\tfor (E e : initVisibleEdges()){\n\t\tresult.add(source(e));\n\t\tresult.add(target(e));\n\t}\n\treturn result;\n}", "private Set<V> initVisibleVertices(){\n\n    Set<V> v = new HashSet<>();\n    for(E e : this.getEdges()){\n        v.add(e.getSource());\n        v.add(e.getDestination());\n    }\n    return v;\n}", "private Set<V> initVisibleVertices(){\n\n    Set<V> vertices = new HashSet<>();\n    for(E edge:this.edges){\n        vertices.add(edge.getSource());\n        vertices.add(edge.getTarget());\n    }\n    return vertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tHashSet<V> result=new HashSet<V>();\n\tIterator<E> iterator=this.edges.iterator();\n\twhile (iterator.hasNext()){\n\t\tE e=iterator.next();\n\t\tresult.add(e.getSource());\n\t\tresult.add(e.getTarget());\n\t}\n\treturn result;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor(E e : this.getEdges()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> visibleVertices=new HashSet<V>();\n\tfor(E e:getEdges()){\n\t\tvisibleVertices.add(getSourceVertex(e));\n\t\tvisibleVertices.add(getTargetVertex(e));\n\t}\n\treturn visibleVertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor(E edge : this.getEdges()){\n\t\tvertices.add(this.getSource(edge));\n\t\tvertices.add(this.getDest(edge));\n\t}\n\treturn vertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices = new HashSet<V>();\n\tfor (E e : edgeSet()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}", "private Set<V> initVisibleVertices(){\n\n\tSet<V> vertices=new HashSet<V>(edgeSet().size());\n\tfor(Edge<V,E> e:edgeSet()){\n\t\tvertices.add(e.getSource());\n\t\tvertices.add(e.getTarget());\n\t}\n\treturn vertices;\n}"], "code_level": "class_runnable", "_id": "6367674b1a6d9265ec017dc0", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(treePrev!=null)\n\t\ttreePrev.treeNext = treeNext;\n\tif(treeNext!=null)\n\t\ttreeNext.treePrev = treePrev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(treeNext!=null) treeNext.treePrev=treePrev;\n\tif(treePrev!=null) treePrev.treeNext=treeNext;\n\ttreeNext=null;\n\ttreePrev=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(prevTreeEdge!=null){\n\t\tprevTreeEdge.nextTreeEdge=nextTreeEdge;\n\t}else{\n\t\ttreeEdge=nextTreeEdge;\n\t}\n\tif(nextTreeEdge!=null){\n\t\tnextTreeEdge.prevTreeEdge=prevTreeEdge;\n\t}\n\tnextTreeEdge=null;\n\tprevTreeEdge=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(this.previousInTreeEdgeList==null&&this.nextInTreeEdgeList==null){\n\t\treturn;\n\t}\n\tif(this.previousInTreeEdgeList==null){\n\t\tthis.nextInTreeEdgeList.previousInTreeEdgeList=null;\n\t}\n\telse if(this.nextInTreeEdgeList==null){\n\t\tthis.previousInTreeEdgeList.nextInTreeEdgeList=null;\n\t}\n\telse{\n\t\tthis.previousInTreeEdgeList.nextInTreeEdgeList=this.nextInTreeEdgeList;\n\t\tthis.nextInTreeEdgeList.previousInTreeEdgeList=this.previousInTreeEdgeList;\n\t}\n\tthis.previousInTreeEdgeList=null;\n\tthis.nextInTreeEdgeList=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif (treePrev == null)\n\t\ttreeNext.treePrev = null;\n\telse\n\t\ttreePrev.treeNext = treeNext;\n\tif (treeNext == null)\n\t\ttreePrev.treeNext = null;\n\telse\n\t\ttreeNext.treePrev = treePrev;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\ttreeEdgeList.remove(this);\n\ttreeEdgeList.remove(this.reverseEdge);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\t//System.out.println(\"removing tree edge \"+this);\n\tif (prevTreeEdge!=null){\n\t\tprevTreeEdge.nextTreeEdge = nextTreeEdge;\n\t}\n\telse{\n\t\ttreeEdgeList.head = nextTreeEdge;\n\t}\n\tif (nextTreeEdge!=null){\n\t\tnextTreeEdge.prevTreeEdge = prevTreeEdge;\n\t}\n\telse {\n\t\ttreeEdgeList.tail = prevTreeEdge;\n\t}\n\tnextTreeEdge = null;\n\tprevTreeEdge = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(leftTreeEdge!=null){\n\t\tleftTreeEdge.rightTreeEdge=rightTreeEdge;\n\t}\n\tif(rightTreeEdge!=null){\n\t\trightTreeEdge.leftTreeEdge=leftTreeEdge;\n\t}\n\tleftTreeEdge=rightTreeEdge=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif(treeEdgePrevious!=null){treeEdgePrevious.treeEdgeNext=treeEdgeNext;}\n\tif(treeEdgeNext!=null){treeEdgeNext.treeEdgePrevious=treeEdgePrevious;}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeFromTreeEdgeList(){\n\n\tif (treeEdgePrev!=null && treeEdgeNext!=null){\n\t\ttreeEdgePrev.treeEdgeNext=treeEdgeNext;\n\t\ttreeEdgeNext.treeEdgePrev=treeEdgePrev;\n\t\ttreeEdgePrev=null;\n\t\ttreeEdgeNext=null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes this edge from both doubly linked lists of tree edges.\n */\n", "method_name": "removeFromTreeEdgeList", "codes": ["public void removeFromTreeEdgeList(){\n\n\tif(treePrev!=null)\n\t\ttreePrev.treeNext = treeNext;\n\tif(treeNext!=null)\n\t\ttreeNext.treePrev = treePrev;\n}", "public void removeFromTreeEdgeList(){\n\n\tif(treeNext!=null) treeNext.treePrev=treePrev;\n\tif(treePrev!=null) treePrev.treeNext=treeNext;\n\ttreeNext=null;\n\ttreePrev=null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif(prevTreeEdge!=null){\n\t\tprevTreeEdge.nextTreeEdge=nextTreeEdge;\n\t}else{\n\t\ttreeEdge=nextTreeEdge;\n\t}\n\tif(nextTreeEdge!=null){\n\t\tnextTreeEdge.prevTreeEdge=prevTreeEdge;\n\t}\n\tnextTreeEdge=null;\n\tprevTreeEdge=null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif(this.previousInTreeEdgeList==null&&this.nextInTreeEdgeList==null){\n\t\treturn;\n\t}\n\tif(this.previousInTreeEdgeList==null){\n\t\tthis.nextInTreeEdgeList.previousInTreeEdgeList=null;\n\t}\n\telse if(this.nextInTreeEdgeList==null){\n\t\tthis.previousInTreeEdgeList.nextInTreeEdgeList=null;\n\t}\n\telse{\n\t\tthis.previousInTreeEdgeList.nextInTreeEdgeList=this.nextInTreeEdgeList;\n\t\tthis.nextInTreeEdgeList.previousInTreeEdgeList=this.previousInTreeEdgeList;\n\t}\n\tthis.previousInTreeEdgeList=null;\n\tthis.nextInTreeEdgeList=null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif (treePrev == null)\n\t\ttreeNext.treePrev = null;\n\telse\n\t\ttreePrev.treeNext = treeNext;\n\tif (treeNext == null)\n\t\ttreePrev.treeNext = null;\n\telse\n\t\ttreeNext.treePrev = treePrev;\n}", "public void removeFromTreeEdgeList(){\n\n\ttreeEdgeList.remove(this);\n\ttreeEdgeList.remove(this.reverseEdge);\n}", "public void removeFromTreeEdgeList(){\n\n\t//System.out.println(\"removing tree edge \"+this);\n\tif (prevTreeEdge!=null){\n\t\tprevTreeEdge.nextTreeEdge = nextTreeEdge;\n\t}\n\telse{\n\t\ttreeEdgeList.head = nextTreeEdge;\n\t}\n\tif (nextTreeEdge!=null){\n\t\tnextTreeEdge.prevTreeEdge = prevTreeEdge;\n\t}\n\telse {\n\t\ttreeEdgeList.tail = prevTreeEdge;\n\t}\n\tnextTreeEdge = null;\n\tprevTreeEdge = null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif(leftTreeEdge!=null){\n\t\tleftTreeEdge.rightTreeEdge=rightTreeEdge;\n\t}\n\tif(rightTreeEdge!=null){\n\t\trightTreeEdge.leftTreeEdge=leftTreeEdge;\n\t}\n\tleftTreeEdge=rightTreeEdge=null;\n}", "public void removeFromTreeEdgeList(){\n\n\tif(treeEdgePrevious!=null){treeEdgePrevious.treeEdgeNext=treeEdgeNext;}\n\tif(treeEdgeNext!=null){treeEdgeNext.treeEdgePrevious=treeEdgePrevious;}\n}", "public void removeFromTreeEdgeList(){\n\n\tif (treeEdgePrev!=null && treeEdgeNext!=null){\n\t\ttreeEdgePrev.treeEdgeNext=treeEdgeNext;\n\t\ttreeEdgeNext.treeEdgePrev=treeEdgePrev;\n\t\ttreeEdgePrev=null;\n\t\ttreeEdgeNext=null;\n\t}\n}"], "code_level": "class_runnable", "_id": "6367675c1a6d9265ec01805b", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tList<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new ArrayList<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n\ttouchingEdges=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new ArrayList<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingVerticesEdgeSet==null){\n\t\ttouchingVerticesEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex, touchingVerticesEdgeSet);\n\t}\n\ttouchingVerticesEdgeSet.add(e);\n\ttouchingVerticesEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingVerticesEdgeSet==null){\n\t\ttouchingVerticesEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex, touchingVerticesEdgeSet);\n\t}\n\ttouchingVerticesEdgeSet.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tObjects.requireNonNull(sourceVertex);\n\tObjects.requireNonNull(targetVertex);\n\tObjects.requireNonNull(e);\n\tif(!containsVertex(sourceVertex)||!containsVertex(targetVertex)){\n\t\tthrow new IllegalArgumentException(\"Neither sourceVertex nor targetVertex is in the graph.\");\n\t}\n\tSet<E> edgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(edgeSet==null){\n\t\tedgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,edgeSet);\n\t}\n\tedgeSet.add(e);\n\tedgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(edgeSet==null){\n\t\tedgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,edgeSet);\n\t}\n\tedgeSet.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdgeSet==null){\n\t\ttouchingEdgeSet=new HashSet<>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdgeSet);\n\t}\n\ttouchingEdgeSet.add(e);\n\t\n\ttouchingEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdgeSet==null){\n\t\ttouchingEdgeSet=new HashSet<>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdgeSet);\n\t}\n\ttouchingEdgeSet.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n    Set<E> touchingEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n    if(touchingEdgeSet==null){\n        touchingEdgeSet=new HashSet<>();\n        touchingVerticesToEdgeMap.put(sourceVertex,touchingEdgeSet);\n    }\n    touchingEdgeSet.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesToEdgeSet=null;\n\tif(touchingVerticesToEdgeMap.containsKey(sourceVertex)){\n\t\ttouchingVerticesToEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\t}\n\telse{\n\t\ttouchingVerticesToEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex, touchingVerticesToEdgeSet);\n\t}\n\ttouchingVerticesToEdgeSet.add(e);\n\ttouchingVerticesToEdgeSet=null;\n\tif(touchingVerticesToEdgeMap.containsKey(targetVertex)){\n\t\ttouchingVerticesToEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\t}\n\telse{\n\t\ttouchingVerticesToEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex, touchingVerticesToEdgeSet);\n\t}\n\ttouchingVerticesToEdgeSet.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n\ttouchingEdges=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tif(e==null) throw new IllegalArgumentException(\"Edge cannot be null\");\n\tif(sourceVertex==null) throw new IllegalArgumentException(\"Source vertex cannot be null\");\n\tif(targetVertex==null) throw new IllegalArgumentException(\"Target vertex cannot be null\");\n\t//create a new mapping\n\tHashMap<V,E> targetVertexToEdgeMap=new HashMap<V,E>();\n\ttargetVertexToEdgeMap.put(targetVertex,e);\n\ttouchingVerticesToEdgeMap.put(sourceVertex,targetVertexToEdgeMap);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesToEdgeMap = lookup.get(sourceVertex);\n\tif(touchingVerticesToEdgeMap == null){\n\t\ttouchingVerticesToEdgeMap = new HashSet<E>();\n\t\tlookup.put(sourceVertex, touchingVerticesToEdgeMap);\n\t}\n\ttouchingVerticesToEdgeMap.add(e);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n", "method_name": "addToIndex", "codes": ["protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tList<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new ArrayList<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n\ttouchingEdges=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new ArrayList<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingVerticesEdgeSet==null){\n\t\ttouchingVerticesEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex, touchingVerticesEdgeSet);\n\t}\n\ttouchingVerticesEdgeSet.add(e);\n\ttouchingVerticesEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingVerticesEdgeSet==null){\n\t\ttouchingVerticesEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex, touchingVerticesEdgeSet);\n\t}\n\ttouchingVerticesEdgeSet.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tObjects.requireNonNull(sourceVertex);\n\tObjects.requireNonNull(targetVertex);\n\tObjects.requireNonNull(e);\n\tif(!containsVertex(sourceVertex)||!containsVertex(targetVertex)){\n\t\tthrow new IllegalArgumentException(\"Neither sourceVertex nor targetVertex is in the graph.\");\n\t}\n\tSet<E> edgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(edgeSet==null){\n\t\tedgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,edgeSet);\n\t}\n\tedgeSet.add(e);\n\tedgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(edgeSet==null){\n\t\tedgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,edgeSet);\n\t}\n\tedgeSet.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdgeSet==null){\n\t\ttouchingEdgeSet=new HashSet<>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdgeSet);\n\t}\n\ttouchingEdgeSet.add(e);\n\t\n\ttouchingEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdgeSet==null){\n\t\ttouchingEdgeSet=new HashSet<>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdgeSet);\n\t}\n\ttouchingEdgeSet.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n    Set<E> touchingEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n    if(touchingEdgeSet==null){\n        touchingEdgeSet=new HashSet<>();\n        touchingVerticesToEdgeMap.put(sourceVertex,touchingEdgeSet);\n    }\n    touchingEdgeSet.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesToEdgeSet=null;\n\tif(touchingVerticesToEdgeMap.containsKey(sourceVertex)){\n\t\ttouchingVerticesToEdgeSet=touchingVerticesToEdgeMap.get(sourceVertex);\n\t}\n\telse{\n\t\ttouchingVerticesToEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex, touchingVerticesToEdgeSet);\n\t}\n\ttouchingVerticesToEdgeSet.add(e);\n\ttouchingVerticesToEdgeSet=null;\n\tif(touchingVerticesToEdgeMap.containsKey(targetVertex)){\n\t\ttouchingVerticesToEdgeSet=touchingVerticesToEdgeMap.get(targetVertex);\n\t}\n\telse{\n\t\ttouchingVerticesToEdgeSet=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex, touchingVerticesToEdgeSet);\n\t}\n\ttouchingVerticesToEdgeSet.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingEdges=touchingVerticesToEdgeMap.get(sourceVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(sourceVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n\ttouchingEdges=touchingVerticesToEdgeMap.get(targetVertex);\n\tif(touchingEdges==null){\n\t\ttouchingEdges=new HashSet<E>();\n\t\ttouchingVerticesToEdgeMap.put(targetVertex,touchingEdges);\n\t}\n\ttouchingEdges.add(e);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tif(e==null) throw new IllegalArgumentException(\"Edge cannot be null\");\n\tif(sourceVertex==null) throw new IllegalArgumentException(\"Source vertex cannot be null\");\n\tif(targetVertex==null) throw new IllegalArgumentException(\"Target vertex cannot be null\");\n\t//create a new mapping\n\tHashMap<V,E> targetVertexToEdgeMap=new HashMap<V,E>();\n\ttargetVertexToEdgeMap.put(targetVertex,e);\n\ttouchingVerticesToEdgeMap.put(sourceVertex,targetVertexToEdgeMap);\n}", "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n\n\tSet<E> touchingVerticesToEdgeMap = lookup.get(sourceVertex);\n\tif(touchingVerticesToEdgeMap == null){\n\t\ttouchingVerticesToEdgeMap = new HashSet<E>();\n\t\tlookup.put(sourceVertex, touchingVerticesToEdgeMap);\n\t}\n\ttouchingVerticesToEdgeMap.add(e);\n}"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180fd", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tfloat w = box.width()/2;\n\tfloat h = box.height();\n\tfloat x1 = box.x();\n\tfloat x2 = box.x()+w;\n\tfloat y = box.y();\n\tBox2D box1 = Box2D.atPoint(x1,y,w,h);\n\tBox2D box2 = Box2D.atPoint(x2,y,w,h);\n\treturn new Pair<Box2D,Box2D>(box1,box2);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\treturn splitAlongXAxis(box,0.5);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble w = box.getWidth();\n\tdouble h = box.getHeight();\n\tdouble x = box.getMinX();\n\tdouble y = box.getMinY();\n\tBox2D b1 = new Box2D(x,y,w/2,h);\n\tBox2D b2 = new Box2D(x+w/2,y,w/2,h);\n\treturn new Pair<Box2D,Box2D>(b1,b2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tPair<Box2D,Box2D> p=new Pair<Box2D,Box2D>(\n\t\tnew Box2D(box.xmin(),box.xmax(),box.ymin(),box.ymid()),\n\t\tnew Box2D(box.xmin(),box.xmax(),box.ymid(),box.ymax())\n\t);\n\treturn p;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\t\treturn new Pair<Box2D,Box2D>(new Box2D(box.getX(),box.getY(),box.getWidth()/2,box.getHeight()),new Box2D((box.getX()+box.getWidth()/2),box.getY(),box.getWidth()/2,box.getHeight()));\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble xMin=box.getXMin();\n\tdouble xMax=box.getXMax();\n\tdouble yMin=box.getYMin();\n\tdouble yMax=box.getYMax();\n\tdouble xMid=(xMin+xMax)/2;\n\treturn new Pair<Box2D,Box2D>(\n\t\tnew Box2D(xMin,yMin,xMid,yMax),\n\t\tnew Box2D(xMid,yMin,xMax,yMax)\n\t);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tBox2D left = new Box2D(box.getMinX(),box.getMinY(),box.getMaxX()-0.5*box.getWidth(),box.getMaxY());\n\tBox2D right = new Box2D(box.getMinX()+0.5*box.getWidth(),box.getMinY(),box.getMaxX(),box.getMaxY());\n\treturn new Pair<Box2D,Box2D>(left,right);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble width=box.getWidth();\n\tdouble height=box.getHeight();\n\tdouble x1=box.getMinX();\n\tdouble y1=box.getMinY();\n\tdouble x2=box.getMaxX();\n\tdouble y2=box.getMaxY();\n\tdouble midx=(x1+x2)/2;\n\tBox2D box1=new Box2D(x1,y1,midx,y2);\n\tBox2D box2=new Box2D(midx,y1,x2,y2);\n\treturn new Pair<Box2D,Box2D>(box1,box2);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\t\treturn splitAlongXAxis(box, 0.5);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\treturn splitAlongXAxis(box,box.getCenter().getX());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n", "method_name": "splitAlongXAxis", "codes": ["public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tfloat w = box.width()/2;\n\tfloat h = box.height();\n\tfloat x1 = box.x();\n\tfloat x2 = box.x()+w;\n\tfloat y = box.y();\n\tBox2D box1 = Box2D.atPoint(x1,y,w,h);\n\tBox2D box2 = Box2D.atPoint(x2,y,w,h);\n\treturn new Pair<Box2D,Box2D>(box1,box2);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\treturn splitAlongXAxis(box,0.5);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble w = box.getWidth();\n\tdouble h = box.getHeight();\n\tdouble x = box.getMinX();\n\tdouble y = box.getMinY();\n\tBox2D b1 = new Box2D(x,y,w/2,h);\n\tBox2D b2 = new Box2D(x+w/2,y,w/2,h);\n\treturn new Pair<Box2D,Box2D>(b1,b2);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tPair<Box2D,Box2D> p=new Pair<Box2D,Box2D>(\n\t\tnew Box2D(box.xmin(),box.xmax(),box.ymin(),box.ymid()),\n\t\tnew Box2D(box.xmin(),box.xmax(),box.ymid(),box.ymax())\n\t);\n\treturn p;\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\t\treturn new Pair<Box2D,Box2D>(new Box2D(box.getX(),box.getY(),box.getWidth()/2,box.getHeight()),new Box2D((box.getX()+box.getWidth()/2),box.getY(),box.getWidth()/2,box.getHeight()));\n\t}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble xMin=box.getXMin();\n\tdouble xMax=box.getXMax();\n\tdouble yMin=box.getYMin();\n\tdouble yMax=box.getYMax();\n\tdouble xMid=(xMin+xMax)/2;\n\treturn new Pair<Box2D,Box2D>(\n\t\tnew Box2D(xMin,yMin,xMid,yMax),\n\t\tnew Box2D(xMid,yMin,xMax,yMax)\n\t);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tBox2D left = new Box2D(box.getMinX(),box.getMinY(),box.getMaxX()-0.5*box.getWidth(),box.getMaxY());\n\tBox2D right = new Box2D(box.getMinX()+0.5*box.getWidth(),box.getMinY(),box.getMaxX(),box.getMaxY());\n\treturn new Pair<Box2D,Box2D>(left,right);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\tdouble width=box.getWidth();\n\tdouble height=box.getHeight();\n\tdouble x1=box.getMinX();\n\tdouble y1=box.getMinY();\n\tdouble x2=box.getMaxX();\n\tdouble y2=box.getMaxY();\n\tdouble midx=(x1+x2)/2;\n\tBox2D box1=new Box2D(x1,y1,midx,y2);\n\tBox2D box2=new Box2D(midx,y1,x2,y2);\n\treturn new Pair<Box2D,Box2D>(box1,box2);\n}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\t\treturn splitAlongXAxis(box, 0.5);\n\t}", "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n\n\treturn splitAlongXAxis(box,box.getCenter().getX());\n}"], "code_level": "project_runnable", "_id": "636767521a6d9265ec017ecc", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n    if(p1==null||p2==null)return false;\n    return TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n    if(p1==null||p2==null){\n        throw new IllegalArgumentException(\"points cannot be null\");\n    }else{\n        return TOLERANCE_DOUBLE_COMPARATOR.compare(p1.x,p2.x)==0&&TOLERANCE_DOUBLE_COMPARATOR.compare(p1.y,p2.y)==0;\n    }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\tif(p1==p2){\n\t\treturn true;\n\t}\n\tif(p1==null||p2==null){\n\t\treturn false;\n\t}\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX()) && TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.X,p2.X)&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.Y,p2.Y);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\nreturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.x,p2.x)&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.y,p2.y);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.coordinates[0],p2.coordinates[0])&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.coordinates[1],p2.coordinates[1]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n", "method_name": "equals", "codes": ["public static boolean equals(Point2D p1,Point2D p2){\n\n    if(p1==null||p2==null)return false;\n    return TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n    if(p1==null||p2==null){\n        throw new IllegalArgumentException(\"points cannot be null\");\n    }else{\n        return TOLERANCE_DOUBLE_COMPARATOR.compare(p1.x,p2.x)==0&&TOLERANCE_DOUBLE_COMPARATOR.compare(p1.y,p2.y)==0;\n    }\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\tif(p1==p2){\n\t\treturn true;\n\t}\n\tif(p1==null||p2==null){\n\t\treturn false;\n\t}\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX()) && TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.X,p2.X)&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.Y,p2.Y);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getX(),p2.getX())&&TOLERANCE_DOUBLE_COMPARATOR.equals(p1.getY(),p2.getY());\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\nreturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.x,p2.x)&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.y,p2.y);\n}", "public static boolean equals(Point2D p1,Point2D p2){\n\n\treturn TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.coordinates[0],p2.coordinates[0])&&TOLERANCE_DOUBLE_COMPARATOR.EQ(p1.coordinates[1],p2.coordinates[1]);\n}"], "code_level": "project_runnable", "_id": "636767531a6d9265ec017ef1", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon) return 0;\n\treturn Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1, o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\t\treturn Math.abs(o1-o2)<epsilon?0:Double.compare(o1,o2);\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\t\tif(o1==o2) return 0;\n\t\tif(Math.abs(o1-o2)<epsilon) return 0;\n\t\treturn Double.compare(o1,o2);\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tdouble d=o1-o2;\n\tif(d<epsilon&&d>-epsilon)return 0;\n\treturn Double.compare(o1,o2);\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null){\n\t\tif(o2==null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif(o2==null){\n\t\treturn -1;\n\t}\n\tif(Math.abs(o1-o2)<epsilon){\n\t\treturn 0;\n\t}\n\treturn Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null) return o2==null?0:-1;\n\tif(o2==null) return 1;\n\treturn Double.compare(Math.abs(o1-o2),epsilon)<0?0:Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null) return o2==null ? 0 : -1;\n\tif(o2==null) return 1;\n\tif(o1.doubleValue()==o2.doubleValue()) return 0;\n\tif(Math.abs(o1-o2)<epsilon) return 0;\n\treturn Double.compare(o1,o2);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares two floating point values. Returns 0 if they are equal, -1 if  {@literal o1 < o2}, 1 otherwise\n * @param o1 the first value\n * @param o2 the second value\n * @return 0 if they are equal, -1 if {@literal o1 < o2}, 1 otherwise\n */\n", "method_name": "compare", "codes": ["@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon) return 0;\n\treturn Double.compare(o1,o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1,o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1, o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\tif(Math.abs(o1-o2)<epsilon)return 0;\n\treturn Double.compare(o1,o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\t\treturn Math.abs(o1-o2)<epsilon?0:Double.compare(o1,o2);\n\t}", "@Override public int compare(Double o1,Double o2){\n\n\t\tif(o1==o2) return 0;\n\t\tif(Math.abs(o1-o2)<epsilon) return 0;\n\t\treturn Double.compare(o1,o2);\n\t}", "@Override public int compare(Double o1,Double o2){\n\n\tdouble d=o1-o2;\n\tif(d<epsilon&&d>-epsilon)return 0;\n\treturn Double.compare(o1,o2);\n\t}", "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null){\n\t\tif(o2==null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif(o2==null){\n\t\treturn -1;\n\t}\n\tif(Math.abs(o1-o2)<epsilon){\n\t\treturn 0;\n\t}\n\treturn Double.compare(o1,o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null) return o2==null?0:-1;\n\tif(o2==null) return 1;\n\treturn Double.compare(Math.abs(o1-o2),epsilon)<0?0:Double.compare(o1,o2);\n}", "@Override public int compare(Double o1,Double o2){\n\n\tif(o1==null) return o2==null ? 0 : -1;\n\tif(o2==null) return 1;\n\tif(o1.doubleValue()==o2.doubleValue()) return 0;\n\tif(Math.abs(o1-o2)<epsilon) return 0;\n\treturn Double.compare(o1,o2);\n}"], "code_level": "slib_runnable", "_id": "6367674a1a6d9265ec017dab", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public String toString(){\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    if(this.size != 0){\n        for(int i = 0; i < this.size - 1; i++){\n            sb.append(this.arr[i]);\n            sb.append(\", \");\n        }\n        sb.append(this.arr[this.size - 1]);\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\ntry{\nStringBuilder sb = new StringBuilder(\"\");\n\t\tint i = 0;\n\t\twhile(i < vs.length){\n\t\t\tsb.append(vs[i].toString());\n\t\t\ti = i + 1;\n\t\t}\n\t\treturn sb.toString();\n}catch(Exception e){\nreturn \"\";\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n  return \"[\"+vs+\"]\";\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String toString(){\n\n    String value = \"\";\n    for(int i = 0; i &lt; vs.length; i++){\n        for(int j = 0; j &lt; vs[i].length; j++){\n            value += vs[i][j].toString() + \",\";\n        }\n    }\n    return value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\nif(!isArray)\n\treturn value;\n\nStringBuilder sb = new StringBuilder();\nfor(int i=0;i<value.length();i++){\n\tchar c = value.charAt(i);\n\tif(c=='&'){\n\t\tsb.append(\"&amp;\");\n\t}else if(c=='<'){\n\t\tsb.append(\"&lt;\");\n\t}else if(c=='>'){\n\t\tsb.append(\"&gt;\");\n\t}else if(c=='\"'){\n\t\tsb.append(\"&quot;\");\n\t}else if(c=='\\''){\n\t\tsb.append(\"&apos;\");\n\t}else{\n\t\tsb.append(c);\n\t}\n}\nreturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\treturn String.valueOf(get(0));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<vs.length;i++){\n\t\tsb.append(vs[i]+\" \");\n\t}\n\treturn sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String toString(){\n\nreturn \"\"+value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\tif(value != null)\n\t\treturn value.toString();\n\telse\n\t\treturn \"\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String toString(){\n\n\tif(isNull(value))return \"\";\n\tif(isArray(value)){\n\t\tString s=\"\";\n\t\tint n=arrayLen(value);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i>0)s+=\",\";\n\t\t\ts+=new VarString(arrayGet(value,i)).toString();\n\t\t}\n\t\treturn s;\n\t}\n\treturn new String(value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns a textual representation of the queue.\n * @return a textual representation of the queue.\n */\n", "method_name": "toString", "codes": ["public String toString(){\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    if(this.size != 0){\n        for(int i = 0; i < this.size - 1; i++){\n            sb.append(this.arr[i]);\n            sb.append(\", \");\n        }\n        sb.append(this.arr[this.size - 1]);\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}", "public String toString(){\n\ntry{\nStringBuilder sb = new StringBuilder(\"\");\n\t\tint i = 0;\n\t\twhile(i < vs.length){\n\t\t\tsb.append(vs[i].toString());\n\t\t\ti = i + 1;\n\t\t}\n\t\treturn sb.toString();\n}catch(Exception e){\nreturn \"\";\n}\n}", "public String toString(){\n\n  return \"[\"+vs+\"]\";\n}", "public String toString(){\n\n    String value = \"\";\n    for(int i = 0; i &lt; vs.length; i++){\n        for(int j = 0; j &lt; vs[i].length; j++){\n            value += vs[i][j].toString() + \",\";\n        }\n    }\n    return value;\n}", "public String toString(){\n\nif(!isArray)\n\treturn value;\n\nStringBuilder sb = new StringBuilder();\nfor(int i=0;i<value.length();i++){\n\tchar c = value.charAt(i);\n\tif(c=='&'){\n\t\tsb.append(\"&amp;\");\n\t}else if(c=='<'){\n\t\tsb.append(\"&lt;\");\n\t}else if(c=='>'){\n\t\tsb.append(\"&gt;\");\n\t}else if(c=='\"'){\n\t\tsb.append(\"&quot;\");\n\t}else if(c=='\\''){\n\t\tsb.append(\"&apos;\");\n\t}else{\n\t\tsb.append(c);\n\t}\n}\nreturn sb.toString();\n}", "public String toString(){\n\n\treturn String.valueOf(get(0));\n}", "public String toString(){\n\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<vs.length;i++){\n\t\tsb.append(vs[i]+\" \");\n\t}\n\treturn sb.toString();\n}", "public String toString(){\n\nreturn \"\"+value;\n}", "public String toString(){\n\n\tif(value != null)\n\t\treturn value.toString();\n\telse\n\t\treturn \"\";\n}", "public String toString(){\n\n\tif(isNull(value))return \"\";\n\tif(isArray(value)){\n\t\tString s=\"\";\n\t\tint n=arrayLen(value);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i>0)s+=\",\";\n\t\t\ts+=new VarString(arrayGet(value,i)).toString();\n\t\t}\n\t\treturn s;\n\t}\n\treturn new String(value);\n}"], "code_level": "class_runnable", "_id": "6367674f1a6d9265ec017e74", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private int computeBinaryLog(int n){\n\n\tint pos = 0;\n\tif (n >= 65536){ pos += 16; n >>= 16; }\n\tif (n >= 256){ pos += 8; n >>= 8; }\n\tif (n >= 16){ pos += 4; n >>= 4; }\n\tif (n >= 4){ pos += 2; n >>= 2; }\n\tif (n >= 2){ pos += 1; }\n\treturn ((n == 0) ? (-1) : pos);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n\t//if(n==0) return -1;\n\tif(n<=0) throw new IllegalArgumentException(String.valueOf(n));\n\treturn 31 - Integer.numberOfLeadingZeros(n);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n\tint result = 0;\n\twhile(n > 0)\n\t{\n\t\tn = n >> 1;\n\t\tresult++;\n\t}\n\treturn result - 1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n\tint result = 0;\n\twhile(n != 0){\n\t\tn = n >>> 1;\n\t\tresult++;\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n){\n\n    return (int)(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n\tint log = 0;\n\twhile((n = n>>>1)!=0){\n\t\tlog++;\n\t}\n\treturn log;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n    return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n    int log = 0;\n    if (n == 0 || n == 1)\n        return log;\n    for (int i = n; i >= 1; i = i / 2)\n        log++;\n    return log;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private int computeBinaryLog(int n){\n\n\tint x = 0;\n\twhile((n = n >> 1) > 0){\n\t\tx++;\n\t}\n\treturn x;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private int computeBinaryLog(int n){\n\n    int result = 0;\n    while (n > 1){\n        n >>= 1;\n        result++;\n    }\n    return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes floor($\\log_2 (n)$) $+ 1$\n */\n", "method_name": "computeBinaryLog", "codes": ["private int computeBinaryLog(int n){\n\n\tint pos = 0;\n\tif (n >= 65536){ pos += 16; n >>= 16; }\n\tif (n >= 256){ pos += 8; n >>= 8; }\n\tif (n >= 16){ pos += 4; n >>= 4; }\n\tif (n >= 4){ pos += 2; n >>= 2; }\n\tif (n >= 2){ pos += 1; }\n\treturn ((n == 0) ? (-1) : pos);\n}", "private int computeBinaryLog(int n){\n\n\t//if(n==0) return -1;\n\tif(n<=0) throw new IllegalArgumentException(String.valueOf(n));\n\treturn 31 - Integer.numberOfLeadingZeros(n);\n}", "private int computeBinaryLog(int n){\n\n\tint result = 0;\n\twhile(n > 0)\n\t{\n\t\tn = n >> 1;\n\t\tresult++;\n\t}\n\treturn result - 1;\n}", "private int computeBinaryLog(int n){\n\n\tint result = 0;\n\twhile(n != 0){\n\t\tn = n >>> 1;\n\t\tresult++;\n\t}\n\treturn result;\n}", "private int computeBinaryLog(int n){\n\n    return (int)(Math.log(n) / Math.log(2));\n}", "private int computeBinaryLog(int n){\n\n\tint log = 0;\n\twhile((n = n>>>1)!=0){\n\t\tlog++;\n\t}\n\treturn log;\n}", "private int computeBinaryLog(int n){\n\n    return (int) Math.floor(Math.log(n) / Math.log(2));\n}", "private int computeBinaryLog(int n){\n\n    int log = 0;\n    if (n == 0 || n == 1)\n        return log;\n    for (int i = n; i >= 1; i = i / 2)\n        log++;\n    return log;\n}", "private int computeBinaryLog(int n){\n\n\tint x = 0;\n\twhile((n = n >> 1) > 0){\n\t\tx++;\n\t}\n\treturn x;\n}", "private int computeBinaryLog(int n){\n\n    int result = 0;\n    while (n > 1){\n        n >>= 1;\n        result++;\n    }\n    return result;\n}"], "code_level": "self_contained", "_id": "636767431a6d9265ec017c8d", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public double vertexWeight(Set<V> v){\n\n\t\n\tdouble sum=0;\n\t\n\tfor (E e: graph.incomingEdgesOf(v))\n\t{\n\t\tsum+= e.getWeight();\n\t}\n\treturn sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble sum=0;\n\tfor(V vertex:v){\n\t\tsum+=vertex.weight;\n\t}\n\treturn sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\treturn this.weight(v,this.predecessors(v));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble totalWeight = 0.0;\n\tfor (E edge: edgeList)\n\t\tif (edge.getSourceVertex().equals(v))\n\t\t\ttotalWeight += edge.getWeight();\n\t\treturn totalWeight;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble s = 0.0;\n\tfor(V v1 : v){\n\t\tfor(V v2 : v){\n\t\t\ts += edgeWeight(v1,v2);\n\t\t}\n\t}\n\treturn s;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble w =0;\n\tfor(V v2 : v){\n\t\tw+=this.get(v2);\n\t}\n\treturn w;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble weight=0;\n\tfor(V e:v){\n\t\tweight+=graph.getEdgeWeight(e);\n\t}\n\treturn weight;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble sum = 0;\n\tfor (V vertex : v){\n\t\tsum += vertexWeight(vertex);\n\t}\n\treturn sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble weight = 0.0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tweight += vertexWeight(v);\n\t}\n\treturn weight;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public double vertexWeight(Set<V> v){\n\n\tdouble sum=0;\n\tfor(E e:incomingEdges(v)){\n\t\tsum=sum+e.getWeight();\n\t}\n\treturn sum;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n", "method_name": "vertexWeight", "codes": ["public double vertexWeight(Set<V> v){\n\n\t\n\tdouble sum=0;\n\t\n\tfor (E e: graph.incomingEdgesOf(v))\n\t{\n\t\tsum+= e.getWeight();\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble sum=0;\n\tfor(V vertex:v){\n\t\tsum+=vertex.weight;\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\n\treturn this.weight(v,this.predecessors(v));\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble totalWeight = 0.0;\n\tfor (E edge: edgeList)\n\t\tif (edge.getSourceVertex().equals(v))\n\t\t\ttotalWeight += edge.getWeight();\n\t\treturn totalWeight;\n\t}", "public double vertexWeight(Set<V> v){\n\n\tdouble s = 0.0;\n\tfor(V v1 : v){\n\t\tfor(V v2 : v){\n\t\t\ts += edgeWeight(v1,v2);\n\t\t}\n\t}\n\treturn s;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble w =0;\n\tfor(V v2 : v){\n\t\tw+=this.get(v2);\n\t}\n\treturn w;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble weight=0;\n\tfor(V e:v){\n\t\tweight+=graph.getEdgeWeight(e);\n\t}\n\treturn weight;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble sum = 0;\n\tfor (V vertex : v){\n\t\tsum += vertexWeight(vertex);\n\t}\n\treturn sum;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble weight = 0.0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tweight += vertexWeight(v);\n\t}\n\treturn weight;\n}", "public double vertexWeight(Set<V> v){\n\n\tdouble sum=0;\n\tfor(E e:incomingEdges(v)){\n\t\tsum=sum+e.getWeight();\n\t}\n\treturn sum;\n}"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018106", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> inter=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v))\n\t\t\tinter.add(v);\n\t}\n\treturn inter;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n    Set<V> intersect=new HashSet<V>();\n    for(V v:set1){\n        if(set2.contains(v)){\n            intersect.add(v);\n        }\n    }\n    return intersect;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersectionSet=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersectionSet.add(v);\n\t\t}\n\t}\n\treturn intersectionSet;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n    Set<V> result = new HashSet<>();\n    for(V v:set1){\n        if(set2.contains(v)){\n            result.add(v);\n        }\n    }\n    return result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> auxSet=new HashSet<V>();\n\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tauxSet.add(v);\n\t\t}\n\t}\n\n\treturn auxSet;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersection=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersection.add(v);\n\t\t}\n\t}\n\treturn intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\t\tSet<V> result=new HashSet<V>();\n\t\tfor(V v:set1){\n\t\t\tif(set2.contains(v)){\n\t\t\t\tresult.add(v);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersection=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersection.add(v);\n\t\t}\n\t}\n\treturn intersection;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n", "method_name": "intersection", "codes": ["private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> inter=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v))\n\t\t\tinter.add(v);\n\t}\n\treturn inter;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n    Set<V> intersect=new HashSet<V>();\n    for(V v:set1){\n        if(set2.contains(v)){\n            intersect.add(v);\n        }\n    }\n    return intersect;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersectionSet=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersectionSet.add(v);\n\t\t}\n\t}\n\treturn intersectionSet;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n    Set<V> result = new HashSet<>();\n    for(V v:set1){\n        if(set2.contains(v)){\n            result.add(v);\n        }\n    }\n    return result;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> auxSet=new HashSet<V>();\n\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tauxSet.add(v);\n\t\t}\n\t}\n\n\treturn auxSet;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersection=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersection.add(v);\n\t\t}\n\t}\n\treturn intersection;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\t\tSet<V> result=new HashSet<V>();\n\t\tfor(V v:set1){\n\t\t\tif(set2.contains(v)){\n\t\t\t\tresult.add(v);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> result=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tresult.add(v);\n\t\t}\n\t}\n\treturn result;\n}", "private Set<V> intersection(Set<V> set1,Set<V> set2){\n\n\tSet<V> intersection=new HashSet<V>();\n\tfor(V v:set1){\n\t\tif(set2.contains(v)){\n\t\t\tintersection.add(v);\n\t\t}\n\t}\n\treturn intersection;\n}"], "code_level": "slib_runnable", "_id": "636767611a6d9265ec018116", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n    OuterFaceCirculator circ=new OuterFaceCirculator(this,start,stop,dir);\n    while(!predicate.test(circ.node)){\n        circ.next();\n    }\n    return circ;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator result=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(result.node())){result.next();}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tif(!hasNode(stop)){\n\t\tthrow new IllegalArgumentException(\"Cannot start from a node not in the graph.\");\n\t}\n\tif(!hasNode(start)){\n\t\tthrow new IllegalArgumentException(\"Cannot stop at a node not in the graph.\");\n\t}\n\tif(start==stop){\n\t\tthrow new IllegalArgumentException(\"Start and stop nodes cannot be the same.\");\n\t}\n\tif(!hasEdge(start,stop)){\n\t\tthrow new IllegalArgumentException(\"Start and stop nodes must be connected.\");\n\t}\n\treturn new OuterFaceCirculator(predicate,start,stop,dir);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tNode n = start;\n\tdo{\n\t\tif(predicate.test(n)){\n\t\t\treturn new OuterFaceCirculator(n,dir);\n\t\t}\n\t\tn = n.getNext(dir);\n\t}while(n != stop);\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(this,start);\n\twhile(!circulator.isDone()){\n\t\tif(circulator.node()==stop)return null;\n\t\tif(predicate.test(circulator.node()))return circulator;\n\t\tcirculator.next(dir);\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(start,dir);\n\twhile(circulator.hasNext()){\n\t\tNode node=circulator.next();\n\t\tif(predicate.test(node))return circulator;\n\t\tif(node==stop)break;\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\t\treturn new OuterFaceCirculator(this,start,stop,dir,predicate);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(circulator.current())){\n\t\tcirculator.next();\n\t}\n\treturn circulator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tif(!predicate.test(start))\n\t\tthrow new IllegalArgumentException(\"The start node does not satisfy the predicate\");\n\tif(!predicate.test(stop))\n\t\tthrow new IllegalArgumentException(\"The stop node does not satisfy the predicate\");\n\tOuterFaceCirculator circ=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(circ.getNode()))\n\t\tcirc.increment();\n\treturn circ;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator = getOuterFaceCirculator(start);\n\tcirculator.setDir(dir);\n\tcirculator.setStop(stop);\n\twhile(!predicate.test(circulator.current())){\n\t\tcirculator.next();\n\t}\n\treturn circulator;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n", "method_name": "selectOnOuterFace", "codes": ["private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n    OuterFaceCirculator circ=new OuterFaceCirculator(this,start,stop,dir);\n    while(!predicate.test(circ.node)){\n        circ.next();\n    }\n    return circ;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator result=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(result.node())){result.next();}\n\treturn result;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tif(!hasNode(stop)){\n\t\tthrow new IllegalArgumentException(\"Cannot start from a node not in the graph.\");\n\t}\n\tif(!hasNode(start)){\n\t\tthrow new IllegalArgumentException(\"Cannot stop at a node not in the graph.\");\n\t}\n\tif(start==stop){\n\t\tthrow new IllegalArgumentException(\"Start and stop nodes cannot be the same.\");\n\t}\n\tif(!hasEdge(start,stop)){\n\t\tthrow new IllegalArgumentException(\"Start and stop nodes must be connected.\");\n\t}\n\treturn new OuterFaceCirculator(predicate,start,stop,dir);\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tNode n = start;\n\tdo{\n\t\tif(predicate.test(n)){\n\t\t\treturn new OuterFaceCirculator(n,dir);\n\t\t}\n\t\tn = n.getNext(dir);\n\t}while(n != stop);\n\treturn null;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(this,start);\n\twhile(!circulator.isDone()){\n\t\tif(circulator.node()==stop)return null;\n\t\tif(predicate.test(circulator.node()))return circulator;\n\t\tcirculator.next(dir);\n\t}\n\treturn null;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(start,dir);\n\twhile(circulator.hasNext()){\n\t\tNode node=circulator.next();\n\t\tif(predicate.test(node))return circulator;\n\t\tif(node==stop)break;\n\t}\n\treturn null;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\t\treturn new OuterFaceCirculator(this,start,stop,dir,predicate);\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(circulator.current())){\n\t\tcirculator.next();\n\t}\n\treturn circulator;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tif(!predicate.test(start))\n\t\tthrow new IllegalArgumentException(\"The start node does not satisfy the predicate\");\n\tif(!predicate.test(stop))\n\t\tthrow new IllegalArgumentException(\"The stop node does not satisfy the predicate\");\n\tOuterFaceCirculator circ=new OuterFaceCirculator(start,stop,dir);\n\twhile(!predicate.test(circ.getNode()))\n\t\tcirc.increment();\n\treturn circ;\n}", "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n\n\tOuterFaceCirculator circulator = getOuterFaceCirculator(start);\n\tcirculator.setDir(dir);\n\tcirculator.setStop(stop);\n\twhile(!predicate.test(circulator.current())){\n\t\tcirculator.next();\n\t}\n\treturn circulator;\n}"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb6", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "Edge edgeToNext(){\n\n    int n = edgeTo.size();\n    return edgeTo[n-2];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n return Edge(tree[next[current]].parent, current);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n\tEdge e;\n\te.source=prev;\n\te.destination=curr;\n\treturn e;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n\treturn edgeToNextNode;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n\treturn edgeToNext(false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n  return edges[pos];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n\tEdge e = new Edge(prevNode,currNode);\n\treturn e;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\nreturn e;}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n    if (prevNode == currNode){\n        return null;\n    }\n    return prevNode.getEdge(currNode);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "Edge edgeToNext(){\n\n\treturn e;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n", "method_name": "edgeToNext", "codes": ["Edge edgeToNext(){\n\n    int n = edgeTo.size();\n    return edgeTo[n-2];\n}", "Edge edgeToNext(){\n return Edge(tree[next[current]].parent, current);}", "Edge edgeToNext(){\n\n\tEdge e;\n\te.source=prev;\n\te.destination=curr;\n\treturn e;\n}", "Edge edgeToNext(){\n\n\treturn edgeToNextNode;\n}", "Edge edgeToNext(){\n\n\treturn edgeToNext(false);\n}", "Edge edgeToNext(){\n\n  return edges[pos];\n}", "Edge edgeToNext(){\n\n\tEdge e = new Edge(prevNode,currNode);\n\treturn e;\n}", "Edge edgeToNext(){\nreturn e;}", "Edge edgeToNext(){\n\n    if (prevNode == currNode){\n        return null;\n    }\n    return prevNode.getEdge(currNode);\n}", "Edge edgeToNext(){\n\n\treturn e;\n}"], "code_level": "class_runnable", "_id": "6367675d1a6d9265ec018082", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=null;\n\tif(tour!=null){\n\t\tList<E> tourList=new ArrayList<E>(tour);\n\t\tV startVertex=graph.getEdgeSource(tourList.get(0));\n\t\tV endVertex=graph.getEdgeTarget(tourList.get(tourList.size()-1));\n\t\tGraphWalk<V,E> walk=new GraphWalk<V,E>(graph,startVertex,endVertex,tourList,tour.size());\n\t\tpath=new GraphPathImpl<V,E>(walk,0);\n\t}\n\treturn path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<E> tourList=new ArrayList<E>(tour);\n\t//return new GraphWalk<V,E>(graph,tourList.get(0).getSource(),tourList.get(tourList.size()-1).getTarget(),tourList,tourList.stream().mapToDouble(e->graph.getEdgeWeight(e)).sum());\n\treturn new GraphWalk<V,E>(graph,tourList.get(0).getSource(),tourList.get(tourList.size()-1).getTarget(),tourList,tourList.stream().mapToDouble(e->graph.getEdgeWeight(e)).sum());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<E> edgeList=new ArrayList<>(tour.size());\n\tV v=graph.vertexSet().iterator().next();\n\tV last=v;\n\twhile(!tour.isEmpty()){\n\t\tE e=null;\n\t\tfor(E edge:graph.edgesOf(v)){\n\t\t\tif(tour.remove(edge)){\n\t\t\t\te=edge;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(e==null){\n\t\t\tthrow new IllegalArgumentException(\"Tour is not a tour\");\n\t\t}\n\t\tedgeList.add(e);\n\t\tlast=v;\n\t\tv=Graphs.getOppositeVertex(graph,e,v);\n\t}\n\tif(!last.equals(v)){\n\t\tthrow new IllegalArgumentException(\"Tour is not a tour\");\n\t}\n\treturn new GraphWalk<>(graph,v,v,null,edgeList,tour.size());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=new GraphPathImpl<V,E>(graph,null,null,0);\n\tV prev=null;\n\tE prevEdge=null;\n\tdouble weight=0;\n\tfor(E e:tour){\n\t\tV u=graph.getEdgeSource(e);\n\t\tV v=graph.getEdgeTarget(e);\n\t\tif(prev==null){\n\t\t\tprev=u;\n\t\t}else if(prev.equals(v)){\n\t\t\tprev=v;\n\t\t\tprevEdge=e;\n\t\t\tpath=new GraphWalk<V,E>(graph,u,v,null,weight);\n\t\t\tweight+=graph.getEdgeWeight(e);\n\t\t}else if(prev.equals(u)){\n\t\t\tprev=u;\n\t\t\tprevEdge=e;\n\t\t\tpath=new GraphWalk<V,E>(graph,v,u,null,weight);\n\t\t\tweight+=graph.getEdgeWeight(e);\n\t\t}\n\t}\n\tpath=", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tV start=graph.getEdgeSource(tour.iterator().next());\n\treturn new GraphWalk<V,E>(graph,start,start,tour,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n    GraphPath<V,E> graphPath=null;\n    boolean isDirected=graph.getType().isDirected();\n    Graph<V,E> g=graph;\n    if(!isDirected){\n        g=new AsSubgraph<V,E>(graph,null,null);\n    }\n    GraphWalk<V,E> walk=new GraphWalk<>(g,null,null,null,0);\n    walk.setEdgeList(new ArrayList<>(tour));\n    graphPath=new GraphWalk<>(g,walk.getStartVertex(),walk.getEndVertex(),walk,walk.getWeight());\n    return graphPath;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<V> vertices=new ArrayList<V>();\n\tList<E> edges=new ArrayList<E>();\n\tV vPrev=null;\n\tV vNext=null;\n\tfor(E edge:tour){\n\t\tV[] vs=Graphs.getIncidentVertices(graph,edge);\n\t\tif(vPrev==null){\n\t\t\tvPrev=vs[0];\n\t\t\tvNext=vs[1];\n\t\t\tvertices.add(vPrev);\n\t\t\tvertices.add(vNext);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[0]==vPrev){\n\t\t\tvPrev=vs[1];\n\t\t\tvertices.add(vPrev);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[1]==vPrev){\n\t\t\tvPrev=vs[0];\n\t\t\tvertices.add(vPrev);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[0]==vNext", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=null;\n\tif(tour!=null&&tour.size()>0){\n\t\tGraphWalk<V,E> walk=new GraphWalk<>(graph,null,null,new ArrayList<>(tour),0);\n\t\tpath=new GraphWalk<>(graph,null,null,walk.getVertexList(),walk.getWeight());\n\t}\n\treturn path;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n    GraphPath<V,E> graphPath=null;\n    if(tour.size()>0){\n        graphPath=new GraphWalk<V,E>(\n            graph,\n            null,\n            null,\n            null,\n            new LinkedList<E>(tour),\n            tour.size()\n        );\n    }\n    return graphPath;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tV firstVertex=graph.getEdgeSource(tour.iterator().next());\n\treturn new GraphWalk<V,E>(graph,firstVertex,firstVertex,tour,getTourWeight(tour));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n", "method_name": "edgeSetToTour", "codes": ["protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=null;\n\tif(tour!=null){\n\t\tList<E> tourList=new ArrayList<E>(tour);\n\t\tV startVertex=graph.getEdgeSource(tourList.get(0));\n\t\tV endVertex=graph.getEdgeTarget(tourList.get(tourList.size()-1));\n\t\tGraphWalk<V,E> walk=new GraphWalk<V,E>(graph,startVertex,endVertex,tourList,tour.size());\n\t\tpath=new GraphPathImpl<V,E>(walk,0);\n\t}\n\treturn path;\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<E> tourList=new ArrayList<E>(tour);\n\t//return new GraphWalk<V,E>(graph,tourList.get(0).getSource(),tourList.get(tourList.size()-1).getTarget(),tourList,tourList.stream().mapToDouble(e->graph.getEdgeWeight(e)).sum());\n\treturn new GraphWalk<V,E>(graph,tourList.get(0).getSource(),tourList.get(tourList.size()-1).getTarget(),tourList,tourList.stream().mapToDouble(e->graph.getEdgeWeight(e)).sum());\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<E> edgeList=new ArrayList<>(tour.size());\n\tV v=graph.vertexSet().iterator().next();\n\tV last=v;\n\twhile(!tour.isEmpty()){\n\t\tE e=null;\n\t\tfor(E edge:graph.edgesOf(v)){\n\t\t\tif(tour.remove(edge)){\n\t\t\t\te=edge;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(e==null){\n\t\t\tthrow new IllegalArgumentException(\"Tour is not a tour\");\n\t\t}\n\t\tedgeList.add(e);\n\t\tlast=v;\n\t\tv=Graphs.getOppositeVertex(graph,e,v);\n\t}\n\tif(!last.equals(v)){\n\t\tthrow new IllegalArgumentException(\"Tour is not a tour\");\n\t}\n\treturn new GraphWalk<>(graph,v,v,null,edgeList,tour.size());\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=new GraphPathImpl<V,E>(graph,null,null,0);\n\tV prev=null;\n\tE prevEdge=null;\n\tdouble weight=0;\n\tfor(E e:tour){\n\t\tV u=graph.getEdgeSource(e);\n\t\tV v=graph.getEdgeTarget(e);\n\t\tif(prev==null){\n\t\t\tprev=u;\n\t\t}else if(prev.equals(v)){\n\t\t\tprev=v;\n\t\t\tprevEdge=e;\n\t\t\tpath=new GraphWalk<V,E>(graph,u,v,null,weight);\n\t\t\tweight+=graph.getEdgeWeight(e);\n\t\t}else if(prev.equals(u)){\n\t\t\tprev=u;\n\t\t\tprevEdge=e;\n\t\t\tpath=new GraphWalk<V,E>(graph,v,u,null,weight);\n\t\t\tweight+=graph.getEdgeWeight(e);\n\t\t}\n\t}\n\tpath=", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tV start=graph.getEdgeSource(tour.iterator().next());\n\treturn new GraphWalk<V,E>(graph,start,start,tour,0);\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n    GraphPath<V,E> graphPath=null;\n    boolean isDirected=graph.getType().isDirected();\n    Graph<V,E> g=graph;\n    if(!isDirected){\n        g=new AsSubgraph<V,E>(graph,null,null);\n    }\n    GraphWalk<V,E> walk=new GraphWalk<>(g,null,null,null,0);\n    walk.setEdgeList(new ArrayList<>(tour));\n    graphPath=new GraphWalk<>(g,walk.getStartVertex(),walk.getEndVertex(),walk,walk.getWeight());\n    return graphPath;\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tList<V> vertices=new ArrayList<V>();\n\tList<E> edges=new ArrayList<E>();\n\tV vPrev=null;\n\tV vNext=null;\n\tfor(E edge:tour){\n\t\tV[] vs=Graphs.getIncidentVertices(graph,edge);\n\t\tif(vPrev==null){\n\t\t\tvPrev=vs[0];\n\t\t\tvNext=vs[1];\n\t\t\tvertices.add(vPrev);\n\t\t\tvertices.add(vNext);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[0]==vPrev){\n\t\t\tvPrev=vs[1];\n\t\t\tvertices.add(vPrev);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[1]==vPrev){\n\t\t\tvPrev=vs[0];\n\t\t\tvertices.add(vPrev);\n\t\t\tedges.add(edge);\n\t\t}else if(vs[0]==vNext", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tGraphPath<V,E> path=null;\n\tif(tour!=null&&tour.size()>0){\n\t\tGraphWalk<V,E> walk=new GraphWalk<>(graph,null,null,new ArrayList<>(tour),0);\n\t\tpath=new GraphWalk<>(graph,null,null,walk.getVertexList(),walk.getWeight());\n\t}\n\treturn path;\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n    GraphPath<V,E> graphPath=null;\n    if(tour.size()>0){\n        graphPath=new GraphWalk<V,E>(\n            graph,\n            null,\n            null,\n            null,\n            new LinkedList<E>(tour),\n            tour.size()\n        );\n    }\n    return graphPath;\n}", "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n\n\tV firstVertex=graph.getEdgeSource(tour.iterator().next());\n\treturn new GraphWalk<V,E>(graph,firstVertex,firstVertex,tour,getTourWeight(tour));\n}"], "code_level": "class_runnable", "_id": "636767561a6d9265ec017f7c", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\tbucketsByLabel.get(0).addAll(minBucket);\n\tminBucket.clear();\n\tfor(int vertex:bucketsByLabel.get(0))\n\t\tlabels.set(vertex,0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\t\n\tSet<Integer> minLabelBucket = bucketsByLabel.get(minLabel);\n\tSet<Integer> zeroBucket = bucketsByLabel.get(0);\n\t\n\tfor(int v:minLabelBucket){\n\t\tlabels.set(v, 0);\n\t\tzeroBucket.add(v);\n\t}\n\t\n\tminLabelBucket.clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n\tfor(int i=0;i<labels.size();i++)\n\t\tif(labels.get(i)==minLabel)\n\t\t\tlabels.set(i,0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n    bucketsByLabel.get(minLabel).forEach(v->{\n        bucketsByLabel.get(0).add(v);\n        labels.set(v,0);\n        });\n    bucketsByLabel.get(minLabel).clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tfor(int vertex:bucketsByLabel.get(minLabel)){\n\t\tlabels.set(vertex,0);\n\t}\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\t\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\t\tSet<Integer> zeroBucket=bucketsByLabel.get(0);\n\t\tfor (Integer v : minBucket) {\n\t\t\tzeroBucket.add(v);\n\t\t\tlabels.set(v,0);\n\t\t}\n\t\tminBucket.clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket = bucketsByLabel.get(minLabel);\n\tfor (Integer v : minBucket){\n\t\tlabels.set(v, 0);\n\t}\n\tminBucket.clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tif(DEBUG) System.out.println(\"Reloading vertices from label \"+minLabel+\" to label 0\");\n\tfor(int v:bucketsByLabel.get(minLabel)){\n\t\tlabels.set(v,0);\n\t}\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\tSet<Integer> zeroBucket=bucketsByLabel.get(0);\n\tzeroBucket.addAll(minBucket);\n\tminBucket.clear();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n    bucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n    bucketsByLabel.get(minLabel).clear();\n    labels.set(0,bucketsByLabel.get(0).size());\n    labels.set(minLabel,0);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n", "method_name": "reload", "codes": ["private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\tbucketsByLabel.get(0).addAll(minBucket);\n\tminBucket.clear();\n\tfor(int vertex:bucketsByLabel.get(0))\n\t\tlabels.set(vertex,0);\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\t\n\tSet<Integer> minLabelBucket = bucketsByLabel.get(minLabel);\n\tSet<Integer> zeroBucket = bucketsByLabel.get(0);\n\t\n\tfor(int v:minLabelBucket){\n\t\tlabels.set(v, 0);\n\t\tzeroBucket.add(v);\n\t}\n\t\n\tminLabelBucket.clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n\tfor(int i=0;i<labels.size();i++)\n\t\tif(labels.get(i)==minLabel)\n\t\t\tlabels.set(i,0);\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n    bucketsByLabel.get(minLabel).forEach(v->{\n        bucketsByLabel.get(0).add(v);\n        labels.set(v,0);\n        });\n    bucketsByLabel.get(minLabel).clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tfor(int vertex:bucketsByLabel.get(minLabel)){\n\t\tlabels.set(vertex,0);\n\t}\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\t\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\t\tSet<Integer> zeroBucket=bucketsByLabel.get(0);\n\t\tfor (Integer v : minBucket) {\n\t\t\tzeroBucket.add(v);\n\t\t\tlabels.set(v,0);\n\t\t}\n\t\tminBucket.clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket = bucketsByLabel.get(minLabel);\n\tfor (Integer v : minBucket){\n\t\tlabels.set(v, 0);\n\t}\n\tminBucket.clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tif(DEBUG) System.out.println(\"Reloading vertices from label \"+minLabel+\" to label 0\");\n\tfor(int v:bucketsByLabel.get(minLabel)){\n\t\tlabels.set(v,0);\n\t}\n\tbucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n\tbucketsByLabel.get(minLabel).clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n\tSet<Integer> minBucket=bucketsByLabel.get(minLabel);\n\tSet<Integer> zeroBucket=bucketsByLabel.get(0);\n\tzeroBucket.addAll(minBucket);\n\tminBucket.clear();\n}", "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n\n    bucketsByLabel.get(0).addAll(bucketsByLabel.get(minLabel));\n    bucketsByLabel.get(minLabel).clear();\n    labels.set(0,bucketsByLabel.get(0).size());\n    labels.set(minLabel,0);\n}"], "code_level": "self_contained", "_id": "636767641a6d9265ec018190", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "@Override protected V provideNextVertex(){\n\n\tfinal V result = getVertex();\n\tif(result != null){\n\t\tinvalidateVertex();\n\t\treturn result;\n\t}\n\telse\n\t\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\t\tif(!hasNext()) throw new NoSuchElementException();\n\t\tV curr = data[i];\n\t\ti++;\n\t\treturn curr;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\tif(!iterator.hasNext()) return null;\n\tV v = iterator.next();\n\tif(!iterator.hasNext()) return null;\n\treturn v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\t// TODO Auto-generated method stub\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\t\tif(queue.isEmpty())\n\t\t\treturn null;\n\t\tV v = queue.remove();\n\t\tfor(V w : g.adjacentTo(v)){\n\t\t\tif(!visited.contains(w)){\n\t\t\t\tvisited.add(w);\n\t\t\t\tqueue.add(w);\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n  if(vertexIterator==null) {\n    vertexIterator=graph.vertexSet().iterator();\n    currentVertex=vertexIterator.next();\n  }\n  V v=currentVertex;\n  if(vertexIterator.hasNext())\n    currentVertex=vertexIterator.next();\n  else {\n    vertexIterator=null;\n    currentVertex=null;\n  }\n  return v;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\treturn this.lastVertex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n    return graph.vertices().iterator().next();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n        int n=size();\n        for(int i=0;i<n;i++){\n            V v=(V) getVertex(i);\n            if(!isVisited(v))\n                return v;\n        }\n        return null;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override protected V provideNextVertex(){\n\n\treturn graph.getVertex(nextVertex);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * {@inheritDoc}\n */\n", "method_name": "provideNextVertex", "codes": ["@Override protected V provideNextVertex(){\n\n\tfinal V result = getVertex();\n\tif(result != null){\n\t\tinvalidateVertex();\n\t\treturn result;\n\t}\n\telse\n\t\treturn null;\n}", "@Override protected V provideNextVertex(){\n\n\t\tif(!hasNext()) throw new NoSuchElementException();\n\t\tV curr = data[i];\n\t\ti++;\n\t\treturn curr;\n\t}", "@Override protected V provideNextVertex(){\n\n\tif(!iterator.hasNext()) return null;\n\tV v = iterator.next();\n\tif(!iterator.hasNext()) return null;\n\treturn v;\n}", "@Override protected V provideNextVertex(){\n\n\t// TODO Auto-generated method stub\n\treturn null;\n}", "@Override protected V provideNextVertex(){\n\n\t\tif(queue.isEmpty())\n\t\t\treturn null;\n\t\tV v = queue.remove();\n\t\tfor(V w : g.adjacentTo(v)){\n\t\t\tif(!visited.contains(w)){\n\t\t\t\tvisited.add(w);\n\t\t\t\tqueue.add(w);\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}", "@Override protected V provideNextVertex(){\n\n  if(vertexIterator==null) {\n    vertexIterator=graph.vertexSet().iterator();\n    currentVertex=vertexIterator.next();\n  }\n  V v=currentVertex;\n  if(vertexIterator.hasNext())\n    currentVertex=vertexIterator.next();\n  else {\n    vertexIterator=null;\n    currentVertex=null;\n  }\n  return v;\n}", "@Override protected V provideNextVertex(){\n\n\treturn this.lastVertex;\n}", "@Override protected V provideNextVertex(){\n\n    return graph.vertices().iterator().next();\n}", "@Override protected V provideNextVertex(){\n\n        int n=size();\n        for(int i=0;i<n;i++){\n            V v=(V) getVertex(i);\n            if(!isVisited(v))\n                return v;\n        }\n        return null;\n    }", "@Override protected V provideNextVertex(){\n\n\treturn graph.getVertex(nextVertex);\n}"], "code_level": "class_runnable", "_id": "636767611a6d9265ec018112", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n//initialization\nList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\nList<Pair<Integer,Integer>> localSeparator=new ArrayList<Pair<Integer,Integer>>();\n//for each edge in the graph\nfor (E edge : this.getEdges()) {\n//if the edge isn't a circle\nif(!this.isCircle(edge)){\n//compute the list of the minimal separators in the neighborhood of the edge\nlocalSeparator=this.computeSeparator(edge);\n//put the pair of list and edge into the return list\nglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(localSeparator,edge));\n}\n}\n//return the final list\nreturn globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge:graph.edgeSet()){\n\t\tif(edge.getType()!=EdgeType.CIRCLE){\n\t\t\tList<Pair<Integer,Integer>> separatorList=computeSeparatorList(edge);\n\t\t\tif(separatorList.size()>0) globalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E e:graph.edges()){\n\t\tif(graph.getEdgeWeight(e)==0)\n\t\t\tcontinue;\n\t\tList<Pair<Integer,Integer>> list2=computeMinimalSeparatorList(e);\n\t\tlist.add(new Pair<List<Pair<Integer,Integer>>, E>(list2,e));\n\t}\n\treturn list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> separatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E e:graph.getEdges()){\n\t\tif(e.getType()!=EdgeType.CIRCLE){\n\t\tint tail=e.getTail().getId();\n\t\tint head=e.getHead().getId();\n\t\tList<Pair<Integer,Integer>> separators=computeMinimalSeparators(e.getId());\n\t\tseparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separators,e));\n\t\t}\n\t\t\n\t}\n\treturn separatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();\n\tfor(E edge:graph.edgeSet()){\n\t\tif(edge.getPositions().size()!=3){\n\t\t\tList<Pair<Integer,Integer>> separator=computeMinimalSeparator(edge);\n\t\t\tPair<List<Pair<Integer,Integer>>,E> pair=new Pair<>(separator,edge);\n\t\t\tglobalSeparatorList.add(pair);\n\t\t\t}\n\t\t}\n\treturn globalSeparatorList;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge:this.getEdgeSet()){\n\t\tif(edge.getType()!=Edge.EdgeType.CIRCLE){\n\t\t\t//Compute the list of the minimal separators in the neighborhood of the edge\n\t\t\tList<Pair<Integer,Integer>> separatorList=this.computeSeparatorList(edge);\n\t\t\t//Put the pair of list and edge into the return list\n\t\t\tglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge : this.edgeSet()){\n\t\tif(!globalSeparatorList.isEmpty()){\n\t\t\tList<Pair<Integer,Integer>> separatorList = this.getSeparatorList(edge);\n\t\t\tglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<>();\n\tfor(E e:graph.getEdges()){\n\t\tif(!graph.isLoop(e)){\n\t\t\tList<Pair<Integer,Integer>> l=new ArrayList<>();\n\t\t\tfor(E e1:graph.getEdges(e.getSource())){\n\t\t\t\tif(graph.isLoop(e1)){\n\t\t\t\t\tl.add(new Pair<Integer,Integer>(e1.getSource().getIndex(),e1.getTarget().getIndex()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(E e1:graph.getEdges(e.getTarget())){\n\t\t\t\tif(graph.isLoop(e1)){\n\t\t\t\t\tl.add(new Pair<Integer,Integer>(e1.getSource().getIndex(),e1.getTarget().getIndex()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\t\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\t\tfor(E e : g.edges()) {\n\t\t\tif(g.isCircle(e)) continue;\n\t\t\telse {\n\t\t\t\tPair<List<Pair<Integer,Integer>>,E> pair = new Pair<List<Pair<Integer,Integer>>,E>(computeLocalSeparatorList(e),e);\n\t\t\t\tglobalSeparatorList.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn globalSeparatorList;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tList<Pair<Integer,Integer>> l;\n\tfor(int i=0;i<this.n;i++){\n\t\tfor(int j=i+1;j<this.n;j++){\n\t\t\tif(!this.adj[i][j].equals(empty) && !this.adj[i][j].equals(circle)){\n\t\t\t\tl=minimalSeparatorList(i,j);\n\t\t\t\tlist.add(new Pair<List<Pair<Integer,Integer>>,E>(l,this.adj[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n", "method_name": "computeGlobalSeparatorList", "codes": ["private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n//initialization\nList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\nList<Pair<Integer,Integer>> localSeparator=new ArrayList<Pair<Integer,Integer>>();\n//for each edge in the graph\nfor (E edge : this.getEdges()) {\n//if the edge isn't a circle\nif(!this.isCircle(edge)){\n//compute the list of the minimal separators in the neighborhood of the edge\nlocalSeparator=this.computeSeparator(edge);\n//put the pair of list and edge into the return list\nglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(localSeparator,edge));\n}\n}\n//return the final list\nreturn globalSeparatorList;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge:graph.edgeSet()){\n\t\tif(edge.getType()!=EdgeType.CIRCLE){\n\t\t\tList<Pair<Integer,Integer>> separatorList=computeSeparatorList(edge);\n\t\t\tif(separatorList.size()>0) globalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E e:graph.edges()){\n\t\tif(graph.getEdgeWeight(e)==0)\n\t\t\tcontinue;\n\t\tList<Pair<Integer,Integer>> list2=computeMinimalSeparatorList(e);\n\t\tlist.add(new Pair<List<Pair<Integer,Integer>>, E>(list2,e));\n\t}\n\treturn list;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> separatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E e:graph.getEdges()){\n\t\tif(e.getType()!=EdgeType.CIRCLE){\n\t\tint tail=e.getTail().getId();\n\t\tint head=e.getHead().getId();\n\t\tList<Pair<Integer,Integer>> separators=computeMinimalSeparators(e.getId());\n\t\tseparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separators,e));\n\t\t}\n\t\t\n\t}\n\treturn separatorList;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();\n\tfor(E edge:graph.edgeSet()){\n\t\tif(edge.getPositions().size()!=3){\n\t\t\tList<Pair<Integer,Integer>> separator=computeMinimalSeparator(edge);\n\t\t\tPair<List<Pair<Integer,Integer>>,E> pair=new Pair<>(separator,edge);\n\t\t\tglobalSeparatorList.add(pair);\n\t\t\t}\n\t\t}\n\treturn globalSeparatorList;\n\t}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge:this.getEdgeSet()){\n\t\tif(edge.getType()!=Edge.EdgeType.CIRCLE){\n\t\t\t//Compute the list of the minimal separators in the neighborhood of the edge\n\t\t\tList<Pair<Integer,Integer>> separatorList=this.computeSeparatorList(edge);\n\t\t\t//Put the pair of list and edge into the return list\n\t\t\tglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tfor(E edge : this.edgeSet()){\n\t\tif(!globalSeparatorList.isEmpty()){\n\t\t\tList<Pair<Integer,Integer>> separatorList = this.getSeparatorList(edge);\n\t\t\tglobalSeparatorList.add(new Pair<List<Pair<Integer,Integer>>,E>(separatorList,edge));\n\t\t}\n\t}\n\treturn globalSeparatorList;\n}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<>();\n\tfor(E e:graph.getEdges()){\n\t\tif(!graph.isLoop(e)){\n\t\t\tList<Pair<Integer,Integer>> l=new ArrayList<>();\n\t\t\tfor(E e1:graph.getEdges(e.getSource())){\n\t\t\t\tif(graph.isLoop(e1)){\n\t\t\t\t\tl.add(new Pair<Integer,Integer>(e1.getSource().getIndex(),e1.getTarget().getIndex()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(E e1:graph.getEdges(e.getTarget())){\n\t\t\t\tif(graph.isLoop(e1)){\n\t\t\t\t\tl.add(new Pair<Integer,Integer>(e1.getSource().getIndex(),e1.getTarget().getIndex()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.add(", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\t\tList<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList = new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\t\tfor(E e : g.edges()) {\n\t\t\tif(g.isCircle(e)) continue;\n\t\t\telse {\n\t\t\t\tPair<List<Pair<Integer,Integer>>,E> pair = new Pair<List<Pair<Integer,Integer>>,E>(computeLocalSeparatorList(e),e);\n\t\t\t\tglobalSeparatorList.add(pair);\n\t\t\t}\n\t\t}\n\t\treturn globalSeparatorList;\n\t}", "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n\n\tList<Pair<List<Pair<Integer,Integer>>,E>> list=new ArrayList<Pair<List<Pair<Integer,Integer>>,E>>();\n\tList<Pair<Integer,Integer>> l;\n\tfor(int i=0;i<this.n;i++){\n\t\tfor(int j=i+1;j<this.n;j++){\n\t\t\tif(!this.adj[i][j].equals(empty) && !this.adj[i][j].equals(circle)){\n\t\t\t\tl=minimalSeparatorList(i,j);\n\t\t\t\tlist.add(new Pair<List<Pair<Integer,Integer>>,E>(l,this.adj[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}"], "code_level": "class_runnable", "_id": "636767601a6d9265ec0180e2", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsuffixSum.add(bounds.get(i));\n\t\tsum+=bounds.get(i);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<>();\n\tlong s = 0;\n\tfor(int i = bounds.size()-1;i>=0;i--){\n\t\ts+=bounds.get(i);\n\t\tsuffixSum.add(0,(int)s);\n\t}\n\treturn new Pair<>(suffixSum,s);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint n = bounds.size();\n\tlong sum = 0;\n\tfor(int i = n-1; i>=0; i--){\n\t\tsum += bounds.get(i);\n\t\tsuffixSum.add((int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> sumList = new ArrayList<Integer>();\n\tLong sum=0L;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsumList.add(0,sum.intValue());\n\t}\n\treturn new Pair<List<Integer>,Long>(sumList,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> res=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;--i){\n\t\tsum+=bounds.get(i);\n\t\tres.add(0,(int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(res,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\nList<Integer> suffix = new ArrayList<>();\nlong sum = 0;\nfor(int i = bounds.size()-1; i > -1; i--){\nsum += bounds.get(i);\nsuffix.add(0,(int)sum);\n}\nreturn new Pair<>(suffix,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> res=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tres.add(0,(int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(res,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint sum = 0;\n\tfor(int i = bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsuffixSum.add(sum);\n\t}\n\tlong sumOfBounds = 0;\n\tfor(Integer i : bounds){\n\t\tsumOfBounds+=i;\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sumOfBounds);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint n = bounds.size();\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i==n-1) suffixSum.add(0, bounds.get(i));\n\t\telse{\n\t\t\tsuffixSum.add(0, bounds.get(i)+suffixSum.get(0));\n\t\t}\n\t}\n\tlong sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tsum+=suffixSum.get(i);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum=new ArrayList<>(bounds.size());\n\tint sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsuffixSum.add(0,sum);\n\t}\n\treturn new Pair<>(suffixSum,(long)sum);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n", "method_name": "computeSuffixSum", "codes": ["private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsuffixSum.add(bounds.get(i));\n\t\tsum+=bounds.get(i);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<>();\n\tlong s = 0;\n\tfor(int i = bounds.size()-1;i>=0;i--){\n\t\ts+=bounds.get(i);\n\t\tsuffixSum.add(0,(int)s);\n\t}\n\treturn new Pair<>(suffixSum,s);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint n = bounds.size();\n\tlong sum = 0;\n\tfor(int i = n-1; i>=0; i--){\n\t\tsum += bounds.get(i);\n\t\tsuffixSum.add((int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> sumList = new ArrayList<Integer>();\n\tLong sum=0L;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsumList.add(0,sum.intValue());\n\t}\n\treturn new Pair<List<Integer>,Long>(sumList,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> res=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;--i){\n\t\tsum+=bounds.get(i);\n\t\tres.add(0,(int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(res,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\nList<Integer> suffix = new ArrayList<>();\nlong sum = 0;\nfor(int i = bounds.size()-1; i > -1; i--){\nsum += bounds.get(i);\nsuffix.add(0,(int)sum);\n}\nreturn new Pair<>(suffix,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> res=new ArrayList<Integer>();\n\tlong sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tres.add(0,(int)sum);\n\t}\n\treturn new Pair<List<Integer>,Long>(res,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint sum = 0;\n\tfor(int i = bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsuffixSum.add(sum);\n\t}\n\tlong sumOfBounds = 0;\n\tfor(Integer i : bounds){\n\t\tsumOfBounds+=i;\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sumOfBounds);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum = new ArrayList<Integer>();\n\tint n = bounds.size();\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i==n-1) suffixSum.add(0, bounds.get(i));\n\t\telse{\n\t\t\tsuffixSum.add(0, bounds.get(i)+suffixSum.get(0));\n\t\t}\n\t}\n\tlong sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tsum+=suffixSum.get(i);\n\t}\n\treturn new Pair<List<Integer>,Long>(suffixSum,sum);\n}", "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n\n\tList<Integer> suffixSum=new ArrayList<>(bounds.size());\n\tint sum=0;\n\tfor(int i=bounds.size()-1;i>=0;i--){\n\t\tsum+=bounds.get(i);\n\t\tsuffixSum.add(0,sum);\n\t}\n\treturn new Pair<>(suffixSum,(long)sum);\n}"], "code_level": "project_runnable", "_id": "636767461a6d9265ec017d0e", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> result = new ArrayList<Integer>();\n\tfor(K k : keys){\n\t\tresult.add(computeLowerBound(k));\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tlowerBounds.add(computeLowerBound(keys.get(i)));\n\t}\n\treturn lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lower_bounds = new ArrayList<Integer>();\n\tlower_bounds.add(0);\n\tint lower_bound = 0;\n\tfor(int i=0;i<keys.size();i++){\n\t\tif(keys.get(i).compareTo(keys.get(lower_bound))<0){\n\t\t\tlower_bound = i;\n\t\t}\n\t\tlower_bounds.add(lower_bound);\n\t}\n\treturn lower_bounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> bounds = new ArrayList<Integer>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tint max =0;\n\t\tfor(int j = 0; j < keys.size(); j++){\n\t\t\tif(i != j && keyComp.compare(keys.get(i), keys.get(j)) > 0){\n\t\t\t\tmax++;\n\t\t\t}\n\t\t}\n\t\tbounds.add(max);\n\t}\n\treturn bounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(K key : keys){\n\t\tlowerBounds.add(computeLowerBound(key));\n\t}\n\treturn lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\t\tList<Integer> lowers = new ArrayList<Integer>();\n\t\tfor(K key:keys){\n\t\t\tlowers.add(computeLowerBound(key));\n\t\t}\n\t\treturn lowers;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n    List<Integer> lowerBounds = new ArrayList<>();\n    if(keys == null || keys.size() == 0) return lowerBounds;\n    for(K key : keys){\n        lowerBounds.add(computeLowerBound(key));\n    }\n    return lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> result=new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tK key=keys.get(i);\n\t\tint lowerBound=0;\n\t\tfor(int j=0;j<keys.size();j++){\n\t\t\tif(i==j)continue;\n\t\t\tK other=keys.get(j);\n\t\t\tint cmp=key.compareTo(other);\n\t\t\tif(cmp>0)lowerBound++;\n\t\t}\n\t\tresult.add(lowerBound);\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tif(keys.isEmpty())\n\t\treturn new ArrayList<>();\n\tList<Integer> lowerBounds=new ArrayList<>();\n\tlowerBounds.add(getLowerBound(keys.get(0)));\n\tfor(int i=1;i<keys.size();i++) {\n\t\tlowerBounds.add(Math.max(lowerBounds.get(i-1), getLowerBound(keys.get(i))));\n\t}\n\treturn lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeLowerBounds(List<K> keys){\n\n//\tSystem.out.println(keys);\n\tList<Integer> lowerBounds=new ArrayList<Integer>();\n\tif(keys.size()==0){\n\t\treturn lowerBounds;\n\t}\n\tlowerBounds.add(0);\n\tint start=keys.get(0);\n\tfor(int i=1;i<keys.size();i++){\n\t\tif(start!=keys.get(i)){\n\t\t\tstart=keys.get(i);\n\t\t\tlowerBounds.add(i);\n\t\t}\n\t}\n//\tSystem.out.println(lowerBounds);\n\treturn lowerBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n", "method_name": "computeLowerBounds", "codes": ["private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> result = new ArrayList<Integer>();\n\tfor(K k : keys){\n\t\tresult.add(computeLowerBound(k));\n\t}\n\treturn result;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tlowerBounds.add(computeLowerBound(keys.get(i)));\n\t}\n\treturn lowerBounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lower_bounds = new ArrayList<Integer>();\n\tlower_bounds.add(0);\n\tint lower_bound = 0;\n\tfor(int i=0;i<keys.size();i++){\n\t\tif(keys.get(i).compareTo(keys.get(lower_bound))<0){\n\t\t\tlower_bound = i;\n\t\t}\n\t\tlower_bounds.add(lower_bound);\n\t}\n\treturn lower_bounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> bounds = new ArrayList<Integer>();\n\tfor(int i = 0; i < keys.size(); i++){\n\t\tint max =0;\n\t\tfor(int j = 0; j < keys.size(); j++){\n\t\t\tif(i != j && keyComp.compare(keys.get(i), keys.get(j)) > 0){\n\t\t\t\tmax++;\n\t\t\t}\n\t\t}\n\t\tbounds.add(max);\n\t}\n\treturn bounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> lowerBounds = new ArrayList<Integer>();\n\tfor(K key : keys){\n\t\tlowerBounds.add(computeLowerBound(key));\n\t}\n\treturn lowerBounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\t\tList<Integer> lowers = new ArrayList<Integer>();\n\t\tfor(K key:keys){\n\t\t\tlowers.add(computeLowerBound(key));\n\t\t}\n\t\treturn lowers;\n\t}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n    List<Integer> lowerBounds = new ArrayList<>();\n    if(keys == null || keys.size() == 0) return lowerBounds;\n    for(K key : keys){\n        lowerBounds.add(computeLowerBound(key));\n    }\n    return lowerBounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tList<Integer> result=new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tK key=keys.get(i);\n\t\tint lowerBound=0;\n\t\tfor(int j=0;j<keys.size();j++){\n\t\t\tif(i==j)continue;\n\t\t\tK other=keys.get(j);\n\t\t\tint cmp=key.compareTo(other);\n\t\t\tif(cmp>0)lowerBound++;\n\t\t}\n\t\tresult.add(lowerBound);\n\t}\n\treturn result;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n\tif(keys.isEmpty())\n\t\treturn new ArrayList<>();\n\tList<Integer> lowerBounds=new ArrayList<>();\n\tlowerBounds.add(getLowerBound(keys.get(0)));\n\tfor(int i=1;i<keys.size();i++) {\n\t\tlowerBounds.add(Math.max(lowerBounds.get(i-1), getLowerBound(keys.get(i))));\n\t}\n\treturn lowerBounds;\n}", "private List<Integer> computeLowerBounds(List<K> keys){\n\n//\tSystem.out.println(keys);\n\tList<Integer> lowerBounds=new ArrayList<Integer>();\n\tif(keys.size()==0){\n\t\treturn lowerBounds;\n\t}\n\tlowerBounds.add(0);\n\tint start=keys.get(0);\n\tfor(int i=1;i<keys.size();i++){\n\t\tif(start!=keys.get(i)){\n\t\t\tstart=keys.get(i);\n\t\t\tlowerBounds.add(i);\n\t\t}\n\t}\n//\tSystem.out.println(lowerBounds);\n\treturn lowerBounds;\n}"], "code_level": "class_runnable", "_id": "636767431a6d9265ec017c88", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(K key : keys){\n\t\tint upperBound=0;\n\t\tfor(int i=0;i<key.length();i++){\n\t\t\tint index = key.charAt(i) - 'a';\n\t\t\tupperBound += Math.pow(2,index);\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tint upperBound=computeUpperBound(key);\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tint upperBound = 0;\n\tfor(K key:keys){\n\t\tupperBound = 0;\n\t\tfor(int i=0;i<upperBounds.size();i++){\n\t\t\tif(upperBounds.get(i)<upperBound){\n\t\t\t\tupperBound = upperBounds.get(i);\n\t\t\t}\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tint upperBound=Integer.MAX_VALUE;\n\t\tfor(Map.Entry<K,Integer> entry:keyToUpperBound.entrySet()){\n\t\t\tif(entry.getKey().compareTo(key)>=0&&entry.getValue()<upperBound){\n\t\t\t\tupperBound=entry.getValue();\n\t\t\t}\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new LinkedList<Integer>();\n\tfor(K key : keys){\n\t\tint upperBound=this.computeUpperBound(key);\n\t\tif(upperBound==-1){\n\t\t\tthrow new IllegalArgumentException(\"The key is not in the upper bound map.\");\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n    List<Integer> upperBounds = new ArrayList<>();\n    if(keys.size()==0){\n        return upperBounds;\n    }\n    Integer min = Integer.MAX_VALUE;\n    for(K key:keys){\n        Integer upperBound = upperBounds(key);\n        if(upperBound<min){\n            min = upperBound;\n        }\n    }\n    upperBounds.add(min);\n    return upperBounds;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tList<Integer> upperBoundsForKey = new ArrayList<Integer>();\n\t\tfor(int j=0;j<keys.size();j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(keys.get(j) instanceof Integer){\n\t\t\t\tInteger upperBound = (Integer)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound);\n\t\t\t}\n\t\t\telse if(keys.get(j) instanceof Long){\n\t\t\t\tLong upperBound = (Long)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound.intValue());\n\t\t\t}\n\t\t\telse if(keys.get(j) instanceof String){\n\t\t\t\tString upperBound = (String)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound.length());\n\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n", "method_name": "computeUpperBounds", "codes": ["private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(K key : keys){\n\t\tint upperBound=0;\n\t\tfor(int i=0;i<key.length();i++){\n\t\t\tint index = key.charAt(i) - 'a';\n\t\t\tupperBound += Math.pow(2,index);\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tint upperBound=computeUpperBound(key);\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tint upperBound = 0;\n\tfor(K key:keys){\n\t\tupperBound = 0;\n\t\tfor(int i=0;i<upperBounds.size();i++){\n\t\t\tif(upperBounds.get(i)<upperBound){\n\t\t\t\tupperBound = upperBounds.get(i);\n\t\t\t}\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tint upperBound=Integer.MAX_VALUE;\n\t\tfor(Map.Entry<K,Integer> entry:keyToUpperBound.entrySet()){\n\t\t\tif(entry.getKey().compareTo(key)>=0&&entry.getValue()<upperBound){\n\t\t\t\tupperBound=entry.getValue();\n\t\t\t}\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new LinkedList<Integer>();\n\tfor(K key : keys){\n\t\tint upperBound=this.computeUpperBound(key);\n\t\tif(upperBound==-1){\n\t\t\tthrow new IllegalArgumentException(\"The key is not in the upper bound map.\");\n\t\t}\n\t\tupperBounds.add(upperBound);\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds=new ArrayList<Integer>();\n\tfor(K key:keys){\n\t\tupperBounds.add(computeUpperBound(key));\n\t}\n\treturn upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n    List<Integer> upperBounds = new ArrayList<>();\n    if(keys.size()==0){\n        return upperBounds;\n    }\n    Integer min = Integer.MAX_VALUE;\n    for(K key:keys){\n        Integer upperBound = upperBounds(key);\n        if(upperBound<min){\n            min = upperBound;\n        }\n    }\n    upperBounds.add(min);\n    return upperBounds;\n}", "private List<Integer> computeUpperBounds(List<K> keys){\n\n\tList<Integer> upperBounds = new ArrayList<Integer>();\n\tfor(int i=0;i<keys.size();i++){\n\t\tList<Integer> upperBoundsForKey = new ArrayList<Integer>();\n\t\tfor(int j=0;j<keys.size();j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(keys.get(j) instanceof Integer){\n\t\t\t\tInteger upperBound = (Integer)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound);\n\t\t\t}\n\t\t\telse if(keys.get(j) instanceof Long){\n\t\t\t\tLong upperBound = (Long)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound.intValue());\n\t\t\t}\n\t\t\telse if(keys.get(j) instanceof String){\n\t\t\t\tString upperBound = (String)keys.get(j);\n\t\t\t\tupperBoundsForKey.add(upperBound.length());\n\t\t"], "code_level": "class_runnable", "_id": "636767581a6d9265ec017fb4", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V vertex:vertices){\n\t\tif(!isClique(graph,vertices,vertex))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()<2){\n\t\treturn true;\n\t}\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(!graph.containsEdge(v,u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u && !graph.containsEdge(v,u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()<2)\n\t\treturn false;\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(u.equals(v))\n\t\t\t\tcontinue;\n\t\t\tif(!graph.containsEdge(u,v))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n    if(vertices.size()<=1) return true;\n    Iterator<V>it=vertices.iterator();\n    Set<V>sub=new HashSet<V>();\n    while(it.hasNext()){\n        sub.add(it.next());\n    }\n    V v1=sub.iterator().next();\n    sub.remove(v1);\n    Iterator<V>it2=sub.iterator();\n    while(it2.hasNext()){\n        V v2=it2.next();\n        if(!graph.containsEdge(v1,v2)){\n            return false;\n        }\n    }\n    return isClique(graph,sub);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u&&!graph.containsEdge(v, u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u){\n\t\t\t\tif(!graph.isNeighbor(v,u)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\nfor(V vertex:vertices){\nif(!GraphTests.isClique(graph,vertices,vertex))\nreturn false;\n}\nreturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()==1) return true;\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u && !graph.containsEdge(v,u)) return false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.isEmpty()){\n\t\treturn false;\n\t}\n\tfor(V vertex:vertices){\n\t\tSet<V> neighbors=new HashSet<V>(graph.getNeighbors(vertex));\n\t\tneighbors.retainAll(vertices);\n\t\tif(neighbors.size()!=vertices.size()-1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n", "method_name": "isClique", "codes": ["private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V vertex:vertices){\n\t\tif(!isClique(graph,vertices,vertex))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()<2){\n\t\treturn true;\n\t}\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(!graph.containsEdge(v,u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u && !graph.containsEdge(v,u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()<2)\n\t\treturn false;\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(u.equals(v))\n\t\t\t\tcontinue;\n\t\t\tif(!graph.containsEdge(u,v))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n    if(vertices.size()<=1) return true;\n    Iterator<V>it=vertices.iterator();\n    Set<V>sub=new HashSet<V>();\n    while(it.hasNext()){\n        sub.add(it.next());\n    }\n    V v1=sub.iterator().next();\n    sub.remove(v1);\n    Iterator<V>it2=sub.iterator();\n    while(it2.hasNext()){\n        V v2=it2.next();\n        if(!graph.containsEdge(v1,v2)){\n            return false;\n        }\n    }\n    return isClique(graph,sub);\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u&&!graph.containsEdge(v, u)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u){\n\t\t\t\tif(!graph.isNeighbor(v,u)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\nfor(V vertex:vertices){\nif(!GraphTests.isClique(graph,vertices,vertex))\nreturn false;\n}\nreturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.size()==1) return true;\n\tfor(V v:vertices){\n\t\tfor(V u:vertices){\n\t\t\tif(v!=u && !graph.containsEdge(v,u)) return false;\n\t\t}\n\t}\n\treturn true;\n}", "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n\n\tif(vertices.isEmpty()){\n\t\treturn false;\n\t}\n\tfor(V vertex:vertices){\n\t\tSet<V> neighbors=new HashSet<V>(graph.getNeighbors(vertex));\n\t\tneighbors.retainAll(vertices);\n\t\tif(neighbors.size()!=vertices.size()-1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "6367675f1a6d9265ec0180cf", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "public int nonZeros(int row){\n\n\tif (row<0 || row>=numRows) throw new ArrayIndexOutOfBoundsException();\n\treturn rowVector[row].size();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\treturn getRow(row).nonZeros();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n    int nz=0;\n    for(int i=0;i<cols;i++){\n        if(data[row][i]!=0) nz++;\n    }\n    return nz;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\nreturn nonZeros[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\treturn m_rowStart[row+1]-m_rowStart[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\tif(row < 0 || row >= this.rows)\n\t\tthrow new IllegalArgumentException(\"Incompatible row number in nonZeros.\");\n\t\n\tint count = 0;\n\tfor(int i = rowStart[row]; i < rowStart[row+1]; i++)\n\t\tif(values[i] != 0)\n\t\t\tcount++;\n\treturn count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\treturn rows[row].size();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\tint count = 0;\n\tfor(int j = 0; j < cols; j++){\n\t\tif(get(row,j) != 0) count++;\n\t}\n\treturn count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\n\treturn rowSizes[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int nonZeros(int row){\n\nif(row<0||row>=n) throw new IndexOutOfBoundsException(\"row index out of bounds\");\nreturn nz[row];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Get the number of non-zero entries of a row.\n * @param row the row\n * @return the number of non-zero entries of a row\n */\n", "method_name": "nonZeros", "codes": ["public int nonZeros(int row){\n\n\tif (row<0 || row>=numRows) throw new ArrayIndexOutOfBoundsException();\n\treturn rowVector[row].size();\n}", "public int nonZeros(int row){\n\n\treturn getRow(row).nonZeros();\n}", "public int nonZeros(int row){\n\n    int nz=0;\n    for(int i=0;i<cols;i++){\n        if(data[row][i]!=0) nz++;\n    }\n    return nz;\n}", "public int nonZeros(int row){\n\nreturn nonZeros[row];\n}", "public int nonZeros(int row){\n\n\treturn m_rowStart[row+1]-m_rowStart[row];\n}", "public int nonZeros(int row){\n\n\tif(row < 0 || row >= this.rows)\n\t\tthrow new IllegalArgumentException(\"Incompatible row number in nonZeros.\");\n\t\n\tint count = 0;\n\tfor(int i = rowStart[row]; i < rowStart[row+1]; i++)\n\t\tif(values[i] != 0)\n\t\t\tcount++;\n\treturn count;\n}", "public int nonZeros(int row){\n\n\treturn rows[row].size();\n}", "public int nonZeros(int row){\n\n\tint count = 0;\n\tfor(int j = 0; j < cols; j++){\n\t\tif(get(row,j) != 0) count++;\n\t}\n\treturn count;\n}", "public int nonZeros(int row){\n\n\treturn rowSizes[row];\n}", "public int nonZeros(int row){\n\nif(row<0||row>=n) throw new IndexOutOfBoundsException(\"row index out of bounds\");\nreturn nz[row];\n}"], "code_level": "class_runnable", "_id": "636767511a6d9265ec017eb0", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private String unescapeId(String input){\n\n\t\n\tStringBuilder builder = new StringBuilder();\n\t\n\tfor(int i = 0; i < input.length(); i++){\n\t\tchar c = input.charAt(i);\n\t\tif(c == '\\\\' && i < input.length() - 1){\n\t\t\tchar c2 = input.charAt(i+1);\n\t\t\tif(c2 == '.'){\n\t\t\t\tbuilder.append('.');\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbuilder.append(c);\n\t}\n\t\n\treturn builder.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\tString output=input;\n\tif(input.startsWith(\"\\\\.\")){\n\t\toutput=input.substring(1);\n\t}\n\treturn output;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n    return input.replace(\"\\\\.\", \".\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\tStringBuilder out=new StringBuilder();\n\tfor(int i=0;i<input.length();i++){\n\t\tchar c=input.charAt(i);\n\t\tif(c=='\\\\'){\n\t\t\ti++;\n\t\t\tif(i<input.length()){\n\t\t\t\tout.append(input.charAt(i));\n\t\t\t}else{\n\t\t\t\tout.append(c);\n\t\t\t}\n\t\t}else{\n\t\t\tout.append(c);\n\t\t}\n\t}\n\treturn out.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\tif(input==null || input.length()==0)\n\t\treturn input;\n\t//Check if it is escaped.\n\tif(input.charAt(0)!=ESCAPE_CHAR)\n\t\treturn input;\n\t//Unescape it\n\tStringBuilder sb=new StringBuilder(input.length());\n\tfor(int i=1;i<input.length();i++){\n\t\tchar c=input.charAt(i);\n\t\tif(c==ESCAPE_CHAR)\n\t\t\tsb.append(ESCAPE_CHAR);\n\t\telse\n\t\t\tsb.append(c);\n\t}\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n  input = input.replace(\"\\\\.\",\".\");\n  input = input.replace(\"\\\\\\\\\",\"\\\\\");\n  return input;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\treturn input.replace('\\\\','.');\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\treturn input.replace(\"\\\\.\", \".\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n\tif (input == null) return null;\n\tif (!input.contains(\"\\\\\")) return input;\n\tString output = \"\";\n\tString[] parts = input.split(\"(?<!\\\\\\\\)\\\\.\");\n\tfor (int i = 0; i < parts.length; i++){\n\t\tparts[i] = parts[i].replaceAll(\"\\\\\\\\\\\\.\", \".\");\n\t\tif (i > 0){\n\t\t\toutput += \".\";\n\t\t}\n\t\toutput += parts[i];\n\t}\n\treturn output;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private String unescapeId(String input){\n\n  if(input.indexOf('\\\\') == -1)return input;\n  StringBuilder sb = new StringBuilder();\n  int len = input.length();\n  for(int i = 0; i < len; i++){\n    char c = input.charAt(i);\n    if(c == '\\\\'){\n      if(i < len - 1){\n        char c2 = input.charAt(i+1);\n        if(c2 == '.'){\n          sb.append(c2);\n          i++;\n        }else{\n          sb.append(c);\n        }\n      }else{\n        sb.append(c);\n      }\n    }else{\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Unescape a string DOT identifier.\n * @param input the input\n * @return the unescaped output\n */\n", "method_name": "unescapeId", "codes": ["private String unescapeId(String input){\n\n\t\n\tStringBuilder builder = new StringBuilder();\n\t\n\tfor(int i = 0; i < input.length(); i++){\n\t\tchar c = input.charAt(i);\n\t\tif(c == '\\\\' && i < input.length() - 1){\n\t\t\tchar c2 = input.charAt(i+1);\n\t\t\tif(c2 == '.'){\n\t\t\t\tbuilder.append('.');\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbuilder.append(c);\n\t}\n\t\n\treturn builder.toString();\n}", "private String unescapeId(String input){\n\n\tString output=input;\n\tif(input.startsWith(\"\\\\.\")){\n\t\toutput=input.substring(1);\n\t}\n\treturn output;\n}", "private String unescapeId(String input){\n\n    return input.replace(\"\\\\.\", \".\");\n}", "private String unescapeId(String input){\n\n\tStringBuilder out=new StringBuilder();\n\tfor(int i=0;i<input.length();i++){\n\t\tchar c=input.charAt(i);\n\t\tif(c=='\\\\'){\n\t\t\ti++;\n\t\t\tif(i<input.length()){\n\t\t\t\tout.append(input.charAt(i));\n\t\t\t}else{\n\t\t\t\tout.append(c);\n\t\t\t}\n\t\t}else{\n\t\t\tout.append(c);\n\t\t}\n\t}\n\treturn out.toString();\n}", "private String unescapeId(String input){\n\n\tif(input==null || input.length()==0)\n\t\treturn input;\n\t//Check if it is escaped.\n\tif(input.charAt(0)!=ESCAPE_CHAR)\n\t\treturn input;\n\t//Unescape it\n\tStringBuilder sb=new StringBuilder(input.length());\n\tfor(int i=1;i<input.length();i++){\n\t\tchar c=input.charAt(i);\n\t\tif(c==ESCAPE_CHAR)\n\t\t\tsb.append(ESCAPE_CHAR);\n\t\telse\n\t\t\tsb.append(c);\n\t}\n\treturn sb.toString();\n}", "private String unescapeId(String input){\n\n  input = input.replace(\"\\\\.\",\".\");\n  input = input.replace(\"\\\\\\\\\",\"\\\\\");\n  return input;\n}", "private String unescapeId(String input){\n\n\treturn input.replace('\\\\','.');\n}", "private String unescapeId(String input){\n\n\treturn input.replace(\"\\\\.\", \".\");\n}", "private String unescapeId(String input){\n\n\tif (input == null) return null;\n\tif (!input.contains(\"\\\\\")) return input;\n\tString output = \"\";\n\tString[] parts = input.split(\"(?<!\\\\\\\\)\\\\.\");\n\tfor (int i = 0; i < parts.length; i++){\n\t\tparts[i] = parts[i].replaceAll(\"\\\\\\\\\\\\.\", \".\");\n\t\tif (i > 0){\n\t\t\toutput += \".\";\n\t\t}\n\t\toutput += parts[i];\n\t}\n\treturn output;\n}", "private String unescapeId(String input){\n\n  if(input.indexOf('\\\\') == -1)return input;\n  StringBuilder sb = new StringBuilder();\n  int len = input.length();\n  for(int i = 0; i < len; i++){\n    char c = input.charAt(i);\n    if(c == '\\\\'){\n      if(i < len - 1){\n        char c2 = input.charAt(i+1);\n        if(c2 == '.'){\n          sb.append(c2);\n          i++;\n        }else{\n          sb.append(c);\n        }\n      }else{\n        sb.append(c);\n      }\n    }else{\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}"], "code_level": "class_runnable", "_id": "636767461a6d9265ec017d17", "project_name": "jgrapht-master"}
{"generate_results": [{"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tbyte b=bb.get(i);\n\tif(b>=0){\n\t\tsb.append((char)b);\n\t\treturn i+1;\n\t}\n\n\tint n=0;\n\tif((b>>5)==-2){//110x xxxx\n\t\tn=1;\n\t}else if((b>>4)==-2){//1110 xxxx\n\t\tn=2;\n\t}else if((b>>3)==-2){//11110 xxxx\n\t\tn=3;\n\t}else if((b>>2)==-2){//111110 xxxx\n\t\tn=4;\n\t}else{\n\t\tthrow new IllegalArgumentException(\"Malformed octet sequence at index \"+i);\n\t}\n\n\tint bits=b&0xF;\n\tint c=0;\n\tfor(int j=0;j<n;j++){\n\t\tb=bb.get(i+j+1);\n\t\tif((b>>6)!=2){\n\t\t\tthrow new IllegalArgumentException(\"Malformed UTF-8", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=i+1;\n\tif(j>=bb.limit())throw new IllegalArgumentException(\"Invalid UTF-8 encoding\");\n\tbyte b=bb.get(j);\n\tif((b&0x80)==0){\n\t\tsb.append((char)b);\n\t\treturn j;\n\t}\n\tj=decodeSecondOctet(j,bb,sb);\n\tif((j+1)>=bb.limit())throw new IllegalArgumentException(\"Invalid UTF-8 encoding\");\n\tb=bb.get(j);\n\tif((b&0x80)!=0)j=decodeThirdOctet(j,bb,sb);\n\treturn j;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=bb.position()+i;\n\twhile(i<bb.limit()){\n\t\tint c=bb.get(j++)&0xff;\n\t\tif(c<0x80){//0xxxxxxx\n\t\t\tsb.append((char)c);\n\t\t\ti++;\n\t\t}else if(c<0xc0){//10xxxxxx\n\t\t\tbreak;\n\t\t}else if(c<0xe0){//110xxxxx\n\t\t\tif(j>=bb.limit())break;\n\t\t\tsb.append((char)(((c&0x1f)<<6)|(bb.get(j++)&0x3f)));\n\t\t\ti+=2;\n\t\t}else if(c<0xf0){//1110xxxx\n\t\t\tif(j+1>=bb.limit())break;\n\t\t\tsb.append((char)(((c&0x0f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x3f)));\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=i;\n\tint b=bb.get(j++);\n\tif(b>=0){\n\t\tsb.append((char)b);\n\t\treturn j;\n\t}\n\tif((b&0xe0)==0xc0){\n\t\tsb.append((char)(((b&0x1f)<<6)|(bb.get(j++)&0x3f)));\n\t\treturn j;\n\t}\n\tif((b&0xf0)==0xe0){\n\t\tsb.append((char)(((b&0x0f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x3f)));\n\t\treturn j;\n\t}\n\tif((b&0xf8)==0xf0){\n\t\tsb.append((char)(((b&0x07)<<18)|((bb.get(j++)&0x3f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint c=bb.get(i)&0xff;\n\tif((c&0x80)==0){// 0xxxxxxx\n\t\tsb.append((char)c);\n\t\treturn i+1;\n\t}else if((c&0xe0)==0xc0){// 110xxxxx\n\t\tint c2=bb.get(i+1)&0xff;\n\t\tif((c2&0xc0)!=0x80){\n\t\t\tthrow new IllegalArgumentException(\"Bad UTF-8 encoding of character at index \"+i);\n\t\t}\n\t\tsb.append((char)(((c&0x1f)<<6)|(c2&0x3f)));\n\t\treturn i+2;\n\t}else if((c&0xf0)==0xe0){// 1110xxxx\n\t\tint c2=bb.get(i+1)&0xff;\n\t\tif((c2&0xc0)!=0x80){\n\t\t\tthrow new IllegalArgumentException(\"Bad UTF-8 encoding of character at index \"+i);\n\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\t//Isolate the octets\n\tint b1=bb.get(i++);if(b1>=0)return i;\n\tint b2=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\tint b3=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\tint b4=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\t//Decode octets\n\treturn decodeOctets(b1,b2,b3,b4,sb);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\t//Decode UTF-8 octets.\n\twhile(true){\n\t\tif(bb.hasRemaining()){\n\t\t\tbyte b=bb.get();\n\t\t\tif(b<0){\n\t\t\t\tif((b&192)==128){ //10xxxxxx\n\t\t\t\t\tsb.append((char)(b&63));\n\t\t\t\t}else if((b&224)==192){ //110xxxxx\n\t\t\t\t\tbyte c=bb.get();\n\t\t\t\t\tif((c&192)==128){\n\t\t\t\t\t\tsb.append((char)(((b&31)<<6)|(c&63)));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid UTF-8 encoding at \"+(i+1));\n\t\t\t\t\t}\n\t\t\t\t}else if((b&240)==224){ //1110xxxx\n\t\t\t\t\tbyte c=bb.get();\n\t\t\t\t\tbyte d=bb.get();\n\t\t\t\t\tif(((", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n    char c;\n    if(i+1>=bb.limit())return -1;\n    if(i+2>=bb.limit())return -1;\n    if(i+3>=bb.limit())return -1;\n    c=(char)(bb.get(i+0)&0xFF);\n    if(c>=0x00&&c<=0x7F){\n        sb.append(c);\n        return i+1;\n    }\n    c=(char)(bb.get(i+1)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    c=(char)(bb.get(i+2)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    c=(char)(bb.get(i+3)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    int cp=((bb.get(i+0)&0xFF)<<18)\n          |((", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\nwhile(bb.hasRemaining()){\nint c=bb.get()&0xFF;\nint n=0;\nif((c&0x80)==0){n=1;}\nelse if((c&0xE0)==0xC0){n=2;}\nelse if((c&0xF0)==0xE0){n=3;}\nelse if((c&0xF8)==0xF0){n=4;}\nelse if((c&0xFC)==0xF8){n=5;}\nelse if((c&0xFE)==0xFC){n=6;}\nelse{throw new IllegalStateException(\"Invalid UTF-8 leading octet \"+c);}\nif(n>bb.remaining()){\nthrow new IllegalStateException(\"Incomplete UTF-8 sequence of \"+n+\" octets starting at index \"+i);}\nif(n==2){\nif((c&0x1E)!=0){throw new IllegalStateException(\"Invalid UTF-8 2-octet sequence \"+c+\" \"+bb.get(bb.position()));}\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint b;\n\tint cp;\n\tint m;\n\tint n;\n\twhile(i<bb.limit()){\n\t\tb=bb.get(i++)&0xff;\n\t\tif(b<128){sb.append((char)b);continue;}\n\t\tm=0;n=0;\n\t\tif((b&0xe0)==0xc0){m=0x1f;cp=b&0x1f;n=1;}\n\t\telse if((b&0xf0)==0xe0){m=0x0f;cp=b&0x0f;n=2;}\n\t\telse if((b&0xf8)==0xf0){m=0x07;cp=b&0x07;n=3;}\n\t\telse if((b&0xfc)==0xf8){m=0x03;cp=b&0x03;n=4;}\n\t\telse if((b&0xfe)==0xfc){m=0x01;cp=b&0x01;n=5;}\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decodes octets to characters using the UTF-8 decoding and appends the characters to a StringBuffer.\n * @return the index to the next unchecked character in the string to decode\n */\n", "method_name": "decodeOctets", "codes": ["private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tbyte b=bb.get(i);\n\tif(b>=0){\n\t\tsb.append((char)b);\n\t\treturn i+1;\n\t}\n\n\tint n=0;\n\tif((b>>5)==-2){//110x xxxx\n\t\tn=1;\n\t}else if((b>>4)==-2){//1110 xxxx\n\t\tn=2;\n\t}else if((b>>3)==-2){//11110 xxxx\n\t\tn=3;\n\t}else if((b>>2)==-2){//111110 xxxx\n\t\tn=4;\n\t}else{\n\t\tthrow new IllegalArgumentException(\"Malformed octet sequence at index \"+i);\n\t}\n\n\tint bits=b&0xF;\n\tint c=0;\n\tfor(int j=0;j<n;j++){\n\t\tb=bb.get(i+j+1);\n\t\tif((b>>6)!=2){\n\t\t\tthrow new IllegalArgumentException(\"Malformed UTF-8", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=i+1;\n\tif(j>=bb.limit())throw new IllegalArgumentException(\"Invalid UTF-8 encoding\");\n\tbyte b=bb.get(j);\n\tif((b&0x80)==0){\n\t\tsb.append((char)b);\n\t\treturn j;\n\t}\n\tj=decodeSecondOctet(j,bb,sb);\n\tif((j+1)>=bb.limit())throw new IllegalArgumentException(\"Invalid UTF-8 encoding\");\n\tb=bb.get(j);\n\tif((b&0x80)!=0)j=decodeThirdOctet(j,bb,sb);\n\treturn j;\n}", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=bb.position()+i;\n\twhile(i<bb.limit()){\n\t\tint c=bb.get(j++)&0xff;\n\t\tif(c<0x80){//0xxxxxxx\n\t\t\tsb.append((char)c);\n\t\t\ti++;\n\t\t}else if(c<0xc0){//10xxxxxx\n\t\t\tbreak;\n\t\t}else if(c<0xe0){//110xxxxx\n\t\t\tif(j>=bb.limit())break;\n\t\t\tsb.append((char)(((c&0x1f)<<6)|(bb.get(j++)&0x3f)));\n\t\t\ti+=2;\n\t\t}else if(c<0xf0){//1110xxxx\n\t\t\tif(j+1>=bb.limit())break;\n\t\t\tsb.append((char)(((c&0x0f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x3f)));\n", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint j=i;\n\tint b=bb.get(j++);\n\tif(b>=0){\n\t\tsb.append((char)b);\n\t\treturn j;\n\t}\n\tif((b&0xe0)==0xc0){\n\t\tsb.append((char)(((b&0x1f)<<6)|(bb.get(j++)&0x3f)));\n\t\treturn j;\n\t}\n\tif((b&0xf0)==0xe0){\n\t\tsb.append((char)(((b&0x0f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x3f)));\n\t\treturn j;\n\t}\n\tif((b&0xf8)==0xf0){\n\t\tsb.append((char)(((b&0x07)<<18)|((bb.get(j++)&0x3f)<<12)|((bb.get(j++)&0x3f)<<6)|(bb.get(j++)&0x", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint c=bb.get(i)&0xff;\n\tif((c&0x80)==0){// 0xxxxxxx\n\t\tsb.append((char)c);\n\t\treturn i+1;\n\t}else if((c&0xe0)==0xc0){// 110xxxxx\n\t\tint c2=bb.get(i+1)&0xff;\n\t\tif((c2&0xc0)!=0x80){\n\t\t\tthrow new IllegalArgumentException(\"Bad UTF-8 encoding of character at index \"+i);\n\t\t}\n\t\tsb.append((char)(((c&0x1f)<<6)|(c2&0x3f)));\n\t\treturn i+2;\n\t}else if((c&0xf0)==0xe0){// 1110xxxx\n\t\tint c2=bb.get(i+1)&0xff;\n\t\tif((c2&0xc0)!=0x80){\n\t\t\tthrow new IllegalArgumentException(\"Bad UTF-8 encoding of character at index \"+i);\n\t\t", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\t//Isolate the octets\n\tint b1=bb.get(i++);if(b1>=0)return i;\n\tint b2=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\tint b3=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\tint b4=bb.get(i++);if(b2>=0)return decodeOctet(b1,sb);\n\t//Decode octets\n\treturn decodeOctets(b1,b2,b3,b4,sb);\n}", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\t//Decode UTF-8 octets.\n\twhile(true){\n\t\tif(bb.hasRemaining()){\n\t\t\tbyte b=bb.get();\n\t\t\tif(b<0){\n\t\t\t\tif((b&192)==128){ //10xxxxxx\n\t\t\t\t\tsb.append((char)(b&63));\n\t\t\t\t}else if((b&224)==192){ //110xxxxx\n\t\t\t\t\tbyte c=bb.get();\n\t\t\t\t\tif((c&192)==128){\n\t\t\t\t\t\tsb.append((char)(((b&31)<<6)|(c&63)));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid UTF-8 encoding at \"+(i+1));\n\t\t\t\t\t}\n\t\t\t\t}else if((b&240)==224){ //1110xxxx\n\t\t\t\t\tbyte c=bb.get();\n\t\t\t\t\tbyte d=bb.get();\n\t\t\t\t\tif(((", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n    char c;\n    if(i+1>=bb.limit())return -1;\n    if(i+2>=bb.limit())return -1;\n    if(i+3>=bb.limit())return -1;\n    c=(char)(bb.get(i+0)&0xFF);\n    if(c>=0x00&&c<=0x7F){\n        sb.append(c);\n        return i+1;\n    }\n    c=(char)(bb.get(i+1)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    c=(char)(bb.get(i+2)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    c=(char)(bb.get(i+3)&0xFF);\n    if(c<0x80||c>0xBF)return -1;\n    int cp=((bb.get(i+0)&0xFF)<<18)\n          |((", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\nwhile(bb.hasRemaining()){\nint c=bb.get()&0xFF;\nint n=0;\nif((c&0x80)==0){n=1;}\nelse if((c&0xE0)==0xC0){n=2;}\nelse if((c&0xF0)==0xE0){n=3;}\nelse if((c&0xF8)==0xF0){n=4;}\nelse if((c&0xFC)==0xF8){n=5;}\nelse if((c&0xFE)==0xFC){n=6;}\nelse{throw new IllegalStateException(\"Invalid UTF-8 leading octet \"+c);}\nif(n>bb.remaining()){\nthrow new IllegalStateException(\"Incomplete UTF-8 sequence of \"+n+\" octets starting at index \"+i);}\nif(n==2){\nif((c&0x1E)!=0){throw new IllegalStateException(\"Invalid UTF-8 2-octet sequence \"+c+\" \"+bb.get(bb.position()));}\n", "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n\n\tint b;\n\tint cp;\n\tint m;\n\tint n;\n\twhile(i<bb.limit()){\n\t\tb=bb.get(i++)&0xff;\n\t\tif(b<128){sb.append((char)b);continue;}\n\t\tm=0;n=0;\n\t\tif((b&0xe0)==0xc0){m=0x1f;cp=b&0x1f;n=1;}\n\t\telse if((b&0xf0)==0xe0){m=0x0f;cp=b&0x0f;n=2;}\n\t\telse if((b&0xf8)==0xf0){m=0x07;cp=b&0x07;n=3;}\n\t\telse if((b&0xfc)==0xf8){m=0x03;cp=b&0x03;n=4;}\n\t\telse if((b&0xfe)==0xfc){m=0x01;cp=b&0x01;n=5;}\n\t"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017457", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nif(!u.isAbsolute()){return null;}\nString rawPath=u.getRawPath();\nif(rawPath==null){return null;}\nint len=rawPath.length();\nif(len==0){return EMPTY_LIST;}\nList<PathSegmentImpl> l=new ArrayList<PathSegmentImpl>(8);\nint i=0;\nPathSegmentImpl s;\nwhile(i<len){\ns=new PathSegmentImpl();\nint next=rawPath.indexOf('/',i);\nif(next==-1){next=len;}\nString tem=rawPath.substring(i,next);\nif(tem.length()>0){\nif(decode){s.setPath(UriComponent.decode(tem,UriComponent.PATH));}\nelse{s.setPath(tem);}\n}\nl.add(s);\ni=next+1;\n}\nreturn l;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n// BEGIN android-changed\n    CharSequence seq=u.getRawPath();\n// END android-changed\n    if(seq==null||seq.length()==0){\n        return Collections.emptyList();\n    }\n    String[] a=seq.toString().split(\"/\");\n    List<PathSegmentImpl> l=new ArrayList<PathSegmentImpl>(a.length);\n    for(int i=0;i<a.length;i++){\n        l.add(new PathSegmentImpl(a[i],decode));\n    }\n    return l;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn decodePath(u.getRawPath(),decode);}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn PathTemplate.decodePath(u,decode);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nList<String> segments=u.getPathSegments(decode);\nif(segments.isEmpty()){\nreturn Collections.emptyList();\n}\nList<PathSegmentImpl> result=new ArrayList<PathSegmentImpl>(segments.size());\nfor(String segment:segments){\nresult.add(new PathSegmentImpl(segment,decode));\n}\nreturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn decodePath(u.getRawPath(),decode);}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n    String path=u.getRawPath();\n    if(path==null){\n        return Collections.emptyList();\n    }\n    return decodePath(path,decode);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nif(u.getRawPath()==null){\nreturn Collections.emptyList();\n}\nString[] segments=u.getRawPath().split(\"/\");\nList<PathSegmentImpl> list=new ArrayList<PathSegmentImpl>(segments.length);\nfor(String segment:segments){\nlist.add(new PathSegmentImpl(segment,decode));\n}\nreturn list;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n\tList<PathSegmentImpl> segments=new ArrayList<PathSegmentImpl>();\n\tString path=u.getRawPath();\n\tif(path!=null){\n\t\tStringTokenizer paths=new StringTokenizer(path,\"/\");\n\t\twhile(paths.hasMoreTokens()){\n\t\t\tString pathSegment=paths.nextToken();\n\t\t\tsegments.add(new PathSegmentImpl(pathSegment,decode));\n\t\t}\n\t}\n\treturn segments;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n\tList<PathSegment> l=u.getPathSegments();\n\tList<PathSegmentImpl> r=new ArrayList<PathSegmentImpl>();\n\tfor(PathSegment s:l){\n\t\tString p=s.getPath();\n\t\tString m=s.getMatrixParameters().toString();\n\t\tString d;\n\t\tif(decode){\n\t\t\td=decode(p);\n\t\t}else{\n\t\t\td=p;\n\t\t}\n\t\tr.add(new PathSegmentImpl(d,m));\n\t}\n\treturn r;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n", "method_name": "decodePath", "codes": ["public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nif(!u.isAbsolute()){return null;}\nString rawPath=u.getRawPath();\nif(rawPath==null){return null;}\nint len=rawPath.length();\nif(len==0){return EMPTY_LIST;}\nList<PathSegmentImpl> l=new ArrayList<PathSegmentImpl>(8);\nint i=0;\nPathSegmentImpl s;\nwhile(i<len){\ns=new PathSegmentImpl();\nint next=rawPath.indexOf('/',i);\nif(next==-1){next=len;}\nString tem=rawPath.substring(i,next);\nif(tem.length()>0){\nif(decode){s.setPath(UriComponent.decode(tem,UriComponent.PATH));}\nelse{s.setPath(tem);}\n}\nl.add(s);\ni=next+1;\n}\nreturn l;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n// BEGIN android-changed\n    CharSequence seq=u.getRawPath();\n// END android-changed\n    if(seq==null||seq.length()==0){\n        return Collections.emptyList();\n    }\n    String[] a=seq.toString().split(\"/\");\n    List<PathSegmentImpl> l=new ArrayList<PathSegmentImpl>(a.length);\n    for(int i=0;i<a.length;i++){\n        l.add(new PathSegmentImpl(a[i],decode));\n    }\n    return l;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn decodePath(u.getRawPath(),decode);}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn PathTemplate.decodePath(u,decode);}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nList<String> segments=u.getPathSegments(decode);\nif(segments.isEmpty()){\nreturn Collections.emptyList();\n}\nList<PathSegmentImpl> result=new ArrayList<PathSegmentImpl>(segments.size());\nfor(String segment:segments){\nresult.add(new PathSegmentImpl(segment,decode));\n}\nreturn result;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\nreturn decodePath(u.getRawPath(),decode);}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n    String path=u.getRawPath();\n    if(path==null){\n        return Collections.emptyList();\n    }\n    return decodePath(path,decode);\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\nif(u.getRawPath()==null){\nreturn Collections.emptyList();\n}\nString[] segments=u.getRawPath().split(\"/\");\nList<PathSegmentImpl> list=new ArrayList<PathSegmentImpl>(segments.length);\nfor(String segment:segments){\nlist.add(new PathSegmentImpl(segment,decode));\n}\nreturn list;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n\tList<PathSegmentImpl> segments=new ArrayList<PathSegmentImpl>();\n\tString path=u.getRawPath();\n\tif(path!=null){\n\t\tStringTokenizer paths=new StringTokenizer(path,\"/\");\n\t\twhile(paths.hasMoreTokens()){\n\t\t\tString pathSegment=paths.nextToken();\n\t\t\tsegments.add(new PathSegmentImpl(pathSegment,decode));\n\t\t}\n\t}\n\treturn segments;\n}", "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n\n\tList<PathSegment> l=u.getPathSegments();\n\tList<PathSegmentImpl> r=new ArrayList<PathSegmentImpl>();\n\tfor(PathSegment s:l){\n\t\tString p=s.getPath();\n\t\tString m=s.getMatrixParameters().toString();\n\t\tString d;\n\t\tif(decode){\n\t\t\td=decode(p);\n\t\t}else{\n\t\t\td=p;\n\t\t}\n\t\tr.add(new PathSegmentImpl(d,m));\n\t}\n\treturn r;\n}"], "code_level": "slib_runnable", "_id": "6367667f1a6d9265ec01745d", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public final MatchResult match(CharSequence uri){\n\n\treturn match(uri,0,uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\nreturn getMatcher(uri).match();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null)\n\t\tthrow new IllegalArgumentException(\"uri is null.\");\n\tMatcher matcher=pattern.matcher(uri);\n\treturn matcher.matches()?new MatchResult(uri,matcher):null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n    if (uri==null)\n        return null;\n\n    if (pattern.length()==0)\n        return (uri.length()==0)?new MatchResult(0,0):null;\n\n    if (pattern.equals(uri))\n        return new MatchResult(0,pattern.length());\n\n    if (pattern.charAt(0)=='*')\n        return matchTail(uri,pattern.substring(1,pattern.length()));\n    else if (pattern.charAt(0)=='{')\n        return matchGroup(uri,pattern);\n    else\n        return matchHead(uri,pattern);\n}\n\n/**\n * match head\n * @param uri\n * @param pattern\n * @return\n */\nprivate MatchResult matchHead(CharSequence uri, CharSequence pattern){\n    int i=0;\n    int j=0;\n    while (i<uri.length() && j<pattern.length() &&\n           uri.charAt(i)==pattern.charAt(j)){\n        i++;\n        j++;\n    }\n\n    if (j==", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null) return null;\n\t\n\t//to lower case\n\turi=uri.toString().toLowerCase();\n\t\n\t//match start\n\tint i=0;\n\tint j=0;\n\t\n\t//match result\n\tMatchResult result=new MatchResult();\n\t\n\t//match the first character\n\tif(uri.charAt(i)!=pattern.charAt(j)){\n\t\treturn null;\n\t}\n\t\n\t//match the pattern\n\twhile(i<uri.length() && j<pattern.length()){\n\t\tif(uri.charAt(i)==pattern.charAt(j)){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}else if(pattern.charAt(j)=='*'){\n\t\t\tresult.add(uri.subSequence(i, uri.length()).toString());\n\t\t\tj++;\n\t\t}else if(pattern.charAt(j)=='{'){\n\t\t\tint next=pattern.indexOf('}', j);\n\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\tMatcher m=pattern.matcher(uri);\n\tif(m.matches())return m.toMatchResult();\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\treturn match(uri,0,uri.length());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\tif(this.pattern.matcher(uri).matches()) {\n\t\treturn this.matchResult;\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n    if(uri == null) return null;\n    final Matcher matcher = pattern.matcher(uri);\n    return matcher.find() ? matcher.toMatchResult() : null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null)return null;\n\tMatcher m=pattern.matcher(uri);\n\tif(m.find())return m.toMatchResult();\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Match a URI against the pattern.\n * @param uri the uri to match against the template.\n * @return the match result, otherwise null if no match occurs.\n */\n", "method_name": "match", "codes": ["public final MatchResult match(CharSequence uri){\n\n\treturn match(uri,0,uri.length());\n}", "public final MatchResult match(CharSequence uri){\n\nreturn getMatcher(uri).match();\n}", "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null)\n\t\tthrow new IllegalArgumentException(\"uri is null.\");\n\tMatcher matcher=pattern.matcher(uri);\n\treturn matcher.matches()?new MatchResult(uri,matcher):null;\n}", "public final MatchResult match(CharSequence uri){\n\n    if (uri==null)\n        return null;\n\n    if (pattern.length()==0)\n        return (uri.length()==0)?new MatchResult(0,0):null;\n\n    if (pattern.equals(uri))\n        return new MatchResult(0,pattern.length());\n\n    if (pattern.charAt(0)=='*')\n        return matchTail(uri,pattern.substring(1,pattern.length()));\n    else if (pattern.charAt(0)=='{')\n        return matchGroup(uri,pattern);\n    else\n        return matchHead(uri,pattern);\n}\n\n/**\n * match head\n * @param uri\n * @param pattern\n * @return\n */\nprivate MatchResult matchHead(CharSequence uri, CharSequence pattern){\n    int i=0;\n    int j=0;\n    while (i<uri.length() && j<pattern.length() &&\n           uri.charAt(i)==pattern.charAt(j)){\n        i++;\n        j++;\n    }\n\n    if (j==", "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null) return null;\n\t\n\t//to lower case\n\turi=uri.toString().toLowerCase();\n\t\n\t//match start\n\tint i=0;\n\tint j=0;\n\t\n\t//match result\n\tMatchResult result=new MatchResult();\n\t\n\t//match the first character\n\tif(uri.charAt(i)!=pattern.charAt(j)){\n\t\treturn null;\n\t}\n\t\n\t//match the pattern\n\twhile(i<uri.length() && j<pattern.length()){\n\t\tif(uri.charAt(i)==pattern.charAt(j)){\n\t\t\ti++;\n\t\t\tj++;\n\t\t}else if(pattern.charAt(j)=='*'){\n\t\t\tresult.add(uri.subSequence(i, uri.length()).toString());\n\t\t\tj++;\n\t\t}else if(pattern.charAt(j)=='{'){\n\t\t\tint next=pattern.indexOf('}', j);\n\t\t\t", "public final MatchResult match(CharSequence uri){\n\n\tMatcher m=pattern.matcher(uri);\n\tif(m.matches())return m.toMatchResult();\n\treturn null;\n}", "public final MatchResult match(CharSequence uri){\n\n\treturn match(uri,0,uri.length());\n}", "public final MatchResult match(CharSequence uri){\n\n\tif(this.pattern.matcher(uri).matches()) {\n\t\treturn this.matchResult;\n\t}\n\treturn null;\n}", "public final MatchResult match(CharSequence uri){\n\n    if(uri == null) return null;\n    final Matcher matcher = pattern.matcher(uri);\n    return matcher.find() ? matcher.toMatchResult() : null;\n}", "public final MatchResult match(CharSequence uri){\n\n\tif(uri==null)return null;\n\tMatcher m=pattern.matcher(uri);\n\tif(m.find())return m.toMatchResult();\n\treturn null;\n}"], "code_level": "project_runnable", "_id": "636766861a6d9265ec01755a", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\tif(this.isEmpty())return false;\n\tif(name==null)return false;\n\tname=name.trim();\n\tif(name.length()==0)return false;\n\treturn this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\tif(name==null||\"\".equals(name))return false;\n\tif(templateVariables.containsKey(name))return true;\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\tif(name == null){\n\t\tthrow new NullPointerException();\n\t}\n\treturn (this.variables.containsKey(name));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\tif(this.templateVariables==null||this.templateVariables.isEmpty()){\n\t\treturn false;\n\t}\n\treturn this.templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Ascertain if a template variable is a member of this template.\n * @param name name The template variable.\n * @return true if the template variable is a member of the template, otherwisefalse.\n */\n", "method_name": "isTemplateVariablePresent", "codes": ["public final boolean isTemplateVariablePresent(String name){\n\n\treturn this.templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\tif(this.isEmpty())return false;\n\tif(name==null)return false;\n\tname=name.trim();\n\tif(name.length()==0)return false;\n\treturn this.templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\treturn this.templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\tif(name==null||\"\".equals(name))return false;\n\tif(templateVariables.containsKey(name))return true;\n\treturn false;\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\tif(name == null){\n\t\tthrow new NullPointerException();\n\t}\n\treturn (this.variables.containsKey(name));\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\tif(this.templateVariables==null||this.templateVariables.isEmpty()){\n\t\treturn false;\n\t}\n\treturn this.templateVariables.containsKey(name);\n}", "public final boolean isTemplateVariablePresent(String name){\n\n\treturn templateVariables.containsKey(name);\n}"], "code_level": "class_runnable", "_id": "636766861a6d9265ec017553", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String encodeTemplateNames(String s){\n\n\tStringBuffer buf=new StringBuffer();\n\tint len=s.length();\n\tfor(int i=0;i<len;i++){\n\t\tchar c=s.charAt(i);\n\t\tif(c=='{')\n\t\t\tbuf.append(Template.START_MARKER);\n\t\telse if(c=='}')\n\t\t\tbuf.append(Template.END_MARKER);\n\t\telse\n\t\t\tbuf.append(c);\n\t}\n\treturn buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\tStringBuffer b=new StringBuffer(s.length()+s.length()/10);\n\tfor(int i=0;i<s.length();++i){\n\t\tchar c=s.charAt(i);\n\t\tif(c=='{') b.append(templateNameOpen);\n\t\telse if(c=='}') b.append(templateNameClose);\n\t\telse b.append(c);\n\t\t}\n\treturn b.toString();\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\tStringBuffer temp=new StringBuffer(s);\n\tfor(int i=0;i<temp.length();i++)\n\t\tif(temp.charAt(i)=='{')\n\t\t\ttemp.setCharAt(i,OPEN_TEMPLATE);\n\t\telse if(temp.charAt(i)=='}')\n\t\t\ttemp.setCharAt(i,CLOSE_TEMPLATE);\n\treturn temp.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\nif(s==null)return \"\";\nfor(int i=0;i<s.length();i++){\nif(s.charAt(i)=='{'||s.charAt(i)=='}'){\ns=s.substring(0,i)+\"$\"+s.substring(i+1);\n}\n}\nreturn s;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\treturn s.replace(\"{\",\"<\").replace(\"}\",\">\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n  if(s==null)return null;\n  StringBuffer sb=new StringBuffer();\n  StringTokenizer st = new StringTokenizer(s, \"{}\", true);\n  while(st.hasMoreTokens()){\n    String tok = st.nextToken();\n    if(tok.equals(\"{\")){\n      sb.append(TEMPLATE_NAME_ENCODE_CHAR);\n    }else if(tok.equals(\"}\")){\n      sb.append(TEMPLATE_NAME_ENCODE_CHAR);\n    }else{\n      sb.append(tok);\n    }\n  }\n  return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\tchar c1='\\u2329';\n\tchar c2='\\u232A';\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='{'){\n\t\t\tsb.append(c1);\n\t\t}\n\t\telse if(s.charAt(i)=='}'){\n\t\t\tsb.append(c2);\n\t\t}\n\t\telse{\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\tString result=s;\n\tresult=result.replace(\"{\",\"<\");\n\tresult=result.replace(\"}\",\">\");\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='{')sb.append(template_start_char);\n\t\telse if(s.charAt(i)=='}')sb.append(template_end_char);\n\t\telse sb.append(s.charAt(i));\n\t}\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String encodeTemplateNames(String s){\n\nreturn s.replaceAll(\"\\\\{\",\"&#123;\").replaceAll(\"\\\\}\",\"&#125;\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Encodes a string with template parameters names present, specifically the characters '{' and '}' will be percent-encoded.\n * @param s the string with zero or more template parameters names\n * @return the string with encoded template parameters names.\n */\n", "method_name": "encodeTemplateNames", "codes": ["public static String encodeTemplateNames(String s){\n\n\tStringBuffer buf=new StringBuffer();\n\tint len=s.length();\n\tfor(int i=0;i<len;i++){\n\t\tchar c=s.charAt(i);\n\t\tif(c=='{')\n\t\t\tbuf.append(Template.START_MARKER);\n\t\telse if(c=='}')\n\t\t\tbuf.append(Template.END_MARKER);\n\t\telse\n\t\t\tbuf.append(c);\n\t}\n\treturn buf.toString();\n}", "public static String encodeTemplateNames(String s){\n\n\tStringBuffer b=new StringBuffer(s.length()+s.length()/10);\n\tfor(int i=0;i<s.length();++i){\n\t\tchar c=s.charAt(i);\n\t\tif(c=='{') b.append(templateNameOpen);\n\t\telse if(c=='}') b.append(templateNameClose);\n\t\telse b.append(c);\n\t\t}\n\treturn b.toString();\n\t}", "public static String encodeTemplateNames(String s){\n\n\tStringBuffer temp=new StringBuffer(s);\n\tfor(int i=0;i<temp.length();i++)\n\t\tif(temp.charAt(i)=='{')\n\t\t\ttemp.setCharAt(i,OPEN_TEMPLATE);\n\t\telse if(temp.charAt(i)=='}')\n\t\t\ttemp.setCharAt(i,CLOSE_TEMPLATE);\n\treturn temp.toString();\n}", "public static String encodeTemplateNames(String s){\n\nif(s==null)return \"\";\nfor(int i=0;i<s.length();i++){\nif(s.charAt(i)=='{'||s.charAt(i)=='}'){\ns=s.substring(0,i)+\"$\"+s.substring(i+1);\n}\n}\nreturn s;\n}", "public static String encodeTemplateNames(String s){\n\n\treturn s.replace(\"{\",\"<\").replace(\"}\",\">\");\n}", "public static String encodeTemplateNames(String s){\n\n  if(s==null)return null;\n  StringBuffer sb=new StringBuffer();\n  StringTokenizer st = new StringTokenizer(s, \"{}\", true);\n  while(st.hasMoreTokens()){\n    String tok = st.nextToken();\n    if(tok.equals(\"{\")){\n      sb.append(TEMPLATE_NAME_ENCODE_CHAR);\n    }else if(tok.equals(\"}\")){\n      sb.append(TEMPLATE_NAME_ENCODE_CHAR);\n    }else{\n      sb.append(tok);\n    }\n  }\n  return sb.toString();\n}", "public static String encodeTemplateNames(String s){\n\n\tchar c1='\\u2329';\n\tchar c2='\\u232A';\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='{'){\n\t\t\tsb.append(c1);\n\t\t}\n\t\telse if(s.charAt(i)=='}'){\n\t\t\tsb.append(c2);\n\t\t}\n\t\telse{\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n\n\tString result=s;\n\tresult=result.replace(\"{\",\"<\");\n\tresult=result.replace(\"}\",\">\");\n\treturn result;\n}", "public static String encodeTemplateNames(String s){\n\n\tStringBuffer sb=new StringBuffer();\n\tfor(int i=0;i<s.length();i++){\n\t\tif(s.charAt(i)=='{')sb.append(template_start_char);\n\t\telse if(s.charAt(i)=='}')sb.append(template_end_char);\n\t\telse sb.append(s.charAt(i));\n\t}\n\treturn sb.toString();\n}", "public static String encodeTemplateNames(String s){\n\nreturn s.replaceAll(\"\\\\{\",\"&#123;\").replaceAll(\"\\\\}\",\"&#125;\");\n}"], "code_level": "self_contained", "_id": "636766801a6d9265ec017487", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif(!dir.endsWith(\"/\"))dir=dir+\"/\";\n\tFile dirF=new File(dir);\n\tif(!dirF.exists())return;\n\tFile[] files=dirF.listFiles();\n\tfor(int i=0;i<files.length;i++){\n\t\tif(files[i].getName().endsWith(\".jar\")){\n\t\t\ttry{cpV.add(files[i].toURL());}catch(Exception e){e.printStackTrace();}\n\t\t}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif(dir==null)return;\n\tif(dir.length()==0)return;\n\tFile dirF=new File(dir);\n\tif(!dirF.exists())return;\n\tif(!dirF.isDirectory())return;\n\tFile[] fs=dirF.listFiles();\n\tif(fs==null)return;\n\tfor(File f:fs){\n\t\tif(!f.getAbsolutePath().toLowerCase().endsWith(\".jar\"))continue;\n\t\ttry{\n\t\t\tcpV.add(f.toURI().toURL());\n\t\t}catch(Exception e){e.printStackTrace();}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(dirF.isDirectory()){\n\t\tString[] files=dirF.list();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tFile f=new File(dirF,files[i]);\n\t\t\tif(f.isFile()){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(f.toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\tSystem.out.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(!dirF.exists()){\n\t\tSystem.out.println(\"The directory \"+dir+\" does not exist. Exiting.\");\n\t\tSystem.exit(1);\n\t}\n\tString[] jarFiles=dirF.list(new JarFilter());\n\tfor(int i=0;i<jarFiles.length;i++){\n\t\ttry{\n\t\t\tcpV.add(new URL(\"jar:file:\"+dir+\"/\"+jarFiles[i]+\"!/\"));\n\t\t}catch(MalformedURLException e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\ttry{\n\t\tFile d=new File(dir);\n\t\tif(!d.exists()) return;\n\t\tFile[] files=d.listFiles();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tFile f=files[i];\n\t\t\tif(f.isFile() && f.getName().endsWith(\".jar\")){\n\t\t\t\tcpV.add(f.toURL());\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\t\tFile dirF=new File(dir);\n\t\tif(!dirF.exists()){System.err.println(\"Dir not found: \"+dir);return;}\n\t\tif(!dirF.isDirectory()){System.err.println(\"Not a dir: \"+dir);return;}\n\t\tFile[] files=dirF.listFiles();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tString name=files[i].getName();\n\t\t\tif(name.endsWith(\".jar\")){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(files[i].toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\tSystem.err.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n    try{\n      File fdir=new File(dir);\n      if(!fdir.isDirectory())return;\n      String[] jars=fdir.list(new FilenameFilter(){\n        public boolean accept(File arg0,String arg1){\n          if(arg1.endsWith(\".jar\")||arg1.endsWith(\".zip\"))return true;\n          return false;\n        }\n      });\n      for(int i=0;i<jars.length;i++){\n        cpV.add(new URL(\"file://\"+dir+\"/\"+jars[i]));\n      }\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(!dirF.exists() || !dirF.isDirectory()) return;\n\tFile[] files=dirF.listFiles();\n\tfor(int i=0;i<files.length;i++){\n\t\tif(files[i].isDirectory()) addToClassPath(cpV,files[i].getAbsolutePath());\n\t\telse{\n\t\t\tString name=files[i].getName();\n\t\t\tif(name.endsWith(\".jar\")){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(files[i].toURI().toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif (dir == null) return;\n\tFile dirF = new File(dir);\n\tif (!dirF.exists()) return;\n\tif (!dirF.isDirectory()) {\n\t\tif (dir.endsWith(\".jar\")) {\n\t\t\ttry {cpV.add(new URL(\"file://\" + dir));} catch (Exception e) {e.printStackTrace(System.err);}\n\t\t}\n\t\treturn;\n\t}\n\tString[] files = dirF.list();\n\tfor (int i = 0; i < files.length; i++) {\n\t\tif (files[i].endsWith(\".jar\")) {\n\t\t\ttry {cpV.add(new URL(\"file://\" + dir + files[i]));} catch (Exception e) {e.printStackTrace(System.err);}\n\t\t}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\ttry{\n\t\tFile dirF=new File(dir);\n\t\tString[] files=dirF.list();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tif(files[i].endsWith(\".jar\")){\n\t\t\t\tURL url=new URL(\"file:\\\\\"+dir+\"\\\\\"+files[i]);\n\t\t\t\tcpV.add(url);\n\t\t\t}\n\t\t}\n\t}catch(Exception e){System.out.println(\"Error in Util.addToClassPath() \"+e.toString());}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n", "method_name": "addToClassPath", "codes": ["@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif(!dir.endsWith(\"/\"))dir=dir+\"/\";\n\tFile dirF=new File(dir);\n\tif(!dirF.exists())return;\n\tFile[] files=dirF.listFiles();\n\tfor(int i=0;i<files.length;i++){\n\t\tif(files[i].getName().endsWith(\".jar\")){\n\t\t\ttry{cpV.add(files[i].toURL());}catch(Exception e){e.printStackTrace();}\n\t\t}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif(dir==null)return;\n\tif(dir.length()==0)return;\n\tFile dirF=new File(dir);\n\tif(!dirF.exists())return;\n\tif(!dirF.isDirectory())return;\n\tFile[] fs=dirF.listFiles();\n\tif(fs==null)return;\n\tfor(File f:fs){\n\t\tif(!f.getAbsolutePath().toLowerCase().endsWith(\".jar\"))continue;\n\t\ttry{\n\t\t\tcpV.add(f.toURI().toURL());\n\t\t}catch(Exception e){e.printStackTrace();}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(dirF.isDirectory()){\n\t\tString[] files=dirF.list();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tFile f=new File(dirF,files[i]);\n\t\t\tif(f.isFile()){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(f.toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\tSystem.out.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(!dirF.exists()){\n\t\tSystem.out.println(\"The directory \"+dir+\" does not exist. Exiting.\");\n\t\tSystem.exit(1);\n\t}\n\tString[] jarFiles=dirF.list(new JarFilter());\n\tfor(int i=0;i<jarFiles.length;i++){\n\t\ttry{\n\t\t\tcpV.add(new URL(\"jar:file:\"+dir+\"/\"+jarFiles[i]+\"!/\"));\n\t\t}catch(MalformedURLException e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\ttry{\n\t\tFile d=new File(dir);\n\t\tif(!d.exists()) return;\n\t\tFile[] files=d.listFiles();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tFile f=files[i];\n\t\t\tif(f.isFile() && f.getName().endsWith(\".jar\")){\n\t\t\t\tcpV.add(f.toURL());\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\t\tFile dirF=new File(dir);\n\t\tif(!dirF.exists()){System.err.println(\"Dir not found: \"+dir);return;}\n\t\tif(!dirF.isDirectory()){System.err.println(\"Not a dir: \"+dir);return;}\n\t\tFile[] files=dirF.listFiles();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tString name=files[i].getName();\n\t\t\tif(name.endsWith(\".jar\")){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(files[i].toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\tSystem.err.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n    try{\n      File fdir=new File(dir);\n      if(!fdir.isDirectory())return;\n      String[] jars=fdir.list(new FilenameFilter(){\n        public boolean accept(File arg0,String arg1){\n          if(arg1.endsWith(\".jar\")||arg1.endsWith(\".zip\"))return true;\n          return false;\n        }\n      });\n      for(int i=0;i<jars.length;i++){\n        cpV.add(new URL(\"file://\"+dir+\"/\"+jars[i]));\n      }\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tFile dirF=new File(dir);\n\tif(!dirF.exists() || !dirF.isDirectory()) return;\n\tFile[] files=dirF.listFiles();\n\tfor(int i=0;i<files.length;i++){\n\t\tif(files[i].isDirectory()) addToClassPath(cpV,files[i].getAbsolutePath());\n\t\telse{\n\t\t\tString name=files[i].getName();\n\t\t\tif(name.endsWith(\".jar\")){\n\t\t\t\ttry{\n\t\t\t\t\tcpV.add(files[i].toURI().toURL());\n\t\t\t\t}catch(MalformedURLException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\tif (dir == null) return;\n\tFile dirF = new File(dir);\n\tif (!dirF.exists()) return;\n\tif (!dirF.isDirectory()) {\n\t\tif (dir.endsWith(\".jar\")) {\n\t\t\ttry {cpV.add(new URL(\"file://\" + dir));} catch (Exception e) {e.printStackTrace(System.err);}\n\t\t}\n\t\treturn;\n\t}\n\tString[] files = dirF.list();\n\tfor (int i = 0; i < files.length; i++) {\n\t\tif (files[i].endsWith(\".jar\")) {\n\t\t\ttry {cpV.add(new URL(\"file://\" + dir + files[i]));} catch (Exception e) {e.printStackTrace(System.err);}\n\t\t}\n\t}\n}", "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n\n\ttry{\n\t\tFile dirF=new File(dir);\n\t\tString[] files=dirF.list();\n\t\tfor(int i=0;i<files.length;i++){\n\t\t\tif(files[i].endsWith(\".jar\")){\n\t\t\t\tURL url=new URL(\"file:\\\\\"+dir+\"\\\\\"+files[i]);\n\t\t\t\tcpV.add(url);\n\t\t\t}\n\t\t}\n\t}catch(Exception e){System.out.println(\"Error in Util.addToClassPath() \"+e.toString());}\n}"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec01745c", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String capitalize(String name){\n\n\tchar[] charArray = name.toCharArray();\n\tcharArray[0] = Character.toUpperCase(charArray[0]);\n\tname = new String(charArray);\n\treturn name;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n    name = name.toLowerCase();\n    char[] nameArray = name.toCharArray();\n    nameArray[0] = Character.toUpperCase(nameArray[0]);\n    name = new String(nameArray);\n    return name;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n    String capitalizedName;\n    char [] nameArray = name.toCharArray();\n    if (nameArray[0] &gt;= 'a' &amp;&amp; nameArray[0] &lt;= 'z'){\n        nameArray[0] -= 32;\n    }\n    capitalizedName = new String(nameArray);\n    return capitalizedName;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\tchar[] array = name.toCharArray();\n\tarray[0] = Character.toUpperCase(array[0]);\n\treturn new String(array);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\tString first = name.substring(0, 1);\n\tString rest = name.substring(1, name.length());\n\tfirst = first.toUpperCase();\n\tString result = first + rest;\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\tString result = \"\";\n\tname = name.toLowerCase();\n\tresult+= name.charAt(0);\n\tresult+= name.substring(1,name.length());\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\tchar[] newName = name.toCharArray();\n\tnewName[0] = Character.toUpperCase(name.charAt(0));\n\treturn new String(newName);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n\t\tchar[] nameArray = name.toCharArray();\n\t\tnameArray[0] = Character.toUpperCase(nameArray[0]);\n\t\treturn new String(nameArray);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String capitalize(String name){\n\n    char[] namechars = name.toCharArray();\n    namechars[0] = Character.toUpperCase(namechars[0]);\n    String name_string = new String(namechars);\n    return name_string;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Reverse of Introspector.decapitalize\n */\n", "method_name": "capitalize", "codes": ["public static String capitalize(String name){\n\n\tchar[] charArray = name.toCharArray();\n\tcharArray[0] = Character.toUpperCase(charArray[0]);\n\tname = new String(charArray);\n\treturn name;\n}", "public static String capitalize(String name){\n\n    name = name.toLowerCase();\n    char[] nameArray = name.toCharArray();\n    nameArray[0] = Character.toUpperCase(nameArray[0]);\n    name = new String(nameArray);\n    return name;\n}", "public static String capitalize(String name){\n\n    String capitalizedName;\n    char [] nameArray = name.toCharArray();\n    if (nameArray[0] &gt;= 'a' &amp;&amp; nameArray[0] &lt;= 'z'){\n        nameArray[0] -= 32;\n    }\n    capitalizedName = new String(nameArray);\n    return capitalizedName;\n}", "public static String capitalize(String name){\n\n\tchar[] array = name.toCharArray();\n\tarray[0] = Character.toUpperCase(array[0]);\n\treturn new String(array);\n}", "public static String capitalize(String name){\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "public static String capitalize(String name){\n\n\tString first = name.substring(0, 1);\n\tString rest = name.substring(1, name.length());\n\tfirst = first.toUpperCase();\n\tString result = first + rest;\n\treturn result;\n}", "public static String capitalize(String name){\n\n\tString result = \"\";\n\tname = name.toLowerCase();\n\tresult+= name.charAt(0);\n\tresult+= name.substring(1,name.length());\n\treturn result;\n}", "public static String capitalize(String name){\n\n\tchar[] newName = name.toCharArray();\n\tnewName[0] = Character.toUpperCase(name.charAt(0));\n\treturn new String(newName);\n}", "public static String capitalize(String name){\n\n\t\tchar[] nameArray = name.toCharArray();\n\t\tnameArray[0] = Character.toUpperCase(nameArray[0]);\n\t\treturn new String(nameArray);\n}", "public static String capitalize(String name){\n\n    char[] namechars = name.toCharArray();\n    namechars[0] = Character.toUpperCase(namechars[0]);\n    String name_string = new String(namechars);\n    return name_string;\n}"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174bf", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n\treturn StringEscapeUtils.unescapeJava(str);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    StringBuffer unicode = new StringBuffer(4);\n    StringBuffer output = new StringBuffer(sz);\n    boolean hadSlash = false;\n    boolean inUnicode = false;\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        if (inUnicode) {\n            // if in unicode, then we're reading unicode\n            // values in somehow\n            unicode.append(ch);\n            if (unicode.length() == 4) {\n                // unicode now contains the four hex digits\n                // which represents our unicode character\n                try {\n                    int value = Integer.parseInt(unicode.toString(), 16);\n                    output.append((char) value);\n                    unicode.setLength(0);\n                    inUnicode = false;\n                    hadSlash = false;\n                } catch (NumberFormatException nfe) {\n                    throw new Exception(\"Unable to parse unic", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n\n    try {\n        StringWriter writer = new StringWriter(str.length());\n        unescapeJava(writer, str);\n        return writer.toString();\n    } catch (IOException ioe) {\n        // this should never ever happen while writing to a StringWriter\n        ioe.printStackTrace();\n        return null;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    StringWriter writer = new StringWriter(str.length());\n    unescapeJava(writer, str);\n    return writer.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    try {\n        StringWriter writer = new StringWriter(str.length());\n        unescapeJava(writer, str);\n        return writer.toString();\n    } catch (Exception e) {\n        throw new Exception(e);\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n    StringWriter writer = new StringWriter(str.length());\n    unescapeJava(writer, str);\n    return writer.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String unescapeJava(String str) throws Exception {\n\n\tint sz = str.length();\n\tStringBuilder out = new StringBuilder(sz);\n\tStringBuilder unicode = new StringBuilder(4);\n\tboolean hadSlash = false;\n\tboolean inUnicode = false;\n\tfor (int i = 0; i < sz; ++i) {\n\t\tchar ch = str.charAt(i);\n\t\tif (inUnicode) {\n\t\t\t// if in unicode, then we're reading unicode\n\t\t\t// values in somehow\n\t\t\tunicode.append(ch);\n\t\t\tif (unicode.length() == 4) {\n\t\t\t\t// unicode now contains the four hex digits\n\t\t\t\t// which represents our unicode character\n\t\t\t\ttry {\n\t\t\t\t\tint value = Integer.parseInt(unicode.toString(), 16);\n\t\t\t\t\tout.append((char) value);\n\t\t\t\t\tunicode.setLength(0);\n\t\t\t\t\tinUnicode = false;\n\t\t\t\t\thadSlash =", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n", "method_name": "unescapeJava", "codes": ["public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "public static String unescapeJava(String str) throws Exception {\n\n\treturn StringEscapeUtils.unescapeJava(str);\n}", "public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    StringBuffer unicode = new StringBuffer(4);\n    StringBuffer output = new StringBuffer(sz);\n    boolean hadSlash = false;\n    boolean inUnicode = false;\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        if (inUnicode) {\n            // if in unicode, then we're reading unicode\n            // values in somehow\n            unicode.append(ch);\n            if (unicode.length() == 4) {\n                // unicode now contains the four hex digits\n                // which represents our unicode character\n                try {\n                    int value = Integer.parseInt(unicode.toString(), 16);\n                    output.append((char) value);\n                    unicode.setLength(0);\n                    inUnicode = false;\n                    hadSlash = false;\n                } catch (NumberFormatException nfe) {\n                    throw new Exception(\"Unable to parse unic", "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n\n    try {\n        StringWriter writer = new StringWriter(str.length());\n        unescapeJava(writer, str);\n        return writer.toString();\n    } catch (IOException ioe) {\n        // this should never ever happen while writing to a StringWriter\n        ioe.printStackTrace();\n        return null;\n    }\n}", "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    StringWriter writer = new StringWriter(str.length());\n    unescapeJava(writer, str);\n    return writer.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\n    return StringEscapeUtils.unescapeJava(str);\n}", "public static String unescapeJava(String str) throws Exception {\n\n    if (str == null) {\n        return null;\n    }\n    try {\n        StringWriter writer = new StringWriter(str.length());\n        unescapeJava(writer, str);\n        return writer.toString();\n    } catch (Exception e) {\n        throw new Exception(e);\n    }\n}", "public static String unescapeJava(String str) throws Exception {\n\n    StringWriter writer = new StringWriter(str.length());\n    unescapeJava(writer, str);\n    return writer.toString();\n}", "public static String unescapeJava(String str) throws Exception {\n\n\tint sz = str.length();\n\tStringBuilder out = new StringBuilder(sz);\n\tStringBuilder unicode = new StringBuilder(4);\n\tboolean hadSlash = false;\n\tboolean inUnicode = false;\n\tfor (int i = 0; i < sz; ++i) {\n\t\tchar ch = str.charAt(i);\n\t\tif (inUnicode) {\n\t\t\t// if in unicode, then we're reading unicode\n\t\t\t// values in somehow\n\t\t\tunicode.append(ch);\n\t\t\tif (unicode.length() == 4) {\n\t\t\t\t// unicode now contains the four hex digits\n\t\t\t\t// which represents our unicode character\n\t\t\t\ttry {\n\t\t\t\t\tint value = Integer.parseInt(unicode.toString(), 16);\n\t\t\t\t\tout.append((char) value);\n\t\t\t\t\tunicode.setLength(0);\n\t\t\t\t\tinUnicode = false;\n\t\t\t\t\thadSlash ="], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec017401", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif(c<='9'){\n\t\treturn (char)(c-'0');\n\t}else if(c<='F'){\n\t\treturn (char)(c-'A'+10);\n\t}else if(c<='f'){\n\t\treturn (char)(c-'a'+10);\n\t}else{\n\t\tassert(false);\n\t\tthrow new IllegalArgumentException(\"Not a hex character: \"+(int)c);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\nswitch(c){\ncase '0':return '0';\ncase '1':return '1';\ncase '2':return '2';\ncase '3':return '3';\ncase '4':return '4';\ncase '5':return '5';\ncase '6':return '6';\ncase '7':return '7';\ncase '8':return '8';\ncase '9':return '9';\ncase 'A':case 'a':return 'A';\ncase 'B':case 'b':return 'B';\ncase 'C':case 'c':return 'C';\ncase 'D':case 'd':return 'D';\ncase 'E':case 'e':return 'E';\ncase 'F':case 'f':return 'F';\ndefault:return '\\0';\n}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9'){\n\t\treturn (char)(c-'0');\n\t}\n\tif(c>='A' && c<='F'){\n\t\treturn (char)(10+c-'A');\n\t}\n\tif(c>='a' && c<='f'){\n\t\treturn (char)(10+c-'a');\n\t}\n\tthrow new IllegalArgumentException(\"Invalid hex character '\"+c+\"'\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n    if('0'<=c && c<='9') return (char) (c-'0');\n    if('a'<=c && c<='f') return (char) (c-'a'+10);\n    if('A'<=c && c<='F') return (char) (c-'A'+10);\n    throw new IllegalArgumentException(\"Invalid hex character: \"+c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9')\n\t\treturn (char)(c-'0'); //0x30\n\tif(c>='A' && c<='F')\n\t\treturn (char)(c-'A'+10); //0x37\n\tif(c>='a' && c<='f')\n\t\treturn (char)(c-'a'+10); //0x57\n\treturn 0x00; //invalid character\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n  if(c >= '0' && c <= '9') return (char)(c - '0');\n  if(c >= 'A' && c <= 'F') return (char)(c - 'A' + 10);\n  if(c >= 'a' && c <= 'f') return (char)(c - 'a' + 10);\n  return 0;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n    if(c>='0' && c<='9')\n        return (char)(c-'0');\n    else if(c>='A' && c<='F')\n        return (char)(c-'A'+10);\n    else if(c>='a' && c<='f')\n        return (char)(c-'a'+10);\n    else\n        throw new IllegalArgumentException(\"Not a hex character: \"+c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif(c>='0'&&c<='9')return(char)(c-'0');\n\tif(c>='A'&&c<='F')return(char)(c-'A'+10);\n\tif(c>='a'&&c<='f')return(char)(c-'a'+10);\n\tthrow new IllegalArgumentException(\"Not a hex character: \"+c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9') return (char)(c-'0');\n\tif(c>='A' && c<='F') return (char)(c-'A'+10);\n\tif(c>='a' && c<='f') return (char)(c-'a'+10);\n\tthrow new IllegalArgumentException(\"Not a hex character: '\"+c+\"'\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static char decodeHexNibble(final char c){\n\n\tif('0'<=c && c<='9'){\n\t\treturn (char)(c-'0');\n\t}else if('a'<=c && c<='f'){\n\t\treturn (char)(c-'a'+10);\n\t}else if('A'<=c && c<='F'){\n\t\treturn (char)(c-'A'+10);\n\t}else{\n\t\tthrow new IllegalArgumentException(\"Not a hex character: \"+c);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Helper to decode half of a hexadecimal number from a string.\n * @param c The ASCII character of the hexadecimal number to decode.Must be in the range  {@code [0-9a-fA-F]}.\n * @return The hexadecimal value represented in the ASCII charactergiven, or  {@link Character#MAX_VALUE} if the character is invalid.\n */\n", "method_name": "decodeHexNibble", "codes": ["private static char decodeHexNibble(final char c){\n\n\tif(c<='9'){\n\t\treturn (char)(c-'0');\n\t}else if(c<='F'){\n\t\treturn (char)(c-'A'+10);\n\t}else if(c<='f'){\n\t\treturn (char)(c-'a'+10);\n\t}else{\n\t\tassert(false);\n\t\tthrow new IllegalArgumentException(\"Not a hex character: \"+(int)c);\n\t}\n}", "private static char decodeHexNibble(final char c){\n\nswitch(c){\ncase '0':return '0';\ncase '1':return '1';\ncase '2':return '2';\ncase '3':return '3';\ncase '4':return '4';\ncase '5':return '5';\ncase '6':return '6';\ncase '7':return '7';\ncase '8':return '8';\ncase '9':return '9';\ncase 'A':case 'a':return 'A';\ncase 'B':case 'b':return 'B';\ncase 'C':case 'c':return 'C';\ncase 'D':case 'd':return 'D';\ncase 'E':case 'e':return 'E';\ncase 'F':case 'f':return 'F';\ndefault:return '\\0';\n}\n}", "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9'){\n\t\treturn (char)(c-'0');\n\t}\n\tif(c>='A' && c<='F'){\n\t\treturn (char)(10+c-'A');\n\t}\n\tif(c>='a' && c<='f'){\n\t\treturn (char)(10+c-'a');\n\t}\n\tthrow new IllegalArgumentException(\"Invalid hex character '\"+c+\"'\");\n}", "private static char decodeHexNibble(final char c){\n\n    if('0'<=c && c<='9') return (char) (c-'0');\n    if('a'<=c && c<='f') return (char) (c-'a'+10);\n    if('A'<=c && c<='F') return (char) (c-'A'+10);\n    throw new IllegalArgumentException(\"Invalid hex character: \"+c);\n}", "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9')\n\t\treturn (char)(c-'0'); //0x30\n\tif(c>='A' && c<='F')\n\t\treturn (char)(c-'A'+10); //0x37\n\tif(c>='a' && c<='f')\n\t\treturn (char)(c-'a'+10); //0x57\n\treturn 0x00; //invalid character\n}", "private static char decodeHexNibble(final char c){\n\n  if(c >= '0' && c <= '9') return (char)(c - '0');\n  if(c >= 'A' && c <= 'F') return (char)(c - 'A' + 10);\n  if(c >= 'a' && c <= 'f') return (char)(c - 'a' + 10);\n  return 0;\n}", "private static char decodeHexNibble(final char c){\n\n    if(c>='0' && c<='9')\n        return (char)(c-'0');\n    else if(c>='A' && c<='F')\n        return (char)(c-'A'+10);\n    else if(c>='a' && c<='f')\n        return (char)(c-'a'+10);\n    else\n        throw new IllegalArgumentException(\"Not a hex character: \"+c);\n}", "private static char decodeHexNibble(final char c){\n\n\tif(c>='0'&&c<='9')return(char)(c-'0');\n\tif(c>='A'&&c<='F')return(char)(c-'A'+10);\n\tif(c>='a'&&c<='f')return(char)(c-'a'+10);\n\tthrow new IllegalArgumentException(\"Not a hex character: \"+c);\n}", "private static char decodeHexNibble(final char c){\n\n\tif(c>='0' && c<='9') return (char)(c-'0');\n\tif(c>='A' && c<='F') return (char)(c-'A'+10);\n\tif(c>='a' && c<='f') return (char)(c-'a'+10);\n\tthrow new IllegalArgumentException(\"Not a hex character: '\"+c+\"'\");\n}", "private static char decodeHexNibble(final char c){\n\n\tif('0'<=c && c<='9'){\n\t\treturn (char)(c-'0');\n\t}else if('a'<=c && c<='f'){\n\t\treturn (char)(c-'a'+10);\n\t}else if('A'<=c && c<='F'){\n\t\treturn (char)(c-'A'+10);\n\t}else{\n\t\tthrow new IllegalArgumentException(\"Not a hex character: \"+c);\n\t}\n}"], "code_level": "slib_runnable", "_id": "636766851a6d9265ec01751b", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\nif(genericType instanceof ParameterizedType){ParameterizedType paramType=(ParameterizedType)genericType;Type[] typeArgs=paramType.getActualTypeArguments();Class<?>[] args=new Class<?>[typeArgs.length];for(int i=0;i<typeArgs.length;i++){args[i]=resolveArgument(typeArgs[i],targetType);if(args[i]==null)\nreturn null;}\nreturn args;}\nreturn null;}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof Class)\n\t\treturn null;\n\tif(genericType instanceof ParameterizedType)\n\t\treturn getRawTypes(((ParameterizedType) genericType).getActualTypeArguments());\n\tif(genericType instanceof TypeVariable<?>)\n\t\treturn resolveArguments(((TypeVariable<?>) genericType).getBounds()[0], targetType);\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof TypeVariable){\n\t\treturn resolveArguments((TypeVariable<?>)genericType,targetType);\n\t}\n\tif(genericType instanceof ParameterizedType){\n\t\treturn resolveArguments((ParameterizedType)genericType);\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n    if(genericType instanceof Class){\n        return null;\n    }else if(genericType instanceof ParameterizedType){\n        ParameterizedType parameterizedType=(ParameterizedType)genericType;\n        Type[] genericTypeArguments=parameterizedType.getActualTypeArguments();\n        TypeVariable<?>[] typeParameters=targetType.getTypeParameters();\n        Class<?>[] resolvedArguments=new Class<?>[genericTypeArguments.length];\n        for(int i=0;i<genericTypeArguments.length;i++){\n            Type genericTypeArgument=genericTypeArguments[i];\n            if(genericTypeArgument instanceof Class){\n                resolvedArguments[i]=(Class<?>)genericTypeArgument;\n            }else if(genericTypeArgument instanceof TypeVariable){\n                for(int j=0;j<typeParameters.length;j++){\n                    if(typeParameters[j].getName().equals(((TypeVariable<?>)genericTypeArgument).getName())){\n                        resolvedArguments[i]=resolveArgument(typeParameters[j],targetType);", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\treturn resolveArguments((ParameterizedType)genericType,targetType);\n\t}\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\nif(!(genericType instanceof ParameterizedType)){return null;}\nParameterizedType parameterizedType=(ParameterizedType)genericType;Type[] genericTypes=parameterizedType.getActualTypeArguments();if(genericTypes.length==0){return null;}\nClass<?>[] args=new Class<?>[genericTypes.length];for(int i=0;i<genericTypes.length;i++){Type type=genericTypes[i];if(type instanceof Class){args[i]=(Class<?>)type;continue;}\nif(type instanceof TypeVariable){TypeVariable<?> tv=(TypeVariable<?>)type;Type resolved=getTypeVariableMap(targetType).get(tv);if(resolved==null){return null;}\nif(resolved instanceof Class){args[i]=(Class<?>)resolved;continue;}\nif(resolved instanceof GenericArrayType){Type component=((GenericArrayType)resolved).getGenericComponentType();if(component instanceof Class){args[i]=Array.newInstance((Class<?>)component,0).getClass();continue;}\nreturn null;}\nif(resolved instanceof Param", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif (genericType instanceof ParameterizedType){\n\t\tParameterizedType paramType=(ParameterizedType)genericType;\n\t\tType[] arguments=paramType.getActualTypeArguments();\n\t\tif (arguments!=null && arguments.length>0){\n\t\t\tClass<?>[] result=new Class[arguments.length];\n\t\t\tfor (int i=0;i<arguments.length;i++){\n\t\t\t\tType argument=arguments[i];\n\t\t\t\tif (argument instanceof TypeVariable){\n\t\t\t\t\tTypeVariable<?> var=(TypeVariable<?>)argument;\n\t\t\t\t\targument=resolveTypeVariable(var,targetType);\n\t\t\t\t\tif (argument==null){\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[i]=(Class<?>)argument;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType paramType=(ParameterizedType)genericType;\n\t\tType[] typeArguments=paramType.getActualTypeArguments();\n\t\tClass<?>[] resolvedTypeArguments=new Class[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tif(typeArguments[i] instanceof TypeVariable){\n\t\t\t\tTypeVariable typeVariable=(TypeVariable)typeArguments[i];\n\t\t\t\tresolvedTypeArguments[i]=resolveTypeVariable(typeVariable,targetType);\n\t\t\t}else if(typeArguments[i] instanceof ParameterizedType){\n\t\t\t\tresolvedTypeArguments[i]=resolveParameterizedType((ParameterizedType)typeArguments[i],targetType);\n\t\t\t}else{\n\t\t\t\tresolvedTypeArguments[i]=(Class<?>)typeArguments[i];\n\t\t\t}\n\t\t}\n\t\treturn resolvedTypeArguments;\n\t}\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType pType=(ParameterizedType)genericType;\n\t\tType[] typeArgs=pType.getActualTypeArguments();\n\t\tClass<?>[] result=new Class<?>[typeArgs.length];\n\t\tfor(int i=0;i<typeArgs.length;i++){\n\t\t\tresult[i]=resolveType(typeArgs[i],targetType);\n\t\t}\n\t\treturn result;\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof Class){return null;}\n\tTypeVariable<?>[] typeVariables=targetType.getTypeParameters();\n\tType[] actualTypeArguments=((ParameterizedType)genericType).getActualTypeArguments();\n\tif(typeVariables.length!=actualTypeArguments.length){return null;}\n\tClass<?>[] resolvedTypes=new Class<?>[actualTypeArguments.length];\n\tfor(int i=0;i<actualTypeArguments.length;i++){\n\t\tresolvedTypes[i]=resolveClass(actualTypeArguments[i],typeVariables,targetType.getGenericSuperclass());\n\t}\n\treturn resolvedTypes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n", "method_name": "resolveArguments", "codes": ["public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\nif(genericType instanceof ParameterizedType){ParameterizedType paramType=(ParameterizedType)genericType;Type[] typeArgs=paramType.getActualTypeArguments();Class<?>[] args=new Class<?>[typeArgs.length];for(int i=0;i<typeArgs.length;i++){args[i]=resolveArgument(typeArgs[i],targetType);if(args[i]==null)\nreturn null;}\nreturn args;}\nreturn null;}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof Class)\n\t\treturn null;\n\tif(genericType instanceof ParameterizedType)\n\t\treturn getRawTypes(((ParameterizedType) genericType).getActualTypeArguments());\n\tif(genericType instanceof TypeVariable<?>)\n\t\treturn resolveArguments(((TypeVariable<?>) genericType).getBounds()[0], targetType);\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof TypeVariable){\n\t\treturn resolveArguments((TypeVariable<?>)genericType,targetType);\n\t}\n\tif(genericType instanceof ParameterizedType){\n\t\treturn resolveArguments((ParameterizedType)genericType);\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n    if(genericType instanceof Class){\n        return null;\n    }else if(genericType instanceof ParameterizedType){\n        ParameterizedType parameterizedType=(ParameterizedType)genericType;\n        Type[] genericTypeArguments=parameterizedType.getActualTypeArguments();\n        TypeVariable<?>[] typeParameters=targetType.getTypeParameters();\n        Class<?>[] resolvedArguments=new Class<?>[genericTypeArguments.length];\n        for(int i=0;i<genericTypeArguments.length;i++){\n            Type genericTypeArgument=genericTypeArguments[i];\n            if(genericTypeArgument instanceof Class){\n                resolvedArguments[i]=(Class<?>)genericTypeArgument;\n            }else if(genericTypeArgument instanceof TypeVariable){\n                for(int j=0;j<typeParameters.length;j++){\n                    if(typeParameters[j].getName().equals(((TypeVariable<?>)genericTypeArgument).getName())){\n                        resolvedArguments[i]=resolveArgument(typeParameters[j],targetType);", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\treturn resolveArguments((ParameterizedType)genericType,targetType);\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\nif(!(genericType instanceof ParameterizedType)){return null;}\nParameterizedType parameterizedType=(ParameterizedType)genericType;Type[] genericTypes=parameterizedType.getActualTypeArguments();if(genericTypes.length==0){return null;}\nClass<?>[] args=new Class<?>[genericTypes.length];for(int i=0;i<genericTypes.length;i++){Type type=genericTypes[i];if(type instanceof Class){args[i]=(Class<?>)type;continue;}\nif(type instanceof TypeVariable){TypeVariable<?> tv=(TypeVariable<?>)type;Type resolved=getTypeVariableMap(targetType).get(tv);if(resolved==null){return null;}\nif(resolved instanceof Class){args[i]=(Class<?>)resolved;continue;}\nif(resolved instanceof GenericArrayType){Type component=((GenericArrayType)resolved).getGenericComponentType();if(component instanceof Class){args[i]=Array.newInstance((Class<?>)component,0).getClass();continue;}\nreturn null;}\nif(resolved instanceof Param", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif (genericType instanceof ParameterizedType){\n\t\tParameterizedType paramType=(ParameterizedType)genericType;\n\t\tType[] arguments=paramType.getActualTypeArguments();\n\t\tif (arguments!=null && arguments.length>0){\n\t\t\tClass<?>[] result=new Class[arguments.length];\n\t\t\tfor (int i=0;i<arguments.length;i++){\n\t\t\t\tType argument=arguments[i];\n\t\t\t\tif (argument instanceof TypeVariable){\n\t\t\t\t\tTypeVariable<?> var=(TypeVariable<?>)argument;\n\t\t\t\t\targument=resolveTypeVariable(var,targetType);\n\t\t\t\t\tif (argument==null){\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[i]=(Class<?>)argument;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType paramType=(ParameterizedType)genericType;\n\t\tType[] typeArguments=paramType.getActualTypeArguments();\n\t\tClass<?>[] resolvedTypeArguments=new Class[typeArguments.length];\n\t\tfor(int i=0;i<typeArguments.length;i++){\n\t\t\tif(typeArguments[i] instanceof TypeVariable){\n\t\t\t\tTypeVariable typeVariable=(TypeVariable)typeArguments[i];\n\t\t\t\tresolvedTypeArguments[i]=resolveTypeVariable(typeVariable,targetType);\n\t\t\t}else if(typeArguments[i] instanceof ParameterizedType){\n\t\t\t\tresolvedTypeArguments[i]=resolveParameterizedType((ParameterizedType)typeArguments[i],targetType);\n\t\t\t}else{\n\t\t\t\tresolvedTypeArguments[i]=(Class<?>)typeArguments[i];\n\t\t\t}\n\t\t}\n\t\treturn resolvedTypeArguments;\n\t}\n\t", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof ParameterizedType){\n\t\tParameterizedType pType=(ParameterizedType)genericType;\n\t\tType[] typeArgs=pType.getActualTypeArguments();\n\t\tClass<?>[] result=new Class<?>[typeArgs.length];\n\t\tfor(int i=0;i<typeArgs.length;i++){\n\t\t\tresult[i]=resolveType(typeArgs[i],targetType);\n\t\t}\n\t\treturn result;\n\t}\n\treturn null;\n}", "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n\n\tif(genericType instanceof Class){return null;}\n\tTypeVariable<?>[] typeVariables=targetType.getTypeParameters();\n\tType[] actualTypeArguments=((ParameterizedType)genericType).getActualTypeArguments();\n\tif(typeVariables.length!=actualTypeArguments.length){return null;}\n\tClass<?>[] resolvedTypes=new Class<?>[actualTypeArguments.length];\n\tfor(int i=0;i<actualTypeArguments.length;i++){\n\t\tresolvedTypes[i]=resolveClass(actualTypeArguments[i],typeVariables,targetType.getGenericSuperclass());\n\t}\n\treturn resolvedTypes;\n}"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174b6", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n    Type[] bounds=typeVariable.getBounds();\n    if(bounds.length==0){\n        return Unknown.class;\n    }\n\n    Type bound=bounds[0];\n    if(bound instanceof TypeVariable){\n        bound=resolveBound((TypeVariable<?>)bound);\n    }\n    return bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Object.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\nType[] bounds=typeVariable.getBounds();\nif(bounds.length==0){\nreturn Unknown.class;\n}\nType bound=bounds[0];\nif(bound instanceof TypeVariable){\nbound=resolveBound((TypeVariable<?>)bound);\n}\nreturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\nType[] bounds=typeVariable.getBounds();\nif(bounds.length==0)return Unknown.class;\n\nType bound=bounds[0];\nif(bound instanceof TypeVariable)\nbound=resolveBound((TypeVariable<?>)bound);\nreturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Resolves the first bound for the  {@code typeVariable}, returning  {@code Unknown.class} if nonecan be resolved.\n */\n", "method_name": "resolveBound", "codes": ["public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n    Type[] bounds=typeVariable.getBounds();\n    if(bounds.length==0){\n        return Unknown.class;\n    }\n\n    Type bound=bounds[0];\n    if(bound instanceof TypeVariable){\n        bound=resolveBound((TypeVariable<?>)bound);\n    }\n    return bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Object.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\nType[] bounds=typeVariable.getBounds();\nif(bounds.length==0){\nreturn Unknown.class;\n}\nType bound=bounds[0];\nif(bound instanceof TypeVariable){\nbound=resolveBound((TypeVariable<?>)bound);\n}\nreturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\nType[] bounds=typeVariable.getBounds();\nif(bounds.length==0)return Unknown.class;\n\nType bound=bounds[0];\nif(bound instanceof TypeVariable)\nbound=resolveBound((TypeVariable<?>)bound);\nreturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}", "public static Type resolveBound(TypeVariable<?> typeVariable){\n\n\tType[] bounds=typeVariable.getBounds();\n\tif(bounds.length==0){\n\t\treturn Unknown.class;\n\t}\n\tType bound=bounds[0];\n\tif(bound instanceof TypeVariable){\n\t\tbound=resolveBound((TypeVariable<?>)bound);\n\t}\n\treturn bound;\n}"], "code_level": "slib_runnable", "_id": "6367667d1a6d9265ec01741d", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new Builder().request(request).build();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n  return new Builder().request(request).build();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\tAtmosphereRequestImpl.Builder b = new AtmosphereRequestImpl.Builder();\n\tb.request(request);\n\treturn b.build();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest(request);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new AtmosphereRequest.Builder().request(request).build();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new Builder().request(request).build();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new Builder().request(request).build();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new AtmosphereRequest.Builder().request(request).build();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest.Builder().request(request).build();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n", "method_name": "wrap", "codes": ["public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n  return new Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\tAtmosphereRequestImpl.Builder b = new AtmosphereRequestImpl.Builder();\n\tb.request(request);\n\treturn b.build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest(request);\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new AtmosphereRequest.Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n    return new AtmosphereRequest.Builder().request(request).build();\n}", "public static AtmosphereRequest wrap(HttpServletRequest request){\n\n\treturn new AtmosphereRequest.Builder().request(request).build();\n}"], "code_level": "class_runnable", "_id": "636766821a6d9265ec0174d2", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\tif(mapping != null){\n\t\treturn atmosphereHandlers.remove(mapping);\n\t}else{\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn this.removeAtmosphereHandler(mapping,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n    return atmosphereHandlers.remove(mapping);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(atmosphereHandlers.get(mapping));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, null, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\tif(mapping!=null){\n\t\treturn atmosphereHandlers.remove(mapping);\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public AtmosphereFramework removeAtmosphereHandler(String mapping){\nreturn null;}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Remove an  {@link AtmosphereHandler}.\n * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String,AtmosphereHandler)};\n * @return true if removed\n */\n", "method_name": "removeAtmosphereHandler", "codes": ["public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\tif(mapping != null){\n\t\treturn atmosphereHandlers.remove(mapping);\n\t}else{\n\t\treturn null;\n\t}\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn this.removeAtmosphereHandler(mapping,false);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n    return atmosphereHandlers.remove(mapping);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(atmosphereHandlers.get(mapping));\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, null, null);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, false);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\tif(mapping!=null){\n\t\treturn atmosphereHandlers.remove(mapping);\n\t}\n\treturn null;\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping, false);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\n\n\treturn removeAtmosphereHandler(mapping,true);\n}", "public AtmosphereFramework removeAtmosphereHandler(String mapping){\nreturn null;}"], "code_level": "class_runnable", "_id": "6367667f1a6d9265ec017458", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "protected Object filter(Object msg){\n\n\tif((msg instanceof BroadcastAction) &&\n\t\t\t(((BroadcastAction)msg).getType() == BroadcastAction.ActionType.ABORT ||\n\t\t\t\t\t((BroadcastAction)msg).getType() == BroadcastAction.ActionType.NONE)){\n\t\treturn null;\n\t}\n\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(null == msg){\n\t\treturn null;\n\t}\n\telse{\n\t\tif(msg instanceof BroadcastAction){\n\t\t\tBroadcastAction ba=(BroadcastAction)msg;\n\t\t\tif(ba.isAbort() || ba.getAction() == null){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn ba.getAction();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn msg;\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction ba = (BroadcastAction)msg;\n\t\tif(ba.getActionType()==BroadcastAction.ActionType.NULL){\n\t\t\treturn null;\n\t\t}else if(ba.getActionType()==BroadcastAction.ActionType.ABORT){\n\t\t\treturn ba;\n\t\t}\n\t}\n\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction bas = (BroadcastAction)msg;\n\t\tif(bas.getType().equals(BroadcastActionType.ABORT) ||\n\t\t\t\tbas.getType().equals(BroadcastActionType.NULL)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif (msg instanceof BroadcastAction){\n\t\tBroadcastAction action = (BroadcastAction)msg;\n\t\tif (action.getMessage()==null || action.getMessage() instanceof AbortMessage)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn action.getMessage();\n\t}\n\telse\n\t\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction action = (BroadcastAction) msg;\n\t\tif(action.getMessage() instanceof AKA_Abort){\n\t\t\treturn null;\n\t\t}\n\t\tif(action.getMessage() instanceof AKA_Null){\n\t\t\treturn null;\n\t\t}\n\t\treturn action.getMessage();\n\t}\n\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg == null || msg == BroadcastAction.ABORT){\n\t\treturn null;\n\t}\n\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif (msg instanceof BroadcastAction){\n\t\tBroadcastAction ba = (BroadcastAction) msg;\n\t\tif (ba.getAction().equals(\"null\")){\n\t\t\t\treturn null;\n\t\t\t}\n\t\telse if (ba.getAction().equals(\"abort\")){\n\t\t\t\treturn null;\n\t\t\t}\n\t\telse{\n\t\t\treturn ba.getAction();\n\t\t}\n\t}\n\telse{\n\t\treturn msg;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg != null && msg != BroadcastAction.ABORT)\n\t\treturn msg;\n\telse\n\t\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction bmsg = (BroadcastAction)msg;\n\t\tif(bmsg.getMessage()==null)\n\t\t\treturn null;\n\t\telse if(bmsg.getMessage() instanceof AbortMessage)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn bmsg.getMessage();\n\t}else\n\t\treturn msg;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n", "method_name": "filter", "codes": ["protected Object filter(Object msg){\n\n\tif((msg instanceof BroadcastAction) &&\n\t\t\t(((BroadcastAction)msg).getType() == BroadcastAction.ActionType.ABORT ||\n\t\t\t\t\t((BroadcastAction)msg).getType() == BroadcastAction.ActionType.NONE)){\n\t\treturn null;\n\t}\n\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif(null == msg){\n\t\treturn null;\n\t}\n\telse{\n\t\tif(msg instanceof BroadcastAction){\n\t\t\tBroadcastAction ba=(BroadcastAction)msg;\n\t\t\tif(ba.isAbort() || ba.getAction() == null){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn ba.getAction();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn msg;\n\t\t}\n\t}\n}", "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction ba = (BroadcastAction)msg;\n\t\tif(ba.getActionType()==BroadcastAction.ActionType.NULL){\n\t\t\treturn null;\n\t\t}else if(ba.getActionType()==BroadcastAction.ActionType.ABORT){\n\t\t\treturn ba;\n\t\t}\n\t}\n\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction bas = (BroadcastAction)msg;\n\t\tif(bas.getType().equals(BroadcastActionType.ABORT) ||\n\t\t\t\tbas.getType().equals(BroadcastActionType.NULL)){\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif (msg instanceof BroadcastAction){\n\t\tBroadcastAction action = (BroadcastAction)msg;\n\t\tif (action.getMessage()==null || action.getMessage() instanceof AbortMessage)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn action.getMessage();\n\t}\n\telse\n\t\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction action = (BroadcastAction) msg;\n\t\tif(action.getMessage() instanceof AKA_Abort){\n\t\t\treturn null;\n\t\t}\n\t\tif(action.getMessage() instanceof AKA_Null){\n\t\t\treturn null;\n\t\t}\n\t\treturn action.getMessage();\n\t}\n\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif(msg == null || msg == BroadcastAction.ABORT){\n\t\treturn null;\n\t}\n\treturn msg;\n}", "protected Object filter(Object msg){\n\n\tif (msg instanceof BroadcastAction){\n\t\tBroadcastAction ba = (BroadcastAction) msg;\n\t\tif (ba.getAction().equals(\"null\")){\n\t\t\t\treturn null;\n\t\t\t}\n\t\telse if (ba.getAction().equals(\"abort\")){\n\t\t\t\treturn null;\n\t\t\t}\n\t\telse{\n\t\t\treturn ba.getAction();\n\t\t}\n\t}\n\telse{\n\t\treturn msg;\n\t}\n}", "protected Object filter(Object msg){\n\n\tif(msg != null && msg != BroadcastAction.ABORT)\n\t\treturn msg;\n\telse\n\t\treturn null;\n}", "protected Object filter(Object msg){\n\n\tif(msg instanceof BroadcastAction){\n\t\tBroadcastAction bmsg = (BroadcastAction)msg;\n\t\tif(bmsg.getMessage()==null)\n\t\t\treturn null;\n\t\telse if(bmsg.getMessage() instanceof AbortMessage)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn bmsg.getMessage();\n\t}else\n\t\treturn msg;\n}"], "code_level": "project_runnable", "_id": "636766821a6d9265ec0174b3", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tboolean found=false;\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(c.isInstance(interceptor)){\n\t\t\tfound=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif(interceptorList==null || interceptorList.size()<=0){\n\t\treturn false;\n\t}\n\tfor(AtmosphereInterceptor ai : interceptorList){\n\t\tif(ai.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tboolean duplicateFound=false;\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(interceptor.getClass().equals(c)){\n\t\t\tduplicateFound=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn duplicateFound;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor i:interceptorList){\n\t\tif(c.isInstance(i)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif (interceptorList == null || interceptorList.isEmpty()) return false;\n\tfor (AtmosphereInterceptor interceptor : interceptorList){\n\t\tif (interceptor.getClass().equals(c)) return true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor interceptor : interceptorList){\n\t\tif(c.isInstance(interceptor)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif(interceptorList.size()>0){\n\t\tfor(AtmosphereInterceptor atm:interceptorList){\n\t\t\tif(atm.getClass().equals(c)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\t\tboolean hasDuplicate=false;\n\t\tfor(AtmosphereInterceptor atm:interceptorList){\n\t\t\tif(atm.getClass().equals(c)){\n\t\t\t\thasDuplicate=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hasDuplicate;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor ai:interceptorList){\n\t\tif(ai.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(interceptor.getClass()==c){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n", "method_name": "checkDuplicate", "codes": ["private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tboolean found=false;\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(c.isInstance(interceptor)){\n\t\t\tfound=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif(interceptorList==null || interceptorList.size()<=0){\n\t\treturn false;\n\t}\n\tfor(AtmosphereInterceptor ai : interceptorList){\n\t\tif(ai.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tboolean duplicateFound=false;\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(interceptor.getClass().equals(c)){\n\t\t\tduplicateFound=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn duplicateFound;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor i:interceptorList){\n\t\tif(c.isInstance(i)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif (interceptorList == null || interceptorList.isEmpty()) return false;\n\tfor (AtmosphereInterceptor interceptor : interceptorList){\n\t\tif (interceptor.getClass().equals(c)) return true;\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor interceptor : interceptorList){\n\t\tif(c.isInstance(interceptor)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tif(interceptorList.size()>0){\n\t\tfor(AtmosphereInterceptor atm:interceptorList){\n\t\t\tif(atm.getClass().equals(c)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\t\tboolean hasDuplicate=false;\n\t\tfor(AtmosphereInterceptor atm:interceptorList){\n\t\t\tif(atm.getClass().equals(c)){\n\t\t\t\thasDuplicate=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hasDuplicate;\n\t}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor ai:interceptorList){\n\t\tif(ai.getClass().equals(c)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n\n\tfor(AtmosphereInterceptor interceptor:interceptorList){\n\t\tif(interceptor.getClass()==c){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "636766811a6d9265ec017499", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes==null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes!=null) return true;\n\telse return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes==null)return false;\n\telse return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n    return this.dataBytes!=null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes==null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\treturn dataBytes!=null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\treturn !(dataBytes==null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes==null)\n\t\treturn false;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\tif(dataBytes == null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean hasBytes(){\n\n\treturn (dataBytes != null);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * True is the body is a byte array\n * @return True is the body is a byte array\n */\n", "method_name": "hasBytes", "codes": ["public boolean hasBytes(){\n\n\tif(dataBytes==null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean hasBytes(){\n\n\tif(dataBytes!=null) return true;\n\telse return false;\n}", "public boolean hasBytes(){\n\n\tif(dataBytes==null)return false;\n\telse return true;\n}", "public boolean hasBytes(){\n\n    return this.dataBytes!=null;\n}", "public boolean hasBytes(){\n\n\tif(dataBytes==null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean hasBytes(){\n\n\treturn dataBytes!=null;\n}", "public boolean hasBytes(){\n\n\treturn !(dataBytes==null);\n}", "public boolean hasBytes(){\n\n\tif(dataBytes==null)\n\t\treturn false;\n\treturn true;\n}", "public boolean hasBytes(){\n\n\tif(dataBytes == null){\n\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean hasBytes(){\n\n\treturn (dataBytes != null);\n}"], "code_level": "class_runnable", "_id": "6367667c1a6d9265ec0173f7", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\ttry{\n\t\treturn (Meteor)r.getSession().getAttribute(\"meteor\");\n\t}catch(Exception e){\n\t\treturn null;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\t\treturn lookup(Meteor.getContext().get(r));\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\treturn lookup(r,null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m=null;\n\tHttpSession session=r.getSession();\n\tif(session==null) return null;\n\tsynchronized(session){\n\t\tm=(Meteor)session.getAttribute(Meteor.class.getName());\n\t\tif(m==null){\n\t\t\tm=new Meteor(session);\n\t\t\tsession.setAttribute(Meteor.class.getName(), m);\n\t\t}\n\t}\n\treturn m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\nif(r==null)return null;\nMeteor m=(Meteor)r.getAttribute(\"meteor\");\nif(m!=null)return m;\nif(r instanceof MeteorRequest){\nm=(Meteor)((MeteorRequest)r).getMeteor();\nif(m!=null)return m;\n}\nreturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\tString path=r.getServletPath();\n\tString context=r.getContextPath();\n\tif(path.startsWith(context)){\n\t\tpath=path.substring(context.length());\n\t}\n\tif(path.startsWith(\"/\")){\n\t\tpath=path.substring(1);\n\t}\n\tif(path.endsWith(\"/\")){\n\t\tpath=path.substring(0,path.length()-1);\n\t}\n\tString[] parts=path.split(\"/\");\n\treturn lookup(parts);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\ttry{\n\t\treturn lookup(r.getRemoteHost());\n\t}catch(Exception x){\n\t\tSystem.out.println(x);\n\t\tx.printStackTrace();\n\t\treturn new Meteor();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m = (Meteor)r.getAttribute(\"meteor\");\n\tif (m==null){\n\t\tm = new Meteor(r);\n\t\tr.setAttribute(\"meteor\", m);\n\t}\n\treturn m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\t\treturn lookup(r.getServletPath());\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m = null;\n\tHttpSession s = r.getSession(false);\n\tif (s == null)\n\t\treturn null;\n\tm = (Meteor)s.getAttribute(METEOR_SESSION_ATTRIBUTE);\n\treturn m;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n", "method_name": "lookup", "codes": ["public static Meteor lookup(HttpServletRequest r){\n\n\ttry{\n\t\treturn (Meteor)r.getSession().getAttribute(\"meteor\");\n\t}catch(Exception e){\n\t\treturn null;\n\t}\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\t\treturn lookup(Meteor.getContext().get(r));\n\t}", "public static Meteor lookup(HttpServletRequest r){\n\n\treturn lookup(r,null);\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m=null;\n\tHttpSession session=r.getSession();\n\tif(session==null) return null;\n\tsynchronized(session){\n\t\tm=(Meteor)session.getAttribute(Meteor.class.getName());\n\t\tif(m==null){\n\t\t\tm=new Meteor(session);\n\t\t\tsession.setAttribute(Meteor.class.getName(), m);\n\t\t}\n\t}\n\treturn m;\n}", "public static Meteor lookup(HttpServletRequest r){\n\nif(r==null)return null;\nMeteor m=(Meteor)r.getAttribute(\"meteor\");\nif(m!=null)return m;\nif(r instanceof MeteorRequest){\nm=(Meteor)((MeteorRequest)r).getMeteor();\nif(m!=null)return m;\n}\nreturn null;\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\tString path=r.getServletPath();\n\tString context=r.getContextPath();\n\tif(path.startsWith(context)){\n\t\tpath=path.substring(context.length());\n\t}\n\tif(path.startsWith(\"/\")){\n\t\tpath=path.substring(1);\n\t}\n\tif(path.endsWith(\"/\")){\n\t\tpath=path.substring(0,path.length()-1);\n\t}\n\tString[] parts=path.split(\"/\");\n\treturn lookup(parts);\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\ttry{\n\t\treturn lookup(r.getRemoteHost());\n\t}catch(Exception x){\n\t\tSystem.out.println(x);\n\t\tx.printStackTrace();\n\t\treturn new Meteor();\n\t}\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m = (Meteor)r.getAttribute(\"meteor\");\n\tif (m==null){\n\t\tm = new Meteor(r);\n\t\tr.setAttribute(\"meteor\", m);\n\t}\n\treturn m;\n}", "public static Meteor lookup(HttpServletRequest r){\n\n\t\treturn lookup(r.getServletPath());\n\t}", "public static Meteor lookup(HttpServletRequest r){\n\n\tMeteor m = null;\n\tHttpSession s = r.getSession(false);\n\tif (s == null)\n\t\treturn null;\n\tm = (Meteor)s.getAttribute(METEOR_SESSION_ATTRIBUTE);\n\treturn m;\n}"], "code_level": "class_runnable", "_id": "6367667d1a6d9265ec0173ff", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tif(e == null){\n\t\treturn null;\n\t}\n\t\n\tif(!events.contains(e)){\n\t\tevents.add(e);\n\t}\n\t\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n  if(!eventListenerList.contains(e)){eventListenerList.add(e);}\n  return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tlisteners.add(e);\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n//AtmosphereResource resource = e.getResource();\n//AtmosphereResourceEventListener eventListener = new AtmosphereResourceEventListener();\n/**Adding the AtmosphereResourceEventListener e into a list**/\nlist.add(e);\nreturn e.getResource();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tatmosphereResourceEventListeners.add(e);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tatmosphereResourceEventListenerList.add(e);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\teventList.add(e);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n        if (listeners == null){ listeners = new ArrayList<AtmosphereResourceEventListener>(); }\n        listeners.add(e);\n        return this;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tif(!listeners.contains(e)){\n\t\tlisteners.add(e);\n\t}\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\teventListeners.add(e);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a  {@link AtmosphereResourceEventListener}.\n * @param e an instance of AtmosphereResourceEventListener\n */\n", "method_name": "addEventListener", "codes": ["@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tif(e == null){\n\t\treturn null;\n\t}\n\t\n\tif(!events.contains(e)){\n\t\tevents.add(e);\n\t}\n\t\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n  if(!eventListenerList.contains(e)){eventListenerList.add(e);}\n  return this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tlisteners.add(e);\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n//AtmosphereResource resource = e.getResource();\n//AtmosphereResourceEventListener eventListener = new AtmosphereResourceEventListener();\n/**Adding the AtmosphereResourceEventListener e into a list**/\nlist.add(e);\nreturn e.getResource();\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tatmosphereResourceEventListeners.add(e);\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tatmosphereResourceEventListenerList.add(e);\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\teventList.add(e);\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n        if (listeners == null){ listeners = new ArrayList<AtmosphereResourceEventListener>(); }\n        listeners.add(e);\n        return this;\n    }", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\tif(!listeners.contains(e)){\n\t\tlisteners.add(e);\n\t}\n\treturn this;\n}", "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n\n\teventListeners.add(e);\n\treturn this;\n}"], "code_level": "project_runnable", "_id": "6367667c1a6d9265ec0173fb", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public InputStream next() throws IOException {\n\n\tif(!stack.isEmpty()) {\n\t\tInputStream is = (InputStream)stack.pop();\n\t\tis.reset();\n\t\treturn is;\n\t}\n\telse {\n\t\treturn null;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n\n\tif (!stack.isEmpty()) {\n\t\treturn (InputStream) stack.pop();\n\t} else {\n\t\treturn null;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n\n\tif (stack.size() > 0) {\n\t\tInputStream input = stack.remove(stack.size() - 1);\n\t\tif (input instanceof FileInputStream) {\n\t\t\tFileInputStream fileInput = (FileInputStream) input;\n\t\t\tFile file = new File(fileInput.getFD());\n\t\t\tif (file.getAbsolutePath().endsWith(\".zip\") || file.getAbsolutePath().endsWith(\".jar\")) {\n\t\t\t\tZipInputStream zipInput = new ZipInputStream(input);\n\t\t\t\tZipEntry entry;\n\t\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\t\tif (!entry.isDirectory()) {\n\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\tif (name.endsWith(\".class\")) {\n\t\t\t\t\t\t\tstack.add(zipInput);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (file.isDirectory()) {\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n\n\tif(!isEmpty())\n\t\treturn stack.pop();\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n\n    InputStream next = null;\n    if(!this.stack.isEmpty()) {\n        next = this.stack.remove(this.stack.size()-1);\n    }\n    return next;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n\n    if(!this.stack.isEmpty()) {\n        return this.stack.pop();\n    }\n    return null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n\n    if (stack.isEmpty()) {\n        return null;\n    } else {\n        InputStream is = stack.pop();\n        InputStream result = is;\n        if (is.available() == 0) {\n            result = next();\n        }\n        return result;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public InputStream next() throws IOException {\n\n    if (isEmpty()) {\n        return null;\n    }\n    else {\n        return stack.get(stack.size() - 1);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n\n\tif(stack.isEmpty()) return null;\n\treturn stack.removeLast().getInputStream();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public InputStream next() throws IOException {\n\n  if (stack.isEmpty())\n    return null;\n  return stack.removeLast();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return the next  {@link java.io.File} object or {@code null} if no more files areavailable.\n */\n", "method_name": "next", "codes": ["public InputStream next() throws IOException {\n\n\tif(!stack.isEmpty()) {\n\t\tInputStream is = (InputStream)stack.pop();\n\t\tis.reset();\n\t\treturn is;\n\t}\n\telse {\n\t\treturn null;\n\t}\n}", "public InputStream next() throws IOException {\n\n\tif (!stack.isEmpty()) {\n\t\treturn (InputStream) stack.pop();\n\t} else {\n\t\treturn null;\n\t}\n}", "public InputStream next() throws IOException {\n\n\tif (stack.size() > 0) {\n\t\tInputStream input = stack.remove(stack.size() - 1);\n\t\tif (input instanceof FileInputStream) {\n\t\t\tFileInputStream fileInput = (FileInputStream) input;\n\t\t\tFile file = new File(fileInput.getFD());\n\t\t\tif (file.getAbsolutePath().endsWith(\".zip\") || file.getAbsolutePath().endsWith(\".jar\")) {\n\t\t\t\tZipInputStream zipInput = new ZipInputStream(input);\n\t\t\t\tZipEntry entry;\n\t\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\t\tif (!entry.isDirectory()) {\n\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\tif (name.endsWith(\".class\")) {\n\t\t\t\t\t\t\tstack.add(zipInput);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (file.isDirectory()) {\n", "public InputStream next() throws IOException {\n\n\tif(!isEmpty())\n\t\treturn stack.pop();\n\treturn null;\n}", "public InputStream next() throws IOException {\n\n    InputStream next = null;\n    if(!this.stack.isEmpty()) {\n        next = this.stack.remove(this.stack.size()-1);\n    }\n    return next;\n}", "public InputStream next() throws IOException {\n\n    if(!this.stack.isEmpty()) {\n        return this.stack.pop();\n    }\n    return null;\n}", "public InputStream next() throws IOException {\n\n    if (stack.isEmpty()) {\n        return null;\n    } else {\n        InputStream is = stack.pop();\n        InputStream result = is;\n        if (is.available() == 0) {\n            result = next();\n        }\n        return result;\n    }\n}", "public InputStream next() throws IOException {\n\n    if (isEmpty()) {\n        return null;\n    }\n    else {\n        return stack.get(stack.size() - 1);\n    }\n}", "public InputStream next() throws IOException {\n\n\tif(stack.isEmpty()) return null;\n\treturn stack.removeLast().getInputStream();\n}", "public InputStream next() throws IOException {\n\n  if (stack.isEmpty())\n    return null;\n  return stack.removeLast();\n}"], "code_level": "class_runnable", "_id": "636766811a6d9265ec017496", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "private static File[] classPath(){\n\n\tString[] files = System.getProperty(\"java.class.path\").split(File.pathSeparator);\n\tFile[] paths = new File[files.length];\n\tfor(int i = 0; i < files.length; i++)\n\t\tpaths[i] = new File(files[i]);\n\treturn paths;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n    String s = System.getProperty(\"java.class.path\");\n    String[] str = s.split(File.pathSeparator);\n    File[] classPath = new File[str.length];\n    for(int i=0;i&lt;str.length;i++)\n        classPath[i] = new File(str[i]);\n    return classPath;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static File[] classPath(){\n\ntry{\nFile[] path=new File[0];\nString[] paths=System.getProperty(\"java.class.path\").split(File.pathSeparator);\npath=new File[paths.length];\nfor(int i=0;i<path.length;i++){\npath[i]=new File(paths[i]);\n}\nreturn path;\n}catch(Exception e){return new File[0];}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\tString[] path = System.getProperty(\"java.class.path\").split(\";\");\n\tFile[] files = new File[path.length];\n\tfor(int i = 0; i < path.length; i++)\n\t\tfiles[i] = new File(path[i]);\n\treturn files;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\tString classPath = System.getProperty(\"java.class.path\");\n\tString[] paths = classPath.split(System.getProperty(\"path.separator\"));\n\tFile[] files = new File[paths.length];\n\tfor(int i = 0; i < paths.length; i++)\n\t\tfiles[i] = new File(paths[i]);\n\treturn files;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\t\tfinal String classPath = System.getProperty(\"java.class.path\");\n\t\tfinal String[] fileNames = classPath.split(\";\");\n\t\tfinal File[] files = new File[fileNames.length];\n\t\tfor(int i = 0; i < fileNames.length; i++){\n\t\t\tfiles[i] = new File(fileNames[i]);\n\t\t}\n\t\treturn files;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\tString[] paths = System.getProperty(\"java.class.path\").split(System.getProperty(\"path.separator\"));\n\tFile[] filePaths = new File[paths.length];\n\tfor(int i = 0; i < filePaths.length; i++)\n\t\tfilePaths[i] = new File(paths[i]);\n\treturn filePaths;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\tFile[] classPath;\n\tString classPathString = System.getProperty(\"java.class.path\");\n\tString[] classPathStrings = classPathString.split(File.pathSeparator);\n\tclassPath = new File[classPathStrings.length];\n\tfor(int i = 0; i < classPath.length; i++){\n\t\tclassPath[i] = new File(classPathStrings[i]);\n\t}\n\treturn classPath;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n    String[] path=System.getProperty(\"java.class.path\").split(System.getProperty(\"path.separator\"));\n    File[] file=new File[path.length];\n    for(int i=0;i<path.length;i++)\n        file[i]=new File(path[i]);\n    return file;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static File[] classPath(){\n\n\tString[] path = System.getProperty(\"java.class.path\").split(\";\");\n\tFile[] files = new File[path.length];\n\tfor (int i = 0; i < path.length; i++){\n\t\tfiles[i] = new File(path[i]);\n\t}\n\treturn files;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the class path of the current JVM instance as an array of  {@link File} objects.\n */\n", "method_name": "classPath", "codes": ["private static File[] classPath(){\n\n\tString[] files = System.getProperty(\"java.class.path\").split(File.pathSeparator);\n\tFile[] paths = new File[files.length];\n\tfor(int i = 0; i < files.length; i++)\n\t\tpaths[i] = new File(files[i]);\n\treturn paths;\n}", "private static File[] classPath(){\n\n    String s = System.getProperty(\"java.class.path\");\n    String[] str = s.split(File.pathSeparator);\n    File[] classPath = new File[str.length];\n    for(int i=0;i&lt;str.length;i++)\n        classPath[i] = new File(str[i]);\n    return classPath;\n}", "private static File[] classPath(){\n\ntry{\nFile[] path=new File[0];\nString[] paths=System.getProperty(\"java.class.path\").split(File.pathSeparator);\npath=new File[paths.length];\nfor(int i=0;i<path.length;i++){\npath[i]=new File(paths[i]);\n}\nreturn path;\n}catch(Exception e){return new File[0];}\n}", "private static File[] classPath(){\n\n\tString[] path = System.getProperty(\"java.class.path\").split(\";\");\n\tFile[] files = new File[path.length];\n\tfor(int i = 0; i < path.length; i++)\n\t\tfiles[i] = new File(path[i]);\n\treturn files;\n}", "private static File[] classPath(){\n\n\tString classPath = System.getProperty(\"java.class.path\");\n\tString[] paths = classPath.split(System.getProperty(\"path.separator\"));\n\tFile[] files = new File[paths.length];\n\tfor(int i = 0; i < paths.length; i++)\n\t\tfiles[i] = new File(paths[i]);\n\treturn files;\n}", "private static File[] classPath(){\n\n\t\tfinal String classPath = System.getProperty(\"java.class.path\");\n\t\tfinal String[] fileNames = classPath.split(\";\");\n\t\tfinal File[] files = new File[fileNames.length];\n\t\tfor(int i = 0; i < fileNames.length; i++){\n\t\t\tfiles[i] = new File(fileNames[i]);\n\t\t}\n\t\treturn files;\n}", "private static File[] classPath(){\n\n\tString[] paths = System.getProperty(\"java.class.path\").split(System.getProperty(\"path.separator\"));\n\tFile[] filePaths = new File[paths.length];\n\tfor(int i = 0; i < filePaths.length; i++)\n\t\tfilePaths[i] = new File(paths[i]);\n\treturn filePaths;\n}", "private static File[] classPath(){\n\n\tFile[] classPath;\n\tString classPathString = System.getProperty(\"java.class.path\");\n\tString[] classPathStrings = classPathString.split(File.pathSeparator);\n\tclassPath = new File[classPathStrings.length];\n\tfor(int i = 0; i < classPath.length; i++){\n\t\tclassPath[i] = new File(classPathStrings[i]);\n\t}\n\treturn classPath;\n}", "private static File[] classPath(){\n\n    String[] path=System.getProperty(\"java.class.path\").split(System.getProperty(\"path.separator\"));\n    File[] file=new File[path.length];\n    for(int i=0;i<path.length;i++)\n        file[i]=new File(path[i]);\n    return file;\n}", "private static File[] classPath(){\n\n\tString[] path = System.getProperty(\"java.class.path\").split(\";\");\n\tFile[] files = new File[path.length];\n\tfor (int i = 0; i < path.length; i++){\n\t\tfiles[i] = new File(path[i]);\n\t}\n\treturn files;\n}"], "code_level": "slib_runnable", "_id": "636766821a6d9265ec0174c9", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n        int size = in.read();\n        if(size==-1) throw new EOFException();\n        if(size==0) return;\n        if(size<0) {\n            size+=256;\n        }\n        int read=0;\n        while(read<size) {\n            int r = in.read(buffer,read,size-read);\n            if(r==-1) throw new EOFException();\n            read+=r;\n        }\n        this.size=size;\n    }", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n  byte[] buffer = new byte[512];\n  int read = 0;\n  while (read != -1) {\n    read = in.read(buffer);\n    if (read != -1) {\n      append(buffer, 0, read);\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int length = in.read();\n\tif (length == -1) throw new IOException(\"Cannot read length of buffer.\");\n\tfinal byte[] newBuffer = new byte[length];\n\tfinal int read = in.read(newBuffer);\n\tif (read != length) throw new IOException(\"Cannot read buffer.\");\n\tbuffer = newBuffer;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n    final int len = in.read();\n    final byte[] buf = new byte[len];\n    int r = 0;\n    while (r < len) {\n        r += in.read(buf, r, len - r);\n    }\n    this.value = new String(buf, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int total = in.read(buffer, 0, BUFFER_SIZE);\n\tif (total == -1) {\n\t\tthrow new IOException(\"Could not read from stream.\");\n\t}\n\tbytesRead = total;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n\tStringBuffer sb = new StringBuffer();\n\tint c;\n\twhile ((c = in.read()) > 0)\n\t\tsb.append((char) c);\n\tString data = sb.toString();\n\tString[] lines = data.split(\"\\n\");\n\tString[] header = lines[0].split(\" \");\n\tthis.opcode = header[0];\n\tthis.key = header[1];\n\tthis.flags = Integer.parseInt(header[2]);\n\tthis.exp = Integer.parseInt(header[3]);\n\tthis.bytes = Integer.parseInt(header[4]);\n\tif (lines.length > 1)\n\t\tthis.data = lines[1];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int size = in.read();\n\tif (size != -1) {\n\t\tif (data == null || data.length < size)\n\t\t\tdata = new byte[size];\n\t\tthis.size = size;\n\t\tin.read(data, 0, size);\n\t} else {\n\t\tdata = null;\n\t\tsize = 0;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n  byte[] buf = new byte[BUFFER_SIZE];\n  int bytesRead = 0;\n  while ((bytesRead = in.read(buf)) != -1) {\n    m_out.write(buf, 0, bytesRead);\n  }\n  m_out.flush();\n  m_out.close();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n  final DataInputStream input = new DataInputStream(in);\n  /**Read from the buffer.**/\n  this.fileID = input.readInt();\n  this.pageNo = input.readInt();\n  this.pageSize = input.readInt();\n  this.pageType = input.readInt();\n  this.pageData = new byte[pageSize];\n  input.read(pageData);\n  this.pageRID = new PageRID();\n  this.pageRID.readFrom(in);\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void readFrom(final InputStream in) throws IOException {\n\n    if (in == null) {\n        throw new IllegalArgumentException(\"in == null\");\n    }\n    final byte[] buffer = getBuffer();\n    final int len = buffer.length;\n    int offset = 0;\n    while (offset < len) {\n        final int count = in.read(buffer, offset, len - offset);\n        if (count < 0) {\n            throw new IOException(\"Unexpected end of stream.\");\n        }\n        offset += count;\n    }\n    writeTo(0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n", "method_name": "readFrom", "codes": ["public void readFrom(final InputStream in) throws IOException {\n\n        int size = in.read();\n        if(size==-1) throw new EOFException();\n        if(size==0) return;\n        if(size<0) {\n            size+=256;\n        }\n        int read=0;\n        while(read<size) {\n            int r = in.read(buffer,read,size-read);\n            if(r==-1) throw new EOFException();\n            read+=r;\n        }\n        this.size=size;\n    }", "public void readFrom(final InputStream in) throws IOException {\n\n  byte[] buffer = new byte[512];\n  int read = 0;\n  while (read != -1) {\n    read = in.read(buffer);\n    if (read != -1) {\n      append(buffer, 0, read);\n    }\n  }\n}", "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int length = in.read();\n\tif (length == -1) throw new IOException(\"Cannot read length of buffer.\");\n\tfinal byte[] newBuffer = new byte[length];\n\tfinal int read = in.read(newBuffer);\n\tif (read != length) throw new IOException(\"Cannot read buffer.\");\n\tbuffer = newBuffer;\n}", "public void readFrom(final InputStream in) throws IOException {\n\n    final int len = in.read();\n    final byte[] buf = new byte[len];\n    int r = 0;\n    while (r < len) {\n        r += in.read(buf, r, len - r);\n    }\n    this.value = new String(buf, \"UTF-8\");\n}", "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int total = in.read(buffer, 0, BUFFER_SIZE);\n\tif (total == -1) {\n\t\tthrow new IOException(\"Could not read from stream.\");\n\t}\n\tbytesRead = total;\n}", "public void readFrom(final InputStream in) throws IOException {\n\n\tStringBuffer sb = new StringBuffer();\n\tint c;\n\twhile ((c = in.read()) > 0)\n\t\tsb.append((char) c);\n\tString data = sb.toString();\n\tString[] lines = data.split(\"\\n\");\n\tString[] header = lines[0].split(\" \");\n\tthis.opcode = header[0];\n\tthis.key = header[1];\n\tthis.flags = Integer.parseInt(header[2]);\n\tthis.exp = Integer.parseInt(header[3]);\n\tthis.bytes = Integer.parseInt(header[4]);\n\tif (lines.length > 1)\n\t\tthis.data = lines[1];\n}", "public void readFrom(final InputStream in) throws IOException {\n\n\tfinal int size = in.read();\n\tif (size != -1) {\n\t\tif (data == null || data.length < size)\n\t\t\tdata = new byte[size];\n\t\tthis.size = size;\n\t\tin.read(data, 0, size);\n\t} else {\n\t\tdata = null;\n\t\tsize = 0;\n\t}\n}", "public void readFrom(final InputStream in) throws IOException {\n\n  byte[] buf = new byte[BUFFER_SIZE];\n  int bytesRead = 0;\n  while ((bytesRead = in.read(buf)) != -1) {\n    m_out.write(buf, 0, bytesRead);\n  }\n  m_out.flush();\n  m_out.close();\n}", "public void readFrom(final InputStream in) throws IOException {\n\n  final DataInputStream input = new DataInputStream(in);\n  /**Read from the buffer.**/\n  this.fileID = input.readInt();\n  this.pageNo = input.readInt();\n  this.pageSize = input.readInt();\n  this.pageType = input.readInt();\n  this.pageData = new byte[pageSize];\n  input.read(pageData);\n  this.pageRID = new PageRID();\n  this.pageRID.readFrom(in);\n  }", "public void readFrom(final InputStream in) throws IOException {\n\n    if (in == null) {\n        throw new IllegalArgumentException(\"in == null\");\n    }\n    final byte[] buffer = getBuffer();\n    final int len = buffer.length;\n    int offset = 0;\n    while (offset < len) {\n        final int count = in.read(buffer, offset, len - offset);\n        if (count < 0) {\n            throw new IOException(\"Unexpected end of stream.\");\n        }\n        offset += count;\n    }\n    writeTo(0);\n}"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017482", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=0;i<files.length;i++)\n\t\tadd(files[files.length-1-i]);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n    for(int i=files.length-1;i>=0;i--){\n        try {\n            add(files[i]);\n        } catch (final PdfException e) {\n            LogWriter.writeLog(\"Exception \"+e+\" adding file\");\n        }\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\tadd(files[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n    /**Loop through the files in reverse order.**/\n    for(int i = files.length - 1; i > -1; i--){\n        /**Add the file to the stack.**/\n        this.stack.addLast(files[i]);\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tadd(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\tadd(files[i]);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor (int i=files.length; --i >= 0;)\n\t\tadd(files[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=0; i<files.length; i++){\n\t\tif(files[i]!=null) {\n\t\t\tadd(files[i]);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tthis.add(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final InputStream[] files){\n\n\tfor(int i = files.length; --i >= 0;) add(files[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final InputStream[] files){\n\n\tfor(int i=0;i<files.length;i++)\n\t\tadd(files[files.length-1-i]);\n\t}", "private void addReverse(final InputStream[] files){\n\n    for(int i=files.length-1;i>=0;i--){\n        try {\n            add(files[i]);\n        } catch (final PdfException e) {\n            LogWriter.writeLog(\"Exception \"+e+\" adding file\");\n        }\n    }\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\tadd(files[i]);\n}", "private void addReverse(final InputStream[] files){\n\n    /**Loop through the files in reverse order.**/\n    for(int i = files.length - 1; i > -1; i--){\n        /**Add the file to the stack.**/\n        this.stack.addLast(files[i]);\n    }\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tadd(files[i]);\n\t}\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\tadd(files[i]);\n\t}", "private void addReverse(final InputStream[] files){\n\n\tfor (int i=files.length; --i >= 0;)\n\t\tadd(files[i]);\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i=0; i<files.length; i++){\n\t\tif(files[i]!=null) {\n\t\t\tadd(files[i]);\n\t\t}\n\t}\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tthis.add(files[i]);\n\t}\n}", "private void addReverse(final InputStream[] files){\n\n\tfor(int i = files.length; --i >= 0;) add(files[i]);\n}"], "code_level": "class_runnable", "_id": "636766801a6d9265ec017477", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\taddFile(files[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tfileStack.push(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tif(files==null) return;\n\tfor(int i=files.length-1; i>=0; i--){\n\t\taddFile(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tif(files==null || files.length==0) return;\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tstack.push(files[i]);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i = files.length-1; i >= 0; i--){\n\t\tadd(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tadd(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length -1; i>=0; i--){\n\t\tadd(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tfileStack.add(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tif(files!=null){\n\t\tfor(int i=files.length-1;i>=0;i--) add(files[i]);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1; i>=0; i--)\n\t\tadd(files[i]);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add the specified files in reverse order.\n */\n", "method_name": "addReverse", "codes": ["private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--)\n\t\taddFile(files[i]);\n}", "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tfileStack.push(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tif(files==null) return;\n\tfor(int i=files.length-1; i>=0; i--){\n\t\taddFile(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tif(files==null || files.length==0) return;\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tstack.push(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tfor(int i = files.length-1; i >= 0; i--){\n\t\tadd(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1;i>=0;i--){\n\t\tadd(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tfor(int i=files.length -1; i>=0; i--){\n\t\tadd(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1; i>=0; i--){\n\t\tfileStack.add(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tif(files!=null){\n\t\tfor(int i=files.length-1;i>=0;i--) add(files[i]);\n\t}\n}", "private void addReverse(final File[] files){\n\n\tfor(int i=files.length-1; i>=0; i--)\n\t\tadd(files[i]);\n}"], "code_level": "class_runnable", "_id": "636766831a6d9265ec0174eb", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\treturn lastWrite==-1?-1:System.currentTimeMillis();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWrite == -1)\n\t\treturn -1;\n\treturn System.currentTimeMillis();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\nif(lastWrite == -1) return -1;\nreturn System.currentTimeMillis();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(this.lastWriteTimeStamp == -1){\n\t\treturn -1;\n\t}\n\treturn System.currentTimeMillis();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(lastWriteTimeStampInMilliseconds == -1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWriteTimeStamp==-1){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn System.currentTimeMillis();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWriteTime == -1){\n\t\treturn -1;\n\t}else{\n\t\treturn System.currentTimeMillis();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(lastWrite==-1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\treturn lastWriteTimeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastwrite == -1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * The last time, in milliseconds, a write operation occurred.\n * @return this\n */\n", "method_name": "lastWriteTimeStampInMilliseconds", "codes": ["public long lastWriteTimeStampInMilliseconds(){\n\n\treturn lastWrite==-1?-1:System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWrite == -1)\n\t\treturn -1;\n\treturn System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\nif(lastWrite == -1) return -1;\nreturn System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(this.lastWriteTimeStamp == -1){\n\t\treturn -1;\n\t}\n\treturn System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(lastWriteTimeStampInMilliseconds == -1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWriteTimeStamp==-1){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn System.currentTimeMillis();\n\t}\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastWriteTime == -1){\n\t\treturn -1;\n\t}else{\n\t\treturn System.currentTimeMillis();\n\t}\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif(lastWrite==-1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\treturn lastWriteTimeStamp;\n}", "public long lastWriteTimeStampInMilliseconds(){\n\n\tif (lastwrite == -1)\n\t\treturn -1;\n\telse\n\t\treturn System.currentTimeMillis();\n}"], "code_level": "class_runnable", "_id": "6367667e1a6d9265ec01743a", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport()== AtmosphereResource.TRANSPORT.WEBSOCKET) {\n        logger.info(\"Suspending: {}\", r.uuid());\n        return Action.SUSPEND;\n    }\n    else{\n        logger.info(\"Cancelling: {}\", r.uuid());\n        return Action.CANCELLED;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    String ua = r.getRequest().getHeader(\"User-Agent\");\n    if(ua != null && ua.indexOf(\"Android\") != -1){\n        return Action.SUSPEND;\n    }else{\n        return Action.CONTINUE;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n\tAtmosphereRequest request = r.getRequest();\n\tString transport = request.getHeader(\"X-Atmosphere-Transport\");\n\tif(transport != null && transport.equalsIgnoreCase(\"long-polling\")){\n\t\trequest.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, Boolean.TRUE);\n\t\treturn Action.SUSPEND;\n\t}\n\treturn Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n \n    //return Action.CONTINUE;\n    if(r.transport().equals(Request.TRANSPORT.LONG_POLLING)){\n        return Action.SUSPEND;\n    } else {\n        return Action.CONTINUE;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport().equals(AtmosphereResource.TRANSPORT.SSE) &amp;&amp; r.getRequest().getHeader(\"X-Atmosphere-Transport\") != null){\n        r.suspend();\n    }\n    return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n\tif (transport == null)\n\t\treturn Action.CONTINUE;\n\tif (transport.equals(r.transport()))\n\t\treturn Action.SUSPEND;\n\telse\n\t\treturn Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    if(!AtmosphereResourceImpl.class.isAssignableFrom(r.getClass())) return Action.CONTINUE;\n    AtmosphereResourceImpl impl = AtmosphereResourceImpl.class.cast(r);\n    if(impl.isInScope()){\n        if(!impl.getRequest().getAttribute(FrameworkConfig.TRANSPORT_IN_USE).equals(impl.transport())){\n            try{\n                impl.suspend();\n            }catch(IllegalStateException ise){\n                logger.trace(\"\",ise);\n            }\n        }\n    }\n    return Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    //System.out.println(\"inspect() : \" + r.uuid() + \" : \" + r.transport());\n    if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET\n        || r.transport() == AtmosphereResource.TRANSPORT.STREAMING\n        || r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING\n        || r.transport() == AtmosphereResource.TRANSPORT.JSONP) {\n        return Action.SUSPEND;\n    } else {\n        return Action.CONTINUE;\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n\tSystem.out.println(\"inspect\"+r.transport());\n\tif(r.transport().equals(Request.TRANSPORT.WEBSOCKET)){\n\t\tSystem.out.println(\"suspend\");\n\t\treturn Action.SUSPEND;\n\t}\n\treturn Action.CONTINUE;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING)\n        r.suspend();\n    return Action.CONTINUE;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n", "method_name": "inspect", "codes": ["@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport()== AtmosphereResource.TRANSPORT.WEBSOCKET) {\n        logger.info(\"Suspending: {}\", r.uuid());\n        return Action.SUSPEND;\n    }\n    else{\n        logger.info(\"Cancelling: {}\", r.uuid());\n        return Action.CANCELLED;\n    }\n}", "@Override public Action inspect(AtmosphereResource r){\n\n    String ua = r.getRequest().getHeader(\"User-Agent\");\n    if(ua != null && ua.indexOf(\"Android\") != -1){\n        return Action.SUSPEND;\n    }else{\n        return Action.CONTINUE;\n    }\n}", "@Override public Action inspect(AtmosphereResource r){\n\n\tAtmosphereRequest request = r.getRequest();\n\tString transport = request.getHeader(\"X-Atmosphere-Transport\");\n\tif(transport != null && transport.equalsIgnoreCase(\"long-polling\")){\n\t\trequest.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, Boolean.TRUE);\n\t\treturn Action.SUSPEND;\n\t}\n\treturn Action.CONTINUE;\n}", "@Override public Action inspect(AtmosphereResource r){\n \n    //return Action.CONTINUE;\n    if(r.transport().equals(Request.TRANSPORT.LONG_POLLING)){\n        return Action.SUSPEND;\n    } else {\n        return Action.CONTINUE;\n    }\n}", "@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport().equals(AtmosphereResource.TRANSPORT.SSE) &amp;&amp; r.getRequest().getHeader(\"X-Atmosphere-Transport\") != null){\n        r.suspend();\n    }\n    return Action.CONTINUE;\n}", "@Override public Action inspect(AtmosphereResource r){\n\n\tif (transport == null)\n\t\treturn Action.CONTINUE;\n\tif (transport.equals(r.transport()))\n\t\treturn Action.SUSPEND;\n\telse\n\t\treturn Action.CONTINUE;\n}", "@Override public Action inspect(AtmosphereResource r){\n\n    if(!AtmosphereResourceImpl.class.isAssignableFrom(r.getClass())) return Action.CONTINUE;\n    AtmosphereResourceImpl impl = AtmosphereResourceImpl.class.cast(r);\n    if(impl.isInScope()){\n        if(!impl.getRequest().getAttribute(FrameworkConfig.TRANSPORT_IN_USE).equals(impl.transport())){\n            try{\n                impl.suspend();\n            }catch(IllegalStateException ise){\n                logger.trace(\"\",ise);\n            }\n        }\n    }\n    return Action.CONTINUE;\n}", "@Override public Action inspect(AtmosphereResource r){\n\n    //System.out.println(\"inspect() : \" + r.uuid() + \" : \" + r.transport());\n    if (r.transport() == AtmosphereResource.TRANSPORT.WEBSOCKET\n        || r.transport() == AtmosphereResource.TRANSPORT.STREAMING\n        || r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING\n        || r.transport() == AtmosphereResource.TRANSPORT.JSONP) {\n        return Action.SUSPEND;\n    } else {\n        return Action.CONTINUE;\n    }\n}", "@Override public Action inspect(AtmosphereResource r){\n\n\tSystem.out.println(\"inspect\"+r.transport());\n\tif(r.transport().equals(Request.TRANSPORT.WEBSOCKET)){\n\t\tSystem.out.println(\"suspend\");\n\t\treturn Action.SUSPEND;\n\t}\n\treturn Action.CONTINUE;\n}", "@Override public Action inspect(AtmosphereResource r){\n\n    if(r.transport() == AtmosphereResource.TRANSPORT.LONG_POLLING)\n        r.suspend();\n    return Action.CONTINUE;\n}"], "code_level": "project_runnable", "_id": "636766851a6d9265ec017515", "project_name": "atmosphere-atmosphere-2.7.x"}
{"generate_results": [{"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif (ObjectUtils.isEmpty(array)) {\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n    if (ObjectUtils.isEmpty(array)) {\n        return new String[0];\n    }\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n    return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n    if (array == null || array.length == 0) {\n        return new String[0];\n    }\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n    return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element=array[i];\n\t\tresult[i]=element!=null?element.trim():null;\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif(ArrayUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element !=null?element.trim():null);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif (ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n    if(ArrayUtils.isEmpty(array)){\n        return new String[0];\n    }\n\n    String[] result = new String[array.length];\n\n    for(int i=0; i<array.length; i++){\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n\n    return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element=array[i];\n\t\tresult[i]=element!=null?element.trim():null;\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n", "method_name": "trimArrayElements", "codes": ["public static String[] trimArrayElements(String[] array){\n\n\tif (ObjectUtils.isEmpty(array)) {\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++) {\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n    if (ObjectUtils.isEmpty(array)) {\n        return new String[0];\n    }\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n    return result;\n}", "public static String[] trimArrayElements(String[] array){\n\n    if (array == null || array.length == 0) {\n        return new String[0];\n    }\n    String[] result = new String[array.length];\n    for (int i = 0; i < array.length; i++) {\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n    return result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif(array==null){\n\t\treturn null;\n\t}\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element=array[i];\n\t\tresult[i]=element!=null?element.trim():null;\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif(ArrayUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element !=null?element.trim():null);\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif (ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor (int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n    if(ArrayUtils.isEmpty(array)){\n        return new String[0];\n    }\n\n    String[] result = new String[array.length];\n\n    for(int i=0; i<array.length; i++){\n        String element = array[i];\n        result[i] = (element != null ? element.trim() : null);\n    }\n\n    return result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result=new String[array.length];\n\tfor(int i=0;i<array.length;i++){\n\t\tString element=array[i];\n\t\tresult[i]=element!=null?element.trim():null;\n\t}\n\treturn result;\n}", "public static String[] trimArrayElements(String[] array){\n\n\tif(ObjectUtils.isEmpty(array)){\n\t\treturn new String[0];\n\t}\n\tString[] result = new String[array.length];\n\tfor(int i = 0; i < array.length; i++){\n\t\tString element = array[i];\n\t\tresult[i] = (element != null ? element.trim() : null);\n\t}\n\treturn result;\n}"], "code_level": "self_contained", "_id": "6367676d1a6d9265ec018229", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static int nullSafeHashCode(long[] array){\n\nif(array==null){\nreturn0;\n}\nint hash=INITIAL_HASH;\nfor(long element:array){\nhash=MULTIPLIER*hash+hashCode(element);\n}\nreturnhash;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif(array == null)\n\t\treturn 0;\n\tint hash = INITIAL_HASH;\n\tfor(long element : array)\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null){\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array){\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\nreturn Arrays.hashCode(array);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif(array == null){\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor(int i = 0; i < array.length; i++){\n\t\thash = MULTIPLIER * hash + hashCode(array[i]);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n  if(array == null){\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for(long element : array){\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null) {\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif(array==null){return 0;}\n\tint hash=INITIAL_HASH;\n\tfor(long element:array){\n\t\thash=MULTIPLIER*hash+hashCode(element);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null) {\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nullSafeHashCode(long[] array){\n\n\t\n\tif(array==null)\n\t\treturn 0;\n\t\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n", "method_name": "nullSafeHashCode", "codes": ["public static int nullSafeHashCode(long[] array){\n\nif(array==null){\nreturn0;\n}\nint hash=INITIAL_HASH;\nfor(long element:array){\nhash=MULTIPLIER*hash+hashCode(element);\n}\nreturnhash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif(array == null)\n\t\treturn 0;\n\tint hash = INITIAL_HASH;\n\tfor(long element : array)\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null){\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array){\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\nreturn Arrays.hashCode(array);\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif(array == null){\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor(int i = 0; i < array.length; i++){\n\t\thash = MULTIPLIER * hash + hashCode(array[i]);\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n  if(array == null){\n    return 0;\n  }\n  int hash = INITIAL_HASH;\n  for(long element : array){\n    hash = MULTIPLIER * hash + hashCode(element);\n  }\n  return hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null) {\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif(array==null){return 0;}\n\tint hash=INITIAL_HASH;\n\tfor(long element:array){\n\t\thash=MULTIPLIER*hash+hashCode(element);\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\tif (array == null) {\n\t\treturn 0;\n\t}\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}", "public static int nullSafeHashCode(long[] array){\n\n\t\n\tif(array==null)\n\t\treturn 0;\n\t\n\tint hash = INITIAL_HASH;\n\tfor (long element : array) {\n\t\thash = MULTIPLIER * hash + hashCode(element);\n\t}\n\treturn hash;\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181aa", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\nreturn str!=null&&prefix!=null&&str.length()>=prefix.length()&&str.regionMatches(true,0,prefix,0,prefix.length());\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return str.regionMatches(true,0,prefix,0,prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n  return str.regionMatches(true,0,prefix,0,prefix.length());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWithIgnoreCase(str,prefix,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return startsWith(str,prefix,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\nreturn startsWithIgnoreCase(str,prefix,0);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWith(str,prefix,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWithIgnoreCase(str,prefix,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return startsWith(str,prefix,true);\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\nreturn str.regionMatches(true,0,prefix,0,prefix.length());}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns  {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @param str the String to check\n * @param prefix the prefix to look for\n * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n * @see java.lang.String#startsWith\n */\n", "method_name": "startsWithIgnoreCase", "codes": ["public static boolean startsWithIgnoreCase(String str,String prefix){\n\nreturn str!=null&&prefix!=null&&str.length()>=prefix.length()&&str.regionMatches(true,0,prefix,0,prefix.length());\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return str.regionMatches(true,0,prefix,0,prefix.length());\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n  return str.regionMatches(true,0,prefix,0,prefix.length());\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWithIgnoreCase(str,prefix,0);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return startsWith(str,prefix,true);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\nreturn startsWithIgnoreCase(str,prefix,0);}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWith(str,prefix,true);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n\treturn startsWithIgnoreCase(str,prefix,0);\n}", "public static boolean startsWithIgnoreCase(String str,String prefix){\n\n    return startsWith(str,prefix,true);\n    }", "public static boolean startsWithIgnoreCase(String str,String prefix){\nreturn str.regionMatches(true,0,prefix,0,prefix.length());}"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181df", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\nif(source==null||candidates==null)\nreturn null;Iterator iter=candidates.iterator();while(iter.hasNext()){Object candidate=iter.next();if(candidate==null)\ncontinue;if(source.contains(candidate))\nreturn candidate;if(candidate instanceof Collection){Object match=((Collection)candidate).contains(source);if(match!=null)\nreturn match;}}\nreturn null;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tIterator i = candidates.iterator();\n\twhile (i.hasNext()) {\n\t\tObject candidate = i.next();\n\t\tif(match(source,candidate)){\n\t\t\treturn candidate;\n\t\t}\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Object o:candidates){\n\t\tif(source.contains(o))return o;\n\t}\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n    Object ret=null;\n    Iterator iter=candidates.iterator();\n    while(iter.hasNext()){\n        Object candidate=iter.next();\n        if(source.contains(candidate)){\n            ret=candidate;\n            break;\n        }\n    }\n    return ret;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Object o:candidates){\n\t\tif(source.contains(o))return o;\n\t}\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\nObject[] src=source.toArray();\nObject[] cnd=candidates.toArray();\nfor(int i=0;i<cnd.length;i++){\nif(Util.member(cnd[i],src))return cnd[i];\n}\nreturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Iterator i=source.iterator();i.hasNext();){\n\t\tObject current=i.next();\n\t\tif(candidates.contains(current))return current;\n\t}\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tIterator it=candidates.iterator();\n\twhile(it.hasNext()){\n\t\tObject o=it.next();\n\t\tif(source.contains(o)){\n\t\t\treturn o;\n\t\t}\n\t}\n\treturn null;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\nif(source==null||candidates==null)\nreturn null;\nfor(Iterator iter=source.iterator();iter.hasNext();){\nObject element=iter.next();\nif(candidates.contains(element))\nreturn element;\n}\nreturn null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n\nif(isEmpty(source) || isEmpty(candidates)){\nreturn null;\n}\nfor(Iterator iterator=candidates.iterator();iterator.hasNext();){\nObject candidate=iterator.next();\nif(source.contains(candidate)){\nreturn candidate;\n}\n}\nreturn null;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n", "method_name": "findFirstMatch", "codes": ["public static Object findFirstMatch(Collection source,Collection candidates){\nif(source==null||candidates==null)\nreturn null;Iterator iter=candidates.iterator();while(iter.hasNext()){Object candidate=iter.next();if(candidate==null)\ncontinue;if(source.contains(candidate))\nreturn candidate;if(candidate instanceof Collection){Object match=((Collection)candidate).contains(source);if(match!=null)\nreturn match;}}\nreturn null;}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tIterator i = candidates.iterator();\n\twhile (i.hasNext()) {\n\t\tObject candidate = i.next();\n\t\tif(match(source,candidate)){\n\t\t\treturn candidate;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Object o:candidates){\n\t\tif(source.contains(o))return o;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n    Object ret=null;\n    Iterator iter=candidates.iterator();\n    while(iter.hasNext()){\n        Object candidate=iter.next();\n        if(source.contains(candidate)){\n            ret=candidate;\n            break;\n        }\n    }\n    return ret;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Object o:candidates){\n\t\tif(source.contains(o))return o;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\nObject[] src=source.toArray();\nObject[] cnd=candidates.toArray();\nfor(int i=0;i<cnd.length;i++){\nif(Util.member(cnd[i],src))return cnd[i];\n}\nreturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tfor(Iterator i=source.iterator();i.hasNext();){\n\t\tObject current=i.next();\n\t\tif(candidates.contains(current))return current;\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\n\tIterator it=candidates.iterator();\n\twhile(it.hasNext()){\n\t\tObject o=it.next();\n\t\tif(source.contains(o)){\n\t\t\treturn o;\n\t\t}\n\t}\n\treturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\nif(source==null||candidates==null)\nreturn null;\nfor(Iterator iter=source.iterator();iter.hasNext();){\nObject element=iter.next();\nif(candidates.contains(element))\nreturn element;\n}\nreturn null;\n}", "public static Object findFirstMatch(Collection source,Collection candidates){\n\nif(isEmpty(source) || isEmpty(candidates)){\nreturn null;\n}\nfor(Iterator iterator=candidates.iterator();iterator.hasNext();){\nObject candidate=iterator.next();\nif(source.contains(candidate)){\nreturn candidate;\n}\n}\nreturn null;\n}"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181e2", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tchar[] val = str.toCharArray();\n\tint len = val.length;\n\twhile ((0 < len) && (val[len - 1] <= ' ')) {\n\t\tlen--;\n\t}\n\treturn ((len < val.length) ? str.substring(0, len) : str);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n    if(!hasLength(str)){\n        return str;\n    }\n    StringBuilder sb = new StringBuilder(str);\n    while(sb.length()>0&&Character.isWhitespace(sb.charAt(sb.length()-1))){\n        sb.deleteCharAt(sb.length()-1);\n    }\n    return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null)return null;\n\tint index=str.length()-1;\n\twhile(index>=0&&Character.isWhitespace(str.charAt(index)))index--;\n\treturn str.substring(0,index+1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null){\n\t\treturn str;\n\t}\n\tint len=str.length();\n\tfor(int i=len-1;i>=0;i--){\n\t\tif(!Character.isWhitespace(str.charAt(i))){\n\t\t\treturn str.substring(0, i+1);\n\t\t}\n\t}\n\treturn \"\";\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(isEmpty(str)){\n\t\treturn str;\n\t}\n\tStringBuffer buf = new StringBuffer(str);\n\twhile (buf.length() > 0 && Character.isWhitespace(buf.charAt(buf.length() - 1))) {\n\t\tbuf.deleteCharAt(buf.length() - 1);\n\t}\n\treturn buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null||str.length()==0)\n\t\treturn str;\n\tint len=str.length();\n\tfor(int i=len-1;i>=0;i--){\n\t\tif(!Character.isWhitespace(str.charAt(i)))\n\t\t\treturn str.substring(0,i+1);\n\t}\n\treturn \"\";\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(str == null){\n\t\treturn null;\n\t}\n\tStringBuilder sb = new StringBuilder(str);\n\twhile(sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))){\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\treturn str.replaceAll(\"\\\\s+$\", \"\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null || str.length()==0)\n\t\treturn str;\n\tint i=str.length()-1;\n\twhile(i>=0 && Character.isWhitespace(str.charAt(i)))\n\t\ti--;\n\treturn str.substring(0,i+1);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimTrailingWhitespace(String str){\n\n\tif(StringUtils.isEmpty(str)){\n\t\treturn str;\n\t}\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length()>0&&Character.isWhitespace(buf.charAt(buf.length()-1))){\n\t\tbuf.deleteCharAt(buf.length()-1);\n\t}\n\treturn buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimTrailingWhitespace", "codes": ["public static String trimTrailingWhitespace(String str){\n\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tchar[] val = str.toCharArray();\n\tint len = val.length;\n\twhile ((0 < len) && (val[len - 1] <= ' ')) {\n\t\tlen--;\n\t}\n\treturn ((len < val.length) ? str.substring(0, len) : str);\n}", "public static String trimTrailingWhitespace(String str){\n\n    if(!hasLength(str)){\n        return str;\n    }\n    StringBuilder sb = new StringBuilder(str);\n    while(sb.length()>0&&Character.isWhitespace(sb.charAt(sb.length()-1))){\n        sb.deleteCharAt(sb.length()-1);\n    }\n    return sb.toString();\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null)return null;\n\tint index=str.length()-1;\n\twhile(index>=0&&Character.isWhitespace(str.charAt(index)))index--;\n\treturn str.substring(0,index+1);\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null){\n\t\treturn str;\n\t}\n\tint len=str.length();\n\tfor(int i=len-1;i>=0;i--){\n\t\tif(!Character.isWhitespace(str.charAt(i))){\n\t\t\treturn str.substring(0, i+1);\n\t\t}\n\t}\n\treturn \"\";\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(isEmpty(str)){\n\t\treturn str;\n\t}\n\tStringBuffer buf = new StringBuffer(str);\n\twhile (buf.length() > 0 && Character.isWhitespace(buf.charAt(buf.length() - 1))) {\n\t\tbuf.deleteCharAt(buf.length() - 1);\n\t}\n\treturn buf.toString();\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null||str.length()==0)\n\t\treturn str;\n\tint len=str.length();\n\tfor(int i=len-1;i>=0;i--){\n\t\tif(!Character.isWhitespace(str.charAt(i)))\n\t\t\treturn str.substring(0,i+1);\n\t}\n\treturn \"\";\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(str == null){\n\t\treturn null;\n\t}\n\tStringBuilder sb = new StringBuilder(str);\n\twhile(sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))){\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t}\n\treturn sb.toString();\n}", "public static String trimTrailingWhitespace(String str){\n\n\treturn str.replaceAll(\"\\\\s+$\", \"\");\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(str==null || str.length()==0)\n\t\treturn str;\n\tint i=str.length()-1;\n\twhile(i>=0 && Character.isWhitespace(str.charAt(i)))\n\t\ti--;\n\treturn str.substring(0,i+1);\n}", "public static String trimTrailingWhitespace(String str){\n\n\tif(StringUtils.isEmpty(str)){\n\t\treturn str;\n\t}\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length()>0&&Character.isWhitespace(buf.charAt(buf.length()-1))){\n\t\tbuf.deleteCharAt(buf.length()-1);\n\t}\n\treturn buf.toString();\n}"], "code_level": "class_runnable", "_id": "6367676b1a6d9265ec0181ee", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj+\"'\";\n\treturn obj;\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n    if(obj instanceof String){\n        obj = \"'\"+obj+\"'\";\n    }\n    return obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif (obj instanceof String) {\n\t\treturn \"'\" + obj.toString() + \"'\";\n\t} else {\n\t\treturn obj;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}else{\n\t\treturn obj;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj.toString()+\"'\";\n\telse\n\t\treturn obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn quote((String)obj);\n\t}\n\treturn obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj+\"'\";\n\telse\n\t\treturn obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\nreturn (obj instanceof String)?(\"\\\"\"+obj+\"\\\"\"):obj;}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}\n\treturn obj;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}else{\n\t\treturn obj;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n", "method_name": "quoteIfString", "codes": ["public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj+\"'\";\n\treturn obj;\n\t}", "public static Object quoteIfString(Object obj){\n\n    if(obj instanceof String){\n        obj = \"'\"+obj+\"'\";\n    }\n    return obj;\n}", "public static Object quoteIfString(Object obj){\n\n\tif (obj instanceof String) {\n\t\treturn \"'\" + obj.toString() + \"'\";\n\t} else {\n\t\treturn obj;\n\t}\n}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}else{\n\t\treturn obj;\n\t}\n}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj.toString()+\"'\";\n\telse\n\t\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn quote((String)obj);\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String)\n\t\treturn \"'\"+obj+\"'\";\n\telse\n\t\treturn obj;\n}", "public static Object quoteIfString(Object obj){\nreturn (obj instanceof String)?(\"\\\"\"+obj+\"\\\"\"):obj;}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}\n\treturn obj;\n}", "public static Object quoteIfString(Object obj){\n\n\tif(obj instanceof String){\n\t\treturn \"'\"+obj+\"'\";\n\t}else{\n\t\treturn obj;\n\t}\n}"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181bf", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str==null) return null;\n\tint len=str.length();\n\tint st=0;\n\tchar[] val=str.toCharArray();\n\twhile((st<len)&&(val[st]<=' ')) st++;\n\treturn (st>0) ? str.substring(st,len) : str;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null)\n\t\treturn null;\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\treturn buf.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n  String result=\"\";\n  for (int i=0; i<str.length(); i++){\n    if (str.charAt(i)==' ' || str.charAt(i)=='\\t' || str.charAt(i)=='\\n'){\n      result+=str.charAt(i);\n    }\n    else break;\n  }\n  return result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n  for(int i=0; i<str.length(); i++)\n    if(!isWhitespace(str.charAt(i)))\n      return str.substring(i);\n  return \"\";\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str==null) return null;\n\tStringBuffer buffer = new StringBuffer(str);\n\twhile(buffer.length()>0 && Character.isWhitespace(buffer.charAt(0))) buffer.deleteCharAt(0);\n\treturn buffer.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str.length() == 0)\n\t\treturn str;\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\treturn buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null) return null;\n\tStringBuffer buff = new StringBuffer(str);\n\twhile(buff.length() > 0 && buff.charAt(0) <= ' ')\n\t\tbuff.deleteCharAt(0);\n\treturn buff.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n    if(str.length() == 0)\n        return str;\n    int index = 0;\n    while(str.charAt(index) == ' ')\n        index++;\n    return str.substring(index);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null)\n\t\treturn null;\n\t\n\tStringBuffer buf = new StringBuffer(str);\n\t\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\t\n\treturn buf.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingWhitespace(String str){\n\n\tint len = str.length();\n\tint st = 0;\n\twhile ((st < len) && Character.isWhitespace(str.charAt(st))){\n\t\tst++;\n\t}\n\treturn str.substring(st, len);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n", "method_name": "trimLeadingWhitespace", "codes": ["public static String trimLeadingWhitespace(String str){\n\n\tif(str==null) return null;\n\tint len=str.length();\n\tint st=0;\n\tchar[] val=str.toCharArray();\n\twhile((st<len)&&(val[st]<=' ')) st++;\n\treturn (st>0) ? str.substring(st,len) : str;\n}", "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null)\n\t\treturn null;\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\treturn buf.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\n  String result=\"\";\n  for (int i=0; i<str.length(); i++){\n    if (str.charAt(i)==' ' || str.charAt(i)=='\\t' || str.charAt(i)=='\\n'){\n      result+=str.charAt(i);\n    }\n    else break;\n  }\n  return result;\n}", "public static String trimLeadingWhitespace(String str){\n\n  for(int i=0; i<str.length(); i++)\n    if(!isWhitespace(str.charAt(i)))\n      return str.substring(i);\n  return \"\";\n}", "public static String trimLeadingWhitespace(String str){\n\n\tif(str==null) return null;\n\tStringBuffer buffer = new StringBuffer(str);\n\twhile(buffer.length()>0 && Character.isWhitespace(buffer.charAt(0))) buffer.deleteCharAt(0);\n\treturn buffer.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\n\tif(str.length() == 0)\n\t\treturn str;\n\tStringBuffer buf = new StringBuffer(str);\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\treturn buf.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null) return null;\n\tStringBuffer buff = new StringBuffer(str);\n\twhile(buff.length() > 0 && buff.charAt(0) <= ' ')\n\t\tbuff.deleteCharAt(0);\n\treturn buff.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\n    if(str.length() == 0)\n        return str;\n    int index = 0;\n    while(str.charAt(index) == ' ')\n        index++;\n    return str.substring(index);\n}", "public static String trimLeadingWhitespace(String str){\n\n\tif(str == null)\n\t\treturn null;\n\t\n\tStringBuffer buf = new StringBuffer(str);\n\t\n\twhile(buf.length() > 0 && Character.isWhitespace(buf.charAt(0)))\n\t\tbuf.deleteCharAt(0);\n\t\n\treturn buf.toString();\n}", "public static String trimLeadingWhitespace(String str){\n\n\tint len = str.length();\n\tint st = 0;\n\twhile ((st < len) && Character.isWhitespace(str.charAt(st))){\n\t\tst++;\n\t}\n\treturn str.substring(st, len);\n}"], "code_level": "class_runnable", "_id": "6367676a1a6d9265ec0181cd", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null){\n\t\treturn null;\n\t}\n\tArrayList<String> strings=new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tstrings.add(enumeration.nextElement());\n\t}\n\treturn toStringArray(strings);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n    List<String> list=new ArrayList<String>();\n    while(enumeration.hasMoreElements()){\n        list.add(enumeration.nextElement());\n    }\n    return list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tVector<String> vector = new Vector<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tvector.add(enumeration.nextElement());\n\t}\n\tString[] array = new String[vector.size()];\n\tvector.toArray(array);\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null)return null;\n\tint size=enumeration.size();\n\tif(size==0)return new String[0];\n\tString[] array=new String[size];\n\tfor(int i=0;i<size;i++){\n\t\tarray[i]=enumeration.nextElement();\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tString[] array=new String[enumeration.size()];\n\tint c=0;\n\twhile(enumeration.hasMoreElements())\n\t\tarray[c++]=enumeration.nextElement();\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tList<String> list = new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tlist.add(enumeration.nextElement());\n\t}\n\treturn list.toArray(new String[list.size()]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tVector<String> vector=new Vector<String>();\n\twhile(enumeration.hasMoreElements())vector.add(enumeration.nextElement());\n\treturn toStringArray(vector);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tArrayList<String> arrayList=new ArrayList<String>();\n\twhile(enumeration.hasMoreElements())\n\t\tarrayList.add(enumeration.nextElement());\n\tString[] array=new String[arrayList.size()];\n\treturn arrayList.toArray(array);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n    if(enumeration == null) return null;\n    Vector<String> vector = new Vector<String>();\n    while(enumeration.hasMoreElements()) {\n        vector.addElement(enumeration.nextElement());\n    }\n    String[] stringArray = new String[vector.size()];\n    vector.copyInto(stringArray);\n    return stringArray;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null) return null;\n\tArrayList<String> temp = new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()) temp.add(enumeration.nextElement());\n\treturn temp.toArray(new String[0]);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Copy the given Enumeration into a String array. The Enumeration must contain String elements only.\n * @param enumeration the Enumeration to copy\n * @return the String array (<code>null</code> if the passed-inEnumeration was <code>null</code>)\n */\n", "method_name": "toStringArray", "codes": ["public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null){\n\t\treturn null;\n\t}\n\tArrayList<String> strings=new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tstrings.add(enumeration.nextElement());\n\t}\n\treturn toStringArray(strings);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n    List<String> list=new ArrayList<String>();\n    while(enumeration.hasMoreElements()){\n        list.add(enumeration.nextElement());\n    }\n    return list.toArray(new String[list.size()]);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tVector<String> vector = new Vector<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tvector.add(enumeration.nextElement());\n\t}\n\tString[] array = new String[vector.size()];\n\tvector.toArray(array);\n\treturn array;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null)return null;\n\tint size=enumeration.size();\n\tif(size==0)return new String[0];\n\tString[] array=new String[size];\n\tfor(int i=0;i<size;i++){\n\t\tarray[i]=enumeration.nextElement();\n\t}\n\treturn array;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tString[] array=new String[enumeration.size()];\n\tint c=0;\n\twhile(enumeration.hasMoreElements())\n\t\tarray[c++]=enumeration.nextElement();\n\treturn array;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tList<String> list = new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()){\n\t\tlist.add(enumeration.nextElement());\n\t}\n\treturn list.toArray(new String[list.size()]);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tVector<String> vector=new Vector<String>();\n\twhile(enumeration.hasMoreElements())vector.add(enumeration.nextElement());\n\treturn toStringArray(vector);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tArrayList<String> arrayList=new ArrayList<String>();\n\twhile(enumeration.hasMoreElements())\n\t\tarrayList.add(enumeration.nextElement());\n\tString[] array=new String[arrayList.size()];\n\treturn arrayList.toArray(array);\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n    if(enumeration == null) return null;\n    Vector<String> vector = new Vector<String>();\n    while(enumeration.hasMoreElements()) {\n        vector.addElement(enumeration.nextElement());\n    }\n    String[] stringArray = new String[vector.size()];\n    vector.copyInto(stringArray);\n    return stringArray;\n}", "public static String[] toStringArray(Enumeration<String> enumeration){\n\n\tif(enumeration==null) return null;\n\tArrayList<String> temp = new ArrayList<String>();\n\twhile(enumeration.hasMoreElements()) temp.add(enumeration.nextElement());\n\treturn temp.toArray(new String[0]);\n}"], "code_level": "slib_runnable", "_id": "636767691a6d9265ec0181ae", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif (!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor (int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif (charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n    if(!hasLength(inString)||!hasLength(charsToDelete)){\n        return inString;\n    }\n    StringBuilder sb=new StringBuilder();\n    for(int i=0;i<inString.length();i++){\n        char c=inString.charAt(i);\n        if(charsToDelete.indexOf(c)==-1){\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(isEmpty(inString)||isEmpty(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n  if(!hasLength(inString)||!hasLength(charsToDelete)){return inString;}\n  StringBuilder sb=new StringBuilder();\n  for(int i=0;i<inString.length();i++){\n    char c=inString.charAt(i);\n    if(charsToDelete.indexOf(c)==-1){sb.append(c);}\n  }\n  return sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n", "method_name": "deleteAny", "codes": ["public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif (!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor (int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif (charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n    if(!hasLength(inString)||!hasLength(charsToDelete)){\n        return inString;\n    }\n    StringBuilder sb=new StringBuilder();\n    for(int i=0;i<inString.length();i++){\n        char c=inString.charAt(i);\n        if(charsToDelete.indexOf(c)==-1){\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(isEmpty(inString)||isEmpty(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n  if(!hasLength(inString)||!hasLength(charsToDelete)){return inString;}\n  StringBuilder sb=new StringBuilder();\n  for(int i=0;i<inString.length();i++){\n    char c=inString.charAt(i);\n    if(charsToDelete.indexOf(c)==-1){sb.append(c);}\n  }\n  return sb.toString();\n}", "public static String deleteAny(String inString,String charsToDelete){\n\n\tif(!hasLength(inString)||!hasLength(charsToDelete)){\n\t\treturn inString;\n\t}\n\tStringBuilder sb=new StringBuilder();\n\tfor(int i=0;i<inString.length();i++){\n\t\tchar c=inString.charAt(i);\n\t\tif(charsToDelete.indexOf(c)==-1){\n\t\t\tsb.append(c);\n\t\t}\n\t}\n\treturn sb.toString();\n}"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec01820b", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection==null || element==null){\n\t\treturn false;\n\t}\n\tfor(Object item:collection){\n\t\tif(item==element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection!=null){\n\t\tif(collection instanceof List){\n\t\t\tList list=(List)collection;\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tObject obj=list.get(i);\n\t\t\t\tif(element.equals(obj)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(collection instanceof Set){\n\t\t\tSet set=(Set)collection;\n\t\t\tIterator iterator=set.iterator();\n\t\t\twhile(iterator.hasNext()){\n\t\t\t\tObject obj=iterator.next();\n\t\t\t\tif(element.equals(obj)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection==null){\n\t\treturn false;\n\t}\n\ttry{\n\tIterator itr=collection.iterator();\n\twhile(itr.hasNext()){\n\t\tObject obj=itr.next();\n\t\tif(obj==element){\n\t\t\treturn true;\n\t\t}\n\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection == null){\n\t\treturn false;\n\t}\n\tif(element instanceof Collection){\n\t\tIterator it = ((Collection) element).iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tObject elem = it.next();\n\t\t\tif(!containsInstance(collection, elem)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse{\n\t\ttry {\n\t\t\treturn collection.contains(element);\n\t\t} catch (ClassCastException ex) {\n\t\t\tIterator it = collection.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tObject elem = it.next();\n\t\t\t\tif(element == elem){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn getInstanceIndex(collection,element)!=-1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn getInstance(collection,element)!=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tIterator it = collection.iterator();\n\twhile(it.hasNext()){\n\t\tObject next = it.next();\n\t\tif(element == next){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tfor(Iterator it = collection.iterator();it.hasNext();){\n\t\tObject instance = it.next();\n\t\tif(instance == element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\tfor(Iterator it=collection.iterator();it.hasNext();){\n\t\tObject obj=it.next();\n\t\tif(obj==element)return true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn collection.stream()\n\t\t\t.anyMatch(e -> e == element);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Check whether the given Collection contains the given element instance. <p>Enforces the given instance to be present, rather than returning <code>true</code> for an equal element as well.\n * @param collection the Collection to check\n * @param element the element to look for\n * @return <code>true</code> if found, <code>false</code> else\n */\n", "method_name": "containsInstance", "codes": ["public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection==null || element==null){\n\t\treturn false;\n\t}\n\tfor(Object item:collection){\n\t\tif(item==element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection!=null){\n\t\tif(collection instanceof List){\n\t\t\tList list=(List)collection;\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tObject obj=list.get(i);\n\t\t\t\tif(element.equals(obj)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(collection instanceof Set){\n\t\t\tSet set=(Set)collection;\n\t\t\tIterator iterator=set.iterator();\n\t\t\twhile(iterator.hasNext()){\n\t\t\t\tObject obj=iterator.next();\n\t\t\t\tif(element.equals(obj)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection==null){\n\t\treturn false;\n\t}\n\ttry{\n\tIterator itr=collection.iterator();\n\twhile(itr.hasNext()){\n\t\tObject obj=itr.next();\n\t\tif(obj==element){\n\t\t\treturn true;\n\t\t}\n\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tif(collection == null){\n\t\treturn false;\n\t}\n\tif(element instanceof Collection){\n\t\tIterator it = ((Collection) element).iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tObject elem = it.next();\n\t\t\tif(!containsInstance(collection, elem)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse{\n\t\ttry {\n\t\t\treturn collection.contains(element);\n\t\t} catch (ClassCastException ex) {\n\t\t\tIterator it = collection.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tObject elem = it.next();\n\t\t\t\tif(element == elem){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn getInstanceIndex(collection,element)!=-1;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn getInstance(collection,element)!=null;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tIterator it = collection.iterator();\n\twhile(it.hasNext()){\n\t\tObject next = it.next();\n\t\tif(element == next){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tfor(Iterator it = collection.iterator();it.hasNext();){\n\t\tObject instance = it.next();\n\t\tif(instance == element){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\tfor(Iterator it=collection.iterator();it.hasNext();){\n\t\tObject obj=it.next();\n\t\tif(obj==element)return true;\n\t}\n\treturn false;\n}", "public static boolean containsInstance(Collection collection,Object element){\n\n\treturn collection.stream()\n\t\t\t.anyMatch(e -> e == element);\n}"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018223", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(array1==null||array1.length==0){\n\t\treturn array2;\n\t}\n\tif(array2==null||array2.length==0){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr = new String[array1.length + array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n", "method_name": "concatenateStringArrays", "codes": ["public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(array1==null||array1.length==0){\n\t\treturn array2;\n\t}\n\tif(array2==null||array2.length==0){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr = new String[array1.length + array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}", "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n\n\tif(ObjectUtils.isEmpty(array1)){\n\t\treturn array2;\n\t}\n\tif(ObjectUtils.isEmpty(array2)){\n\t\treturn array1;\n\t}\n\tString[] newArr=new String[array1.length+array2.length];\n\tSystem.arraycopy(array1,0,newArr,0,array1.length);\n\tSystem.arraycopy(array2,0,newArr,array1.length,array2.length);\n\treturn newArr;\n}"], "code_level": "slib_runnable", "_id": "6367676c1a6d9265ec018204", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n    if(array==null){\n        return new String[]{str};\n    }\n    else{\n        int len=array.length;\n        String[] newarray=new String[len+1];\n        System.arraycopy(array,0,newarray,0,len);\n        newarray[len]=str;\n        return newarray;\n    }\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] newArray=new String[array.length+1];\n\tfor (int i=0;i<array.length;i++){\n\t\tnewArray[i]=array[i];\n\t}\n\tnewArray[array.length]=str;\n\treturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null){\n\t\tarray=new String[0];\n\t}\n\tString[] newArray=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\tnewArray[i]=array[i];\n\t}\n\tnewArray[newArray.length-1]=str;\n\treturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] newArray = new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\tnewArray[i] = array[i];\n\t}\n\tnewArray[newArray.length-1] = str;\n\treturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n  if(array==null)return new String[]{str};\n  if(str==null)return array;\n  String[] newArray=new String[array.length+1];\n  System.arraycopy(array,0,newArray,0,array.length);\n  newArray[array.length]=str;\n  return newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n    if(array==null){\n        array=new String[]{str};\n    }else{\n        int arrayLength=array.length;\n        String[] newArray=new String[arrayLength+1];\n        System.arraycopy(array,0,newArray,0,arrayLength);\n        newArray[arrayLength]=str;\n        array=newArray;\n    }\n    return array;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null){return new String[]{str};}\n\tString[] temp=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){temp[i]=array[i];}\n\ttemp[array.length]=str;\n\treturn temp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null) return new String[]{str};\n\tint len=array.length;\n\tString[] newArray=new String[len+1];\n\tfor(int i=0;i<len;i++) newArray[i]=array[i];\n\tnewArray[len]=str;\n\treturn newArray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null) return new String[]{str};\n\tint len=array.length;\n\tString[] narray=new String[len+1];\n\tfor(int i=0;i<len;i++) narray[i]=array[i];\n\tnarray[len]=str;\n\treturn narray;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] tmp=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\ttmp[i]=array[i];\n\t}\n\ttmp[array.length]=str;\n\treturn tmp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n", "method_name": "addStringToArray", "codes": ["public static String[] addStringToArray(String[] array,String str){\n\n    if(array==null){\n        return new String[]{str};\n    }\n    else{\n        int len=array.length;\n        String[] newarray=new String[len+1];\n        System.arraycopy(array,0,newarray,0,len);\n        newarray[len]=str;\n        return newarray;\n    }\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] newArray=new String[array.length+1];\n\tfor (int i=0;i<array.length;i++){\n\t\tnewArray[i]=array[i];\n\t}\n\tnewArray[array.length]=str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null){\n\t\tarray=new String[0];\n\t}\n\tString[] newArray=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\tnewArray[i]=array[i];\n\t}\n\tnewArray[newArray.length-1]=str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] newArray = new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\tnewArray[i] = array[i];\n\t}\n\tnewArray[newArray.length-1] = str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n  if(array==null)return new String[]{str};\n  if(str==null)return array;\n  String[] newArray=new String[array.length+1];\n  System.arraycopy(array,0,newArray,0,array.length);\n  newArray[array.length]=str;\n  return newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n    if(array==null){\n        array=new String[]{str};\n    }else{\n        int arrayLength=array.length;\n        String[] newArray=new String[arrayLength+1];\n        System.arraycopy(array,0,newArray,0,arrayLength);\n        newArray[arrayLength]=str;\n        array=newArray;\n    }\n    return array;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null){return new String[]{str};}\n\tString[] temp=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){temp[i]=array[i];}\n\ttemp[array.length]=str;\n\treturn temp;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null) return new String[]{str};\n\tint len=array.length;\n\tString[] newArray=new String[len+1];\n\tfor(int i=0;i<len;i++) newArray[i]=array[i];\n\tnewArray[len]=str;\n\treturn newArray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tif(array==null) return new String[]{str};\n\tint len=array.length;\n\tString[] narray=new String[len+1];\n\tfor(int i=0;i<len;i++) narray[i]=array[i];\n\tnarray[len]=str;\n\treturn narray;\n}", "public static String[] addStringToArray(String[] array,String str){\n\n\tString[] tmp=new String[array.length+1];\n\tfor(int i=0;i<array.length;i++){\n\t\ttmp[i]=array[i];\n\t}\n\ttmp[array.length]=str;\n\treturn tmp;\n}"], "code_level": "slib_runnable", "_id": "6367676a1a6d9265ec0181d4", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n    if(str == null || sub == null || str.length() == 0 || sub.length() == 0) return 0;\n    int count = 0;\n    int pos = 0;\n    int idx;\n    while((idx = str.indexOf(sub,pos)) != -1){\n        ++count;\n        pos = idx + sub.length();\n    }\n    return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\nif((str==null)||(sub==null)||(str.length()==0)||(sub.length()==0)){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\nif(!hasLength(str)||!hasLength(sub)){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\nint count=0;\nif(str==null||sub==null||str.length()==0||sub.length()==0)\nreturn 0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0)return 0;\n    int count=0,pos=0,idx=0;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0){\n        return 0;\n    }\n    int count=0;\n    int pos=0;\n    int idx=0;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n  if(str==null || sub==null || str.length()==0 || sub.length()==0){return 0;}\n  int count=0,pos=0,idx=0;\n  while((idx=str.indexOf(sub,pos))!=-1){\n    ++count;\n    pos=idx+sub.length();\n  }\n  return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\nif(str==null||sub==null||str.length()==0||sub.length()==0){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0){\n        return 0;\n    }\n    int count=0;\n    int pos=0;\n    int idx;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int countOccurrencesOf(String str,String sub){\n\n    if((str==null)||(sub==null)||(str.length()==0)||(sub.length()==0))\n        return 0;\n    int count=0;\n    int pos=0;\n    int idx;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns the number of occurrences the substring  {@code sub} appears in string {@code str}.\n * @param str string to search in. Return 0 if this is null.\n * @param sub string to search for. Return 0 if this is null.\n * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n */\n", "method_name": "countOccurrencesOf", "codes": ["public static int countOccurrencesOf(String str,String sub){\n\n    if(str == null || sub == null || str.length() == 0 || sub.length() == 0) return 0;\n    int count = 0;\n    int pos = 0;\n    int idx;\n    while((idx = str.indexOf(sub,pos)) != -1){\n        ++count;\n        pos = idx + sub.length();\n    }\n    return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\nif((str==null)||(sub==null)||(str.length()==0)||(sub.length()==0)){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\nif(!hasLength(str)||!hasLength(sub)){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\nint count=0;\nif(str==null||sub==null||str.length()==0||sub.length()==0)\nreturn 0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0)return 0;\n    int count=0,pos=0,idx=0;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0){\n        return 0;\n    }\n    int count=0;\n    int pos=0;\n    int idx=0;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\n  if(str==null || sub==null || str.length()==0 || sub.length()==0){return 0;}\n  int count=0,pos=0,idx=0;\n  while((idx=str.indexOf(sub,pos))!=-1){\n    ++count;\n    pos=idx+sub.length();\n  }\n  return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\nif(str==null||sub==null||str.length()==0||sub.length()==0){\nreturn 0;\n}\nint count=0;\nint pos=0;\nint idx;\nwhile((idx=str.indexOf(sub,pos))!=-1){\n++count;\npos=idx+sub.length();\n}\nreturn count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\n    if(str==null||sub==null||str.length()==0||sub.length()==0){\n        return 0;\n    }\n    int count=0;\n    int pos=0;\n    int idx;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}", "public static int countOccurrencesOf(String str,String sub){\n\n    if((str==null)||(sub==null)||(str.length()==0)||(sub.length()==0))\n        return 0;\n    int count=0;\n    int pos=0;\n    int idx;\n    while((idx=str.indexOf(sub,pos))!=-1){\n        ++count;\n        pos=idx+sub.length();\n    }\n    return count;\n}"], "code_level": "self_contained", "_id": "6367676b1a6d9265ec0181dd", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif(extIndex==-1){\n\t\treturn path;\n\t}\n\tint folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(folderIndex>extIndex){\n\t\treturn path;\n\t}\n\treturn path.substring(0,extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\tint sepIndex = path.lastIndexOf(\".\");\n\treturn (sepIndex != -1 ? path.substring(0, sepIndex) : path);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\treturn (sepIndex!=-1?path.substring(0,sepIndex):path);\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n    // Handle null case specially.\n    if (path == null) return null;\n    \n    // Get position of last '.'.\n    int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n    \n    // If there isn't one, we don't strip an extension.\n    if (extIndex == -1) return path;\n    \n    // Otherwise return the string before it.\n    return path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\nif(path==null){\nreturn null;\n}\nint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\nreturn (sepIndex!=-1?path.substring(0,sepIndex):path);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\treturn (sepIndex!=-1 ? path.substring(0,sepIndex):path);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\treturn FilenameUtils.removeExtension(path);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n    if(path==null){\n        return null;\n    }\n    int sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n    return (sepIndex!=-1?path.substring(0,sepIndex):path);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\tint extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif(extIndex==-1)\n\t\treturn path;\n\tint folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(folderIndex>extIndex)\n\t\treturn path;\n\treturn path.substring(0,extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String stripFilenameExtension(String path){\n\n\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif (extIndex == -1) {\n\t    return path;\n\t}\n\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n\tif (folderIndex > extIndex) {\n\t    return path;\n\t}\n\treturn path.substring(0, extIndex);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Strip the filename extension from the given path, e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n * @param path the file path (may be <code>null</code>)\n * @return the path with stripped filename extension,or <code>null</code> if none\n */\n", "method_name": "stripFilenameExtension", "codes": ["public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif(extIndex==-1){\n\t\treturn path;\n\t}\n\tint folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(folderIndex>extIndex){\n\t\treturn path;\n\t}\n\treturn path.substring(0,extIndex);\n}", "public static String stripFilenameExtension(String path){\n\n\tint sepIndex = path.lastIndexOf(\".\");\n\treturn (sepIndex != -1 ? path.substring(0, sepIndex) : path);\n}", "public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\treturn (sepIndex!=-1?path.substring(0,sepIndex):path);\n\t}", "public static String stripFilenameExtension(String path){\n\n    // Handle null case specially.\n    if (path == null) return null;\n    \n    // Get position of last '.'.\n    int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n    \n    // If there isn't one, we don't strip an extension.\n    if (extIndex == -1) return path;\n    \n    // Otherwise return the string before it.\n    return path.substring(0, extIndex);\n}", "public static String stripFilenameExtension(String path){\n\nif(path==null){\nreturn null;\n}\nint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\nreturn (sepIndex!=-1?path.substring(0,sepIndex):path);\n}", "public static String stripFilenameExtension(String path){\n\n\tif(path==null){\n\t\treturn null;\n\t}\n\tint sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\treturn (sepIndex!=-1 ? path.substring(0,sepIndex):path);\n}", "public static String stripFilenameExtension(String path){\n\n\treturn FilenameUtils.removeExtension(path);\n}", "public static String stripFilenameExtension(String path){\n\n    if(path==null){\n        return null;\n    }\n    int sepIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n    return (sepIndex!=-1?path.substring(0,sepIndex):path);\n}", "public static String stripFilenameExtension(String path){\n\n\tint extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif(extIndex==-1)\n\t\treturn path;\n\tint folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(folderIndex>extIndex)\n\t\treturn path;\n\treturn path.substring(0,extIndex);\n}", "public static String stripFilenameExtension(String path){\n\n\tint extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n\tif (extIndex == -1) {\n\t    return path;\n\t}\n\tint folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n\tif (folderIndex > extIndex) {\n\t    return path;\n\t}\n\treturn path.substring(0, extIndex);\n}"], "code_level": "class_runnable", "_id": "6367676c1a6d9265ec018220", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null) return str;\n\tStringBuffer sb=new StringBuffer(str);\n\twhile(sb.length()>0&&sb.charAt(0)==leadingCharacter) sb.deleteCharAt(0);\n\treturn sb.toString();\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null)return null;\n\tint len=str.length();\n\tif(len==0)return str;\n\tint st=0;\n\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\tst++;\n\t}\n\treturn st>0?str.substring(st,len):str;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null)return null;\n\tint strLen=str.length();\n\tif(strLen==0)return str;\n\tint start=0;\n\twhile(start!=strLen&&str.charAt(start)==leadingCharacter){\n\t\tstart++;\n\t}\n\treturn str.substring(start);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null){\n\t\treturn str;\n\t}\n\tint startIndex=0;\n\twhile(startIndex<str.length()&&str.charAt(startIndex)==leadingCharacter){\n\t\tstartIndex++;\n\t}\n\treturn str.substring(startIndex);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\treturn trimLeadingCharacter(str,leadingCharacter,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str!=null){\n\t\tint len=str.length();\n\t\tint st=0;\n\t\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\t\tst++;\n\t\t}\n\t\treturn st>0?str.substring(st,len):str;\n\t}else{\n\t\treturn str;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tint len=str.length();\n\tint st=0;\n\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\tst++;\n\t}\n\treturn str.substring(st,len);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\nif(str==null){return null;}\nif(leadingCharacter==0){return \"\";}\nint length=str.length();\nint start=0;\nwhile(start<length&&str.charAt(start)==leadingCharacter){start++;}\nreturn str.substring(start);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\nif(str==null)\nreturn null;\n\nfor(int i=0;i<str.length();i++){\nif(str.charAt(i)==leadingCharacter)\ncontinue;\nelse\nreturn str.substring(i);\n}\nreturn str;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\t\n\tif(str==null || str.length()==0){\n\t\treturn str;\n\t}\n\t\n\tStringBuffer buffer=new StringBuffer(str);\n\t\n\twhile(buffer.length()>0 && buffer.charAt(0)==leadingCharacter){\n\t\tbuffer.deleteCharAt(0);\n\t}\n\t\n\treturn buffer.toString();\n\t\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n", "method_name": "trimLeadingCharacter", "codes": ["public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null) return str;\n\tStringBuffer sb=new StringBuffer(str);\n\twhile(sb.length()>0&&sb.charAt(0)==leadingCharacter) sb.deleteCharAt(0);\n\treturn sb.toString();\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null)return null;\n\tint len=str.length();\n\tif(len==0)return str;\n\tint st=0;\n\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\tst++;\n\t}\n\treturn st>0?str.substring(st,len):str;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null)return null;\n\tint strLen=str.length();\n\tif(strLen==0)return str;\n\tint start=0;\n\twhile(start!=strLen&&str.charAt(start)==leadingCharacter){\n\t\tstart++;\n\t}\n\treturn str.substring(start);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str==null){\n\t\treturn str;\n\t}\n\tint startIndex=0;\n\twhile(startIndex<str.length()&&str.charAt(startIndex)==leadingCharacter){\n\t\tstartIndex++;\n\t}\n\treturn str.substring(startIndex);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\treturn trimLeadingCharacter(str,leadingCharacter,true);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tif(str!=null){\n\t\tint len=str.length();\n\t\tint st=0;\n\t\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\t\tst++;\n\t\t}\n\t\treturn st>0?str.substring(st,len):str;\n\t}else{\n\t\treturn str;\n\t}\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\tint len=str.length();\n\tint st=0;\n\twhile((st<len)&&(str.charAt(st)==leadingCharacter)){\n\t\tst++;\n\t}\n\treturn str.substring(st,len);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\nif(str==null){return null;}\nif(leadingCharacter==0){return \"\";}\nint length=str.length();\nint start=0;\nwhile(start<length&&str.charAt(start)==leadingCharacter){start++;}\nreturn str.substring(start);\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\nif(str==null)\nreturn null;\n\nfor(int i=0;i<str.length();i++){\nif(str.charAt(i)==leadingCharacter)\ncontinue;\nelse\nreturn str.substring(i);\n}\nreturn str;\n}", "public static String trimLeadingCharacter(String str,char leadingCharacter){\n\n\t\n\tif(str==null || str.length()==0){\n\t\treturn str;\n\t}\n\t\n\tStringBuffer buffer=new StringBuffer(str);\n\t\n\twhile(buffer.length()>0 && buffer.charAt(0)==leadingCharacter){\n\t\tbuffer.deleteCharAt(0);\n\t}\n\t\n\treturn buffer.toString();\n\t\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a7", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\tint offset = toSplit.indexOf(delimiter);\n\tif(offset<0){\n\t\treturn null;\n\t}\n\tString beforeDelimiter = toSplit.substring(0,offset);\n\tString afterDelimiter = toSplit.substring(offset+delimiter.length());\n\treturn new String[]{beforeDelimiter,afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\tif(toSplit.indexOf(delimiter)==-1)\n\t\treturn new String[]{toSplit};\n\treturn new String[]{toSplit.substring(0,toSplit.indexOf(delimiter)),\n\t\ttoSplit.substring(toSplit.indexOf(delimiter)+delimiter.length())};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\tint offset=toSplit.indexOf(delimiter);\n\tif(offset<0){\n\t\treturn null;\n\t}\n\tString beforeDelimiter=toSplit.substring(0,offset);\n\tString afterDelimiter=toSplit.substring(offset+delimiter.length());\n\treturn new String[]{beforeDelimiter,afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\nif((toSplit==null)||(delimiter==null)){\nreturn null;\n}\nint offset=toSplit.indexOf(delimiter);\nif(offset<0){\nreturn null;\n}\nString beforeDelimiter=toSplit.substring(0,offset);\nString afterDelimiter=toSplit.substring(offset+delimiter.length());\nreturn new String[]{beforeDelimiter,afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\nif(delimiter.length()==0){// Delimiter is an empty string.\n// This is a special case that I'm choosing to handle differently than\n// String.split(). String.split() throws PatternSyntaxException in this case,\n// while I'm choosing to return the original string as the only element in an\n// array.\nreturn new String[]{toSplit};}String[] splitArray=new String[2];int pos=toSplit.indexOf(delimiter);if(pos==-1){// Delimiter is not present in string.\nsplitArray[0]=toSplit;splitArray[1]=\"\";}else{// Delimiter is present in string.\nsplitArray[0]=toSplit.substring(0,pos);splitArray[1]=toSplit.substring(pos+delimiter.length());}return splitArray;}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\t// Perform primitive validation\n\tif (toSplit==null||delimiter==null||delimiter.length()==0){\n\t\treturn null;\n\t}\n\t// We use an arraylist to collect the substrings that don't contain delimiters.\n\t// As a side effect, we also record whether the last character in toSplit is\n\t// a delimiter.\n\tint offset=0;\n\tArrayList<String> substrings=new ArrayList<String>();\n\tboolean match=false;\n\twhile(true){\n\t\tint found=toSplit.indexOf(delimiter,offset);\n\t\tif (found==-1){\n\t\t\t// We've exhausted toSplit - there's no more delimiters in it.\n\t\t\tif (offset==0){\n\t\t\t\t// We found no delimiters at all.Return the whole thing as the first/only substring,with a null second substring.\n\t\t\t\treturn new String[]{toSplit,null};\n\t\t\t}else{\n\t\t\t\t// We found at least one delimiter.Add everything between", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\treturn split(toSplit,delimiter,false,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n    int offset=toSplit.indexOf(delimiter);\n    if(offset<0){\n        return null;\n    }\n    String beforeDelimiter=toSplit.substring(0,offset);\n    String afterDelimiter=toSplit.substring(offset+delimiter.length());\n    return new String[]{beforeDelimiter,afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n    if(toSplit==null)return null;\n    if(delimiter==null)return new String[]{toSplit};\n    int offset=toSplit.indexOf(delimiter);\n    if(offset<0)return new String[]{toSplit};\n    String beforeDelimiter=toSplit.substring(0,offset);\n    String afterDelimiter=toSplit.substring(offset+delimiter.length());\n    return new String[]{beforeDelimiter,afterDelimiter};\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String[] split(String toSplit,String delimiter){\n\n\tif(toSplit==null||delimiter==null||!toSplit.contains(delimiter)){\n\t\treturn null;\n\t}\n\tString[] result=new String[2];\n\tresult[0]=toSplit.substring(0,toSplit.indexOf(delimiter));\n\tresult[1]=toSplit.substring(toSplit.indexOf(delimiter)+1);\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n", "method_name": "split", "codes": ["public static String[] split(String toSplit,String delimiter){\n\n\tint offset = toSplit.indexOf(delimiter);\n\tif(offset<0){\n\t\treturn null;\n\t}\n\tString beforeDelimiter = toSplit.substring(0,offset);\n\tString afterDelimiter = toSplit.substring(offset+delimiter.length());\n\treturn new String[]{beforeDelimiter,afterDelimiter};\n}", "public static String[] split(String toSplit,String delimiter){\n\n\tif(toSplit.indexOf(delimiter)==-1)\n\t\treturn new String[]{toSplit};\n\treturn new String[]{toSplit.substring(0,toSplit.indexOf(delimiter)),\n\t\ttoSplit.substring(toSplit.indexOf(delimiter)+delimiter.length())};\n}", "public static String[] split(String toSplit,String delimiter){\n\n\tint offset=toSplit.indexOf(delimiter);\n\tif(offset<0){\n\t\treturn null;\n\t}\n\tString beforeDelimiter=toSplit.substring(0,offset);\n\tString afterDelimiter=toSplit.substring(offset+delimiter.length());\n\treturn new String[]{beforeDelimiter,afterDelimiter};\n}", "public static String[] split(String toSplit,String delimiter){\n\nif((toSplit==null)||(delimiter==null)){\nreturn null;\n}\nint offset=toSplit.indexOf(delimiter);\nif(offset<0){\nreturn null;\n}\nString beforeDelimiter=toSplit.substring(0,offset);\nString afterDelimiter=toSplit.substring(offset+delimiter.length());\nreturn new String[]{beforeDelimiter,afterDelimiter};\n}", "public static String[] split(String toSplit,String delimiter){\nif(delimiter.length()==0){// Delimiter is an empty string.\n// This is a special case that I'm choosing to handle differently than\n// String.split(). String.split() throws PatternSyntaxException in this case,\n// while I'm choosing to return the original string as the only element in an\n// array.\nreturn new String[]{toSplit};}String[] splitArray=new String[2];int pos=toSplit.indexOf(delimiter);if(pos==-1){// Delimiter is not present in string.\nsplitArray[0]=toSplit;splitArray[1]=\"\";}else{// Delimiter is present in string.\nsplitArray[0]=toSplit.substring(0,pos);splitArray[1]=toSplit.substring(pos+delimiter.length());}return splitArray;}", "public static String[] split(String toSplit,String delimiter){\n\n\t// Perform primitive validation\n\tif (toSplit==null||delimiter==null||delimiter.length()==0){\n\t\treturn null;\n\t}\n\t// We use an arraylist to collect the substrings that don't contain delimiters.\n\t// As a side effect, we also record whether the last character in toSplit is\n\t// a delimiter.\n\tint offset=0;\n\tArrayList<String> substrings=new ArrayList<String>();\n\tboolean match=false;\n\twhile(true){\n\t\tint found=toSplit.indexOf(delimiter,offset);\n\t\tif (found==-1){\n\t\t\t// We've exhausted toSplit - there's no more delimiters in it.\n\t\t\tif (offset==0){\n\t\t\t\t// We found no delimiters at all.Return the whole thing as the first/only substring,with a null second substring.\n\t\t\t\treturn new String[]{toSplit,null};\n\t\t\t}else{\n\t\t\t\t// We found at least one delimiter.Add everything between", "public static String[] split(String toSplit,String delimiter){\n\n\treturn split(toSplit,delimiter,false,0);\n}", "public static String[] split(String toSplit,String delimiter){\n\n    int offset=toSplit.indexOf(delimiter);\n    if(offset<0){\n        return null;\n    }\n    String beforeDelimiter=toSplit.substring(0,offset);\n    String afterDelimiter=toSplit.substring(offset+delimiter.length());\n    return new String[]{beforeDelimiter,afterDelimiter};\n}", "public static String[] split(String toSplit,String delimiter){\n\n    if(toSplit==null)return null;\n    if(delimiter==null)return new String[]{toSplit};\n    int offset=toSplit.indexOf(delimiter);\n    if(offset<0)return new String[]{toSplit};\n    String beforeDelimiter=toSplit.substring(0,offset);\n    String afterDelimiter=toSplit.substring(offset+delimiter.length());\n    return new String[]{beforeDelimiter,afterDelimiter};\n}", "public static String[] split(String toSplit,String delimiter){\n\n\tif(toSplit==null||delimiter==null||!toSplit.contains(delimiter)){\n\t\treturn null;\n\t}\n\tString[] result=new String[2];\n\tresult[0]=toSplit.substring(0,toSplit.indexOf(delimiter));\n\tresult[1]=toSplit.substring(toSplit.indexOf(delimiter)+1);\n\treturn result;\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181a6", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.indexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.indexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Apply the given relative path to the given path, assuming standard Java folder separation (i.e. \"/\" separators).\n * @param path the path to start from (usually a full file path)\n * @param relativePath the relative path to apply(relative to the full file path above)\n * @return the full file path that results from applying the relative path\n */\n", "method_name": "applyRelativePath", "codes": ["public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.indexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.indexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}\n\telse{\n\t\treturn relativePath;\n\t}\n}", "public static String applyRelativePath(String path,String relativePath){\n\n\tint separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n\tif(separatorIndex!=-1){\n\t\tString newPath=path.substring(0,separatorIndex);\n\t\tif(!relativePath.startsWith(FOLDER_SEPARATOR)){\n\t\t\tnewPath+=FOLDER_SEPARATOR;\n\t\t}\n\t\treturn newPath+relativePath;\n\t}else{\n\t\treturn relativePath;\n\t}\n}"], "code_level": "class_runnable", "_id": "636767691a6d9265ec0181ac", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\nfor(int j=0;j<substring.length();j++){int i=index+j;if(i>=str.length()||str.charAt(i)!=substring.charAt(j)){return false;}}\nreturn true;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n    for(int j=0;j<substring.length();j++){\n        int i=index+j;\n        if(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n            return false;\n        }\n    }\n    return true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns  {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n * @param str the original string (or StringBuilder)\n * @param index the index in the original string to start matching against\n * @param substring the substring to match at the given index\n * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n */\n", "method_name": "substringMatch", "codes": ["public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\nfor(int j=0;j<substring.length();j++){int i=index+j;if(i>=str.length()||str.charAt(i)!=substring.charAt(j)){return false;}}\nreturn true;}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n    for(int j=0;j<substring.length();j++){\n        int i=index+j;\n        if(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n            return false;\n        }\n    }\n    return true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\nfor(int j=0;j<substring.length();j++){\nint i=index+j;\nif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\nreturn false;\n}\n}\nreturn true;\n}", "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n\n\tfor(int j=0;j<substring.length();j++){\n\t\tint i=index+j;\n\t\tif(i>=str.length()||str.charAt(i)!=substring.charAt(j)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "slib_runnable", "_id": "6367676b1a6d9265ec0181e9", "project_name": "jjwt-master"}
{"generate_results": [{"generate_code": "protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n    File file = new File(fileName);\n    if (file.exists()) {\n        file.delete();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif (file.exists()){\n\t\tfile.delete();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\ttry{\n\t\tFile f=new File(fileName);\n\t\tif(f.exists()){\n\t\t\tif(!f.delete()){\n\t\t\t\tSystem.out.println(\"Could not delete \"+fileName);\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\tSystem.out.println(\"Could not delete \"+fileName);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\tFile f = new File(fileName);\n\tf.delete();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\tif(fileExists(fileName)){\n\t\tFile file = new File(fileName);\n\t\tfile.delete();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\tFile f = new File(fileName);\n\tif (f.exists()) f.delete();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\ttry{\n\tFile file = new File(fileName);\n\tfile.delete();\n\t}\n\tcatch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected static void deleteFile(String fileName){\n\n   File file = new File(fileName);\n   if(file.exists()){\n      file.delete();\n   }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Delete's the specified file if it exists \n */\n", "method_name": "deleteFile", "codes": ["protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "protected static void deleteFile(String fileName){\n\n    File file = new File(fileName);\n    if (file.exists()) {\n        file.delete();\n    }\n}", "protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif (file.exists()){\n\t\tfile.delete();\n\t}\n}", "protected static void deleteFile(String fileName){\n\n\ttry{\n\t\tFile f=new File(fileName);\n\t\tif(f.exists()){\n\t\t\tif(!f.delete()){\n\t\t\t\tSystem.out.println(\"Could not delete \"+fileName);\n\t\t\t}\n\t\t}\n\t}catch(Exception e){\n\t\tSystem.out.println(\"Could not delete \"+fileName);\n\t}\n}", "protected static void deleteFile(String fileName){\n\n\tFile f = new File(fileName);\n\tf.delete();\n}", "protected static void deleteFile(String fileName){\n\n\tif(fileExists(fileName)){\n\t\tFile file = new File(fileName);\n\t\tfile.delete();\n\t}\n}", "protected static void deleteFile(String fileName){\n\n\tFile f = new File(fileName);\n\tif (f.exists()) f.delete();\n}", "protected static void deleteFile(String fileName){\n\n\ttry{\n\tFile file = new File(fileName);\n\tfile.delete();\n\t}\n\tcatch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "protected static void deleteFile(String fileName){\n\n\tFile file = new File(fileName);\n\tif(file.exists()){\n\t\tfile.delete();\n\t}\n}", "protected static void deleteFile(String fileName){\n\n   File file = new File(fileName);\n   if(file.exists()){\n      file.delete();\n   }\n}"], "code_level": "slib_runnable", "_id": "636767821a6d9265ec0183a0", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String format(LoggingEvent event){\n\nreturn converter.convert(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tif(this.patternConverter==null){\n\t\tif(this.next!=null){\n\t\t\treturn this.next.format(event);\n\t\t}\n\t\treturn null;\n\t}\n\tthis.stringBuffer.setLength(0);\n\tthis.patternConverter.format(this.stringBuffer,event);\n\tif(this.next!=null){\n\t\tthis.next.format(this.stringBuffer,event);\n\t}\n\treturn this.stringBuffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\nString s = patternConverter.convert(event);\nif(s==null)\n\treturn null;\nif(s.length()==0){\n\tif(next==null)\n\t\treturn s;\n\treturn next.format(event);\n}\ntry{\n\twriter.write(s);\n}catch(IOException e){\n\te.printStackTrace();\n}\nif(next==null){\n\tString s1 = writer.toString();\n\twriter.getBuffer().setLength(0);\n\treturn s1;\n}\nreturn next.format(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tfor (int i=0;i<contents.length();i++){\n\t\tchar ch=contents.charAt(i);\n\t\tif (ch=='\\\\'){\n\t\t\tswitch (contents.charAt(++i)){\n\t\t\t\tcase 'n':\n\t\t\t\t\tsbuf.append(Layout.LINE_SEP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tsbuf.append(Layout.TAB);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tsbuf.append(Layout.LINE_SEP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tsbuf.append('\\\\');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsbuf.append(contents.charAt(i));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch=='", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\treturn pattern.convert(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tString[] s=convert(event);\n\tif(s==null)return null;\n\tint len=s.length;\n\tfor(int i=0;i<len;i++){\n\t\tsbuf.append(s[i]);\n\t}\n\treturn sbuf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tif(this.patternConverter==null){\n\t\treturn null;\n\t}\n\tif(this.buffer==null){\n\t\tbuffer=new StringBuffer(256);\n\t}\n\tthis.buffer.setLength(0);\n\tthis.patternConverter.format(buffer,event);\n\treturn this.buffer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tif(formattingInfo.isLeftAligned()){\n\t\tint fieldStart=stringLength;\n\t\tsbuf.append(string);\n\t\twhile(fieldStart<formattingInfo.getMin()){\n\t\t\tsbuf.append(' ');\n\t\t\tfieldStart++;\n\t\t}\n\t\tif(formattingInfo.getMax()>0&&formattingInfo.getMax()<formattingInfo.getMin()){\n\t\t\tformattingInfo.setMax(formattingInfo.getMin());\n\t\t}\n\t}\n\tif((formattingInfo.getMin()>0)||(formattingInfo.getMax()>0)){\n\t\tStringBuffer field=converter.convert(event);\n\t\tif(formattingInfo.getMax()>0&&field.length()>formattingInfo.getMax()){\n\t\t\tsbuf.append(field.substring(field.length()-formattingInfo.getMax()));\n\t\t}else{\n\t\t\tsbuf.append(field);\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n    if(patternConverter == null) return null;\n    return patternConverter.convert(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(LoggingEvent event){\n\n\tStringBuffer buf=new StringBuffer();\n\tformat(buf, event);\n\treturn buf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Produces a formatted string as specified by the conversion pattern.\n */\n", "method_name": "format", "codes": ["public String format(LoggingEvent event){\n\nreturn converter.convert(event);\n}", "public String format(LoggingEvent event){\n\n\tif(this.patternConverter==null){\n\t\tif(this.next!=null){\n\t\t\treturn this.next.format(event);\n\t\t}\n\t\treturn null;\n\t}\n\tthis.stringBuffer.setLength(0);\n\tthis.patternConverter.format(this.stringBuffer,event);\n\tif(this.next!=null){\n\t\tthis.next.format(this.stringBuffer,event);\n\t}\n\treturn this.stringBuffer.toString();\n}", "public String format(LoggingEvent event){\n\nString s = patternConverter.convert(event);\nif(s==null)\n\treturn null;\nif(s.length()==0){\n\tif(next==null)\n\t\treturn s;\n\treturn next.format(event);\n}\ntry{\n\twriter.write(s);\n}catch(IOException e){\n\te.printStackTrace();\n}\nif(next==null){\n\tString s1 = writer.toString();\n\twriter.getBuffer().setLength(0);\n\treturn s1;\n}\nreturn next.format(event);\n}", "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tfor (int i=0;i<contents.length();i++){\n\t\tchar ch=contents.charAt(i);\n\t\tif (ch=='\\\\'){\n\t\t\tswitch (contents.charAt(++i)){\n\t\t\t\tcase 'n':\n\t\t\t\t\tsbuf.append(Layout.LINE_SEP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tsbuf.append(Layout.TAB);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tsbuf.append(Layout.LINE_SEP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tsbuf.append('\\\\');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsbuf.append(contents.charAt(i));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch=='", "public String format(LoggingEvent event){\n\n\treturn pattern.convert(event);\n}", "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tString[] s=convert(event);\n\tif(s==null)return null;\n\tint len=s.length;\n\tfor(int i=0;i<len;i++){\n\t\tsbuf.append(s[i]);\n\t}\n\treturn sbuf.toString();\n}", "public String format(LoggingEvent event){\n\n\tif(this.patternConverter==null){\n\t\treturn null;\n\t}\n\tif(this.buffer==null){\n\t\tbuffer=new StringBuffer(256);\n\t}\n\tthis.buffer.setLength(0);\n\tthis.patternConverter.format(buffer,event);\n\treturn this.buffer.toString();\n}", "public String format(LoggingEvent event){\n\n\tStringBuffer sbuf=new StringBuffer();\n\tif(formattingInfo.isLeftAligned()){\n\t\tint fieldStart=stringLength;\n\t\tsbuf.append(string);\n\t\twhile(fieldStart<formattingInfo.getMin()){\n\t\t\tsbuf.append(' ');\n\t\t\tfieldStart++;\n\t\t}\n\t\tif(formattingInfo.getMax()>0&&formattingInfo.getMax()<formattingInfo.getMin()){\n\t\t\tformattingInfo.setMax(formattingInfo.getMin());\n\t\t}\n\t}\n\tif((formattingInfo.getMin()>0)||(formattingInfo.getMax()>0)){\n\t\tStringBuffer field=converter.convert(event);\n\t\tif(formattingInfo.getMax()>0&&field.length()>formattingInfo.getMax()){\n\t\t\tsbuf.append(field.substring(field.length()-formattingInfo.getMax()));\n\t\t}else{\n\t\t\tsbuf.append(field);\n\t", "public String format(LoggingEvent event){\n\n    if(patternConverter == null) return null;\n    return patternConverter.convert(event);\n}", "public String format(LoggingEvent event){\n\n\tStringBuffer buf=new StringBuffer();\n\tformat(buf, event);\n\treturn buf.toString();\n}"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01830f", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "protected void subAppend(LoggingEvent event){\n\n\tString message=event.getRenderedMessage();\n\tString msg=message;\n\tif(msg==null){\n\t\tmsg=\"\";\n\t}\n\tif(msg.length()>=4000){\n\t\tmsg=message.substring(0,4000);\n\t}\n\ttry{\n\t\tif(!this.isFileOpened){\n\t\t\tif(this.tempFile==null){\n\t\t\t\tthis.tempFile=new File(this.tempFilePath);\n\t\t\t}\n\t\t\tthis.out=new FileWriter(this.tempFile,true);\n\t\t\tthis.isFileOpened=true;\n\t\t}\n\t\tthis.out.write(msg);\n\t\tthis.out.write(\"\\n\");\n\t\tthis.out.flush();\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\t\n\ttry{\n\t\tthis.qw.write(this.layout.format(event));\n\t\t\n\t\tif(this.layout.ignoresThrowable()){\n\t\t\tString[] s = event.getThrowableStrRep();\n\t\t\tif(s!=null){\n\t\t\t\tint len = s.length;\n\t\t\t\tfor(int i=0;i<len;i++){\n\t\t\t\t\tthis.qw.write(s[i]);\n\t\t\t\t\tthis.qw.write(Layout.LINE_SEP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.qw.flush();\n\t}catch(IOException e){\n\t\tthis.errorHandler.error(\"Failed to write to file [\"+this.fileName+\"]\",e,ErrorCode.WRITE_FAILURE);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\t\n\t//TODO:\n\t//\t1. \u65f6\u95f4\u683c\u5f0f\u95ee\u9898\n\t//\t2. \u65e5\u5fd7\u7ea7\u522b\u4e0d\u540c\uff0c\u8ffd\u52a0\u5230\u4e0d\u540c\u7684\u6587\u4ef6\u4e2d\n\t//\t3. \u6bcf\u5929\u81ea\u52a8\u521b\u5efa\u4e0d\u540c\u7684\u6587\u4ef6\uff0c\u5e76\u5220\u9664\u65e7\u7684\u6587\u4ef6\n\t//\t4. \u6bcf\u5929\u81ea\u52a8\u521b\u5efa\u4e0d\u540c\u7684\u6587\u4ef6\u5939\uff0c\u5e76\u5220\u9664\u65e7\u7684\u6587\u4ef6\n\t\n\tFile file = new File(this.fileName);\n\t\n\tif(!file.exists()){\n\t\ttry{\n\t\t\tfile.createNewFile();\n\t\t}catch(IOException e){\n\t\t\tLogLog.error(\"create file failed.\", e);\n\t\t}\n\t}\n\t\n\tString msg = this.layout.format(event);\n\t\n\ttry{\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\ttry{\n\t\tfos.write(layout.format(event));\n\t\tif(layout.ignoresThrowable()){\n\t\t\tString[] s = event.getThrowableStrRep();\n\t\t\tif(s!=null){\n\t\t\t\tint len = s.length;\n\t\t\t\tfor(int i=0;i<len;i++){\n\t\t\t\t\tfos.write(s[i]);\n\t\t\t\t\tfos.write(Layout.LINE_SEP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfos.flush();\n\t}catch(Exception e){\n\t\terrorHandler.error(\"Write into file error.\");\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n    try{\n        out.println(layout.format(event));\n        if(layout.ignoresThrowable()){\n            String[] s = event.getThrowableStrRep();\n            if(s!=null){\n                int len = s.length;\n                for(int i=0;i<len;i++){\n                    out.println(s[i]);\n                }\n            }\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\n// \tByteArrayOutputStream baos = new ByteArrayOutputStream();\n// \tObjectOutputStream oos = new ObjectOutputStream(baos);\n// \toos.writeObject(event);\n// \toos.flush();\n// \toos.close();\n\t\n\t\n\t\n\t\n\tlong eventTime = event.getTimeStamp();\n\tString msg = event.getMessage().toString();\n\tint priority = event.getLevel().toInt();\n\tString threadName = event.getThreadName();\n\tString categoryName = event.getLoggerName();\n\t\n\t//System.out.println(\"eventTime=\" + eventTime + \", msg=\" + msg + \", priority=\" + priority + \", threadName=\" + threadName + \", categoryName=\" + categoryName);\n\t\n\t//LogEvent logEvent = new LogEvent(eventTime, msg, priority, threadName, categoryName);\n\t\n\t//System.out.println(\"logEvent=\" + logEvent);\n\t\n\t//byte[] bytes = baos.toByteArray();\n\t\n\t//System.out.println(\"bytes=\" +", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n    String msg = this.layout.format(event);\n    String path = getDirectory();\n    String fileName = getFile();\n    if(fileName == null)\n        return;\n    String fullPath = path + fileName;\n    try{\n        synchronized(fileAppender){\n            File f = new File(fullPath);\n            if(!f.exists())\n                f.createNewFile();\n            BufferedWriter output = new BufferedWriter(new FileWriter(f,true));\n            output.write(msg);\n            output.flush();\n            output.close();\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\nFileWriter fw=null;\ntry{\n//if(fileName!=null){\n//fw=new FileWriter(fileName,true);\nfw=new FileWriter(fileName,true);\n}catch(IOException e){\nLogLog.error(\"Open file error\",e);\n}\nif(fw!=null){\ntry{\nString message=this.layout.format(event);\nfw.write(\"\\n\"+message);\nif(layout.ignoresThrowable()){\nString[] s=event.getThrowableStrRep();\nif(s!=null){\nint len=s.length;\nfor(int i=0;i<len;i++){\nfw.write(s[i]);\nfw.write(\"\\n\");\n}\n}\n}\nfw.flush();\nfw.close();\n}catch(IOException e){\nLogLog.error(\"Write file error\",e);\n}\n}\n}\n/**This method called by the AppenderSkeleton.Do not call it directly.*/\npublic void close(){\n}\n/**This method called by the AppenderSkeleton.Do not", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\t\t\n\t\tfinal String filePath = getFilePath();\n\t\tfinal String fileName = getFileName();\n\t\tfinal String fileNameWithPath = filePath + fileName;\n\t\t\n\t\tif(!fileNameWithPath.equals(lastFileNameWithPath)){\n\t\t\tif(writer != null){\n\t\t\t\ttry{\n\t\t\t\t\twriter.close();\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\tlogger.warn(\"close writer error\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tFile file = new File(filePath);\n\t\t\tif(!file.exists()){\n\t\t\t\tfile.mkdirs();\n\t\t\t}\n\t\t\t\n\t\t\ttry{\n\t\t\t\twriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileNameWithPath, true), \"UTF-8\"));\n\t\t\t}catch(IOException e){\n\t\t\t\tlogger.warn(\"create writer error\", e);\n\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void subAppend(LoggingEvent event){\n\n\tlong n = System.currentTimeMillis();\n\tif (n >= nextCheck) {\n\t\tnow.setTime(n);\n\t\tnextCheck = rc.getNextCheckMillis(now);\n\t\ttry {\n\t\t\trollOver();\n\t\t} catch (IOException ioe) {\n\t\t\tLogLog.error(\"rollOver() failed.\", ioe);\n\t\t}\n\t}\n\tif (qw == null) {\n\t\terrorHandler.error(\"No output stream or file set for the appender named [\"+name+\"].\");\n\t\treturn;\n\t}\n\tif(!isAsSevereAsThreshold(event.getLevel()))\n\t\treturn;\n\t\n\tevent.getThreadName();\n\tevent.getNDC();\n\tevent.getMDCCopy();\n\tif(locationInfo) {\n\t\tevent.getLocationInformation();\n\t}\n\tevent.getRenderedMessage();\n\tevent.getThrowableStrRep();\n\tqw.write(layout.format(event));\n\n\tif (layout.ignoresThrowable()) {\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * This method does actual writing\n */\n", "method_name": "subAppend", "codes": ["protected void subAppend(LoggingEvent event){\n\n\tString message=event.getRenderedMessage();\n\tString msg=message;\n\tif(msg==null){\n\t\tmsg=\"\";\n\t}\n\tif(msg.length()>=4000){\n\t\tmsg=message.substring(0,4000);\n\t}\n\ttry{\n\t\tif(!this.isFileOpened){\n\t\t\tif(this.tempFile==null){\n\t\t\t\tthis.tempFile=new File(this.tempFilePath);\n\t\t\t}\n\t\t\tthis.out=new FileWriter(this.tempFile,true);\n\t\t\tthis.isFileOpened=true;\n\t\t}\n\t\tthis.out.write(msg);\n\t\tthis.out.write(\"\\n\");\n\t\tthis.out.flush();\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "protected void subAppend(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\t\n\ttry{\n\t\tthis.qw.write(this.layout.format(event));\n\t\t\n\t\tif(this.layout.ignoresThrowable()){\n\t\t\tString[] s = event.getThrowableStrRep();\n\t\t\tif(s!=null){\n\t\t\t\tint len = s.length;\n\t\t\t\tfor(int i=0;i<len;i++){\n\t\t\t\t\tthis.qw.write(s[i]);\n\t\t\t\t\tthis.qw.write(Layout.LINE_SEP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.qw.flush();\n\t}catch(IOException e){\n\t\tthis.errorHandler.error(\"Failed to write to file [\"+this.fileName+\"]\",e,ErrorCode.WRITE_FAILURE);\n\t}\n}", "protected void subAppend(LoggingEvent event){\n\n\t\n\t//TODO:\n\t//\t1. \u65f6\u95f4\u683c\u5f0f\u95ee\u9898\n\t//\t2. \u65e5\u5fd7\u7ea7\u522b\u4e0d\u540c\uff0c\u8ffd\u52a0\u5230\u4e0d\u540c\u7684\u6587\u4ef6\u4e2d\n\t//\t3. \u6bcf\u5929\u81ea\u52a8\u521b\u5efa\u4e0d\u540c\u7684\u6587\u4ef6\uff0c\u5e76\u5220\u9664\u65e7\u7684\u6587\u4ef6\n\t//\t4. \u6bcf\u5929\u81ea\u52a8\u521b\u5efa\u4e0d\u540c\u7684\u6587\u4ef6\u5939\uff0c\u5e76\u5220\u9664\u65e7\u7684\u6587\u4ef6\n\t\n\tFile file = new File(this.fileName);\n\t\n\tif(!file.exists()){\n\t\ttry{\n\t\t\tfile.createNewFile();\n\t\t}catch(IOException e){\n\t\t\tLogLog.error(\"create file failed.\", e);\n\t\t}\n\t}\n\t\n\tString msg = this.layout.format(event);\n\t\n\ttry{\n\t", "protected void subAppend(LoggingEvent event){\n\n\ttry{\n\t\tfos.write(layout.format(event));\n\t\tif(layout.ignoresThrowable()){\n\t\t\tString[] s = event.getThrowableStrRep();\n\t\t\tif(s!=null){\n\t\t\t\tint len = s.length;\n\t\t\t\tfor(int i=0;i<len;i++){\n\t\t\t\t\tfos.write(s[i]);\n\t\t\t\t\tfos.write(Layout.LINE_SEP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfos.flush();\n\t}catch(Exception e){\n\t\terrorHandler.error(\"Write into file error.\");\n\t}\n}", "protected void subAppend(LoggingEvent event){\n\n    try{\n        out.println(layout.format(event));\n        if(layout.ignoresThrowable()){\n            String[] s = event.getThrowableStrRep();\n            if(s!=null){\n                int len = s.length;\n                for(int i=0;i<len;i++){\n                    out.println(s[i]);\n                }\n            }\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}", "protected void subAppend(LoggingEvent event){\n\n\n// \tByteArrayOutputStream baos = new ByteArrayOutputStream();\n// \tObjectOutputStream oos = new ObjectOutputStream(baos);\n// \toos.writeObject(event);\n// \toos.flush();\n// \toos.close();\n\t\n\t\n\t\n\t\n\tlong eventTime = event.getTimeStamp();\n\tString msg = event.getMessage().toString();\n\tint priority = event.getLevel().toInt();\n\tString threadName = event.getThreadName();\n\tString categoryName = event.getLoggerName();\n\t\n\t//System.out.println(\"eventTime=\" + eventTime + \", msg=\" + msg + \", priority=\" + priority + \", threadName=\" + threadName + \", categoryName=\" + categoryName);\n\t\n\t//LogEvent logEvent = new LogEvent(eventTime, msg, priority, threadName, categoryName);\n\t\n\t//System.out.println(\"logEvent=\" + logEvent);\n\t\n\t//byte[] bytes = baos.toByteArray();\n\t\n\t//System.out.println(\"bytes=\" +", "protected void subAppend(LoggingEvent event){\n\n    String msg = this.layout.format(event);\n    String path = getDirectory();\n    String fileName = getFile();\n    if(fileName == null)\n        return;\n    String fullPath = path + fileName;\n    try{\n        synchronized(fileAppender){\n            File f = new File(fullPath);\n            if(!f.exists())\n                f.createNewFile();\n            BufferedWriter output = new BufferedWriter(new FileWriter(f,true));\n            output.write(msg);\n            output.flush();\n            output.close();\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}", "protected void subAppend(LoggingEvent event){\n\nFileWriter fw=null;\ntry{\n//if(fileName!=null){\n//fw=new FileWriter(fileName,true);\nfw=new FileWriter(fileName,true);\n}catch(IOException e){\nLogLog.error(\"Open file error\",e);\n}\nif(fw!=null){\ntry{\nString message=this.layout.format(event);\nfw.write(\"\\n\"+message);\nif(layout.ignoresThrowable()){\nString[] s=event.getThrowableStrRep();\nif(s!=null){\nint len=s.length;\nfor(int i=0;i<len;i++){\nfw.write(s[i]);\nfw.write(\"\\n\");\n}\n}\n}\nfw.flush();\nfw.close();\n}catch(IOException e){\nLogLog.error(\"Write file error\",e);\n}\n}\n}\n/**This method called by the AppenderSkeleton.Do not call it directly.*/\npublic void close(){\n}\n/**This method called by the AppenderSkeleton.Do not", "protected void subAppend(LoggingEvent event){\n\n\t\t\n\t\tfinal String filePath = getFilePath();\n\t\tfinal String fileName = getFileName();\n\t\tfinal String fileNameWithPath = filePath + fileName;\n\t\t\n\t\tif(!fileNameWithPath.equals(lastFileNameWithPath)){\n\t\t\tif(writer != null){\n\t\t\t\ttry{\n\t\t\t\t\twriter.close();\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\tlogger.warn(\"close writer error\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tFile file = new File(filePath);\n\t\t\tif(!file.exists()){\n\t\t\t\tfile.mkdirs();\n\t\t\t}\n\t\t\t\n\t\t\ttry{\n\t\t\t\twriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileNameWithPath, true), \"UTF-8\"));\n\t\t\t}catch(IOException e){\n\t\t\t\tlogger.warn(\"create writer error\", e);\n\t\t\t", "protected void subAppend(LoggingEvent event){\n\n\tlong n = System.currentTimeMillis();\n\tif (n >= nextCheck) {\n\t\tnow.setTime(n);\n\t\tnextCheck = rc.getNextCheckMillis(now);\n\t\ttry {\n\t\t\trollOver();\n\t\t} catch (IOException ioe) {\n\t\t\tLogLog.error(\"rollOver() failed.\", ioe);\n\t\t}\n\t}\n\tif (qw == null) {\n\t\terrorHandler.error(\"No output stream or file set for the appender named [\"+name+\"].\");\n\t\treturn;\n\t}\n\tif(!isAsSevereAsThreshold(event.getLevel()))\n\t\treturn;\n\t\n\tevent.getThreadName();\n\tevent.getNDC();\n\tevent.getMDCCopy();\n\tif(locationInfo) {\n\t\tevent.getLocationInformation();\n\t}\n\tevent.getRenderedMessage();\n\tevent.getThrowableStrRep();\n\tqw.write(layout.format(event));\n\n\tif (layout.ignoresThrowable()) {\n"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static String peek(){\n\n\tif(top == null){\n\t\treturn null;\n\t}\n\treturn top.value;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n\tif(!isEmpty()){\n\t\treturn stack[top];\n\t}\n\telse{\n\t\treturn null;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n  if(stack.isEmpty()){\n    return null;\n  }\n  return stack.get(stack.size()-1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n    return stack.peek();    \n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n    return stack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n\treturn stack[stackSize-1];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n\treturn stack.get(stack.size()-1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n\treturn stack.peek();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n\tif(isEmpty())\n\t\tthrow new EmptyStackException();\n\treturn stack[top];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String peek(){\n\n    if(top == null)\n        return null;\n    else\n        return top.data;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n", "method_name": "peek", "codes": ["public static String peek(){\n\n\tif(top == null){\n\t\treturn null;\n\t}\n\treturn top.value;\n}", "public static String peek(){\n\n\tif(!isEmpty()){\n\t\treturn stack[top];\n\t}\n\telse{\n\t\treturn null;\n\t}\n}", "public static String peek(){\n\n  if(stack.isEmpty()){\n    return null;\n  }\n  return stack.get(stack.size()-1);\n}", "public static String peek(){\n\n    return stack.peek();    \n}", "public static String peek(){\n\n    return stack.peek();\n}", "public static String peek(){\n\n\treturn stack[stackSize-1];\n}", "public static String peek(){\n\n\treturn stack.get(stack.size()-1);\n}", "public static String peek(){\n\n\treturn stack.peek();\n}", "public static String peek(){\n\n\tif(isEmpty())\n\t\tthrow new EmptyStackException();\n\treturn stack[top];\n}", "public static String peek(){\n\n    if(top == null)\n        return null;\n    else\n        return top.data;\n}"], "code_level": "class_runnable", "_id": "636767831a6d9265ec0183c9", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public Logger exists(String name){\n\n\treturn this.loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n    Logger x = (Logger)ht.get(new LoggerKey(name,null));\n    if(x==null){\n        return null;\n    }\n    return x;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n    Logger nLogger;\n    for(Logger logger:loggers){\n        nLogger=logger.exists(name);\n        if(nLogger!=null) return nLogger;\n    }\n    return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n\treturn (Logger)ht.get(name);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n\tLogger exists=null;\n\t\n\t//synchronized(loggers){\n\t\tfor(int i=0;i<loggers.size();i++)\n\t\t\tif(((Logger)loggers.get(i)).getName().equals(name)){\n\t\t\t\texists=(Logger)loggers.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t//}\n\treturn exists;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n\tfor (Logger logger : loggers) {\n\t\tif (logger.getName().equals(name)){\n\t\t\treturn logger;\n\t\t}\n\t}\n\treturn null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n  if (name == null)\n    return null;\n  return loggers.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n\tLogger ret = null;\n\tif(map.containsKey(name)){\n\t\tret = map.get(name);\n\t}\n\treturn ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n\treturn (Logger)map.get(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Logger exists(String name){\n\n  Logger logger;\n  logger=find(name);\n  if(logger==null)\n    return null;\n  else\n    return logger;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if the named logger exists in the hierarchy. If so return its reference, otherwise returns <code>null</code>.\n * @param name The name of the logger to search for.\n */\n", "method_name": "exists", "codes": ["public Logger exists(String name){\n\n\treturn this.loggers.get(name);\n}", "public Logger exists(String name){\n\n    Logger x = (Logger)ht.get(new LoggerKey(name,null));\n    if(x==null){\n        return null;\n    }\n    return x;\n}", "public Logger exists(String name){\n\n    Logger nLogger;\n    for(Logger logger:loggers){\n        nLogger=logger.exists(name);\n        if(nLogger!=null) return nLogger;\n    }\n    return null;\n}", "public Logger exists(String name){\n\n\treturn (Logger)ht.get(name);\n}", "public Logger exists(String name){\n\n\tLogger exists=null;\n\t\n\t//synchronized(loggers){\n\t\tfor(int i=0;i<loggers.size();i++)\n\t\t\tif(((Logger)loggers.get(i)).getName().equals(name)){\n\t\t\t\texists=(Logger)loggers.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t//}\n\treturn exists;\n}", "public Logger exists(String name){\n\n\tfor (Logger logger : loggers) {\n\t\tif (logger.getName().equals(name)){\n\t\t\treturn logger;\n\t\t}\n\t}\n\treturn null;\n}", "public Logger exists(String name){\n\n  if (name == null)\n    return null;\n  return loggers.get(name);\n}", "public Logger exists(String name){\n\n\tLogger ret = null;\n\tif(map.containsKey(name)){\n\t\tret = map.get(name);\n\t}\n\treturn ret;\n}", "public Logger exists(String name){\n\n\treturn (Logger)map.get(name);\n}", "public Logger exists(String name){\n\n  Logger logger;\n  logger=find(name);\n  if(logger==null)\n    return null;\n  else\n    return logger;\n}"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec01832e", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String format(final LoggingEvent event){\n\n\tStringBuffer sbuf = new StringBuffer(256);\n\tsbuf.append(event.getLevel().toString());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLoggerName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getMessage());\n\tObject[] params = event.getArgumentArray();\n\tif (params != null) {\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tsbuf.append(' ');\n\t\t\tsbuf.append(params[i].toString());\n\t\t}\n\t}\n\tsbuf.append(LINE_SEP);\n\treturn sbuf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n\tStringBuffer sbuf = new StringBuffer(100);\n\tsbuf.append(event.timeStamp - LoggingEvent.getStartTime());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLevel());\n\tsbuf.append(' ');\n\tsbuf.append(event.getThreadName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLoggerName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getNDC());\n\tsbuf.append(' ');\n\tsbuf.append(event.getMessage());\n\tsbuf.append(' ');\n\tsbuf.append(event.getThrowableStrRep());\n\tsbuf.append(LINE_SEP);\n\treturn sbuf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n  StringBuffer sbuf = new StringBuffer();\n  sbuf.append(layout.format(event));\n  if(layout.ignoresThrowable()) {\n    String[] s = event.getThrowableStrRep();\n    if (s != null) {\n      int len = s.length;\n      for(int i = 0; i < len; i++) {\n\tsbuf.append(s[i]);\n      }\n    }\n  }\n  return sbuf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n\n    StringBuffer sb = new StringBuffer();\n    sb.append(event.level);\n    sb.append(\" - \");\n    sb.append(event.getRenderedMessage());\n    sb.append(\" \");\n    sb.append(new java.util.Date());\n    sb.append(Layout.LINE_SEP);\n    if(event.getNDC() != null){\n        sb.append(event.getNDC());\n        sb.append(Layout.LINE_SEP);\n    }\n    if(event.getThrowableStrRep() != null){\n        String[] strs = event.getThrowableStrRep();\n        for(int i = 0; i < strs.length; i++){\n            sb.append(strs[i]);\n            sb.append(Layout.LINE_SEP);\n        }\n    }\n    return sb.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n    StringBuffer buf = new StringBuffer(BUF_SIZE);\n    buf.append(event.getLevel().toString());\n    buf.append(\"\\t\");\n    buf.append(event.getLoggerName());\n    buf.append(\" - \");\n    buf.append(event.getRenderedMessage());\n    buf.append(LINE_SEP);\n    return buf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n    final StringBuffer sbuf=new StringBuffer(200);\n    sbuf.append(dateFormat.format(new Date(event.getTimeStamp())));\n    sbuf.append(\" [\");\n    sbuf.append(event.getThreadName());\n    sbuf.append(\"] \");\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" \");\n    sbuf.append(event.getLoggerName());\n    sbuf.append(\" - \");\n    sbuf.append(event.getRenderedMessage());\n    sbuf.append(LINE_SEP);\n    if(event.getNDC()!=null){\n        sbuf.append(event.getNDC());\n        sbuf.append(LINE_SEP);\n    }\n    return sbuf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n    StringBuffer sbuf = new StringBuffer(256);\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" - \");\n    sbuf.append(event.getRenderedMessage());\n    sbuf.append(Layout.LINE_SEP);\n    return sbuf.toString();\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n    final StringBuffer sbuf = new StringBuffer(256);\n    // Append a readable representation of the log leavel\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" - \");\n    // Append the name of the log instance if so configured\n    if(instanceField) {\n        sbuf.append(event.getLoggerName());\n        sbuf.append(\" - \");\n    }\n    // Append the time\n    if(dateField) {\n        // Convert time to string\n        Calendar calendar = new GregorianCalendar();\n        calendar.setTimeInMillis(event.getTimeStamp());\n        sbuf.append(calendar.get(Calendar.YEAR));\n        sbuf.append('-');\n        int twoDigit = calendar.get(Calendar.MONTH) + 1;\n        if(twoDigit < 10)\n            sbuf.append('0');\n        sbuf.append(twoDigit);\n        sbuf.append('-');\n        twoDigit = calendar.get(Calendar.DAY_OF_MON", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n\tStringBuffer buf = new StringBuffer(BUF_SIZE);\n\t\n\tbuf.append(dateFormat.format(new Date(event.timeStamp)));\n\tbuf.append(T_SPACE);\n\tbuf.append(event.getLevel().toString());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getLoggerName());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getThreadName());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getRenderedMessage());\n\tbuf.append(T_TAB);\n\tif(event.getNDC() != null){\n\t\tbuf.append(event.getNDC());\n\t}\n\tbuf.append(T_TAB);\n\tif(event.getMDCCopy() != null){\n\t\tbuf.append(event.getMDCCopy());\n\t}\n\tbuf.append(T_TAB);\n\tif(event.getThrowableStrRep() != null){\n\t\tString[] temp = event.getThrowableStrRep", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String format(final LoggingEvent event){\n\n\treturn event.getThreadName()+\" \"+event.getLevel()+\" [\"+event.getRenderedMessage()+\"]\";\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Formats a logging event to a writer.\n * @param event logging event to be formatted.\n */\n", "method_name": "format", "codes": ["public String format(final LoggingEvent event){\n\n\tStringBuffer sbuf = new StringBuffer(256);\n\tsbuf.append(event.getLevel().toString());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLoggerName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getMessage());\n\tObject[] params = event.getArgumentArray();\n\tif (params != null) {\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tsbuf.append(' ');\n\t\t\tsbuf.append(params[i].toString());\n\t\t}\n\t}\n\tsbuf.append(LINE_SEP);\n\treturn sbuf.toString();\n}", "public String format(final LoggingEvent event){\n\n\tStringBuffer sbuf = new StringBuffer(100);\n\tsbuf.append(event.timeStamp - LoggingEvent.getStartTime());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLevel());\n\tsbuf.append(' ');\n\tsbuf.append(event.getThreadName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getLoggerName());\n\tsbuf.append(' ');\n\tsbuf.append(event.getNDC());\n\tsbuf.append(' ');\n\tsbuf.append(event.getMessage());\n\tsbuf.append(' ');\n\tsbuf.append(event.getThrowableStrRep());\n\tsbuf.append(LINE_SEP);\n\treturn sbuf.toString();\n}", "public String format(final LoggingEvent event){\n\n  StringBuffer sbuf = new StringBuffer();\n  sbuf.append(layout.format(event));\n  if(layout.ignoresThrowable()) {\n    String[] s = event.getThrowableStrRep();\n    if (s != null) {\n      int len = s.length;\n      for(int i = 0; i < len; i++) {\n\tsbuf.append(s[i]);\n      }\n    }\n  }\n  return sbuf.toString();\n}", "public String format(final LoggingEvent event){\n\n\n    StringBuffer sb = new StringBuffer();\n    sb.append(event.level);\n    sb.append(\" - \");\n    sb.append(event.getRenderedMessage());\n    sb.append(\" \");\n    sb.append(new java.util.Date());\n    sb.append(Layout.LINE_SEP);\n    if(event.getNDC() != null){\n        sb.append(event.getNDC());\n        sb.append(Layout.LINE_SEP);\n    }\n    if(event.getThrowableStrRep() != null){\n        String[] strs = event.getThrowableStrRep();\n        for(int i = 0; i < strs.length; i++){\n            sb.append(strs[i]);\n            sb.append(Layout.LINE_SEP);\n        }\n    }\n    return sb.toString();\n}", "public String format(final LoggingEvent event){\n\n    StringBuffer buf = new StringBuffer(BUF_SIZE);\n    buf.append(event.getLevel().toString());\n    buf.append(\"\\t\");\n    buf.append(event.getLoggerName());\n    buf.append(\" - \");\n    buf.append(event.getRenderedMessage());\n    buf.append(LINE_SEP);\n    return buf.toString();\n}", "public String format(final LoggingEvent event){\n\n    final StringBuffer sbuf=new StringBuffer(200);\n    sbuf.append(dateFormat.format(new Date(event.getTimeStamp())));\n    sbuf.append(\" [\");\n    sbuf.append(event.getThreadName());\n    sbuf.append(\"] \");\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" \");\n    sbuf.append(event.getLoggerName());\n    sbuf.append(\" - \");\n    sbuf.append(event.getRenderedMessage());\n    sbuf.append(LINE_SEP);\n    if(event.getNDC()!=null){\n        sbuf.append(event.getNDC());\n        sbuf.append(LINE_SEP);\n    }\n    return sbuf.toString();\n}", "public String format(final LoggingEvent event){\n\n    StringBuffer sbuf = new StringBuffer(256);\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" - \");\n    sbuf.append(event.getRenderedMessage());\n    sbuf.append(Layout.LINE_SEP);\n    return sbuf.toString();\n}", "public String format(final LoggingEvent event){\n\n    final StringBuffer sbuf = new StringBuffer(256);\n    // Append a readable representation of the log leavel\n    sbuf.append(event.getLevel().toString());\n    sbuf.append(\" - \");\n    // Append the name of the log instance if so configured\n    if(instanceField) {\n        sbuf.append(event.getLoggerName());\n        sbuf.append(\" - \");\n    }\n    // Append the time\n    if(dateField) {\n        // Convert time to string\n        Calendar calendar = new GregorianCalendar();\n        calendar.setTimeInMillis(event.getTimeStamp());\n        sbuf.append(calendar.get(Calendar.YEAR));\n        sbuf.append('-');\n        int twoDigit = calendar.get(Calendar.MONTH) + 1;\n        if(twoDigit < 10)\n            sbuf.append('0');\n        sbuf.append(twoDigit);\n        sbuf.append('-');\n        twoDigit = calendar.get(Calendar.DAY_OF_MON", "public String format(final LoggingEvent event){\n\n\tStringBuffer buf = new StringBuffer(BUF_SIZE);\n\t\n\tbuf.append(dateFormat.format(new Date(event.timeStamp)));\n\tbuf.append(T_SPACE);\n\tbuf.append(event.getLevel().toString());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getLoggerName());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getThreadName());\n\tbuf.append(T_TAB);\n\tbuf.append(event.getRenderedMessage());\n\tbuf.append(T_TAB);\n\tif(event.getNDC() != null){\n\t\tbuf.append(event.getNDC());\n\t}\n\tbuf.append(T_TAB);\n\tif(event.getMDCCopy() != null){\n\t\tbuf.append(event.getMDCCopy());\n\t}\n\tbuf.append(T_TAB);\n\tif(event.getThrowableStrRep() != null){\n\t\tString[] temp = event.getThrowableStrRep", "public String format(final LoggingEvent event){\n\n\treturn event.getThreadName()+\" \"+event.getLevel()+\" [\"+event.getRenderedMessage()+\"]\";\n}"], "code_level": "project_runnable", "_id": "6367677b1a6d9265ec0182bd", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        //to define class in package com.sample\n        String url = \"file:///D:/app/workspace/javaagent-bytebuddy/target/classes/com/sample/\";\n        URL[] urls = { new URL(url) };\n        URLClassLoader ucl = new URLClassLoader(urls);\n        return ucl.loadClass(className);\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    }\n    return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n\t// if the class has already been loaded,\n\t// the existing class is returned \n\tClass result = findLoadedClass(className);\n\tif (result != null) {\n\t\treturn result;\n\t}\n\t\n\t//try to load it\n\ttry {\n\t\tresult = findSystemClass(className);\n\t\treturn result;\n\t} catch (ClassNotFoundException e) {\n\t\t//ignore and continue\n\t}\n\t\n\t//check the cache\n\tbyte[] classBytes = (byte[]) cachedClassFileData.get(className);\n\tif (classBytes == null) {\n\t\tthrow new ClassNotFoundException();\n\t}\n\t\n\t// convert the file to a class\n\tresult = defineClass(className, classBytes, 0, classBytes.length);\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        String url = String.format(\"http://%s/%s.class\", host, className);\n        URL myUrl = new URL(url);\n        URLConnection connection = myUrl.openConnection();\n        InputStream input = connection.getInputStream();\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int data = input.read();\n\n        while (data != -1) {\n            buffer.write(data);\n            data = input.read();\n        }\n\n        input.close();\n\n        byte[] classData = buffer.toByteArray();\n\n        return defineClass(className, classData, 0, classData.length);\n\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    /**Class Not Found Exception.**/\n    try {\n        /**Return the Class of the given name.**/\n        return Class.forName(className);\n    } catch (final ClassNotFoundException ex) {\n        /**Return the Class of the given name from this ClassLoader.**/\n        return super.findClass(className);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        return Class.forName(className);\n    } catch (final ClassNotFoundException e) {\n        //Ignore\n    }\n\n    return findClass(className.replace(\".\", \"/\").concat(\".class\"));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n  return new ClassLoader() {\n    @Override\n    protected Class findClass(String name) throws ClassNotFoundException {\n      return super.findClass(name);\n    }\n  }.loadClass(className);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n\tClass result = null;\n\tif (className != null) {\n\t\tresult = (Class)classCache.get(className);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tresult = super.findClass(className);\n\t\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\t\t//ignore\n\t\t\t}\n\t\t\tif (result == null) {\n\t\t\t\tresult = Class.forName(className);\n\t\t\t}\n\t\t\tclassCache.put(className, result);\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n\treturn (Class) AccessController.doPrivileged(new PrivilegedAction() {\n\t\tpublic Object run() {\n\t\t\tClass clazz = null;\n\t\t\tString path = className.replace('.', '/') + \".class\";\n\t\t\tInputStream is = getResourceAsStream(path);\n\t\t\tif (is != null) {\n\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\t\tint i = -1;\n\t\t\t\ttry {\n\t\t\t\t\twhile ((i = is.read()) != -1) {\n\t\t\t\t\t\tbaos.write(i);\n\t\t\t\t\t}\n\t\t\t\t\tclazz = defineClass(className, baos.toByteArray(), 0, baos.size());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new ClassNotFoundException(className, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clazz;\n\t\t}\n\t});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    byte[] classData;\n    try {\n        classData = getClassData(className);\n    } catch (IOException e) {\n        throw new ClassNotFoundException(\"Class [\" + className + \"] could not be found\", e);\n    }\n\n    return defineClass(className, classData, 0, classData.length);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Class findClass(final String className) throws ClassNotFoundException {\n\n    return (Class) AccessController.doPrivileged(new PrivilegedAction() {\n        public Object run() {\n            String path = className.replace('.', '/').concat(\".class\");\n            Resource res = ucp.getResource(path, false);\n            if (res != null) {\n                try {\n                    return defineClass(className, res);\n                } catch (IOException e) {\n                    throw new ClassNotFoundException(className, e);\n                }\n            } else {\n                return null;\n            }\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find class given class name.\n * @param className class name, may not be null.\n * @return class, will not be null.\n * @throws ClassNotFoundException thrown if class can not be found.\n */\n", "method_name": "findClass", "codes": ["private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        //to define class in package com.sample\n        String url = \"file:///D:/app/workspace/javaagent-bytebuddy/target/classes/com/sample/\";\n        URL[] urls = { new URL(url) };\n        URLClassLoader ucl = new URLClassLoader(urls);\n        return ucl.loadClass(className);\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    }\n    return null;\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n\t// if the class has already been loaded,\n\t// the existing class is returned \n\tClass result = findLoadedClass(className);\n\tif (result != null) {\n\t\treturn result;\n\t}\n\t\n\t//try to load it\n\ttry {\n\t\tresult = findSystemClass(className);\n\t\treturn result;\n\t} catch (ClassNotFoundException e) {\n\t\t//ignore and continue\n\t}\n\t\n\t//check the cache\n\tbyte[] classBytes = (byte[]) cachedClassFileData.get(className);\n\tif (classBytes == null) {\n\t\tthrow new ClassNotFoundException();\n\t}\n\t\n\t// convert the file to a class\n\tresult = defineClass(className, classBytes, 0, classBytes.length);\n\treturn result;\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        String url = String.format(\"http://%s/%s.class\", host, className);\n        URL myUrl = new URL(url);\n        URLConnection connection = myUrl.openConnection();\n        InputStream input = connection.getInputStream();\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int data = input.read();\n\n        while (data != -1) {\n            buffer.write(data);\n            data = input.read();\n        }\n\n        input.close();\n\n        byte[] classData = buffer.toByteArray();\n\n        return defineClass(className, classData, 0, classData.length);\n\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n    /**Class Not Found Exception.**/\n    try {\n        /**Return the Class of the given name.**/\n        return Class.forName(className);\n    } catch (final ClassNotFoundException ex) {\n        /**Return the Class of the given name from this ClassLoader.**/\n        return super.findClass(className);\n    }\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n    try {\n        return Class.forName(className);\n    } catch (final ClassNotFoundException e) {\n        //Ignore\n    }\n\n    return findClass(className.replace(\".\", \"/\").concat(\".class\"));\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n  return new ClassLoader() {\n    @Override\n    protected Class findClass(String name) throws ClassNotFoundException {\n      return super.findClass(name);\n    }\n  }.loadClass(className);\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n\tClass result = null;\n\tif (className != null) {\n\t\tresult = (Class)classCache.get(className);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tresult = super.findClass(className);\n\t\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\t\t//ignore\n\t\t\t}\n\t\t\tif (result == null) {\n\t\t\t\tresult = Class.forName(className);\n\t\t\t}\n\t\t\tclassCache.put(className, result);\n\t\t}\n\t}\n\treturn result;\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n\treturn (Class) AccessController.doPrivileged(new PrivilegedAction() {\n\t\tpublic Object run() {\n\t\t\tClass clazz = null;\n\t\t\tString path = className.replace('.', '/') + \".class\";\n\t\t\tInputStream is = getResourceAsStream(path);\n\t\t\tif (is != null) {\n\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\t\tint i = -1;\n\t\t\t\ttry {\n\t\t\t\t\twhile ((i = is.read()) != -1) {\n\t\t\t\t\t\tbaos.write(i);\n\t\t\t\t\t}\n\t\t\t\t\tclazz = defineClass(className, baos.toByteArray(), 0, baos.size());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new ClassNotFoundException(className, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clazz;\n\t\t}\n\t});\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n    byte[] classData;\n    try {\n        classData = getClassData(className);\n    } catch (IOException e) {\n        throw new ClassNotFoundException(\"Class [\" + className + \"] could not be found\", e);\n    }\n\n    return defineClass(className, classData, 0, classData.length);\n}", "private Class findClass(final String className) throws ClassNotFoundException {\n\n    return (Class) AccessController.doPrivileged(new PrivilegedAction() {\n        public Object run() {\n            String path = className.replace('.', '/').concat(\".class\");\n            Resource res = ucp.getResource(path, false);\n            if (res != null) {\n                try {\n                    return defineClass(className, res);\n                } catch (IOException e) {\n                    throw new ClassNotFoundException(className, e);\n                }\n            } else {\n                return null;\n            }\n        }\n    });\n}"], "code_level": "slib_runnable", "_id": "636767791a6d9265ec018263", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void addMessage(final LogRecord lr){\n\n\ttry{\n\t\tSwingUtilities.invokeAndWait(new Runnable(){\n\t\t\tpublic void run(){\n\t\t\t\taddMessage0(lr);\n\t\t\t}\n\t\t});\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n            String message = lr.getMessage();\n            String level = lr.getLevel().toString();\n            String logger = lr.getLoggerName();\n            String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n            Object[] row = {message, level, logger, timestamp};\n            tableModel.addRow(row);\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        public void run(){\n            addMessageToTable(lr);\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    if(lr.getLevel().intValue() >= levelValue)\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                StringBuffer sb = new StringBuffer();\n                sb.append(lr.getMessage());\n                Object[] params = lr.getParameters();\n                if (params != null) {\n                    for (Object param : params) {\n                        sb.append(\", \");\n                        sb.append(param);\n                    }\n                }\n                int row = model.getRowCount();\n                model.insertRow(row, new Object[]{lr.getLevel(),\n                        dateFormat.format(new Date(lr.getMillis())),\n                        sb.toString()});\n\n                if (isAutoScroll) {\n                    scrollToBottom();\n                }\n            }\n        });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n            String[] line = new String[columns.length];\n            line[0] = lr.getLevel().getName();\n            line[1] = lr.getMessage();\n            line[2] = new Date(lr.getMillis()).toString();\n            line[3] = lr.getThreadID()+\"\";\n            line[4] = lr.getSourceClassName();\n            line[5] = lr.getSourceMethodName();\n            model.addRow(line);\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        @Override\n        public void run(){\n            model.addRow(new Object[]{\n                lr.getLevel().toString(),\n                lr.getMessage()\n            });\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\tpublic void run(){\n\t\t\tString msg = lr.getMessage();\n\t\t\tif(msg != null){\n\t\t\t\tint row = model.getRowCount();\n\t\t\t\tmodel.addRow(new Object[]{new Integer(row + 1), lr.getMillis(), lr.getSourceClassName(), lr.getSourceMethodName(), lr.getLevel(), msg});\n\t\t\t}\n\t\t}\n\t});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\tpublic void run(){\n\t\t\tlogTableModel.addRow(new Object[]{\n\t\t\t\t\tnew java.sql.Date(lr.getDate()),\n\t\t\t\t\tnew java.sql.Time(lr.getDate()),\n\t\t\t\t\tlr.getMessage(),\n\t\t\t\t\tlr.getLevel()\n\t\t\t});\n\t\t}\n\t});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\t@Override\n\t\tpublic void run() {\n\t\t\taddMessageLogRecord(lr);\n\t\t}});\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        @Override\n        public void run(){\n            addRecord(lr);\n        }\n    });\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n", "method_name": "addMessage", "codes": ["public void addMessage(final LogRecord lr){\n\n\ttry{\n\t\tSwingUtilities.invokeAndWait(new Runnable(){\n\t\t\tpublic void run(){\n\t\t\t\taddMessage0(lr);\n\t\t\t}\n\t\t});\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t}\n}", "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n            String message = lr.getMessage();\n            String level = lr.getLevel().toString();\n            String logger = lr.getLoggerName();\n            String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n            Object[] row = {message, level, logger, timestamp};\n            tableModel.addRow(row);\n        }\n    });\n}", "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        public void run(){\n            addMessageToTable(lr);\n        }\n    });\n}", "public void addMessage(final LogRecord lr){\n\n    if(lr.getLevel().intValue() >= levelValue)\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                StringBuffer sb = new StringBuffer();\n                sb.append(lr.getMessage());\n                Object[] params = lr.getParameters();\n                if (params != null) {\n                    for (Object param : params) {\n                        sb.append(\", \");\n                        sb.append(param);\n                    }\n                }\n                int row = model.getRowCount();\n                model.insertRow(row, new Object[]{lr.getLevel(),\n                        dateFormat.format(new Date(lr.getMillis())),\n                        sb.toString()});\n\n                if (isAutoScroll) {\n                    scrollToBottom();\n                }\n            }\n        });\n}", "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n            String[] line = new String[columns.length];\n            line[0] = lr.getLevel().getName();\n            line[1] = lr.getMessage();\n            line[2] = new Date(lr.getMillis()).toString();\n            line[3] = lr.getThreadID()+\"\";\n            line[4] = lr.getSourceClassName();\n            line[5] = lr.getSourceMethodName();\n            model.addRow(line);\n        }\n    });\n}", "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        @Override\n        public void run(){\n            model.addRow(new Object[]{\n                lr.getLevel().toString(),\n                lr.getMessage()\n            });\n        }\n    });\n}", "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\tpublic void run(){\n\t\t\tString msg = lr.getMessage();\n\t\t\tif(msg != null){\n\t\t\t\tint row = model.getRowCount();\n\t\t\t\tmodel.addRow(new Object[]{new Integer(row + 1), lr.getMillis(), lr.getSourceClassName(), lr.getSourceMethodName(), lr.getLevel(), msg});\n\t\t\t}\n\t\t}\n\t});\n}", "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\tpublic void run(){\n\t\t\tlogTableModel.addRow(new Object[]{\n\t\t\t\t\tnew java.sql.Date(lr.getDate()),\n\t\t\t\t\tnew java.sql.Time(lr.getDate()),\n\t\t\t\t\tlr.getMessage(),\n\t\t\t\t\tlr.getLevel()\n\t\t\t});\n\t\t}\n\t});\n}", "public void addMessage(final LogRecord lr){\n\n\tSwingUtilities.invokeLater(new Runnable(){\n\t\t@Override\n\t\tpublic void run() {\n\t\t\taddMessageLogRecord(lr);\n\t\t}});\n}", "public void addMessage(final LogRecord lr){\n\n    SwingUtilities.invokeLater(new Runnable(){\n        @Override\n        public void run(){\n            addRecord(lr);\n        }\n    });\n}"], "code_level": "project_runnable", "_id": "636767791a6d9265ec018257", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tint size = table.getModel().getRowCount();\n\tif(size>0&&row<size){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle rect = table.getCellRect(row,0,true);\n\t\ttable.scrollRectToVisible(rect);\n\t\tif(pane!=null){\n\t\t\tpane.getVerticalScrollBar().setValue(pane.getVerticalScrollBar().getValue()+rect.y);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(new Rectangle(table.getCellRect(row,0,true)));\n\tpane.getVerticalScrollBar().setValue(\n\t\t\tpane.getVerticalScrollBar().getValue()-pane.getVerticalScrollBar().getUnitIncrement(-1));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(row==-1)return;\n\ttable.setRowSelectionInterval(row,row);\n\tpane.scrollRectToVisible(table.getCellRect(row,0,true));\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(table.getCellRect(row,0,true));\n\tAdjustmentListener listener = new AdjustmentListener(){\n\t\tpublic void adjustmentValueChanged(AdjustmentEvent e){\n\t\t\te.getAdjustable().setValue(e.getAdjustable().getMinimum());\n\t\t\te.getAdjustable().removeAdjustmentListener(this);\n\t\t}\n\t};\n\tpane.getVerticalScrollBar().addAdjustmentListener(listener);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tint viewRow = table.convertRowIndexToView(row);\n\tRectangle rect = table.getCellRect(viewRow,0,true);\n\ttable.setRowSelectionInterval(viewRow,viewRow);\n\tpane.getViewport().scrollRectToVisible(rect);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(table != null && pane != null){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle rect = table.getCellRect(row,0,true);\n\t\tpane.getViewport().scrollRectToVisible(rect);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\tJViewport viewport = pane.getViewport();\n\tRectangle rect = table.getCellRect(table.getSelectedRow(),0,true);\n\tPoint pt = viewport.getViewPosition();\n\trect.setLocation(rect.x-pt.x,rect.y-pt.y);\n\tviewport.scrollRectToVisible(rect);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(row!=table.getSelectedRow()){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle r=table.getCellRect(row,0,true);\n\t\tpane.getViewport().scrollRectToVisible(r);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.changeSelection(row,0,false,false);\n\tpane.getVerticalScrollBar().setValue(0);\n\tpane.getVerticalScrollBar().setValue(row*table.getRowHeight());\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(table.getCellRect(row,0,true));\n\tpane.getVerticalScrollBar().setValue(pane.getVerticalScrollBar().getValue()+table.getCellRect(row,0,true).y-30);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Selects a the specified row in the specified JTable and scrolls the specified JScrollpane to the newly selected row. More importantly, the call to repaint() delayed long enough to have the table properly paint the newly selected row which may be offscre\n * @param table should belong to the specified JScrollPane\n */\n", "method_name": "selectRow", "codes": ["public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tint size = table.getModel().getRowCount();\n\tif(size>0&&row<size){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle rect = table.getCellRect(row,0,true);\n\t\ttable.scrollRectToVisible(rect);\n\t\tif(pane!=null){\n\t\t\tpane.getVerticalScrollBar().setValue(pane.getVerticalScrollBar().getValue()+rect.y);\n\t\t}\n\t}\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(new Rectangle(table.getCellRect(row,0,true)));\n\tpane.getVerticalScrollBar().setValue(\n\t\t\tpane.getVerticalScrollBar().getValue()-pane.getVerticalScrollBar().getUnitIncrement(-1));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(row==-1)return;\n\ttable.setRowSelectionInterval(row,row);\n\tpane.scrollRectToVisible(table.getCellRect(row,0,true));\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(table.getCellRect(row,0,true));\n\tAdjustmentListener listener = new AdjustmentListener(){\n\t\tpublic void adjustmentValueChanged(AdjustmentEvent e){\n\t\t\te.getAdjustable().setValue(e.getAdjustable().getMinimum());\n\t\t\te.getAdjustable().removeAdjustmentListener(this);\n\t\t}\n\t};\n\tpane.getVerticalScrollBar().addAdjustmentListener(listener);\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tint viewRow = table.convertRowIndexToView(row);\n\tRectangle rect = table.getCellRect(viewRow,0,true);\n\ttable.setRowSelectionInterval(viewRow,viewRow);\n\tpane.getViewport().scrollRectToVisible(rect);\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(table != null && pane != null){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle rect = table.getCellRect(row,0,true);\n\t\tpane.getViewport().scrollRectToVisible(rect);\n\t}\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\tJViewport viewport = pane.getViewport();\n\tRectangle rect = table.getCellRect(table.getSelectedRow(),0,true);\n\tPoint pt = viewport.getViewPosition();\n\trect.setLocation(rect.x-pt.x,rect.y-pt.y);\n\tviewport.scrollRectToVisible(rect);\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\tif(row!=table.getSelectedRow()){\n\t\ttable.setRowSelectionInterval(row,row);\n\t\tRectangle r=table.getCellRect(row,0,true);\n\t\tpane.getViewport().scrollRectToVisible(r);\n\t}\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.changeSelection(row,0,false,false);\n\tpane.getVerticalScrollBar().setValue(0);\n\tpane.getVerticalScrollBar().setValue(row*table.getRowHeight());\n}", "public static void selectRow(int row,JTable table,JScrollPane pane){\n\n\ttable.setRowSelectionInterval(row,row);\n\ttable.scrollRectToVisible(table.getCellRect(row,0,true));\n\tpane.getVerticalScrollBar().setValue(pane.getVerticalScrollBar().getValue()+table.getCellRect(row,0,true).y-30);\n}"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183ff", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static void createConfigurationDirectory(){\n\n\tString configDir = getConfigDirectory();\n\tFile dir = new File(configDir);\n\tif(!dir.exists())\n\t\tdir.mkdir();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\tFile dir = new File(System.getProperty(\"user.home\")+\"/lf5\");\n\tif(!dir.exists()){\n\t\tdir.mkdirs();\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\tString osName = System.getProperty(\"os.name\");\n\tif (osName.startsWith(\"Windows\")){\n\t\ttry {\n\t\t\tString userProfile = System.getenv(\"USERPROFILE\");\n\t\t\tFile configDir = new File(userProfile+\"\\\\lf5\");\n\t\t\tconfigDir.mkdir();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}else{\n\t\ttry {\n\t\t\tString userHome = System.getProperty(\"user.home\");\n\t\t\tFile configDir = new File(userHome+\"/lf5\");\n\t\t\tconfigDir.mkdir();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\tif(System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")){\n\t\tString path = System.getenv(\"APPDATA\");\n\t\tFile configurationDirectory = new File(path+\"\\\\lf5\");\n\t\tif(!configurationDirectory.exists())\n\t\t\tconfigurationDirectory.mkdir();\n\t}\n\telse{\n\t\tFile configurationDirectory = new File(System.getProperty(\"user.home\")+\"\\\\lf5\");\n\t\tif(!configurationDirectory.exists())\n\t\t\tconfigurationDirectory.mkdir();\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory(){\n\n        String homeDir = System.getProperty(\"user.home\");\n        String fileSeparator = System.getProperty(\"file.separator\");\n        String lf5Dir = homeDir + fileSeparator + \"lf5\";\n        File lf5 = new File(lf5Dir);\n        if(!lf5.exists()){\n            lf5.mkdir();\n        }\n    }", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\t\ttry {\n\t\t\t//get the location of the Documents and Settings directory\n\t\t\tString home = System.getProperty(\"user.home\");\n\t\t\tFile lf5Directory = new File(home+File.separator+\"lf5\");\n\t\t\t//if it doesn't exist, create it\n\t\t\tif (!lf5Directory.exists()){\n\t\t\t\tlf5Directory.mkdir();\n\t\t\t}\n\t\t} catch (SecurityException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void createConfigurationDirectory(){\n\n    if(!configurationDirectory.exists()){\n        configurationDirectory.mkdir();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\ttry {\n\t\t//String dirPath = System.getProperty(\"user.home\") + File.separator + \"lf5\";\n\t\tString dirPath = System.getProperty(\"user.home\") + File.separator + \"lf5\";\n\t\tFile dir = new File(dirPath);\n\t\tif (!dir.exists()) {\n\t\t\tdir.mkdir();\n\t\t}\n\t} catch (SecurityException e) {\n\t\t//log(\"Could not create config directory.\");\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\t\n\tString directoryPath = getWorkingDirectory();\n\t\n\tFile directory = new File(directoryPath);\n\t\n\tif (!directory.exists()){\n\t\t\n\t\tdirectory.mkdir();\n\t\t\n\t}\n\t\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static void createConfigurationDirectory(){\n\n\tif (System.getProperty(\"os.name\").startsWith(\"Windows\")){\n\t\tconfigurationDirectory = System.getProperty(\"user.home\")+\"\\\\\"+configurationDirectory;\n\t}\n\tconfigurationDirectory = System.getProperty(\"user.home\")+\"/\"+configurationDirectory;\n\tFile file = new File(configurationDirectory);\n\tif (!file.exists()) {\n\t\tfile.mkdir();\n\t}\n\tfile = null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Creates the directory where the MRU file list will be written. The \"lf5\" directory is created in the Documents and Settings directory on Windows 2000 machines and where ever the user.home variable points on all other platforms.\n */\n", "method_name": "createConfigurationDirectory", "codes": ["public static void createConfigurationDirectory(){\n\n\tString configDir = getConfigDirectory();\n\tFile dir = new File(configDir);\n\tif(!dir.exists())\n\t\tdir.mkdir();\n}", "public static void createConfigurationDirectory(){\n\n\tFile dir = new File(System.getProperty(\"user.home\")+\"/lf5\");\n\tif(!dir.exists()){\n\t\tdir.mkdirs();\n\t}\n}", "public static void createConfigurationDirectory(){\n\n\tString osName = System.getProperty(\"os.name\");\n\tif (osName.startsWith(\"Windows\")){\n\t\ttry {\n\t\t\tString userProfile = System.getenv(\"USERPROFILE\");\n\t\t\tFile configDir = new File(userProfile+\"\\\\lf5\");\n\t\t\tconfigDir.mkdir();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}else{\n\t\ttry {\n\t\t\tString userHome = System.getProperty(\"user.home\");\n\t\t\tFile configDir = new File(userHome+\"/lf5\");\n\t\t\tconfigDir.mkdir();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "public static void createConfigurationDirectory(){\n\n\tif(System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")){\n\t\tString path = System.getenv(\"APPDATA\");\n\t\tFile configurationDirectory = new File(path+\"\\\\lf5\");\n\t\tif(!configurationDirectory.exists())\n\t\t\tconfigurationDirectory.mkdir();\n\t}\n\telse{\n\t\tFile configurationDirectory = new File(System.getProperty(\"user.home\")+\"\\\\lf5\");\n\t\tif(!configurationDirectory.exists())\n\t\t\tconfigurationDirectory.mkdir();\n\t}\n}", "public static void createConfigurationDirectory(){\n\n        String homeDir = System.getProperty(\"user.home\");\n        String fileSeparator = System.getProperty(\"file.separator\");\n        String lf5Dir = homeDir + fileSeparator + \"lf5\";\n        File lf5 = new File(lf5Dir);\n        if(!lf5.exists()){\n            lf5.mkdir();\n        }\n    }", "public static void createConfigurationDirectory(){\n\n\t\ttry {\n\t\t\t//get the location of the Documents and Settings directory\n\t\t\tString home = System.getProperty(\"user.home\");\n\t\t\tFile lf5Directory = new File(home+File.separator+\"lf5\");\n\t\t\t//if it doesn't exist, create it\n\t\t\tif (!lf5Directory.exists()){\n\t\t\t\tlf5Directory.mkdir();\n\t\t\t}\n\t\t} catch (SecurityException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "public static void createConfigurationDirectory(){\n\n    if(!configurationDirectory.exists()){\n        configurationDirectory.mkdir();\n    }\n}", "public static void createConfigurationDirectory(){\n\n\ttry {\n\t\t//String dirPath = System.getProperty(\"user.home\") + File.separator + \"lf5\";\n\t\tString dirPath = System.getProperty(\"user.home\") + File.separator + \"lf5\";\n\t\tFile dir = new File(dirPath);\n\t\tif (!dir.exists()) {\n\t\t\tdir.mkdir();\n\t\t}\n\t} catch (SecurityException e) {\n\t\t//log(\"Could not create config directory.\");\n\t}\n}", "public static void createConfigurationDirectory(){\n\n\t\n\tString directoryPath = getWorkingDirectory();\n\t\n\tFile directory = new File(directoryPath);\n\t\n\tif (!directory.exists()){\n\t\t\n\t\tdirectory.mkdir();\n\t\t\n\t}\n\t\n}", "public static void createConfigurationDirectory(){\n\n\tif (System.getProperty(\"os.name\").startsWith(\"Windows\")){\n\t\tconfigurationDirectory = System.getProperty(\"user.home\")+\"\\\\\"+configurationDirectory;\n\t}\n\tconfigurationDirectory = System.getProperty(\"user.home\")+\"/\"+configurationDirectory;\n\tFile file = new File(configurationDirectory);\n\tif (!file.exists()) {\n\t\tfile.mkdir();\n\t}\n\tfile = null;\n}"], "code_level": "slib_runnable", "_id": "636767871a6d9265ec01846d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public synchronized void send(final String message){\n\n\tfor(final Connection c : connections)\n\t\tc.send(message);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n    for(final Connection c : connections)\n        c.send(message);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n    if(message == null || message.equals(\"\")){\n        return;\n    }\n    final String[] lines=message.split(\"\\n\");\n    for(int i=0;i<lines.length;i++){\n        if(lines[i].length()>0){\n            final String[] words=lines[i].split(\" \");\n            for(int w=0;w<words.length;w++){\n                if(words[w].length()==0){\n                    continue;\n                }\n                if(words[w].length()>(maxWordLength-2)){\n                    for(int c=0;c<words[w].length();c++){\n                        if(c==0){\n                            sendRawGMCP(\"comm.channel\",words[w].charAt(c)+\"\");\n                        }else{\n                            sendRawGMCP(\"comm.channel.next\",words[w].charAt(c)+\"\");\n                        }\n                    }\n                }else{\n                    sendRawGMCP(\"comm.channel\",words[w]);\n                }\n                if(w<words.", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(message == null || message.length() == 0){\n\t\treturn;\n\t}\n\tfinal StringBuilder sb = new StringBuilder(message.length());\n\tfor(final Connection c : connections){\n\t\tif(c != null){\n\t\t\tsb.setLength(0);\n\t\t\tsb.append(message);\n\t\t\tc.rawPrintln(sb.toString());\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(message==null) return;\n\tif(message.length()==0) return;\n\tfor(int i=0;i<connections.size();i++){\n\t\tConnection c=(Connection)connections.elementAt(i);\n\t\tc.send(message);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tEnumeration e=connections.elements();\n\twhile(e.hasMoreElements()){\n\t\ttry{\n\t\t\t((Connection)e.nextElement()).send(message);\n\t\t}catch(IOException ex){\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(message==null){\n\t\tthrow new NullPointerException(\"TelnetServer.send(String): message is null\");\n\t}\n\tif(message.length()==0){\n\t\tthrow new IllegalArgumentException(\"TelnetServer.send(String): message is empty\");\n\t}\n\tfor(final Connection c : connections){\n\t\tc.send(message);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(message != null){\n\t\tfor(final Connection c : connections){\n\t\t\tif(c != null)\n\t\t\t\tc.send(message);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(message.length()==0){\n\t    return;\n\t}\n\tfor(int i=0;i<connections.size();i++){\n\t    //System.out.println(\"[Send] \"+message);\n\t    connections.get(i).send(message);\n\t}\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public synchronized void send(final String message){\n\n\tif(this.getConnections().size() == 0) return;\n\tfor(final Connection c : this.getConnections()){\n\t\tc.send(message);\n\t\tc.send(\"\\n\");\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * sends a message to each of the clients in telnet-friendly output. \n */\n", "method_name": "send", "codes": ["public synchronized void send(final String message){\n\n\tfor(final Connection c : connections)\n\t\tc.send(message);\n}", "public synchronized void send(final String message){\n\n    for(final Connection c : connections)\n        c.send(message);\n}", "public synchronized void send(final String message){\n\n    if(message == null || message.equals(\"\")){\n        return;\n    }\n    final String[] lines=message.split(\"\\n\");\n    for(int i=0;i<lines.length;i++){\n        if(lines[i].length()>0){\n            final String[] words=lines[i].split(\" \");\n            for(int w=0;w<words.length;w++){\n                if(words[w].length()==0){\n                    continue;\n                }\n                if(words[w].length()>(maxWordLength-2)){\n                    for(int c=0;c<words[w].length();c++){\n                        if(c==0){\n                            sendRawGMCP(\"comm.channel\",words[w].charAt(c)+\"\");\n                        }else{\n                            sendRawGMCP(\"comm.channel.next\",words[w].charAt(c)+\"\");\n                        }\n                    }\n                }else{\n                    sendRawGMCP(\"comm.channel\",words[w]);\n                }\n                if(w<words.", "public synchronized void send(final String message){\n\n\tif(message == null || message.length() == 0){\n\t\treturn;\n\t}\n\tfinal StringBuilder sb = new StringBuilder(message.length());\n\tfor(final Connection c : connections){\n\t\tif(c != null){\n\t\t\tsb.setLength(0);\n\t\t\tsb.append(message);\n\t\t\tc.rawPrintln(sb.toString());\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\n\tif(message==null) return;\n\tif(message.length()==0) return;\n\tfor(int i=0;i<connections.size();i++){\n\t\tConnection c=(Connection)connections.elementAt(i);\n\t\tc.send(message);\n\t}\n}", "public synchronized void send(final String message){\n\n\tEnumeration e=connections.elements();\n\twhile(e.hasMoreElements()){\n\t\ttry{\n\t\t\t((Connection)e.nextElement()).send(message);\n\t\t}catch(IOException ex){\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\n\tif(message==null){\n\t\tthrow new NullPointerException(\"TelnetServer.send(String): message is null\");\n\t}\n\tif(message.length()==0){\n\t\tthrow new IllegalArgumentException(\"TelnetServer.send(String): message is empty\");\n\t}\n\tfor(final Connection c : connections){\n\t\tc.send(message);\n\t}\n}", "public synchronized void send(final String message){\n\n\tif(message != null){\n\t\tfor(final Connection c : connections){\n\t\t\tif(c != null)\n\t\t\t\tc.send(message);\n\t\t}\n\t}\n}", "public synchronized void send(final String message){\n\n\tif(message.length()==0){\n\t    return;\n\t}\n\tfor(int i=0;i<connections.size();i++){\n\t    //System.out.println(\"[Send] \"+message);\n\t    connections.get(i).send(message);\n\t}\n    }", "public synchronized void send(final String message){\n\n\tif(this.getConnections().size() == 0) return;\n\tfor(final Connection c : this.getConnections()){\n\t\tc.send(message);\n\t\tc.send(\"\\n\");\n\t}\n}"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec018347", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions())\n\t\treturn;\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n//Protected but visible for test\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n    if(layout.ignoresThrowable()){\n        String[] s=event.getThrowableStrRep();\n        if(s!=null){\n            int len=s.length;\n            for(int i=0;i<len;i++){\n                super.append(s[i]);\n                super.append(Layout.LINE_SEP);\n            }\n        }\n    }\n    if(locationInfo){\n        LocationInfo locInfo=event.getLocationInformation();\n        sb.append(Layout.LINE_SEP);\n        sb.append(locInfo.getFileName());\n        sb.append(':');\n        sb.append(locInfo.getLineNumber());\n        sb.append(':');\n        sb.append(locInfo.getClassName());\n        sb.append('.');\n        sb.append(locInfo.getMethodName());\n    }\n    sb.append(Layout.LINE_SEP);\n    sb.append(event.timeStamp-LoggingEvent.getStartTime());\n    sb.append(' ');", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(event==null) return;\n\tif(layout==null){\n\t\terrorHandler.error(\"No layout set for the appender named [\"+name+\"].\");\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions())\n\t\treturn;\n\tevent.getNDC();\n\tevent.getThreadName();\n\t//we must call getRenderedMessage() to get a str representation\n\t//of the message in case toString() is overloaded.\n\tevent.getRenderedMessage();\n\tevent.getMDCCopy();\n\tif(event.getThrowableInformation()!=null){\n\t\tevent.getThrowableInformation().getThrowableStrRep();\n\t}\n\tStringBuffer buf=new StringBuffer(layout.headerToString());\n\tString h=layout.format(event);\n\tbuf.append(h);\n\t// Append throwable if exists\n\tif(layout.ignoresThrowable()&&event.getThrowableInformation()!=null){\n\t\tString[] s=event.getThrowableStrRep();\n\t\tif(s!=null){\n\t\t\tbuf.append(Layout.LINE_SEP);\n\t\t\tfor(int i=0;i<s.length;i++){\n\t\t\t\tbuf.append(s[i]);\n\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n", "method_name": "append", "codes": ["protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions())\n\t\treturn;\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n//Protected but visible for test\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n    if(layout.ignoresThrowable()){\n        String[] s=event.getThrowableStrRep();\n        if(s!=null){\n            int len=s.length;\n            for(int i=0;i<len;i++){\n                super.append(s[i]);\n                super.append(Layout.LINE_SEP);\n            }\n        }\n    }\n    if(locationInfo){\n        LocationInfo locInfo=event.getLocationInformation();\n        sb.append(Layout.LINE_SEP);\n        sb.append(locInfo.getFileName());\n        sb.append(':');\n        sb.append(locInfo.getLineNumber());\n        sb.append(':');\n        sb.append(locInfo.getClassName());\n        sb.append('.');\n        sb.append(locInfo.getMethodName());\n    }\n    sb.append(Layout.LINE_SEP);\n    sb.append(event.timeStamp-LoggingEvent.getStartTime());\n    sb.append(' ');", "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\tif(event==null) return;\n\tif(layout==null){\n\t\terrorHandler.error(\"No layout set for the appender named [\"+name+\"].\");\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\n\tif(!checkEntryConditions()){\n\t\treturn;\n\t}\n\tsubAppend(event);\n}", "protected void append(LoggingEvent event){\n\n\tif(!checkEntryConditions())\n\t\treturn;\n\tevent.getNDC();\n\tevent.getThreadName();\n\t//we must call getRenderedMessage() to get a str representation\n\t//of the message in case toString() is overloaded.\n\tevent.getRenderedMessage();\n\tevent.getMDCCopy();\n\tif(event.getThrowableInformation()!=null){\n\t\tevent.getThrowableInformation().getThrowableStrRep();\n\t}\n\tStringBuffer buf=new StringBuffer(layout.headerToString());\n\tString h=layout.format(event);\n\tbuf.append(h);\n\t// Append throwable if exists\n\tif(layout.ignoresThrowable()&&event.getThrowableInformation()!=null){\n\t\tString[] s=event.getThrowableStrRep();\n\t\tif(s!=null){\n\t\t\tbuf.append(Layout.LINE_SEP);\n\t\t\tfor(int i=0;i<s.length;i++){\n\t\t\t\tbuf.append(s[i]);\n\t\t"], "code_level": "project_runnable", "_id": "636767781a6d9265ec01823e", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void put(LoggingEvent o){\n\n\tsynchronized(buf){\n\t\ttry{\n\t\t\twhile(full){\n\t\t\t\tbuf.wait();\n\t\t\t}\n\t\t\tbuf.addElement(o);\n\t\t\tfull=buf.size()==bufSize;\n\t\t\tbuf.notifyAll();\n\t\t}catch(InterruptedException e){\n\t\t\tThread.currentThread().interrupt();\n\t\t\tlogger.error(\"interrupted\",e);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\t\tif( o == null ){\n\t\t\tSystem.out.println(\"LoggingEvent is null\");\n\t\t\treturn;\n\t\t}\n\t\ttry{\n\t\t\tbuf.put(o);\n\t\t}catch(InterruptedException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\tbuf.add(o);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\t\ttry {\n\t\t\tbuf.put(o);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\tint newLen;\n\tint len=0;\n\tboolean found=false;\t\n\tLoggingEvent old;\n\t\n\tlen=buf.size();\t\n\t\n\tif(len==0){\n\t\tbuf.add(o);\n\t\treturn;\n\t}\n\t\n\tfor(int i=0;i<len;i++){\n\t\told=(LoggingEvent)buf.get(i);\n\t\tif(o.getTimeStamp()>old.getTimeStamp()){\n\t\t\tbuf.add(i,o);\n\t\t\tfound=true;\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(!found){\n\t\tbuf.add(o);\n\t}\n\t\n\tnewLen=buf.size();\n\t\n\tif(newLen>maxSize){\n\t\tbuf.remove(newLen-1);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\tLoggingEvent event=o;\n\tif(buf==null){\n\t\tbuf=new LoggingEvent[size];\n\t\t}\n\tif(event!=null){\n\t\tif(count<size){\n\t\t\tbuf[count]=event;\n\t\t\tcount++;\n\t\t\t}\n\t\telse if(count==size){\n\t\t\tcount=0;\n\t\t\tbuf[count]=event;\n\t\t\tcount++;\n\t\t\t}\n\t\telse{\n\t\t\t\n\t\t\t}\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\tif(o==null){\n\t\tthrow new NullPointerException();\n\t}\n\tif(buf.length==0){\n\t\tthrow new IllegalStateException(\"Buffer must have a length of at least 1.\");\n\t}\n\tif(buf.length==1){\n\t\tbuf[0]=o;\n\t\treturn;\n\t}\n\tbuf[(index+1)%buf.length]=o;\n\tif(index==buf.length-1){\n\t\tindex=0;\n\t}\n\telse{\n\t\tindex++;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\t//System.out.println(\"LoggingEventBuffer.put()\");\n\tsynchronized(this){\n\t\tif(size>=buf.length){\n\t\t\tLoggingEvent[] temp=new LoggingEvent[buf.length*2];\n\t\t\tfor(int i=0;i<buf.length;i++){\n\t\t\t\ttemp[i]=buf[(oldest+i)%buf.length];\n\t\t\t}\n\t\t\toldest=0;\n\t\t\tbuf=temp;\n\t\t}\n\t\tbuf[(oldest+size++)%buf.length]=o;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n        try{\n                buf.put(o);\n        }catch(InterruptedException e){\n                Thread.currentThread().interrupt();\n        }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void put(LoggingEvent o){\n\n\tint next=0;\n\t//write to buffer\n\ttry {\n\t\tnext = (int) out.writeLong(o.timeStamp);\n\t\tnext = (int) out.writeLong(o.sequenceNumber);\n\t\tnext = out.writeInt(o.level.toInt());\n\t\tnext = (int) out.writeUTF(o.categoryName);\n\t\tnext = (int) out.writeUTF(o.threadName);\n\t\tnext = (int) out.writeUTF(o.message.toString());\n\t\tnext = (int) out.writeUTF(o.ndc);\n\t\tnext = (int) out.writeUTF(o.throwableInfo.getThrowableStrRep()[0]);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Place a  {@link LoggingEvent} in the buffer. If the buffer is fullthen the event is <b>silently dropped</b>. It is the caller's responsability to make sure that the buffer has free space.  \n */\n", "method_name": "put", "codes": ["public void put(LoggingEvent o){\n\n\tsynchronized(buf){\n\t\ttry{\n\t\t\twhile(full){\n\t\t\t\tbuf.wait();\n\t\t\t}\n\t\t\tbuf.addElement(o);\n\t\t\tfull=buf.size()==bufSize;\n\t\t\tbuf.notifyAll();\n\t\t}catch(InterruptedException e){\n\t\t\tThread.currentThread().interrupt();\n\t\t\tlogger.error(\"interrupted\",e);\n\t\t}\n\t}\n}", "public void put(LoggingEvent o){\n\n\t\tif( o == null ){\n\t\t\tSystem.out.println(\"LoggingEvent is null\");\n\t\t\treturn;\n\t\t}\n\t\ttry{\n\t\t\tbuf.put(o);\n\t\t}catch(InterruptedException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "public void put(LoggingEvent o){\n\n\tbuf.add(o);\n}", "public void put(LoggingEvent o){\n\n\t\ttry {\n\t\t\tbuf.put(o);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}", "public void put(LoggingEvent o){\n\n\tint newLen;\n\tint len=0;\n\tboolean found=false;\t\n\tLoggingEvent old;\n\t\n\tlen=buf.size();\t\n\t\n\tif(len==0){\n\t\tbuf.add(o);\n\t\treturn;\n\t}\n\t\n\tfor(int i=0;i<len;i++){\n\t\told=(LoggingEvent)buf.get(i);\n\t\tif(o.getTimeStamp()>old.getTimeStamp()){\n\t\t\tbuf.add(i,o);\n\t\t\tfound=true;\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(!found){\n\t\tbuf.add(o);\n\t}\n\t\n\tnewLen=buf.size();\n\t\n\tif(newLen>maxSize){\n\t\tbuf.remove(newLen-1);\n\t}\n}", "public void put(LoggingEvent o){\n\n\tLoggingEvent event=o;\n\tif(buf==null){\n\t\tbuf=new LoggingEvent[size];\n\t\t}\n\tif(event!=null){\n\t\tif(count<size){\n\t\t\tbuf[count]=event;\n\t\t\tcount++;\n\t\t\t}\n\t\telse if(count==size){\n\t\t\tcount=0;\n\t\t\tbuf[count]=event;\n\t\t\tcount++;\n\t\t\t}\n\t\telse{\n\t\t\t\n\t\t\t}\n\t\t}\n\t}", "public void put(LoggingEvent o){\n\n\tif(o==null){\n\t\tthrow new NullPointerException();\n\t}\n\tif(buf.length==0){\n\t\tthrow new IllegalStateException(\"Buffer must have a length of at least 1.\");\n\t}\n\tif(buf.length==1){\n\t\tbuf[0]=o;\n\t\treturn;\n\t}\n\tbuf[(index+1)%buf.length]=o;\n\tif(index==buf.length-1){\n\t\tindex=0;\n\t}\n\telse{\n\t\tindex++;\n\t}\n}", "public void put(LoggingEvent o){\n\n\t//System.out.println(\"LoggingEventBuffer.put()\");\n\tsynchronized(this){\n\t\tif(size>=buf.length){\n\t\t\tLoggingEvent[] temp=new LoggingEvent[buf.length*2];\n\t\t\tfor(int i=0;i<buf.length;i++){\n\t\t\t\ttemp[i]=buf[(oldest+i)%buf.length];\n\t\t\t}\n\t\t\toldest=0;\n\t\t\tbuf=temp;\n\t\t}\n\t\tbuf[(oldest+size++)%buf.length]=o;\n\t}\n}", "public void put(LoggingEvent o){\n\n        try{\n                buf.put(o);\n        }catch(InterruptedException e){\n                Thread.currentThread().interrupt();\n        }\n}", "public void put(LoggingEvent o){\n\n\tint next=0;\n\t//write to buffer\n\ttry {\n\t\tnext = (int) out.writeLong(o.timeStamp);\n\t\tnext = (int) out.writeLong(o.sequenceNumber);\n\t\tnext = out.writeInt(o.level.toInt());\n\t\tnext = (int) out.writeUTF(o.categoryName);\n\t\tnext = (int) out.writeUTF(o.threadName);\n\t\tnext = (int) out.writeUTF(o.message.toString());\n\t\tnext = (int) out.writeUTF(o.ndc);\n\t\tnext = (int) out.writeUTF(o.throwableInfo.getThrowableStrRep()[0]);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}"], "code_level": "class_runnable", "_id": "6367677f1a6d9265ec01834b", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=null;\n\ttry{\n\t\tval=props.getProperty(key);\n\t\tval=substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tval=null;\n\t}\n\treturn val;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\treturn substVars(val,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null) return null;\n\ttry{\n\t\treturn substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString propVal=null;\n\ttry{\n\t\tpropVal=props.getProperty(key);\n\t\treturn substVars(propVal,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn propVal;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)\n\t\treturn null;\n\ttry{\n\t\treturn substVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tSystem.err.println(\"Bad option value [\"+val+\"].\");\n\t\treturn val;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString value=props.getProperty(key);\n\tif(value==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\treturn substVars(value,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn value;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null) return val;\n\ttry{\n\t\treturn substVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tLOG.warn(\"Could not perform variable substitution.\", e);\n\t\treturn val;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=null;\n\ttry{\n\t\tval=props.getProperty(key);\n\t\tval=substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n\treturn val;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)return null;\n\ttry{return substVars(val,key,null,props);}\n\tcatch(IllegalArgumentException e){return val;}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)\n\t\treturn val;\n\ttry{\n\t\treturn substVars(val,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Find the value corresponding to <code>key</code> in <code>props</code>. Then perform variable substitution on the found value.\n */\n", "method_name": "findAndSubst", "codes": ["public static String findAndSubst(String key,Properties props){\n\n\tString val=null;\n\ttry{\n\t\tval=props.getProperty(key);\n\t\tval=substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tval=null;\n\t}\n\treturn val;\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\treturn substVars(val,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null) return null;\n\ttry{\n\t\treturn substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString propVal=null;\n\ttry{\n\t\tpropVal=props.getProperty(key);\n\t\treturn substVars(propVal,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn propVal;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)\n\t\treturn null;\n\ttry{\n\t\treturn substVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tSystem.err.println(\"Bad option value [\"+val+\"].\");\n\t\treturn val;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString value=props.getProperty(key);\n\tif(value==null){\n\t\treturn null;\n\t}\n\ttry{\n\t\treturn substVars(value,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn value;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null) return val;\n\ttry{\n\t\treturn substVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\tLOG.warn(\"Could not perform variable substitution.\", e);\n\t\treturn val;\n\t}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=null;\n\ttry{\n\t\tval=props.getProperty(key);\n\t\tval=substituteVars(val,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n\treturn val;\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)return null;\n\ttry{return substVars(val,key,null,props);}\n\tcatch(IllegalArgumentException e){return val;}\n}", "public static String findAndSubst(String key,Properties props){\n\n\tString val=props.getProperty(key);\n\tif(val==null)\n\t\treturn val;\n\ttry{\n\t\treturn substVars(val,key,null,props);\n\t}catch(IllegalArgumentException e){\n\t\treturn val;\n\t}\n}"], "code_level": "project_runnable", "_id": "636767791a6d9265ec01826d", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public boolean isAttached(Appender appender){\n\n\tif(appenderList==null)\n\t\treturn false;\n\tif(appenderList.contains(appender))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n    return appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tboolean result = false;\n\tfor(int i=0; i<appenderList.size(); i++){\n\t\tif(appenderList.get(i).equals(appender)){\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n    synchronized (appenderList){\n        return appenderList.contains(appender);\n    }\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\t\treturn appenderList.contains(appender);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tif(appenderList == null) return false;\n\tfor (int i=0; i<appenderList.size(); i++){\n\t\tif(appenderList.get(i).getName().equals(appender.getName())) return true;\n\t}\n\treturn false;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tif (appender==null) return false;\n\tif (appenderList.contains(appender)) return true;\n\telse return false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tif (appenderList.contains(appender)){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tif(appenderList.contains(appender))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isAttached(Appender appender){\n\n\tif(appenderList.contains(appender)){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns <code>true</code> if the specified appender is in the list of attached appenders, <code>false</code> otherwise.\n * @since 1.2 \n */\n", "method_name": "isAttached", "codes": ["public boolean isAttached(Appender appender){\n\n\tif(appenderList==null)\n\t\treturn false;\n\tif(appenderList.contains(appender))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "public boolean isAttached(Appender appender){\n\n    return appenderList.contains(appender);\n}", "public boolean isAttached(Appender appender){\n\n\tboolean result = false;\n\tfor(int i=0; i<appenderList.size(); i++){\n\t\tif(appenderList.get(i).equals(appender)){\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "public boolean isAttached(Appender appender){\n\n    synchronized (appenderList){\n        return appenderList.contains(appender);\n    }\n}", "public boolean isAttached(Appender appender){\n\n\t\treturn appenderList.contains(appender);\n}", "public boolean isAttached(Appender appender){\n\n\tif(appenderList == null) return false;\n\tfor (int i=0; i<appenderList.size(); i++){\n\t\tif(appenderList.get(i).getName().equals(appender.getName())) return true;\n\t}\n\treturn false;\n}", "public boolean isAttached(Appender appender){\n\n\tif (appender==null) return false;\n\tif (appenderList.contains(appender)) return true;\n\telse return false;\n}", "public boolean isAttached(Appender appender){\n\n\tif (appenderList.contains(appender)){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}", "public boolean isAttached(Appender appender){\n\n\tif(appenderList.contains(appender))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "public boolean isAttached(Appender appender){\n\n\tif(appenderList.contains(appender)){\n\t\treturn true;\n\t}\n\treturn false;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018238", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\tif(value.equalsIgnoreCase(\"true\"))return true;\n\tif(value.equalsIgnoreCase(\"false\"))return false;\n\treturn dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\tif(value.length()==0)return dEfault;\n\tif(value.equalsIgnoreCase(\"true\"))return true;\n\tif(value.equalsIgnoreCase(\"false\"))return false;\n\treturn dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim().toLowerCase();\n\treturn value.equals(\"true\")||value.equals(\"yes\")||value.equals(\"on\")||value.equals(\"1\")||value.equals(\"ok\")||value.equals(\"enable\")||value.equals(\"enabled\")||value.equals(\"active\")||value.equals(\"activated\")||value.equals(\"available\")||value.equals(\"available\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\treturn toBoolean(value,dEfault,true);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(StringUtils.isEmpty(value))return dEfault;\n\tvalue=value.trim();\n\tif(value.equalsIgnoreCase(\"true\")||value.equalsIgnoreCase(\"yes\")||value.equalsIgnoreCase(\"on\"))return true;\n\telse if(value.equalsIgnoreCase(\"false\")||value.equalsIgnoreCase(\"no\")||value.equalsIgnoreCase(\"off\"))return false;\n\treturn dEfault;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\nreturn toBoolean(value,dEfault,true);}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null) return dEfault;\n\tvalue=value.trim().toLowerCase();\n\tif(value.equals(\"true\")) return true;\n\tif(value.equals(\"false\")) return false;\n\treturn dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\treturn value.equalsIgnoreCase(\"true\")||value.equals(\"1\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\ttry{return Boolean.parseBoolean(value.trim().toLowerCase());}catch(Exception e){return dEfault;}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null) return dEfault;\n\tvalue=value.trim().toLowerCase();\n\tif(value.equals(\"true\")) return true;\n\telse if(value.equals(\"false\")) return false;\n\treturn dEfault;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * If <code>value</code> is \"true\", then <code>true</code> is returned. If <code>value</code> is \"false\", then <code>true</code> is returned. Otherwise, <code>default</code> is returned. <p>Case of value is unimportant.  \n */\n", "method_name": "toBoolean", "codes": ["public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\tif(value.equalsIgnoreCase(\"true\"))return true;\n\tif(value.equalsIgnoreCase(\"false\"))return false;\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\tif(value.length()==0)return dEfault;\n\tif(value.equalsIgnoreCase(\"true\"))return true;\n\tif(value.equalsIgnoreCase(\"false\"))return false;\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim().toLowerCase();\n\treturn value.equals(\"true\")||value.equals(\"yes\")||value.equals(\"on\")||value.equals(\"1\")||value.equals(\"ok\")||value.equals(\"enable\")||value.equals(\"enabled\")||value.equals(\"active\")||value.equals(\"activated\")||value.equals(\"available\")||value.equals(\"available\");\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\treturn toBoolean(value,dEfault,true);\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(StringUtils.isEmpty(value))return dEfault;\n\tvalue=value.trim();\n\tif(value.equalsIgnoreCase(\"true\")||value.equalsIgnoreCase(\"yes\")||value.equalsIgnoreCase(\"on\"))return true;\n\telse if(value.equalsIgnoreCase(\"false\")||value.equalsIgnoreCase(\"no\")||value.equalsIgnoreCase(\"off\"))return false;\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\nreturn toBoolean(value,dEfault,true);}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null) return dEfault;\n\tvalue=value.trim().toLowerCase();\n\tif(value.equals(\"true\")) return true;\n\tif(value.equals(\"false\")) return false;\n\treturn dEfault;\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null)return dEfault;\n\tvalue=value.trim();\n\treturn value.equalsIgnoreCase(\"true\")||value.equals(\"1\");\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\ttry{return Boolean.parseBoolean(value.trim().toLowerCase());}catch(Exception e){return dEfault;}\n}", "public static boolean toBoolean(String value,boolean dEfault){\n\n\tif(value==null) return dEfault;\n\tvalue=value.trim().toLowerCase();\n\tif(value.equals(\"true\")) return true;\n\telse if(value.equals(\"false\")) return false;\n\treturn dEfault;\n}"], "code_level": "self_contained", "_id": "6367677d1a6d9265ec0182fd", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void add(LoggingEvent event){\n\n\tint tmp=first;\n\tint last=first+count;\n\tif(last>=events.length){\n\t\tlast-=events.length;\n\t}\n\tevents[last]=event;\n\tcount++;\n\tif(count>=events.length){\n\t\tfirst++;\n\t\tif(first>=events.length){\n\t\t\tfirst-=events.length;\n\t\t}\n\t\tcount--;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\tif (events.size()==0){\n\t\tstartOfPeriod=event.timeStamp;\n\t\tendOfPeriod=event.timeStamp;\n\t} else {\n\t\tendOfPeriod=event.timeStamp;\n\t}\n\tevents.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n        //check to see if the array needs resizing.\n        if(nextFreeLocation == size){\n                resize();\n        }\n        buffer[nextFreeLocation++] = event;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\tsynchronized(this){\n\t\tif(this.buf.length()>=this.maxBufSize){\n\t\t\tthis.buf.delete(0,this.buf.length()-this.maxBufSize/2);\n\t\t}\n\t\tthis.buf.append(event.getMessage());\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\tif(len==buf.length){\n\t\tLoggingEvent[] newBuf=new LoggingEvent[buf.length*2];\n\t\tSystem.arraycopy(buf,0,newBuf,0,len);\n\t\tbuf=newBuf;\n\t}\n\tbuf[len++]=event;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\t\n\t\tif(!(event instanceof LoggingEventImpl)){\n\t\t\tLoggingEventImpl e=new LoggingEventImpl();\n\t\t\te.setLoggerName(event.getLoggerName());\n\t\t\te.setLevel(event.getLevel());\n\t\t\te.setInternalTimestamp(event.getTimeStamp());\n\t\t\te.setMessage(event.getMessage());\n\t\t\te.setRenderedMessage(event.getRenderedMessage());\n\t\t\te.setThreadName(event.getThreadName());\n\t\t\te.setThrowableStrRep(event.getThrowableStrRep());\n\t\t\tevent=e;\n\t\t}\n\t\tlog.add(event);\n\t\tif(log.size()>=maxSize){\n\t\t\tlog.remove(0);\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\t\tsynchronized(this){\n\t\t\tif(!buffering){\n\t\t\t\tdoAppend(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(buffer.size()<bufferSize){\n\t\t\t\tbuffer.add(event);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLoggingEvent last=buffer.get(bufferSize-1);\n\t\t\t\tif(last!=null){\n\t\t\t\t\tremove(last);\n\t\t\t\t}\n\t\t\t\tbuffer.add(event);\n\t\t\t}\n\t\t\tif(!buffering){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(buffering){\n\t\t\tif(this.bufferStrategy==BufferStrategy.ON_OVERFLOW_DROP){\n\t\t\t\tbuffer.remove(0);\n\t\t\t}\n\t\t\telse if(this.bufferStrategy==BufferStrategy.ON_OVERFLOW_BLOCK){\n\t\t\t\ttry{\n\t\t\t\t\twait", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\tif(this.buffer.length==0){\n\t\tthis.buffer = new LoggingEvent[1];\n\t\tthis.buffer[0]=event;\n\t}\n\telse{\n\t\tint len = this.buffer.length;\n\t\tLoggingEvent[] tmp = new LoggingEvent[len+1];\n\t\tSystem.arraycopy(this.buffer,0,tmp,0,len);\n\t\ttmp[len] = event;\n\t\tthis.buffer = tmp;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\t// if buffer is full, remove the first element\n\tif(size()>=maxSize){\n\t\tremove(0);\n\t}\n\tadd(event, false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void add(LoggingEvent event){\n\n\tevents.add(event);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add an <code>event</code> as the last event in the buffer.\n */\n", "method_name": "add", "codes": ["public void add(LoggingEvent event){\n\n\tint tmp=first;\n\tint last=first+count;\n\tif(last>=events.length){\n\t\tlast-=events.length;\n\t}\n\tevents[last]=event;\n\tcount++;\n\tif(count>=events.length){\n\t\tfirst++;\n\t\tif(first>=events.length){\n\t\t\tfirst-=events.length;\n\t\t}\n\t\tcount--;\n\t}\n}", "public void add(LoggingEvent event){\n\n\tif (events.size()==0){\n\t\tstartOfPeriod=event.timeStamp;\n\t\tendOfPeriod=event.timeStamp;\n\t} else {\n\t\tendOfPeriod=event.timeStamp;\n\t}\n\tevents.add(event);\n}", "public void add(LoggingEvent event){\n\n        //check to see if the array needs resizing.\n        if(nextFreeLocation == size){\n                resize();\n        }\n        buffer[nextFreeLocation++] = event;\n}", "public void add(LoggingEvent event){\n\n\tsynchronized(this){\n\t\tif(this.buf.length()>=this.maxBufSize){\n\t\t\tthis.buf.delete(0,this.buf.length()-this.maxBufSize/2);\n\t\t}\n\t\tthis.buf.append(event.getMessage());\n\t}\n}", "public void add(LoggingEvent event){\n\n\tif(len==buf.length){\n\t\tLoggingEvent[] newBuf=new LoggingEvent[buf.length*2];\n\t\tSystem.arraycopy(buf,0,newBuf,0,len);\n\t\tbuf=newBuf;\n\t}\n\tbuf[len++]=event;\n}", "public void add(LoggingEvent event){\n\n\t\n\t\tif(!(event instanceof LoggingEventImpl)){\n\t\t\tLoggingEventImpl e=new LoggingEventImpl();\n\t\t\te.setLoggerName(event.getLoggerName());\n\t\t\te.setLevel(event.getLevel());\n\t\t\te.setInternalTimestamp(event.getTimeStamp());\n\t\t\te.setMessage(event.getMessage());\n\t\t\te.setRenderedMessage(event.getRenderedMessage());\n\t\t\te.setThreadName(event.getThreadName());\n\t\t\te.setThrowableStrRep(event.getThrowableStrRep());\n\t\t\tevent=e;\n\t\t}\n\t\tlog.add(event);\n\t\tif(log.size()>=maxSize){\n\t\t\tlog.remove(0);\n\t\t}\n\t}", "public void add(LoggingEvent event){\n\n\t\tsynchronized(this){\n\t\t\tif(!buffering){\n\t\t\t\tdoAppend(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(buffer.size()<bufferSize){\n\t\t\t\tbuffer.add(event);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLoggingEvent last=buffer.get(bufferSize-1);\n\t\t\t\tif(last!=null){\n\t\t\t\t\tremove(last);\n\t\t\t\t}\n\t\t\t\tbuffer.add(event);\n\t\t\t}\n\t\t\tif(!buffering){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(buffering){\n\t\t\tif(this.bufferStrategy==BufferStrategy.ON_OVERFLOW_DROP){\n\t\t\t\tbuffer.remove(0);\n\t\t\t}\n\t\t\telse if(this.bufferStrategy==BufferStrategy.ON_OVERFLOW_BLOCK){\n\t\t\t\ttry{\n\t\t\t\t\twait", "public void add(LoggingEvent event){\n\n\tif(this.buffer.length==0){\n\t\tthis.buffer = new LoggingEvent[1];\n\t\tthis.buffer[0]=event;\n\t}\n\telse{\n\t\tint len = this.buffer.length;\n\t\tLoggingEvent[] tmp = new LoggingEvent[len+1];\n\t\tSystem.arraycopy(this.buffer,0,tmp,0,len);\n\t\ttmp[len] = event;\n\t\tthis.buffer = tmp;\n\t}\n}", "public void add(LoggingEvent event){\n\n\t// if buffer is full, remove the first element\n\tif(size()>=maxSize){\n\t\tremove(0);\n\t}\n\tadd(event, false);\n}", "public void add(LoggingEvent event){\n\n\tevents.add(event);\n}"], "code_level": "class_runnable", "_id": "636767841a6d9265ec0183e8", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void removeAppender(String name){\n\n\tappenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\nif(name==null || name.equals(\"\"))\nreturn;\nAppenderHolder holder=\n(AppenderHolder)appenders.get(name);\nif(holder!=null){\nappenders.remove(name);\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tsynchronized(ht){\n\t\tht.remove(name);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tif(name==null||name.trim().length()==0)\n\t\treturn;\n\t\n\tAppender appender=this.appenders.remove(name);\n\tif(appender!=null){\n\t\tappender.close();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tappenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tsynchronized(this){\n\t\tif(appenderList != null){\n\t\t\tint size = appenderList.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tif(name.equals(((Appender)appenderList.get(i)).getName())){\n\t\t\t\t\tappenderList.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void removeAppender(String name){\n\n\tsynchronized(this){\n\t\tif(name==null || appenders==null) return;\n\t\tAppender appender=(Appender)appenders.get(name);\n\t\tif(appender!=null)\tremoveAppender(appender);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tif(name==null){\n\t\tthrow new NullPointerException(\"name\");\n\t}\n\tsynchronized (appenders){\n\t\tappenders.remove(name);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void removeAppender(String name){\n\n\tif(name==null||name.length()==0)return;\n\tsynchronized(appenderList){\n\t\tint size=appenderList.size();\n\t\tfor(int i=0;i<size;i++){\n\t\t\tAppender appender=(Appender)appenderList.get(i);\n\t\t\tif(name.equals(appender.getName())){\n\t\t\t\tappenderList.remove(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void removeAppender(String name){\n\n\tappenders.remove(name);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Remove the appender with the name passed as parameter form the list of appenders.  \n */\n", "method_name": "removeAppender", "codes": ["public void removeAppender(String name){\n\n\tappenders.remove(name);\n}", "public void removeAppender(String name){\n\nif(name==null || name.equals(\"\"))\nreturn;\nAppenderHolder holder=\n(AppenderHolder)appenders.get(name);\nif(holder!=null){\nappenders.remove(name);\n}\n}", "public void removeAppender(String name){\n\n\tsynchronized(ht){\n\t\tht.remove(name);\n\t}\n}", "public void removeAppender(String name){\n\n\tif(name==null||name.trim().length()==0)\n\t\treturn;\n\t\n\tAppender appender=this.appenders.remove(name);\n\tif(appender!=null){\n\t\tappender.close();\n\t}\n}", "public void removeAppender(String name){\n\n\tappenders.remove(name);\n}", "public void removeAppender(String name){\n\n\tsynchronized(this){\n\t\tif(appenderList != null){\n\t\t\tint size = appenderList.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tif(name.equals(((Appender)appenderList.get(i)).getName())){\n\t\t\t\t\tappenderList.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "public void removeAppender(String name){\n\n\tsynchronized(this){\n\t\tif(name==null || appenders==null) return;\n\t\tAppender appender=(Appender)appenders.get(name);\n\t\tif(appender!=null)\tremoveAppender(appender);\n\t}\n}", "public void removeAppender(String name){\n\n\tif(name==null){\n\t\tthrow new NullPointerException(\"name\");\n\t}\n\tsynchronized (appenders){\n\t\tappenders.remove(name);\n\t}\n}", "public void removeAppender(String name){\n\n\tif(name==null||name.length()==0)return;\n\tsynchronized(appenderList){\n\t\tint size=appenderList.size();\n\t\tfor(int i=0;i<size;i++){\n\t\t\tAppender appender=(Appender)appenderList.get(i);\n\t\t\tif(name.equals(appender.getName())){\n\t\t\t\tappenderList.remove(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "public void removeAppender(String name){\n\n\tappenders.remove(name);\n}"], "code_level": "project_runnable", "_id": "636767861a6d9265ec01844c", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\t\n\tsynchronized(appenderList){\n\t\tsize = appenderList.size();\n\t\tfor(i = 0; i < size; i++)\n\t\t\t( (Appender) appenderList.elementAt(i)).doAppend(event);\n\t}\n\treturn size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n   int size,i;\n   Appender appender;\n   if(aai!=null){\n      size=aai.size();\n      for(i=0;i<size;i++){\n         appender=aai.appenderAt(i);\n         appender.doAppend(event);\n      }\n      return size;\n   }\n   else return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size=0;\n\tAppender appender;\n\tif (aai!=null) size=aai.size();\n\tfor (int i=0;i<size;i++){\n\t\tappender=aai.getAppender(i);\n\t\tappender.doAppend(event);\n\t}\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n    int size,i;\n    if(aai!=null)\n    {\n        size=aai.size();\n        for(i=0;i<size;i++)\n        {\n            Appender appender=(Appender)aai.elementAt(i);\n            appender.doAppend(event);\n        }\n        return size;\n    }\n    return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\tAppender appender;\n\t\n\tsize = aai.size();\n\tfor(i = 0; i < size; i++){\n\t\tappender = (Appender) aai.elementAt(i);\n\t\tappender.doAppend(event);\n\t}\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size,i;\n\tAppender appender;\n\tif(aai!=null) {\n\t\tsize=aai.size();\n\t\tfor(i=0;i<size;i++) {\n\t\t\tappender=aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\n\t}\n\treturn 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\n\tsynchronized(aai) {\n\t\tsize = aai.size();\n\t\tfor(i = 0; i < size; i++) {\n\t\t\taai.getAppender(i).doAppend(event);\n\t\t}\n\t}\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n    int size=0;\n    if(appenderList!=null)\n    \tsize=appenderList.size();\n    for(int i=0;i<size;i++){\n        Appender appender=(Appender)appenderList.elementAt(i);\n        appender.doAppend(event);\n    }\n    return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\tAppender appender;\n\tif(aai != null){\n\t\tsize = aai.size();\n\t\tfor(i = 0; i < size; i++){\n\t\t\tappender = (Appender) aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\t\t\n\t}\n\treturn 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size,i;\n\tAppender appender;\n\tif(aai!=null){\n\t\tsize=aai.size();\n\t\tfor(i=0;i<size;i++){\n\t\t\tappender=aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\n\t}\n\treturn 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n", "method_name": "appendLoopOnAppenders", "codes": ["public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\t\n\tsynchronized(appenderList){\n\t\tsize = appenderList.size();\n\t\tfor(i = 0; i < size; i++)\n\t\t\t( (Appender) appenderList.elementAt(i)).doAppend(event);\n\t}\n\treturn size;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n   int size,i;\n   Appender appender;\n   if(aai!=null){\n      size=aai.size();\n      for(i=0;i<size;i++){\n         appender=aai.appenderAt(i);\n         appender.doAppend(event);\n      }\n      return size;\n   }\n   else return 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size=0;\n\tAppender appender;\n\tif (aai!=null) size=aai.size();\n\tfor (int i=0;i<size;i++){\n\t\tappender=aai.getAppender(i);\n\t\tappender.doAppend(event);\n\t}\n\treturn size;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n    int size,i;\n    if(aai!=null)\n    {\n        size=aai.size();\n        for(i=0;i<size;i++)\n        {\n            Appender appender=(Appender)aai.elementAt(i);\n            appender.doAppend(event);\n        }\n        return size;\n    }\n    return 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\tAppender appender;\n\t\n\tsize = aai.size();\n\tfor(i = 0; i < size; i++){\n\t\tappender = (Appender) aai.elementAt(i);\n\t\tappender.doAppend(event);\n\t}\n\treturn size;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size,i;\n\tAppender appender;\n\tif(aai!=null) {\n\t\tsize=aai.size();\n\t\tfor(i=0;i<size;i++) {\n\t\t\tappender=aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\n\t}\n\treturn 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\n\tsynchronized(aai) {\n\t\tsize = aai.size();\n\t\tfor(i = 0; i < size; i++) {\n\t\t\taai.getAppender(i).doAppend(event);\n\t\t}\n\t}\n\treturn size;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n    int size=0;\n    if(appenderList!=null)\n    \tsize=appenderList.size();\n    for(int i=0;i<size;i++){\n        Appender appender=(Appender)appenderList.elementAt(i);\n        appender.doAppend(event);\n    }\n    return size;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size, i;\n\tAppender appender;\n\tif(aai != null){\n\t\tsize = aai.size();\n\t\tfor(i = 0; i < size; i++){\n\t\t\tappender = (Appender) aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\t\t\n\t}\n\treturn 0;\n}", "public int appendLoopOnAppenders(LoggingEvent event){\n\n\tint size,i;\n\tAppender appender;\n\tif(aai!=null){\n\t\tsize=aai.size();\n\t\tfor(i=0;i<size;i++){\n\t\t\tappender=aai.elementAt(i);\n\t\t\tappender.doAppend(event);\n\t\t}\n\t}\n\treturn 0;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018242", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public boolean hasThrown(){\n\nreturn thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n    return thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\tif(thrown.size()==0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn (thrown != null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\nreturn thrown!=null;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn hasThrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn thrown;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean hasThrown(){\n\n\treturn (this.thrown != null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n", "method_name": "hasThrown", "codes": ["public boolean hasThrown(){\n\nreturn thrown;\n}", "public boolean hasThrown(){\n\n    return thrown;\n}", "public boolean hasThrown(){\n\n\tif(thrown.size()==0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "public boolean hasThrown(){\n\n\treturn (thrown != null);\n}", "public boolean hasThrown(){\n\nreturn thrown!=null;\n}", "public boolean hasThrown(){\n\n\treturn thrown;\n}", "public boolean hasThrown(){\n\n\treturn hasThrown;\n}", "public boolean hasThrown(){\n\n\treturn thrown;\n}", "public boolean hasThrown(){\n\n\treturn thrown;\n}", "public boolean hasThrown(){\n\n\treturn (this.thrown != null);\n}"], "code_level": "class_runnable", "_id": "636767821a6d9265ec0183ab", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "protected int removeUnusedNodes(){\n\n\treturn removeUnusedNodes(rootNode);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint numRemoved = 0;\n\tfor(int i=0; i<size(); i++){\n\t\tCategory node = (Category)elementAt(i);\n\t\tnumRemoved += node.removeUnusedNodes();\n\t\tif(node.size() == 0 && !node.isUsed()) remove(i--);\n\t}\n\treturn numRemoved;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint count = 0;\n\tfor(Iterator<CategoryNode> i=getRoot().getChildren().iterator();i.hasNext();){\n\t\tCategoryNode child = i.next();\n\t\tif(child.getNumberOfCategories() == 0){\n\t\t\ti.remove();\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint count=0;\n\tfor(int i=0;i<categories.size();i++){\n\t\tCategory cat=(Category)categories.elementAt(i);\n\t\tif(cat.getNumActiveSettings()==0){\n\t\t\tif(cat.parent!=null){\n\t\t\t\tcat.parent.removeChild(cat);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\t\n\tint nDeleted = 0;\n\t\n\tfor(int i=0;i<root.getChildCount();i++){\n\t\tDefaultMutableTreeNode child = (DefaultMutableTreeNode)root.getChildAt(i);\n\t\tnDeleted += removeUnusedNodes(child);\n\t}\n\treturn nDeleted;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint removedNodes=0;\n\tfor(int i=0;i<getChildCount();i++){\n\t\tCategoryNode node=(CategoryNode)getChildAt(i);\n\t\tremovedNodes+=node.removeUnusedNodes();\n\t}\n\tif(isActive.size()==0){\n\t\tCategoryNode parent=(CategoryNode)getParent();\n\t\tparent.remove(this);\n\t\tremovedNodes++;\n\t}\n\treturn removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n    int numRemoved=0;\n    for(int i=0; i<size(); i++){\n        Category c = (Category)elementAt(i);\n        if(c.removeUnusedNodes()>0){\n            numRemoved++;\n            //System.out.println(\"Removed \"+c.getName());\n            removeElementAt(i);\n            i--;\n        }\n    }\n    return numRemoved;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n    int numberRemoved = 0;\n    for(int i = 0; i < numberOfCategories; i++){\n        if(categoryNodes[i].getState() == false){\n            numberRemoved++;\n            categoryNodes[i] = null;\n            }\n        }\n    return numberRemoved;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint count = 0;\n\tif(children != null)\n\t\tfor(int i = 0; i < children.length; i++){\n\t\t\tcount += children[i].removeUnusedNodes();\n\t\t\tif(children[i].isUnused())\n\t\t\t\tchildren[i] = null;\n\t\t}\n\treturn count;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected int removeUnusedNodes(){\n\n\tint removedNodes = 0;\n\tfor (int i=0; i<nodes.size(); i++){\n\t\tCategoryNode node = (CategoryNode)nodes.get(i);\n\t\tif (!node.isActive()) {\n\t\t\tnodes.remove(i);\n\t\t\tremovedNodes++;\n\t\t}\n\t}\n\treturn removedNodes;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n", "method_name": "removeUnusedNodes", "codes": ["protected int removeUnusedNodes(){\n\n\treturn removeUnusedNodes(rootNode);\n}", "protected int removeUnusedNodes(){\n\n\tint numRemoved = 0;\n\tfor(int i=0; i<size(); i++){\n\t\tCategory node = (Category)elementAt(i);\n\t\tnumRemoved += node.removeUnusedNodes();\n\t\tif(node.size() == 0 && !node.isUsed()) remove(i--);\n\t}\n\treturn numRemoved;\n}", "protected int removeUnusedNodes(){\n\n\tint count = 0;\n\tfor(Iterator<CategoryNode> i=getRoot().getChildren().iterator();i.hasNext();){\n\t\tCategoryNode child = i.next();\n\t\tif(child.getNumberOfCategories() == 0){\n\t\t\ti.remove();\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "protected int removeUnusedNodes(){\n\n\tint count=0;\n\tfor(int i=0;i<categories.size();i++){\n\t\tCategory cat=(Category)categories.elementAt(i);\n\t\tif(cat.getNumActiveSettings()==0){\n\t\t\tif(cat.parent!=null){\n\t\t\t\tcat.parent.removeChild(cat);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "protected int removeUnusedNodes(){\n\n\t\n\tint nDeleted = 0;\n\t\n\tfor(int i=0;i<root.getChildCount();i++){\n\t\tDefaultMutableTreeNode child = (DefaultMutableTreeNode)root.getChildAt(i);\n\t\tnDeleted += removeUnusedNodes(child);\n\t}\n\treturn nDeleted;\n}", "protected int removeUnusedNodes(){\n\n\tint removedNodes=0;\n\tfor(int i=0;i<getChildCount();i++){\n\t\tCategoryNode node=(CategoryNode)getChildAt(i);\n\t\tremovedNodes+=node.removeUnusedNodes();\n\t}\n\tif(isActive.size()==0){\n\t\tCategoryNode parent=(CategoryNode)getParent();\n\t\tparent.remove(this);\n\t\tremovedNodes++;\n\t}\n\treturn removedNodes;\n}", "protected int removeUnusedNodes(){\n\n    int numRemoved=0;\n    for(int i=0; i<size(); i++){\n        Category c = (Category)elementAt(i);\n        if(c.removeUnusedNodes()>0){\n            numRemoved++;\n            //System.out.println(\"Removed \"+c.getName());\n            removeElementAt(i);\n            i--;\n        }\n    }\n    return numRemoved;\n}", "protected int removeUnusedNodes(){\n\n    int numberRemoved = 0;\n    for(int i = 0; i < numberOfCategories; i++){\n        if(categoryNodes[i].getState() == false){\n            numberRemoved++;\n            categoryNodes[i] = null;\n            }\n        }\n    return numberRemoved;\n}", "protected int removeUnusedNodes(){\n\n\tint count = 0;\n\tif(children != null)\n\t\tfor(int i = 0; i < children.length; i++){\n\t\t\tcount += children[i].removeUnusedNodes();\n\t\t\tif(children[i].isUnused())\n\t\t\t\tchildren[i] = null;\n\t\t}\n\treturn count;\n}", "protected int removeUnusedNodes(){\n\n\tint removedNodes = 0;\n\tfor (int i=0; i<nodes.size(); i++){\n\t\tCategoryNode node = (CategoryNode)nodes.get(i);\n\t\tif (!node.isActive()) {\n\t\t\tnodes.remove(i);\n\t\t\tremovedNodes++;\n\t\t}\n\t}\n\treturn removedNodes;\n}"], "code_level": "project_runnable", "_id": "6367677e1a6d9265ec018314", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n\tEvent e1=(Event)aObj1;\n\tEvent e2=(Event)aObj2;\n\treturn e1.timestamp.compareTo(e2.timestamp);\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n\tEvent a1 = (Event)aObj1;\n\tEvent a2 = (Event)aObj2;\n\tdouble tim1 = a1.getTimestamp();\n\tdouble tim2 = a2.getTimestamp();\n\tif(tim1 < tim2)\n\t\treturn -1;\n\telse if(tim1 > tim2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\nEvent ev1=(Event)aObj1;\nEvent ev2=(Event)aObj2;\nif(ev1.getTimeStamp()>ev2.getTimeStamp()){\nreturn 1;\n}\nelse if(ev1.getTimeStamp()<ev2.getTimeStamp()){\nreturn -1;\n}\nelse{\nreturn 0;\n}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n    Event ev1=(Event)aObj1,ev2=(Event)aObj2;\n    if(ev1.getTimeStamp()>ev2.getTimeStamp())\n        return 1;\n    else if(ev1.getTimeStamp()<ev2.getTimeStamp())\n        return -1;\n    return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n\tEvent lEvt1=(Event)aObj1;\n\tEvent lEvt2=(Event)aObj2;\n\tif(lEvt1.getTimeStamp()<lEvt2.getTimeStamp())\n\t\treturn -1;\n\telse if(lEvt1.getTimeStamp()>lEvt2.getTimeStamp())\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n\tEvent aEvent1=(Event)aObj1;\n\tEvent aEvent2=(Event)aObj2;\n\treturn aEvent1.timeStamp-aEvent2.timeStamp;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n\tEvent a1=(Event)aObj1;\n\tEvent a2=(Event)aObj2;\n\n\treturn (int)(a1.timeStamp-a2.timeStamp);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n    return ((Event)aObj1).getTimeStamp().compareTo(((Event)aObj2).getTimeStamp());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n    Event e1=(Event)aObj1;\n    Event e2=(Event)aObj2;\n    long t1=e1.getTimeStamp();\n    long t2=e2.getTimeStamp();\n    if (t1<t2)\n        return -1;\n    if (t1>t2)\n        return 1;\n    return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int compare(Object aObj1,Object aObj2){\n\n    if(aObj1 instanceof Event && aObj2 instanceof Event) {\n        Event event1 = (Event) aObj1;\n        Event event2 = (Event) aObj2;\n        return (event1.getTimeStamp() > event2.getTimeStamp()) ? 1 : -1;\n    }\n    else {\n        throw new ClassCastException();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @see Comparator \n */\n", "method_name": "compare", "codes": ["public int compare(Object aObj1,Object aObj2){\n\n\tEvent e1=(Event)aObj1;\n\tEvent e2=(Event)aObj2;\n\treturn e1.timestamp.compareTo(e2.timestamp);\n    }", "public int compare(Object aObj1,Object aObj2){\n\n\tEvent a1 = (Event)aObj1;\n\tEvent a2 = (Event)aObj2;\n\tdouble tim1 = a1.getTimestamp();\n\tdouble tim2 = a2.getTimestamp();\n\tif(tim1 < tim2)\n\t\treturn -1;\n\telse if(tim1 > tim2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\nEvent ev1=(Event)aObj1;\nEvent ev2=(Event)aObj2;\nif(ev1.getTimeStamp()>ev2.getTimeStamp()){\nreturn 1;\n}\nelse if(ev1.getTimeStamp()<ev2.getTimeStamp()){\nreturn -1;\n}\nelse{\nreturn 0;\n}\n}", "public int compare(Object aObj1,Object aObj2){\n\n    Event ev1=(Event)aObj1,ev2=(Event)aObj2;\n    if(ev1.getTimeStamp()>ev2.getTimeStamp())\n        return 1;\n    else if(ev1.getTimeStamp()<ev2.getTimeStamp())\n        return -1;\n    return 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\n\tEvent lEvt1=(Event)aObj1;\n\tEvent lEvt2=(Event)aObj2;\n\tif(lEvt1.getTimeStamp()<lEvt2.getTimeStamp())\n\t\treturn -1;\n\telse if(lEvt1.getTimeStamp()>lEvt2.getTimeStamp())\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\n\tEvent aEvent1=(Event)aObj1;\n\tEvent aEvent2=(Event)aObj2;\n\treturn aEvent1.timeStamp-aEvent2.timeStamp;\n}", "public int compare(Object aObj1,Object aObj2){\n\n\tEvent a1=(Event)aObj1;\n\tEvent a2=(Event)aObj2;\n\n\treturn (int)(a1.timeStamp-a2.timeStamp);\n}", "public int compare(Object aObj1,Object aObj2){\n\n    return ((Event)aObj1).getTimeStamp().compareTo(((Event)aObj2).getTimeStamp());\n}", "public int compare(Object aObj1,Object aObj2){\n\n    Event e1=(Event)aObj1;\n    Event e2=(Event)aObj2;\n    long t1=e1.getTimeStamp();\n    long t2=e2.getTimeStamp();\n    if (t1<t2)\n        return -1;\n    if (t1>t2)\n        return 1;\n    return 0;\n}", "public int compare(Object aObj1,Object aObj2){\n\n    if(aObj1 instanceof Event && aObj2 instanceof Event) {\n        Event event1 = (Event) aObj1;\n        Event event2 = (Event) aObj2;\n        return (event1.getTimeStamp() > event2.getTimeStamp()) ? 1 : -1;\n    }\n    else {\n        throw new ClassCastException();\n    }\n}"], "code_level": "project_runnable", "_id": "636767841a6d9265ec0183f2", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public int decide(LoggingEvent event){\n\n    if(!isStarted())return Filter.NEUTRAL;\n    String msg=event.getRenderedMessage();\n    if(msg==null||(event.getLevel().toInt()>Level.INFO.toInt())){\n        return Filter.NEUTRAL;\n    }\n    if(stringMatch(msg)){\n        return onMatch;\n    }else{\n        return onMismatch;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n\tif(m_messagePattern == null){\n\t\treturn NEUTRAL;\n\t}\n\tif(event == null || event.getMessage() == null){\n\t\treturn NEUTRAL;\n\t}\n\tif(m_messagePattern.matcher(event.getMessage().toString()).matches()){\n\t\treturn ACCEPT;\n\t}\n\treturn DENY;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n    if(event.getMessage()==null){\n    return NEUTRAL;\n    }\n    if(event.getMessage().toString().matches(stringToMatch)){\n    return ACCEPT;\n    }\n    return DENY;\n    }", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\nif(!isStarted())\nreturn Filter.NEUTRAL;\nString message=event.getRenderedMessage();\nif(message==null)\nreturn Filter.NEUTRAL;\nif(stringMatcher.isMatch(message))\nreturn onMatchLogLevel;\nelse\nreturn onMismatchLogLevel;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n    if(event.getRenderedMessage() == null) {\n        return Filter.NEUTRAL;\n    } else {\n        if(event.getRenderedMessage().contains(match)) {\n            return Filter.ACCEPT;\n        } else {\n            return Filter.DENY;\n        }\n    }\n\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n    String msg = event.getMessage().toString();\n    if (msg.indexOf(stringToMatch) != -1)\n        return ACCEPT;\n    else\n        return DENY;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n\tif (m_str==null)\n\t\treturn DENY;\n\t\n\tObject msg = event.getMessage();\n\tif (msg instanceof String)\n\t\treturn (((String)msg).indexOf(m_str) != -1) ? DENY : NEUTRAL;\n\t\n\treturn NEUTRAL;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n    if (event.getLevel().toInt()<=this.levelInt){\n        if (event.getMessage().equals(this.trigger)){\n            return this.acceptOnMatch;\n        }\n    }\n    return this.denyAll;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\n    if(event==null||event.getMessage()==null){\n        return Filter.DENY;\n    }\n    String msg=event.getRenderedMessage();\n    if(msg==null||!OptionConverter.toBoolean(getOption(msg),true)){\n        return Filter.DENY;\n    }\n    return Filter.ACCEPT;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int decide(LoggingEvent event){\n\nif(event.getMessage()!=null && event.getMessage().toString().indexOf(stringToMatch)>=0){\nreturn ACCEPT;\n}\nreturn DENY;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n", "method_name": "decide", "codes": ["public int decide(LoggingEvent event){\n\n    if(!isStarted())return Filter.NEUTRAL;\n    String msg=event.getRenderedMessage();\n    if(msg==null||(event.getLevel().toInt()>Level.INFO.toInt())){\n        return Filter.NEUTRAL;\n    }\n    if(stringMatch(msg)){\n        return onMatch;\n    }else{\n        return onMismatch;\n    }\n}", "public int decide(LoggingEvent event){\n\n\tif(m_messagePattern == null){\n\t\treturn NEUTRAL;\n\t}\n\tif(event == null || event.getMessage() == null){\n\t\treturn NEUTRAL;\n\t}\n\tif(m_messagePattern.matcher(event.getMessage().toString()).matches()){\n\t\treturn ACCEPT;\n\t}\n\treturn DENY;\n}", "public int decide(LoggingEvent event){\n\n    if(event.getMessage()==null){\n    return NEUTRAL;\n    }\n    if(event.getMessage().toString().matches(stringToMatch)){\n    return ACCEPT;\n    }\n    return DENY;\n    }", "public int decide(LoggingEvent event){\n\nif(!isStarted())\nreturn Filter.NEUTRAL;\nString message=event.getRenderedMessage();\nif(message==null)\nreturn Filter.NEUTRAL;\nif(stringMatcher.isMatch(message))\nreturn onMatchLogLevel;\nelse\nreturn onMismatchLogLevel;\n}", "public int decide(LoggingEvent event){\n\n    if(event.getRenderedMessage() == null) {\n        return Filter.NEUTRAL;\n    } else {\n        if(event.getRenderedMessage().contains(match)) {\n            return Filter.ACCEPT;\n        } else {\n            return Filter.DENY;\n        }\n    }\n\n}", "public int decide(LoggingEvent event){\n\n    String msg = event.getMessage().toString();\n    if (msg.indexOf(stringToMatch) != -1)\n        return ACCEPT;\n    else\n        return DENY;\n}", "public int decide(LoggingEvent event){\n\n\tif (m_str==null)\n\t\treturn DENY;\n\t\n\tObject msg = event.getMessage();\n\tif (msg instanceof String)\n\t\treturn (((String)msg).indexOf(m_str) != -1) ? DENY : NEUTRAL;\n\t\n\treturn NEUTRAL;\n}", "public int decide(LoggingEvent event){\n\n    if (event.getLevel().toInt()<=this.levelInt){\n        if (event.getMessage().equals(this.trigger)){\n            return this.acceptOnMatch;\n        }\n    }\n    return this.denyAll;\n}", "public int decide(LoggingEvent event){\n\n    if(event==null||event.getMessage()==null){\n        return Filter.DENY;\n    }\n    String msg=event.getRenderedMessage();\n    if(msg==null||!OptionConverter.toBoolean(getOption(msg),true)){\n        return Filter.DENY;\n    }\n    return Filter.ACCEPT;\n}", "public int decide(LoggingEvent event){\n\nif(event.getMessage()!=null && event.getMessage().toString().indexOf(stringToMatch)>=0){\nreturn ACCEPT;\n}\nreturn DENY;\n}"], "code_level": "project_runnable", "_id": "636767781a6d9265ec018250", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint index=nameStart;\n\twhile(count<this.count){\n\t\tif(buf.charAt(index)=='.'){\n\t\t\tcount++;\n\t\t}\n\t\tindex++;\n\t}\n\tbuf.delete(nameStart,index);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\t// if the name is too long, we need to abbreviate it.\n\tchar[] name = this.source;\n\tint nameEnd = this.scanner.getCurrentTokenEndPosition();\n\tint i = nameStart;\n\tint n = 0;\n\twhile (i < nameEnd && n < this.scanner.diet){\n\t\tswitch(name[i]){\n\t\t\tcase '.':\n\t\t\t\tn++;\n\t\t\t\tbreak;\n\t\t\tcase '$':\n\t\t\t\tif(this.scanner.dollarIsError){\n\t\t\t\t\tbuf.append('$');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuf.append(name[i]);\n\t\t}\n\t\ti++;\n\t}\n\tif (i < nameEnd){\n\t\tbuf.append(\"...\"); //$NON-NLS-1$\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint index=nameStart;\n\tint count=0;\n\twhile((count<this.fAbbreviationCount)&&(index<this.fName.length())){\n\t\tif(this.fName.charAt(index++)=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(index<this.fName.length()){\n\t\tbuf.append(this.fName.substring(index));\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(nameStart>=0){\n\t\tint dot=buf.indexOf(\".\",nameStart);\n\t\tif(dot>0){\n\t\t\tbuf.delete(nameStart,dot+1);\n\t\t\tabbreviate(nameStart,buf);\n\t\t}\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=1;\n\tfor(int i=0;i<nameStart;i++){\n\t\tif(this.name[i]=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tthis.abbreviate(nameStart,buf,count);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(startIndex==nameStart){\n\t\treturn;//nothing to do\n\t}\n\tif(nameStart>startIndex){\n\t\tthrow new IllegalArgumentException(\"nameStart cannot be greater than startIndex\");//$NON-NLS-1$\n\t}\n\tif(nameStart<=0){\n\t\tthrow new IllegalArgumentException(\"nameStart cannot be less or equal to zero\");//$NON-NLS-1$\n\t}\n\tif(buf==null){\n\t\tthrow new IllegalArgumentException(\"buf cannot be null\");//$NON-NLS-1$\n\t}\n\tint i=startIndex;\n\tint count=0;\n\twhile(count<nameStart && i<buf.length()){\n\t\tif(buf.charAt(i++)=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count<nameStart){\n\t\tthrow new IllegalArgumentException(\"Name does not contain enough substrings to abbreviate\");//$NON-NLS-1$\n\t}\n\tint start=i;\n\twhile", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint i=buf.length()-1;\n\twhile(i>=nameStart){\n\t\tif(buf.charAt(i)=='.'){\n\t\t\tcount++;\n\t\t\tif(count==this.count){\n\t\t\t\tbuf.delete(nameStart,i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint nameEnd=nameStart;\n\tint dot=nameStart;\n\twhile(dot<buf.length()){\n\t\tif(buf.charAt(dot)=='.'){\n\t\t\tif(dot==nameStart){\n\t\t\t\tnameStart++;\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t\tif(count>=this.abbreviationLength){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnameEnd=dot-1;\n\t\t\t}\n\t\t\tdot++;\n\t\t}else{\n\t\t\tdot++;\n\t\t}\n\t}\n\tif(count>=this.abbreviationLength){\n\t\tbuf.delete(nameStart,nameEnd);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint indexOfDot=nameStart;\n\twhile(indexOfDot<buf.length() && count++<this.mode){\n\t\tindexOfDot=this.findNextOf(buf, '.', indexOfDot);\n\t\tif(indexOfDot<0) break;\n\t\tif(count==this.mode) break;\n\t\tindexOfDot++;\n\t}\n\tif(count>this.mode && indexOfDot<buf.length()){\n\t\tbuf.delete(nameStart, indexOfDot);\n\t\tbuf.insert(nameStart, '*');\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(buf==null) return;\n\tif(nameStart<0) return;\n\tint l=0,r=0;\n\tint count=0;\n\tfor(int i=nameStart;i<buf.length();i++){\n\t\tif(buf.charAt(i)!='.') continue;\n\t\tl=r;\n\t\tr=i;\n\t\tif(++count>=this.abbreviatedLevel) break;\n\t}\n\tif(l==0) return;\n\tbuf.delete(nameStart,l-1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Abbreviate name.\n * @param buf buffer to append abbreviation.\n * @param nameStart start of name to abbreviate.\n */\n", "method_name": "abbreviate", "codes": ["public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint index=nameStart;\n\twhile(count<this.count){\n\t\tif(buf.charAt(index)=='.'){\n\t\t\tcount++;\n\t\t}\n\t\tindex++;\n\t}\n\tbuf.delete(nameStart,index);\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\t// if the name is too long, we need to abbreviate it.\n\tchar[] name = this.source;\n\tint nameEnd = this.scanner.getCurrentTokenEndPosition();\n\tint i = nameStart;\n\tint n = 0;\n\twhile (i < nameEnd && n < this.scanner.diet){\n\t\tswitch(name[i]){\n\t\t\tcase '.':\n\t\t\t\tn++;\n\t\t\t\tbreak;\n\t\t\tcase '$':\n\t\t\t\tif(this.scanner.dollarIsError){\n\t\t\t\t\tbuf.append('$');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuf.append(name[i]);\n\t\t}\n\t\ti++;\n\t}\n\tif (i < nameEnd){\n\t\tbuf.append(\"...\"); //$NON-NLS-1$\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint index=nameStart;\n\tint count=0;\n\twhile((count<this.fAbbreviationCount)&&(index<this.fName.length())){\n\t\tif(this.fName.charAt(index++)=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(index<this.fName.length()){\n\t\tbuf.append(this.fName.substring(index));\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(nameStart>=0){\n\t\tint dot=buf.indexOf(\".\",nameStart);\n\t\tif(dot>0){\n\t\t\tbuf.delete(nameStart,dot+1);\n\t\t\tabbreviate(nameStart,buf);\n\t\t}\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=1;\n\tfor(int i=0;i<nameStart;i++){\n\t\tif(this.name[i]=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tthis.abbreviate(nameStart,buf,count);\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(startIndex==nameStart){\n\t\treturn;//nothing to do\n\t}\n\tif(nameStart>startIndex){\n\t\tthrow new IllegalArgumentException(\"nameStart cannot be greater than startIndex\");//$NON-NLS-1$\n\t}\n\tif(nameStart<=0){\n\t\tthrow new IllegalArgumentException(\"nameStart cannot be less or equal to zero\");//$NON-NLS-1$\n\t}\n\tif(buf==null){\n\t\tthrow new IllegalArgumentException(\"buf cannot be null\");//$NON-NLS-1$\n\t}\n\tint i=startIndex;\n\tint count=0;\n\twhile(count<nameStart && i<buf.length()){\n\t\tif(buf.charAt(i++)=='.'){\n\t\t\tcount++;\n\t\t}\n\t}\n\tif(count<nameStart){\n\t\tthrow new IllegalArgumentException(\"Name does not contain enough substrings to abbreviate\");//$NON-NLS-1$\n\t}\n\tint start=i;\n\twhile", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint i=buf.length()-1;\n\twhile(i>=nameStart){\n\t\tif(buf.charAt(i)=='.'){\n\t\t\tcount++;\n\t\t\tif(count==this.count){\n\t\t\t\tbuf.delete(nameStart,i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint nameEnd=nameStart;\n\tint dot=nameStart;\n\twhile(dot<buf.length()){\n\t\tif(buf.charAt(dot)=='.'){\n\t\t\tif(dot==nameStart){\n\t\t\t\tnameStart++;\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t\tif(count>=this.abbreviationLength){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnameEnd=dot-1;\n\t\t\t}\n\t\t\tdot++;\n\t\t}else{\n\t\t\tdot++;\n\t\t}\n\t}\n\tif(count>=this.abbreviationLength){\n\t\tbuf.delete(nameStart,nameEnd);\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tint count=0;\n\tint indexOfDot=nameStart;\n\twhile(indexOfDot<buf.length() && count++<this.mode){\n\t\tindexOfDot=this.findNextOf(buf, '.', indexOfDot);\n\t\tif(indexOfDot<0) break;\n\t\tif(count==this.mode) break;\n\t\tindexOfDot++;\n\t}\n\tif(count>this.mode && indexOfDot<buf.length()){\n\t\tbuf.delete(nameStart, indexOfDot);\n\t\tbuf.insert(nameStart, '*');\n\t}\n}", "public void abbreviate(final int nameStart,final StringBuffer buf){\n\n\tif(buf==null) return;\n\tif(nameStart<0) return;\n\tint l=0,r=0;\n\tint count=0;\n\tfor(int i=nameStart;i<buf.length();i++){\n\t\tif(buf.charAt(i)!='.') continue;\n\t\tl=r;\n\t\tr=i;\n\t\tif(++count>=this.abbreviatedLevel) break;\n\t}\n\tif(l==0) return;\n\tbuf.delete(nameStart,l-1);\n}"], "code_level": "class_runnable", "_id": "636767861a6d9265ec018440", "project_name": "logging-log4j1-main"}
{"generate_results": [{"generate_code": "public String id(String entityId){\n\n    return point+idConnector+entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn point + idConnector + entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn point+idConnector+entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn String.format(\"%s%s%s\",point,idConnector,entityId);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn this.id()+idConnector+entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn point + ID_CONNECTOR + entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\t/**\n\t * @todo: implement this java.lang.Object method\n\t */\n\tthrow new UnsupportedOperationException(\"Method id() not yet implemented.\");\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\tString id = point + idConnector + entityId;\n\treturn id;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(getId()).append(ID_CONNECTOR).append(entityId);\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public String id(String entityId){\n\n\treturn point+idConnector+entityId;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return the row id\n */\n", "method_name": "id", "codes": ["public String id(String entityId){\n\n    return point+idConnector+entityId;\n}", "public String id(String entityId){\n\n\treturn point + idConnector + entityId;\n}", "public String id(String entityId){\n\n\treturn point+idConnector+entityId;\n}", "public String id(String entityId){\n\n\treturn String.format(\"%s%s%s\",point,idConnector,entityId);\n}", "public String id(String entityId){\n\n\treturn this.id()+idConnector+entityId;\n}", "public String id(String entityId){\n\n\treturn point + ID_CONNECTOR + entityId;\n}", "public String id(String entityId){\n\n\t/**\n\t * @todo: implement this java.lang.Object method\n\t */\n\tthrow new UnsupportedOperationException(\"Method id() not yet implemented.\");\n}", "public String id(String entityId){\n\n\tString id = point + idConnector + entityId;\n\treturn id;\n}", "public String id(String entityId){\n\n\tStringBuilder sb = new StringBuilder();\n\tsb.append(getId()).append(ID_CONNECTOR).append(entityId);\n\treturn sb.toString();\n}", "public String id(String entityId){\n\n\treturn point+idConnector+entityId;\n}"], "code_level": "project_runnable", "_id": "636767df1a6d9265ec01873c", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "@Override public void accept(final METRICS data){\n\n\n\t//put the data into the buffer\n\tfinal boolean isNew = buffer.compute(data.getId(), (id,value)->{\n\t\tif(value==null){\n\t\t\t//this is a new entry\n\t\t\tif(buffer.size() > maxSize){\n\t\t\t\t//this is a new entry, but the buffer is full, so we need to remove the oldest entry\n\t\t\t\tbuffer.remove(oldest.remove(0));\n\t\t\t}\n\t\t\t//this is a new entry, and the buffer is not full, so we add it\n\t\t\toldest.add(data.getId());\n\t\t\treturn data;\n\t\t}else{\n\t\t\t//this is an existing entry, so we try to combine it\n\t\t\tfinal METRICS combined = combineValues(data, value);\n\t\t\tif(combined.isAbandoned()){\n\t\t\t\t//the combined value is abandoned, so we remove it\n\t\t\t\toldest.remove(id);\n\t\t\t\treturn null;\n\t\t\t}else{\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\tfinal int id = data.id;\n\tif(id > maxId) {\n\t\tthrow new IllegalArgumentException(\"id cannot be greater than the maximum id\");\n\t}\n\tif(id == maxId) {\n\t\tmaxId = -1;\n\t\tmax = null;\n\t}\n\tfinal int index = id % buffer.length;\n\tfinal METRICS[] buffer = this.buffer;\n\tfinal METRICS prev = buffer[index];\n\tif(prev == null) {\n\t\tbuffer[index] = data;\n\t} else {\n\t\tcombine(prev, data);\n\t\tif(prev.abandoned()) {\n\t\t\tbuffer[index] = null;\n\t\t}\n\t}\n\tif(maxId == -1) {\n\t\tmaxId = id;\n\t\tmax = data;\n\t} else if(maxId > id) {\n\t\tif(max.abandoned() && maxId == id + buffer.length) {\n\t\t\tmaxId = id;\n\t\t\tmax = data;\n\t\t} else {\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\tfinal long id=data.getID();\n\tfinal long start=data.getStart();\n\tfinal long stop=data.getStop();\n\tfinal int length=data.length();\n\tfinal boolean perfect=data.perfect();\n\t\n\tfinal long[] keys=this.array.keys;\n\tfinal int[] lens=this.array.lens;\n\tfinal int[] starts=this.array.starts;\n\tfinal int[] stops=this.array.stops;\n\tfinal int[] values=this.array.values;\n\tfinal long[] ids=this.array.ids;\n\t\n\tfinal int capacity=keys.length;\n\tfinal int mask=capacity-1;\n\t\n\tint cell=Tools.max(0, (int)(id&mask));\n\tlong key=keys[cell];\n\t\n\twhile(key!=id && key!=0){\n\t\tcell=(cell+1)&mask;\n\t\tkey=keys[cell];\n\t}\n\tif(key==0){\n\t\tids[cell]=id;\n\t\tkeys[cell]=id;\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\tfinal int id=data.id;\n\tfinal Object[] keys=this.keys;\n\tfinal int mask=this.mask;\n\tint cellNum=id&mask;\n\tObject k=keys[cellNum];\n\tif(k!=null){\n\t\tif(k instanceof Integer){\n\t\t\tint cellId=(Integer)k;\n\t\t\tif(cellId==id){\n\t\t\t\tMetricsBuffer.combineInto(data, this.values[cellNum]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcellNum=cellNum+1&mask;\n\t\t\tk=keys[cellNum];\n\t\t\tif(k!=null){\n\t\t\t\tif(k instanceof Integer){\n\t\t\t\t\tcellId=(Integer)k;\n\t\t\t\t\tif(cellId==id){\n\t\t\t\t\t\tMetricsBuffer.combineInto(data, this.values[cellNum]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n   if(data.id == null) return;\n   if(data.id.length > MAX_ID_LENGTH) return;\n   if(data.id.length == 0) return;\n   final byte[] id = data.id;\n   final byte[] value = data.value;\n   if(value == null) return;\n   if(value.length > MAX_VALUE_LENGTH) return;\n   if(value.length == 0) return;\n\n   if(id.length + value.length > MAX_VALUE_LENGTH) return;\n\n   final long timestamp = data.timestamp;\n   if(timestamp == 0) return;\n\n   final long now = System.currentTimeMillis();\n   if(now - timestamp > MAX_AGE) return;\n\n   //System.out.println(\"Received data: \" + data.id + \": \" + data.value + \" @ \" + data.timestamp);\n   //System.out.println(\"Received data: \" + data.id + \": \" + data.value + \" @ \" + timestamp);\n\n   final int hash = hash(id);\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\t\tif(data==null) return;\n\t\tif(data.get_id()==null) return;\n\t\tif(this.contains(data.get_id())){\n\t\t\tfinal METRICS olddata=this.get(data.get_id());\n\t\t\tfinal METRICS combined=data.combine(olddata);\n\t\t\tif(combined.isAbandoned()){\n\t\t\t\tthis.remove(data.get_id());\n\t\t\t}else{\n\t\t\t\tthis.put(data.get_id(), combined);\n\t\t\t}\n\t\t}else{\n\t\t\tthis.put(data.get_id(), data);\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\t\t\t\tif (data.id == null) return;\n\t\t\t\tfinal long now = System.currentTimeMillis();\n\t\t\t\tfinal long id = data.id;\n\t\t\t\tfinal long time = data.time;\n\t\t\t\tfinal long value = data.value;\n\t\t\t\tfinal int i = data.i;\n\t\t\t\tfinal long ts = data.ts;\n\t\t\t\tfinal long l = data.l;\n\t\t\t\tfinal int h = data.h;\n\t\t\t\tfinal int t = data.t;\n\t\t\t\tfinal int c = data.c;\n\t\t\t\tfinal int p = data.p;\n\t\t\t\tfinal int q = data.q;\n\t\t\t\tfinal int r = data.r;\n\t\t\t\tfinal int s = data.s;\n\t\t\t\tfinal int u = data.u;\n\t\t\t\tfinal int v = data.v;\n\t\t\t\tfinal int w = data.w;\n\t\t\t\tfinal int x = data.x;\n\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\t\tfinal long id = data.getID();\n\t\tfinal long[] val = this.buffer.get(id);\n\t\tif (val==null){\n\t\t\tfinal long[] newVal = data.getRecord();\n\t\t\tthis.buffer.put(id, newVal);\n\t\t}\n\t\telse{\n\t\t\tfinal long[] combined = data.combine(val);\n\t\t\tif (combined != null){\n\t\t\t\tthis.buffer.put(id, combined);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.buffer.remove(id);\n\t\t\t\tthis.numRemoved++;\n\t\t\t}\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\nif(data._id==_id){\nif(_size==0){\n_size=1;\n_data=data;\n}else{\nif(data._value>_data._value){\nif(data.isAbandoned()){\n_size=0;\n_data=null;\n}else{\n_data=data;\n}\n}else{\nif(data.isAbandoned()){\nif(_data.isAbandoned()){\n_size=0;\n_data=null;\n}\n}else{\n_data=data;\n}\n}\n}\n}else{\nif(_size==0){\n_size=1;\n_id=data._id;\n_data=data;\n}else{\nif(_id>data._id){\nif(data.isAbandoned()){\n_size=0;\n_data=null;\n}else{\n_id=data._id;\n_data=data;\n}\n}else{\nif(data.isAbandoned()){\nif(_data.isAbandoned()){\n_size=0;\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public void accept(final METRICS data){\n\n\tfinal int id = data.id;\n\tfinal int i = Arrays.binarySearch(ids, 0, size, id);\n\tif(i>=0){\n\t\tfinal METRICS old=array[i];\n\t\tfinal METRICS combined=old.reduce(data);\n\t\tif(combined!=null){array[i]=combined;}\n\t\telse{Tools.removeIndex(array, ids, i, size--);}\n\t}else{\n\t\tinsert(data, -i-1);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accept the data into the cache and merge with the existing value. This method is not thread safe, should avoid concurrency calling.\n * @param data to be added potentially.\n */\n", "method_name": "accept", "codes": ["@Override public void accept(final METRICS data){\n\n\n\t//put the data into the buffer\n\tfinal boolean isNew = buffer.compute(data.getId(), (id,value)->{\n\t\tif(value==null){\n\t\t\t//this is a new entry\n\t\t\tif(buffer.size() > maxSize){\n\t\t\t\t//this is a new entry, but the buffer is full, so we need to remove the oldest entry\n\t\t\t\tbuffer.remove(oldest.remove(0));\n\t\t\t}\n\t\t\t//this is a new entry, and the buffer is not full, so we add it\n\t\t\toldest.add(data.getId());\n\t\t\treturn data;\n\t\t}else{\n\t\t\t//this is an existing entry, so we try to combine it\n\t\t\tfinal METRICS combined = combineValues(data, value);\n\t\t\tif(combined.isAbandoned()){\n\t\t\t\t//the combined value is abandoned, so we remove it\n\t\t\t\toldest.remove(id);\n\t\t\t\treturn null;\n\t\t\t}else{\n\t", "@Override public void accept(final METRICS data){\n\n\tfinal int id = data.id;\n\tif(id > maxId) {\n\t\tthrow new IllegalArgumentException(\"id cannot be greater than the maximum id\");\n\t}\n\tif(id == maxId) {\n\t\tmaxId = -1;\n\t\tmax = null;\n\t}\n\tfinal int index = id % buffer.length;\n\tfinal METRICS[] buffer = this.buffer;\n\tfinal METRICS prev = buffer[index];\n\tif(prev == null) {\n\t\tbuffer[index] = data;\n\t} else {\n\t\tcombine(prev, data);\n\t\tif(prev.abandoned()) {\n\t\t\tbuffer[index] = null;\n\t\t}\n\t}\n\tif(maxId == -1) {\n\t\tmaxId = id;\n\t\tmax = data;\n\t} else if(maxId > id) {\n\t\tif(max.abandoned() && maxId == id + buffer.length) {\n\t\t\tmaxId = id;\n\t\t\tmax = data;\n\t\t} else {\n", "@Override public void accept(final METRICS data){\n\n\tfinal long id=data.getID();\n\tfinal long start=data.getStart();\n\tfinal long stop=data.getStop();\n\tfinal int length=data.length();\n\tfinal boolean perfect=data.perfect();\n\t\n\tfinal long[] keys=this.array.keys;\n\tfinal int[] lens=this.array.lens;\n\tfinal int[] starts=this.array.starts;\n\tfinal int[] stops=this.array.stops;\n\tfinal int[] values=this.array.values;\n\tfinal long[] ids=this.array.ids;\n\t\n\tfinal int capacity=keys.length;\n\tfinal int mask=capacity-1;\n\t\n\tint cell=Tools.max(0, (int)(id&mask));\n\tlong key=keys[cell];\n\t\n\twhile(key!=id && key!=0){\n\t\tcell=(cell+1)&mask;\n\t\tkey=keys[cell];\n\t}\n\tif(key==0){\n\t\tids[cell]=id;\n\t\tkeys[cell]=id;\n\t", "@Override public void accept(final METRICS data){\n\n\tfinal int id=data.id;\n\tfinal Object[] keys=this.keys;\n\tfinal int mask=this.mask;\n\tint cellNum=id&mask;\n\tObject k=keys[cellNum];\n\tif(k!=null){\n\t\tif(k instanceof Integer){\n\t\t\tint cellId=(Integer)k;\n\t\t\tif(cellId==id){\n\t\t\t\tMetricsBuffer.combineInto(data, this.values[cellNum]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcellNum=cellNum+1&mask;\n\t\t\tk=keys[cellNum];\n\t\t\tif(k!=null){\n\t\t\t\tif(k instanceof Integer){\n\t\t\t\t\tcellId=(Integer)k;\n\t\t\t\t\tif(cellId==id){\n\t\t\t\t\t\tMetricsBuffer.combineInto(data, this.values[cellNum]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t", "@Override public void accept(final METRICS data){\n\n   if(data.id == null) return;\n   if(data.id.length > MAX_ID_LENGTH) return;\n   if(data.id.length == 0) return;\n   final byte[] id = data.id;\n   final byte[] value = data.value;\n   if(value == null) return;\n   if(value.length > MAX_VALUE_LENGTH) return;\n   if(value.length == 0) return;\n\n   if(id.length + value.length > MAX_VALUE_LENGTH) return;\n\n   final long timestamp = data.timestamp;\n   if(timestamp == 0) return;\n\n   final long now = System.currentTimeMillis();\n   if(now - timestamp > MAX_AGE) return;\n\n   //System.out.println(\"Received data: \" + data.id + \": \" + data.value + \" @ \" + data.timestamp);\n   //System.out.println(\"Received data: \" + data.id + \": \" + data.value + \" @ \" + timestamp);\n\n   final int hash = hash(id);\n", "@Override public void accept(final METRICS data){\n\n\t\tif(data==null) return;\n\t\tif(data.get_id()==null) return;\n\t\tif(this.contains(data.get_id())){\n\t\t\tfinal METRICS olddata=this.get(data.get_id());\n\t\t\tfinal METRICS combined=data.combine(olddata);\n\t\t\tif(combined.isAbandoned()){\n\t\t\t\tthis.remove(data.get_id());\n\t\t\t}else{\n\t\t\t\tthis.put(data.get_id(), combined);\n\t\t\t}\n\t\t}else{\n\t\t\tthis.put(data.get_id(), data);\n\t\t}\n\t}", "@Override public void accept(final METRICS data){\n\n\t\t\t\tif (data.id == null) return;\n\t\t\t\tfinal long now = System.currentTimeMillis();\n\t\t\t\tfinal long id = data.id;\n\t\t\t\tfinal long time = data.time;\n\t\t\t\tfinal long value = data.value;\n\t\t\t\tfinal int i = data.i;\n\t\t\t\tfinal long ts = data.ts;\n\t\t\t\tfinal long l = data.l;\n\t\t\t\tfinal int h = data.h;\n\t\t\t\tfinal int t = data.t;\n\t\t\t\tfinal int c = data.c;\n\t\t\t\tfinal int p = data.p;\n\t\t\t\tfinal int q = data.q;\n\t\t\t\tfinal int r = data.r;\n\t\t\t\tfinal int s = data.s;\n\t\t\t\tfinal int u = data.u;\n\t\t\t\tfinal int v = data.v;\n\t\t\t\tfinal int w = data.w;\n\t\t\t\tfinal int x = data.x;\n\t\t\t", "@Override public void accept(final METRICS data){\n\n\t\tfinal long id = data.getID();\n\t\tfinal long[] val = this.buffer.get(id);\n\t\tif (val==null){\n\t\t\tfinal long[] newVal = data.getRecord();\n\t\t\tthis.buffer.put(id, newVal);\n\t\t}\n\t\telse{\n\t\t\tfinal long[] combined = data.combine(val);\n\t\t\tif (combined != null){\n\t\t\t\tthis.buffer.put(id, combined);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.buffer.remove(id);\n\t\t\t\tthis.numRemoved++;\n\t\t\t}\n\t\t}\n\t}", "@Override public void accept(final METRICS data){\n\nif(data._id==_id){\nif(_size==0){\n_size=1;\n_data=data;\n}else{\nif(data._value>_data._value){\nif(data.isAbandoned()){\n_size=0;\n_data=null;\n}else{\n_data=data;\n}\n}else{\nif(data.isAbandoned()){\nif(_data.isAbandoned()){\n_size=0;\n_data=null;\n}\n}else{\n_data=data;\n}\n}\n}\n}else{\nif(_size==0){\n_size=1;\n_id=data._id;\n_data=data;\n}else{\nif(_id>data._id){\nif(data.isAbandoned()){\n_size=0;\n_data=null;\n}else{\n_id=data._id;\n_data=data;\n}\n}else{\nif(data.isAbandoned()){\nif(_data.isAbandoned()){\n_size=0;\n", "@Override public void accept(final METRICS data){\n\n\tfinal int id = data.id;\n\tfinal int i = Arrays.binarySearch(ids, 0, size, id);\n\tif(i>=0){\n\t\tfinal METRICS old=array[i];\n\t\tfinal METRICS combined=old.reduce(data);\n\t\tif(combined!=null){array[i]=combined;}\n\t\telse{Tools.removeIndex(array, ids, i, size--);}\n\t}else{\n\t\tinsert(data, -i-1);\n\t}\n}"], "code_level": "self_contained", "_id": "636767e11a6d9265ec018781", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tTimeRange timeRange = null;\n\tlong interval = 0;\n\tlong startTime = start;\n\tlong endTime = end;\n\twhile(startTime < endTime){\n\t\tinterval = endTime - startTime;\n\t\tif(interval > FETCH_DATA_DURATION){\n\t\t\ttimeRange = new TimeRange(startTime, startTime + FETCH_DATA_DURATION);\n\t\t\ttimeRanges.add(timeRange);\n\t\t\tstartTime += FETCH_DATA_DURATION;\n\t\t}else{\n\t\t\ttimeRange = new TimeRange(startTime, startTime + interval);\n\t\t\ttimeRanges.add(timeRange);\n\t\t\tstartTime += interval;\n\t\t}\n\t}\n\treturn timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tlong _start = start;\n\tlong _end = end;\n\twhile(_start < _end){\n\t\tlong _end_tmp = Math.min(start+FETCH_DATA_DURATION, end);\n\t\tranges.add(new TimeRange(_start,_end_tmp));\n\t\t_start = _end_tmp;\n\t}\n\treturn ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n    List<TimeRange> list=new ArrayList<TimeRange>();\n    if(end-start<=FETCH_DATA_DURATION){\n        list.add(new TimeRange(start,end));\n    }else{\n        long tempStart=start;\n        long tempEnd=start+FETCH_DATA_DURATION;\n        while(tempEnd<end){\n            list.add(new TimeRange(tempStart,tempEnd));\n            tempStart=tempEnd;\n            tempEnd=tempStart+FETCH_DATA_DURATION;\n        }\n        list.add(new TimeRange(tempStart,end));\n    }\n    return list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> list=new ArrayList<TimeRange>();\n\twhile(start<end){\n\t\tlist.add(new TimeRange(start, start+FETCH_DATA_DURATION));\n\t\tstart=start+FETCH_DATA_DURATION;\n\t}\n\treturn list;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n        List<TimeRange> ranges=new ArrayList<>();\n        long duration=end-start;\n        long startTime=start;\n        long endTime=startTime+FETCH_DATA_DURATION;\n        while(endTime<=start+duration){\n            ranges.add(TimeRange.between(startTime,endTime));\n            startTime=endTime;\n            endTime+=FETCH_DATA_DURATION;\n        }\n        if(startTime<start+duration){\n            ranges.add(TimeRange.between(startTime,start+duration));\n        }\n        return ranges;\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges=new ArrayList<TimeRange>();\n\tlong time=start;\n\twhile(time<end){\n\t\tlong endTime=Math.min(time+FETCH_DATA_DURATION,end);\n\t\tranges.add(new TimeRange(time,endTime));\n\t\ttime=endTime;\n\t}\n\treturn ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tlong duration = end-start;\n\tlong left = start;\n\tlong right = start;\n\twhile(right<end){\n\t\tright = left+FETCH_DATA_DURATION;\n\t\tranges.add(new TimeRange(left,right>end?end:right));\n\t\tleft = right;\n\t}\n\treturn ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(end - start <= FETCH_DATA_DURATION){\n\t\ttimeRanges.add(new TimeRange(start,end));\n\t}else{\n\t\ttimeRanges.add(new TimeRange(start,start+FETCH_DATA_DURATION));\n\t\ttimeRanges.addAll(buildTimeRanges(start+FETCH_DATA_DURATION+1,end));\n\t}\n\treturn timeRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tif(end-start<=FETCH_DATA_DURATION){\n\t\tranges.add(new TimeRange(start,end));\n\t}else{\n\t\tranges.add(new TimeRange(start,start+FETCH_DATA_DURATION));\n\t\tranges.add(new TimeRange(start+FETCH_DATA_DURATION+1,end));\n\t}\n\treturn ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n    List<TimeRange> ranges = new ArrayList<TimeRange>();\n    while(start<end){\n        TimeRange range = new TimeRange(start,start+FETCH_DATA_DURATION);\n        ranges.add(range);\n        start+=FETCH_DATA_DURATION;\n    }\n    return ranges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Split time ranges to insure the start time and end time is small then  {@link #FETCH_DATA_DURATION}\n */\n", "method_name": "buildTimeRanges", "codes": ["protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tTimeRange timeRange = null;\n\tlong interval = 0;\n\tlong startTime = start;\n\tlong endTime = end;\n\twhile(startTime < endTime){\n\t\tinterval = endTime - startTime;\n\t\tif(interval > FETCH_DATA_DURATION){\n\t\t\ttimeRange = new TimeRange(startTime, startTime + FETCH_DATA_DURATION);\n\t\t\ttimeRanges.add(timeRange);\n\t\t\tstartTime += FETCH_DATA_DURATION;\n\t\t}else{\n\t\t\ttimeRange = new TimeRange(startTime, startTime + interval);\n\t\t\ttimeRanges.add(timeRange);\n\t\t\tstartTime += interval;\n\t\t}\n\t}\n\treturn timeRanges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tlong _start = start;\n\tlong _end = end;\n\twhile(_start < _end){\n\t\tlong _end_tmp = Math.min(start+FETCH_DATA_DURATION, end);\n\t\tranges.add(new TimeRange(_start,_end_tmp));\n\t\t_start = _end_tmp;\n\t}\n\treturn ranges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n    List<TimeRange> list=new ArrayList<TimeRange>();\n    if(end-start<=FETCH_DATA_DURATION){\n        list.add(new TimeRange(start,end));\n    }else{\n        long tempStart=start;\n        long tempEnd=start+FETCH_DATA_DURATION;\n        while(tempEnd<end){\n            list.add(new TimeRange(tempStart,tempEnd));\n            tempStart=tempEnd;\n            tempEnd=tempStart+FETCH_DATA_DURATION;\n        }\n        list.add(new TimeRange(tempStart,end));\n    }\n    return list;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> list=new ArrayList<TimeRange>();\n\twhile(start<end){\n\t\tlist.add(new TimeRange(start, start+FETCH_DATA_DURATION));\n\t\tstart=start+FETCH_DATA_DURATION;\n\t}\n\treturn list;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n        List<TimeRange> ranges=new ArrayList<>();\n        long duration=end-start;\n        long startTime=start;\n        long endTime=startTime+FETCH_DATA_DURATION;\n        while(endTime<=start+duration){\n            ranges.add(TimeRange.between(startTime,endTime));\n            startTime=endTime;\n            endTime+=FETCH_DATA_DURATION;\n        }\n        if(startTime<start+duration){\n            ranges.add(TimeRange.between(startTime,start+duration));\n        }\n        return ranges;\n    }", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges=new ArrayList<TimeRange>();\n\tlong time=start;\n\twhile(time<end){\n\t\tlong endTime=Math.min(time+FETCH_DATA_DURATION,end);\n\t\tranges.add(new TimeRange(time,endTime));\n\t\ttime=endTime;\n\t}\n\treturn ranges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tlong duration = end-start;\n\tlong left = start;\n\tlong right = start;\n\twhile(right<end){\n\t\tright = left+FETCH_DATA_DURATION;\n\t\tranges.add(new TimeRange(left,right>end?end:right));\n\t\tleft = right;\n\t}\n\treturn ranges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> timeRanges = new ArrayList<TimeRange>();\n\tif(end - start <= FETCH_DATA_DURATION){\n\t\ttimeRanges.add(new TimeRange(start,end));\n\t}else{\n\t\ttimeRanges.add(new TimeRange(start,start+FETCH_DATA_DURATION));\n\t\ttimeRanges.addAll(buildTimeRanges(start+FETCH_DATA_DURATION+1,end));\n\t}\n\treturn timeRanges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n\tList<TimeRange> ranges = new ArrayList<TimeRange>();\n\tif(end-start<=FETCH_DATA_DURATION){\n\t\tranges.add(new TimeRange(start,end));\n\t}else{\n\t\tranges.add(new TimeRange(start,start+FETCH_DATA_DURATION));\n\t\tranges.add(new TimeRange(start+FETCH_DATA_DURATION+1,end));\n\t}\n\treturn ranges;\n}", "protected List<TimeRange> buildTimeRanges(long start,long end){\n\n    List<TimeRange> ranges = new ArrayList<TimeRange>();\n    while(start<end){\n        TimeRange range = new TimeRange(start,start+FETCH_DATA_DURATION);\n        ranges.add(range);\n        start+=FETCH_DATA_DURATION;\n    }\n    return ranges;\n}"], "code_level": "self_contained", "_id": "636767df1a6d9265ec018744", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tLong originalValue=get(key);\n\tif(originalValue==null){\n\t\toriginalValue=0l;\n\t}\n\tput(key, originalValue+value);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n    this.data.put(key,this.data.get(key)+value);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(value==null){\n\t\treturn;\n\t}\n\tLong oldValue=getLong(key);\n\tif(oldValue==null){\n\t\toldValue=0L;\n\t}\n\tput(key, oldValue+value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(!map.containsKey(key)){\n\t\tmap.put(key, value);\n\t}else{\n\t\tLong value2 = map.get(key);\n\t\tvalue2 = value2 + value;\n\t\tmap.put(key, value2);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(this.isContainsKey(key)){\n\t\tthis.put(key, this.get(key)+value);\n\t}else{\n\t\tthis.put(key, value);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(key.contains(\"-\")){\n\t\tif(key.contains(\"/\")){\n\t\t\tkey=key.substring(key.indexOf(\"/\")+1,key.length());\n\t\t\tkey=key.substring(key.indexOf(\"/\")+1,key.length());\n\t\t}\n\t\telse{\n\t\t\tkey=key.substring(key.indexOf(\"-\")+1,key.length());\n\t\t}\n\t}\n\tif(this.get(key)!=null){\n\t\tthis.put(key, this.get(key)+value);\n\t}\n\telse{\n\t\tthis.put(key,value);\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n    if(valueAccumulation.containsKey(key)){\n        valueAccumulation.put(key, valueAccumulation.get(key)+value);\n    }else{\n        valueAccumulation.put(key,value);\n        }\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(key==null || key.trim().length()==0){\n\t\treturn;\n\t}\n\t\n\tif(value==null){\n\t\tvalue=new Long(0);\n\t}\n\tif(this.map.containsKey(key)){\n\t\tthis.map.put(key, new Long(this.map.get(key).longValue()+value.longValue()));\n\t}else{\n\t\tthis.map.put(key, value);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tthis.put(key, this.get(key)+value);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void valueAccumulation(String key,Long value){\n\n\tif(value==null) return;\n\tif(value<0){\n\t\tvalueSubtraction(key, -value);\n\t\treturn;\n\t}\n\tLong preValue=getLong(key);\n\tif(preValue==null) preValue=0l;\n\tset(key, preValue+value);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Accumulate the value with existing value in the same given key.\n */\n", "method_name": "valueAccumulation", "codes": ["public void valueAccumulation(String key,Long value){\n\n\tLong originalValue=get(key);\n\tif(originalValue==null){\n\t\toriginalValue=0l;\n\t}\n\tput(key, originalValue+value);\n}", "public void valueAccumulation(String key,Long value){\n\n    this.data.put(key,this.data.get(key)+value);\n}", "public void valueAccumulation(String key,Long value){\n\n\tif(value==null){\n\t\treturn;\n\t}\n\tLong oldValue=getLong(key);\n\tif(oldValue==null){\n\t\toldValue=0L;\n\t}\n\tput(key, oldValue+value);\n}", "public void valueAccumulation(String key,Long value){\n\n\tif(!map.containsKey(key)){\n\t\tmap.put(key, value);\n\t}else{\n\t\tLong value2 = map.get(key);\n\t\tvalue2 = value2 + value;\n\t\tmap.put(key, value2);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\n\tif(this.isContainsKey(key)){\n\t\tthis.put(key, this.get(key)+value);\n\t}else{\n\t\tthis.put(key, value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\n\tif(key.contains(\"-\")){\n\t\tif(key.contains(\"/\")){\n\t\t\tkey=key.substring(key.indexOf(\"/\")+1,key.length());\n\t\t\tkey=key.substring(key.indexOf(\"/\")+1,key.length());\n\t\t}\n\t\telse{\n\t\t\tkey=key.substring(key.indexOf(\"-\")+1,key.length());\n\t\t}\n\t}\n\tif(this.get(key)!=null){\n\t\tthis.put(key, this.get(key)+value);\n\t}\n\telse{\n\t\tthis.put(key,value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\n    if(valueAccumulation.containsKey(key)){\n        valueAccumulation.put(key, valueAccumulation.get(key)+value);\n    }else{\n        valueAccumulation.put(key,value);\n        }\n    }", "public void valueAccumulation(String key,Long value){\n\n\tif(key==null || key.trim().length()==0){\n\t\treturn;\n\t}\n\t\n\tif(value==null){\n\t\tvalue=new Long(0);\n\t}\n\tif(this.map.containsKey(key)){\n\t\tthis.map.put(key, new Long(this.map.get(key).longValue()+value.longValue()));\n\t}else{\n\t\tthis.map.put(key, value);\n\t}\n}", "public void valueAccumulation(String key,Long value){\n\n\tthis.put(key, this.get(key)+value);\n}", "public void valueAccumulation(String key,Long value){\n\n\tif(value==null) return;\n\tif(value<0){\n\t\tvalueSubtraction(key, -value);\n\t\treturn;\n\t}\n\tLong preValue=getLong(key);\n\tif(preValue==null) preValue=0l;\n\tset(key, preValue+value);\n}"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec01871c", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tlong lastUpdateTimestamp=getLastUpdateTimestamp();\n\treturn timestamp-lastUpdateTimestamp>expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tif((timestamp-lastUpdateTimestamp)>expiredThreshold)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return (timestamp - lastUpdateTimestamp) > expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tlong lastUpdateTimestamp = getLastUpdateTimestamp();\n\tif(timestamp-lastUpdateTimestamp>expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-lastUpdateTimestamp>=expiredThreshold;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\nreturn Math.abs(timestamp-lastUpdateTimestamp)>expiredThreshold;}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-this.lastUpdateTimestamp>expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-this.lastUpdateTimestamp>expiredThreshold;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * @param timestamp        of current time\n * @param expiredThreshold represents the duration between last update time and the time point removing from cache.\n * @return true means this metrics should be removed from cache.\n */\n", "method_name": "isExpired", "codes": ["public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tlong lastUpdateTimestamp=getLastUpdateTimestamp();\n\treturn timestamp-lastUpdateTimestamp>expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tif((timestamp-lastUpdateTimestamp)>expiredThreshold)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return (timestamp - lastUpdateTimestamp) > expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\tlong lastUpdateTimestamp = getLastUpdateTimestamp();\n\tif(timestamp-lastUpdateTimestamp>expiredThreshold){\n\t\treturn true;\n\t}\n\treturn false;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-lastUpdateTimestamp>=expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n    return timestamp - lastUpdateTimestamp > expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\nreturn Math.abs(timestamp-lastUpdateTimestamp)>expiredThreshold;}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-this.lastUpdateTimestamp>expiredThreshold;\n}", "public boolean isExpired(long timestamp,long expiredThreshold){\n\n\treturn timestamp-this.lastUpdateTimestamp>expiredThreshold;\n}"], "code_level": "class_runnable", "_id": "636767dd1a6d9265ec0186de", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tcontent.put(\"content\",jsonObject.get(\"content\"));\n\treturn content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n    Map<String,Object> content = new HashMap<>();\n    jsonObject.getAsJsonObject(\"content\").entrySet().forEach(entry -> {\n        if(entry.getValue().isJsonObject()){\n            content.put(entry.getKey(),buildContent(entry.getValue().getAsJsonObject()));\n        }else if(entry.getValue().isJsonArray()){\n            content.put(entry.getKey(),buildContent(entry.getValue().getAsJsonArray()));\n        }else{\n            content.put(entry.getKey(),entry.getValue().getAsString());\n        }\n    });\n    return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String, Object>();\n\tcontent.put(\"content\", jsonObject.get(\"content\"));\n\treturn content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content=new HashMap<String,Object>();\n\tif(jsonObject.has(\"content\")){\n\t\tcontent.put(\"content\",jsonObject.get(\"content\").getAsString());\n\t}\n\treturn content;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n    Map<String,Object> content = new HashMap<>();\n    if (jsonObject.has(\"content\")){\n        content = gson.fromJson(jsonObject.get(\"content\"),Map.class);\n    }\n    return content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\nMap<String,Object> resultMap = new HashMap<String,Object>();\nif(jsonObject.has(\"content\")){\nJsonObject contentObject = jsonObject.get(\"content\").getAsJsonObject();\nMap<String,Object> tempMap = new HashMap<String,Object>();\nfor (Map.Entry<String, JsonElement> entry : contentObject.entrySet()) {\ntempMap.put(entry.getKey(),entry.getValue());\n}\nresultMap.put(\"content\",tempMap);\n}\nreturn resultMap;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor (Entry<String,JsonElement> entry : jsonObject.entrySet()) {\n\t\tif(entry.getValue() instanceof JsonNull) {\n\t\t\tcontent.put(entry.getKey(), null);\n\t\t}else if(entry.getValue() instanceof JsonPrimitive) {\n\t\t\tcontent.put(entry.getKey(), entry.getValue().getAsString());\n\t\t}else if(entry.getValue() instanceof JsonObject) {\n\t\t\tcontent.put(entry.getKey(), buildContent((JsonObject)entry.getValue()));\n\t\t}else if(entry.getValue() instanceof JsonArray) {\n\t\t\tcontent.put(entry.getKey(), buildContents((JsonArray)entry.getValue()));\n\t\t}\n\t}\n\treturn content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor(Entry<String, JsonElement> entry : jsonObject.entrySet()){\n\t\tcontent.put(entry.getKey(),entry.getValue());\n\t}\n\treturn content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor(Entry<String, JsonElement> entry : jsonObject.entrySet()){\n\t\tString key = entry.getKey();\n\t\tString value = entry.getValue().getAsString();\n\t\tcontent.put(key, value);\n\t}\n\treturn content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tif(jsonObject.has(\"content\")){\n\t\tJsonObject contentObject = jsonObject.get(\"content\").getAsJsonObject();\n\t\tSet<Entry<String,JsonElement>> set = contentObject.entrySet();\n\t\tfor(Entry<String,JsonElement> entry : set){\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif(value instanceof JsonPrimitive){\n\t\t\t\tcontent.put(key, ((JsonPrimitive)value).getAsString());\n\t\t\t}else if(value instanceof JsonArray){\n\t\t\t\tcontent.put(key, buildJsonArray((JsonArray)value));\n\t\t\t}\n\t\t}\n\t}\n\treturn content;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * build content,if it has ats someone set the ats\n */\n", "method_name": "buildContent", "codes": ["private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tcontent.put(\"content\",jsonObject.get(\"content\"));\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n    Map<String,Object> content = new HashMap<>();\n    jsonObject.getAsJsonObject(\"content\").entrySet().forEach(entry -> {\n        if(entry.getValue().isJsonObject()){\n            content.put(entry.getKey(),buildContent(entry.getValue().getAsJsonObject()));\n        }else if(entry.getValue().isJsonArray()){\n            content.put(entry.getKey(),buildContent(entry.getValue().getAsJsonArray()));\n        }else{\n            content.put(entry.getKey(),entry.getValue().getAsString());\n        }\n    });\n    return content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String, Object>();\n\tcontent.put(\"content\", jsonObject.get(\"content\"));\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content=new HashMap<String,Object>();\n\tif(jsonObject.has(\"content\")){\n\t\tcontent.put(\"content\",jsonObject.get(\"content\").getAsString());\n\t}\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n    Map<String,Object> content = new HashMap<>();\n    if (jsonObject.has(\"content\")){\n        content = gson.fromJson(jsonObject.get(\"content\"),Map.class);\n    }\n    return content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\nMap<String,Object> resultMap = new HashMap<String,Object>();\nif(jsonObject.has(\"content\")){\nJsonObject contentObject = jsonObject.get(\"content\").getAsJsonObject();\nMap<String,Object> tempMap = new HashMap<String,Object>();\nfor (Map.Entry<String, JsonElement> entry : contentObject.entrySet()) {\ntempMap.put(entry.getKey(),entry.getValue());\n}\nresultMap.put(\"content\",tempMap);\n}\nreturn resultMap;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor (Entry<String,JsonElement> entry : jsonObject.entrySet()) {\n\t\tif(entry.getValue() instanceof JsonNull) {\n\t\t\tcontent.put(entry.getKey(), null);\n\t\t}else if(entry.getValue() instanceof JsonPrimitive) {\n\t\t\tcontent.put(entry.getKey(), entry.getValue().getAsString());\n\t\t}else if(entry.getValue() instanceof JsonObject) {\n\t\t\tcontent.put(entry.getKey(), buildContent((JsonObject)entry.getValue()));\n\t\t}else if(entry.getValue() instanceof JsonArray) {\n\t\t\tcontent.put(entry.getKey(), buildContents((JsonArray)entry.getValue()));\n\t\t}\n\t}\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor(Entry<String, JsonElement> entry : jsonObject.entrySet()){\n\t\tcontent.put(entry.getKey(),entry.getValue());\n\t}\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tfor(Entry<String, JsonElement> entry : jsonObject.entrySet()){\n\t\tString key = entry.getKey();\n\t\tString value = entry.getValue().getAsString();\n\t\tcontent.put(key, value);\n\t}\n\treturn content;\n}", "private Map<String,Object> buildContent(JsonObject jsonObject){\n\n\tMap<String,Object> content = new HashMap<String,Object>();\n\tif(jsonObject.has(\"content\")){\n\t\tJsonObject contentObject = jsonObject.get(\"content\").getAsJsonObject();\n\t\tSet<Entry<String,JsonElement>> set = contentObject.entrySet();\n\t\tfor(Entry<String,JsonElement> entry : set){\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif(value instanceof JsonPrimitive){\n\t\t\t\tcontent.put(key, ((JsonPrimitive)value).getAsString());\n\t\t\t}else if(value instanceof JsonArray){\n\t\t\t\tcontent.put(key, buildJsonArray((JsonArray)value));\n\t\t\t}\n\t\t}\n\t}\n\treturn content;\n}"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018755", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null) {\n\t\tthrow new IllegalStateException(\"The model name must not be null.\");\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null)\n        throw new IllegalStateException(\"The key has not been set\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name is not be null\");\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n        if (modelName == null) {\n            throw new IllegalStateException(\"modelName cannot be null\");\n        }\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null) {\n\t\tthrow new IllegalStateException(\"Model name cannot be null.\");\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n\tif(modelName==null) {\n\t\tthrow new IllegalStateException(\"The key is null\");\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n\t\tif (modelName == null) {\n\t\t\tthrow new IllegalStateException(\"Key must not be null.\");\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name cannot be null\");\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null)throw new IllegalStateException (\"null key\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void check(String modelName) throws IllegalStateException {\n\n        if (modelName == null) {\n            throw new IllegalStateException(\n                    \"Model name must not be null.\");\n        }\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @param modelName model name of the entity\n * @throws IllegalStateException if sharding key indices are not continuous\n */\n", "method_name": "check", "codes": ["private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null) {\n\t\tthrow new IllegalStateException(\"The model name must not be null.\");\n\t}\n}", "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null)\n        throw new IllegalStateException(\"The key has not been set\");\n}", "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name is not be null\");\n    }\n}", "private void check(String modelName) throws IllegalStateException {\n\n        if (modelName == null) {\n            throw new IllegalStateException(\"modelName cannot be null\");\n        }\n    }", "private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null) {\n\t\tthrow new IllegalStateException(\"Model name cannot be null.\");\n\t}\n}", "private void check(String modelName) throws IllegalStateException {\n\n\tif(modelName==null) {\n\t\tthrow new IllegalStateException(\"The key is null\");\n\t}\n}", "private void check(String modelName) throws IllegalStateException {\n\n\t\tif (modelName == null) {\n\t\t\tthrow new IllegalStateException(\"Key must not be null.\");\n\t\t}\n\t}", "private void check(String modelName) throws IllegalStateException {\n\n    if (modelName == null) {\n        throw new IllegalStateException(\"Model name cannot be null\");\n    }\n}", "private void check(String modelName) throws IllegalStateException {\n\n\tif (modelName == null)throw new IllegalStateException (\"null key\");\n}", "private void check(String modelName) throws IllegalStateException {\n\n        if (modelName == null) {\n            throw new IllegalStateException(\n                    \"Model name must not be null.\");\n        }\n    }"], "code_level": "self_contained", "_id": "636767de1a6d9265ec01871e", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<this.size();i++){\n\t\tif(this.get(i).compareTo(oldName)==0){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tint index=this.getColumnIndex(oldName);\n\tif(index<0) return;\n\tfor(int i=0;i<this.rows();i++){\n\t\tif(this.getElement(i,index).equals(oldName)){\n\t\t\tthis.setElement(i,index,newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<this.size();i++){\n\t\tif(this.get(i).equals(oldName))\n\t\t\tthis.set(i, newName);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i = 0; i < this.size(); i++){\n\t\tif(this.get(i).equals(oldName)){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n    for(int i=0;i&lt;column.size();i++){\n        if(column.get(i).equals(oldName))\n            column.set(i, newName);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<size;i++){\n\t\tif(this.get(i).equals(oldName)){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tIterator itr=null;\n\tif (type.equals(DataType.STRING))\n\t\titr=stringList.iterator();\n\telse if (type.equals(DataType.INT))\n\t\titr=intList.iterator();\n\telse if (type.equals(DataType.FLOAT))\n\t\titr=floatList.iterator();\n\telse if (type.equals(DataType.DATE))\n\t\titr=dateList.iterator();\n\t\n\tObject o=null;\n\twhile(itr.hasNext()){\n\t\to=itr.next();\n\t\tif (o.toString().equals(oldName)){\n\t\t\titr.remove();\n\t\t\tif (type.equals(DataType.STRING))\n\t\t\t\tstringList.add(newName);\n\t\t\telse if (type.equals(DataType.INT))\n\t\t\t\tintList.add(Integer.parseInt(newName));\n\t\t\telse if (type.equals(DataType.FLOAT))\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<data.size();i++){\n\t\tif(data.get(i).getName().equals(oldName)){\n\t\t\tdata.get(i).setName(newName);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tint col=this.getColumnIndex(oldName);\n\tfor(int i=0;i<this.getRowCount();i++){\n\t\tthis.setValueAt(newName, i, col);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<numRows;i++){\n\t\tif(column[i].equals(oldName)){\n\t\t\tcolumn[i]=newName;\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Keep the same name replacement as  {@link ColumnName#overrideName(String,String)}\n * @param oldName to be replaced.\n * @param newName to use in the storage level.\n */\n", "method_name": "overrideName", "codes": ["public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<this.size();i++){\n\t\tif(this.get(i).compareTo(oldName)==0){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tint index=this.getColumnIndex(oldName);\n\tif(index<0) return;\n\tfor(int i=0;i<this.rows();i++){\n\t\tif(this.getElement(i,index).equals(oldName)){\n\t\t\tthis.setElement(i,index,newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<this.size();i++){\n\t\tif(this.get(i).equals(oldName))\n\t\t\tthis.set(i, newName);\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tfor(int i = 0; i < this.size(); i++){\n\t\tif(this.get(i).equals(oldName)){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n    for(int i=0;i&lt;column.size();i++){\n        if(column.get(i).equals(oldName))\n            column.set(i, newName);\n    }\n}", "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<size;i++){\n\t\tif(this.get(i).equals(oldName)){\n\t\t\tthis.set(i, newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tIterator itr=null;\n\tif (type.equals(DataType.STRING))\n\t\titr=stringList.iterator();\n\telse if (type.equals(DataType.INT))\n\t\titr=intList.iterator();\n\telse if (type.equals(DataType.FLOAT))\n\t\titr=floatList.iterator();\n\telse if (type.equals(DataType.DATE))\n\t\titr=dateList.iterator();\n\t\n\tObject o=null;\n\twhile(itr.hasNext()){\n\t\to=itr.next();\n\t\tif (o.toString().equals(oldName)){\n\t\t\titr.remove();\n\t\t\tif (type.equals(DataType.STRING))\n\t\t\t\tstringList.add(newName);\n\t\t\telse if (type.equals(DataType.INT))\n\t\t\t\tintList.add(Integer.parseInt(newName));\n\t\t\telse if (type.equals(DataType.FLOAT))\n", "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<data.size();i++){\n\t\tif(data.get(i).getName().equals(oldName)){\n\t\t\tdata.get(i).setName(newName);\n\t\t}\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tint col=this.getColumnIndex(oldName);\n\tfor(int i=0;i<this.getRowCount();i++){\n\t\tthis.setValueAt(newName, i, col);\n\t}\n}", "public void overrideName(String oldName,String newName){\n\n\tfor(int i=0;i<numRows;i++){\n\t\tif(column[i].equals(oldName)){\n\t\t\tcolumn[i]=newName;\n\t\t}\n\t}\n}"], "code_level": "self_contained", "_id": "636767dd1a6d9265ec0186f3", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\treturn isCompatible(dataset, null);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\t\tif(this.numBuckets==dataset.numBuckets){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tif ((dataset.getRowCount()!=this.getRowCount())||(dataset.getColumnCount()!=this.getColumnCount())){\n\t\treturn false;\n\t}else{\n\t\tfor(int i=0;i<this.getRowCount();i++){\n\t\t\tfor(int j=0;j<this.getColumnCount();j++){\n\t\t\t\tif (this.getBucket(i,j)!=dataset.getBucket(i,j)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset==null) return false;\n\tif(dataset.getNumOfAttributes()!=this.getNumOfAttributes()) return false;\n\tif(dataset.getNumOfBuckets()!=this.getNumOfBuckets()) return false;\n\t\n\tfor(int i=0; i<dataset.getNumOfBuckets(); i++){\n\t\tif(!dataset.getBucket(i).isCompatible(this.getBucket(i))){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tBucketList bList=dataset.getBucketList();\n\tif(bList==null || bList.size()==0)\n\t\treturn false;\n\telse{\n\t\tfor(int i=0; i<bList.size(); i++){\n\t\t\tBucket b=bList.get(i);\n\t\t\tif(!b.isCompatible(m_buckets.get(i)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tint[] index=new int[buckets.length];\n\tfor(int i=0;i<buckets.length;i++){\n\t\tindex[i]=dataset.indexOf(buckets[i]);\n\t}\n\treturn index[0]!=-1&&index[1]!=-1;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tdouble[][] buckets=dataset.getBuckets();\n\tif(buckets.length!=this.buckets.length)\n\t\treturn false;\n\tfor(int i=0;i<buckets.length;i++){\n\t\tif(buckets[i].length!=this.buckets[i].length)\n\t\t\treturn false;\n\t\tfor(int j=0;j<this.buckets[i].length;j++)\n\t\t\tif(buckets[i][j]!=this.buckets[i][j])\n\t\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tArrayList<String> tableBuckets = dataset.getBuckets();\n\tif (tableBuckets.size() != buckets.size())\n\t\treturn false;\n\tfor (int i = 0; i < buckets.size(); i ++)\n\t\tif (! tableBuckets.get(i).equalsIgnoreCase(buckets.get(i)))\n\t\t\treturn false;\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset==null) return false;\n\tfor(int i=0;i<dataset.getBucketNum();i++){\n\t\tif(!dataset.getBucket(i).equals(getBucket(i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset.getColumn(0).getNumBuckets()!=this.getColumn(0).getNumBuckets()){\n\t\treturn false;\n\t}\n\tfor(int i=1;i<getNumColumns();i++){\n\t\tif(dataset.getColumn(i).getNumBuckets()!=this.getColumn(i).getNumBuckets()){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int j=0;j<dataset.getColumn(i).getNumBuckets();j++){\n\t\t\tif(!dataset.getColumn(i).getBucketValue(j).equals(this.getColumn(i).getBucketValue(j))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * @return true if the bucket is same.\n */\n", "method_name": "isCompatible", "codes": ["public boolean isCompatible(DataTable dataset){\n\n\treturn isCompatible(dataset, null);\n}", "public boolean isCompatible(DataTable dataset){\n\n\t\tif(this.numBuckets==dataset.numBuckets){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}", "public boolean isCompatible(DataTable dataset){\n\n\tif ((dataset.getRowCount()!=this.getRowCount())||(dataset.getColumnCount()!=this.getColumnCount())){\n\t\treturn false;\n\t}else{\n\t\tfor(int i=0;i<this.getRowCount();i++){\n\t\t\tfor(int j=0;j<this.getColumnCount();j++){\n\t\t\t\tif (this.getBucket(i,j)!=dataset.getBucket(i,j)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}", "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset==null) return false;\n\tif(dataset.getNumOfAttributes()!=this.getNumOfAttributes()) return false;\n\tif(dataset.getNumOfBuckets()!=this.getNumOfBuckets()) return false;\n\t\n\tfor(int i=0; i<dataset.getNumOfBuckets(); i++){\n\t\tif(!dataset.getBucket(i).isCompatible(this.getBucket(i))){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tBucketList bList=dataset.getBucketList();\n\tif(bList==null || bList.size()==0)\n\t\treturn false;\n\telse{\n\t\tfor(int i=0; i<bList.size(); i++){\n\t\t\tBucket b=bList.get(i);\n\t\t\tif(!b.isCompatible(m_buckets.get(i)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tint[] index=new int[buckets.length];\n\tfor(int i=0;i<buckets.length;i++){\n\t\tindex[i]=dataset.indexOf(buckets[i]);\n\t}\n\treturn index[0]!=-1&&index[1]!=-1;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tdouble[][] buckets=dataset.getBuckets();\n\tif(buckets.length!=this.buckets.length)\n\t\treturn false;\n\tfor(int i=0;i<buckets.length;i++){\n\t\tif(buckets[i].length!=this.buckets[i].length)\n\t\t\treturn false;\n\t\tfor(int j=0;j<this.buckets[i].length;j++)\n\t\t\tif(buckets[i][j]!=this.buckets[i][j])\n\t\t\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tArrayList<String> tableBuckets = dataset.getBuckets();\n\tif (tableBuckets.size() != buckets.size())\n\t\treturn false;\n\tfor (int i = 0; i < buckets.size(); i ++)\n\t\tif (! tableBuckets.get(i).equalsIgnoreCase(buckets.get(i)))\n\t\t\treturn false;\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset==null) return false;\n\tfor(int i=0;i<dataset.getBucketNum();i++){\n\t\tif(!dataset.getBucket(i).equals(getBucket(i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "public boolean isCompatible(DataTable dataset){\n\n\tif(dataset.getColumn(0).getNumBuckets()!=this.getColumn(0).getNumBuckets()){\n\t\treturn false;\n\t}\n\tfor(int i=1;i<getNumColumns();i++){\n\t\tif(dataset.getColumn(i).getNumBuckets()!=this.getColumn(i).getNumBuckets()){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int j=0;j<dataset.getColumn(i).getNumBuckets();j++){\n\t\t\tif(!dataset.getColumn(i).getBucketValue(j).equals(this.getColumn(i).getBucketValue(j))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "plib_runnable", "_id": "636767e11a6d9265ec018795", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n    Mapping mapping=getMapping(tableName);\n    Mappings res=new Mappings();\n    for (Variable var:mapping.getVariables()){\n        if (!mappings.getQuery().getVariables().contains(var)){\n            res.add(mappings.getQuery(), var.getName(), var);\n        }\n    }\n    return res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tTable table=getTable(tableName);\n\tif (table==null) return null;\n\tMappings res=new Mappings();\n\tfor (Mapping mapping:mappings){\n\t\tfor (Variable var:table.getVariables()){\n\t\t\tif (mapping.getNode(var.getName())==null){\n\t\t\t\tmapping.addNode(var.getName(), Node.createVariable(var.getName()));\n\t\t\t}\n\t\t}\n\t\tres.add(mapping);\n\t}\n\treturn res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map=new Mappings();\n\tmap.setQuery(mappings.getQuery());\n\tfor (Mapping map1:mappings){\n\t\tif (!map1.getNode(tableName).isVariable()){\n\t\t\tmap.add(map1);\n\t\t}\n\t}\n\treturn map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n  Mappings map = new Mappings();\n  for (Mapping m: mappings){\n    Mapping mp = getMapping(tableName, m.getNode(0).getLabel());\n    if (mp!=null){\n      map.add(mp.diffStructure(m));\n    }\n  }\n  return map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings(this.getQuery().getAST());\n\tres.setRename(mappings.rename);\n\t//res.setAlias(mappings.alias);\n\t\n\t//List<Variable> var1=mappings.getVariables();\n\t//List<Variable> var2=this.getVariables();\n\t\n\t//List<Variable> var=new ArrayList<Variable>();\n\t\n\t//var.addAll(var1);\n\t//var.retainAll(var2);\n\t\n\t//var1.removeAll(var);\n\t//var2.removeAll(var);\n\t\n\t//res.variables.addAll(var1);\n\t//res.variables.addAll(var2);\n\t\n\t\n\t//Mappings m1=this.getMappings();\n\t//Mappings m2=mappings;\n\t\n\t//res.mappings=m1.diffStructure(m2);\n\t\n\tfor (Mapping map : mappings.getMappings()){\n\t\t\n\t\tMapping map1=this", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings();\n\tMappings map=getMappings(tableName);\n\tif (map==null) return mappings;\n\tfor (Mapping map1:map){\n\t\tif (!mappings.contains(map1)) res.add(map1);\n\t}\n\treturn res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res = new Mappings();\n\tif (mappings==null) { //empty mapping\n\t\tfor (String field:getFields())\n\t\t\tres.add(tableName,field);\n\t\treturn res;\n\t}\n\tfor (String field:getFields()){\n\t\tif (!mappings.contains(tableName, field))\n\t\t\tres.add(tableName,field);\n\t}\n\treturn res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map = new Mappings();\n\t\n\t\tfor (Mapping m: mappings){\n\t\t\tif (m.getNode(0).getIndex()!=1 && !isInStructure(tableName, m.getNode(0).getLabel())){\n\t\t\t\tmap.add(m.getNode(0).getLabel(), m.getNode(0).getIndex());\n\t\t\t}\n\t\t}\n\treturn map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map=new Mappings();\n\tfor (String s:mappings.getDistinctValues(tableName)){\n\t\tMapping m=mappings.getMapping(s);\n\t\tMapping mm=new Mapping();\n\t\tfor (Variable v:m.getVariables()){\n\t\t\tif (!getVariables().contains(v)){\n\t\t\t\tmm.add(v);\n\t\t\t}\n\t\t}\n\t\tif (mm.size()>0){\n\t\t\tmap.add(mm);\n\t\t}\n\t}\n\treturn map;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings();\n\tMapping map=mappings.getMapping(tableName);\n\tif (map==null) return res;\n\tfor (String field:getFields())\n\t\tif (!map.contains(field))\n\t\t\tres.add(tableName, getMapping(tableName).get(field));\n\treturn res;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns mappings with fields that not exist in the input mappings. The input mappings should be history mapping from current index. Do not return _source config to avoid current index update conflict.\n */\n", "method_name": "diffStructure", "codes": ["public Mappings diffStructure(String tableName,Mappings mappings){\n\n    Mapping mapping=getMapping(tableName);\n    Mappings res=new Mappings();\n    for (Variable var:mapping.getVariables()){\n        if (!mappings.getQuery().getVariables().contains(var)){\n            res.add(mappings.getQuery(), var.getName(), var);\n        }\n    }\n    return res;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tTable table=getTable(tableName);\n\tif (table==null) return null;\n\tMappings res=new Mappings();\n\tfor (Mapping mapping:mappings){\n\t\tfor (Variable var:table.getVariables()){\n\t\t\tif (mapping.getNode(var.getName())==null){\n\t\t\t\tmapping.addNode(var.getName(), Node.createVariable(var.getName()));\n\t\t\t}\n\t\t}\n\t\tres.add(mapping);\n\t}\n\treturn res;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map=new Mappings();\n\tmap.setQuery(mappings.getQuery());\n\tfor (Mapping map1:mappings){\n\t\tif (!map1.getNode(tableName).isVariable()){\n\t\t\tmap.add(map1);\n\t\t}\n\t}\n\treturn map;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n  Mappings map = new Mappings();\n  for (Mapping m: mappings){\n    Mapping mp = getMapping(tableName, m.getNode(0).getLabel());\n    if (mp!=null){\n      map.add(mp.diffStructure(m));\n    }\n  }\n  return map;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings(this.getQuery().getAST());\n\tres.setRename(mappings.rename);\n\t//res.setAlias(mappings.alias);\n\t\n\t//List<Variable> var1=mappings.getVariables();\n\t//List<Variable> var2=this.getVariables();\n\t\n\t//List<Variable> var=new ArrayList<Variable>();\n\t\n\t//var.addAll(var1);\n\t//var.retainAll(var2);\n\t\n\t//var1.removeAll(var);\n\t//var2.removeAll(var);\n\t\n\t//res.variables.addAll(var1);\n\t//res.variables.addAll(var2);\n\t\n\t\n\t//Mappings m1=this.getMappings();\n\t//Mappings m2=mappings;\n\t\n\t//res.mappings=m1.diffStructure(m2);\n\t\n\tfor (Mapping map : mappings.getMappings()){\n\t\t\n\t\tMapping map1=this", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings();\n\tMappings map=getMappings(tableName);\n\tif (map==null) return mappings;\n\tfor (Mapping map1:map){\n\t\tif (!mappings.contains(map1)) res.add(map1);\n\t}\n\treturn res;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res = new Mappings();\n\tif (mappings==null) { //empty mapping\n\t\tfor (String field:getFields())\n\t\t\tres.add(tableName,field);\n\t\treturn res;\n\t}\n\tfor (String field:getFields()){\n\t\tif (!mappings.contains(tableName, field))\n\t\t\tres.add(tableName,field);\n\t}\n\treturn res;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map = new Mappings();\n\t\n\t\tfor (Mapping m: mappings){\n\t\t\tif (m.getNode(0).getIndex()!=1 && !isInStructure(tableName, m.getNode(0).getLabel())){\n\t\t\t\tmap.add(m.getNode(0).getLabel(), m.getNode(0).getIndex());\n\t\t\t}\n\t\t}\n\treturn map;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings map=new Mappings();\n\tfor (String s:mappings.getDistinctValues(tableName)){\n\t\tMapping m=mappings.getMapping(s);\n\t\tMapping mm=new Mapping();\n\t\tfor (Variable v:m.getVariables()){\n\t\t\tif (!getVariables().contains(v)){\n\t\t\t\tmm.add(v);\n\t\t\t}\n\t\t}\n\t\tif (mm.size()>0){\n\t\t\tmap.add(mm);\n\t\t}\n\t}\n\treturn map;\n}", "public Mappings diffStructure(String tableName,Mappings mappings){\n\n\tMappings res=new Mappings();\n\tMapping map=mappings.getMapping(tableName);\n\tif (map==null) return res;\n\tfor (String field:getFields())\n\t\tif (!map.contains(field))\n\t\t\tres.add(tableName, getMapping(tableName).get(field));\n\treturn res;\n}"], "code_level": "plib_runnable", "_id": "636767de1a6d9265ec018706", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\n\tif(dayStep <= 0) return timeBucket;\n\tif(dayStep >= DAY_OF_MONTH) return timeBucket;\n\n\tlong day = timeBucket % 100;\n\tlong month = (timeBucket / 100) % 100;\n\tlong year = timeBucket / 10000;\n\n\tif(day <= dayStep) return timeBucket;\n\n\tday = (day / dayStep) * dayStep;\n\tif(day == 0) day = dayStep;\n\n\treturn year * 10000 + month * 100 + day;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\t\tString strTimeBucket = String.valueOf(timeBucket);\n\t\tif (strTimeBucket.length() < 8)\n\t\t\treturn timeBucket;\n\t\tString strCompressTimeBucket = strTimeBucket.substring(0, 6) + (String.valueOf(timeBucket / 100 % 100 / dayStep * dayStep)).substring(1);\n\t\treturn Long.parseLong(strCompressTimeBucket);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tif (dayStep <= 0 || dayStep >= 32) {\n\t\treturn timeBucket;\n\t}\n\t\n\tCalendar c = Calendar.getInstance();\n\tc.setTimeInMillis(timeBucket);\n\t\n\tint dayOfMonth = c.get(Calendar.DAY_OF_MONTH);\n\tdayOfMonth = dayOfMonth - dayOfMonth % dayStep;\n\tc.set(Calendar.DAY_OF_MONTH, dayOfMonth);\n\t\n\tc.set(Calendar.HOUR_OF_DAY, 0);\n\tc.set(Calendar.MINUTE, 0);\n\tc.set(Calendar.SECOND, 0);\n\tc.set(Calendar.MILLISECOND, 0);\n\t\n\treturn c.getTimeInMillis();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tString timeBucketStr = String.valueOf(timeBucket);\n\tif(timeBucketStr.length()!= 8){\n\t\tthrow new IllegalArgumentException(\"Time bucket should be 8-bit digit.\");\n\t}\n\tString yearStr = timeBucketStr.substring(0,4);\n\tString monthStr = timeBucketStr.substring(4,6);\n\tString dayStr = timeBucketStr.substring(6,8);\n\tint day = Integer.valueOf(dayStr);\n\tint dayStepBase = dayStep;\n\tint dayStepRemainder = dayStep;\n\twhile(dayStepRemainder > dayStepBase){\n\t\tdayStepRemainder = dayStepRemainder - dayStepBase;\n\t}\n\tday = (day - dayStepRemainder) / dayStepBase * dayStepBase + dayStepRemainder;\n\tif(day<10){\n\t\tdayStr = \"0\" + String.valueOf(day);\n\t}else{\n\t\tdayStr = String.valueOf(day);\n\t}\n\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tif(dayStep>=0){\n\t\treturn timeBucket;\n\t}\n\t\n\tString timeBucketStr = String.valueOf(timeBucket);\n\tString year = timeBucketStr.substring(0, 4);\n\tString month = timeBucketStr.substring(4, 6);\n\tString day = timeBucketStr.substring(6, 8);\n\tint dayOfMonth = Integer.valueOf(day);\t\n\tint mod = dayOfMonth%Math.abs(dayStep);\n\tif(mod!=0){\n\t\tdayOfMonth = dayOfMonth - mod;\n\t}\n\t\n\treturn Long.valueOf(year+month+StringUtil.leftPad(String.valueOf(dayOfMonth),2,'0'));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong result = 0l;\n\tif(dayStep <= 0 || dayStep >= 100){\n\t\treturn result;\n\t}\n\ttry {\n\t\tresult = TIME_BUCKET_FORMATTER.parse(TIME_BUCKET_FORMATTER.format(timeBucket)).getTime();\n\t} catch (ParseException e) {\n\t\te.printStackTrace();\n\t}\n\treturn result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong ret = 0;\n\tint year = 0;\n\tint month = 0;\n\tint day = 0;\n\tint hour = 0;\n\tint min = 0;\n\tint sec = 0;\n\tchar timeBucketStr[20] = {0};\n\tchar timeBucketStrCompressed[20] = {0};\n\tstruct tm timeinfo;\n\t\n\t/**Convert timeBucket from long to string.**/\n\tsprintf(timeBucketStr,\"%ld\",timeBucket);\n\t\n\t/**Get year, month, day, hour, min, sec from timeBucketStr.**/\n\tsscanf(timeBucketStr,\"%4d%2d%2d%2d%2d%2d\",&year,&month,&day,&hour,&min,&sec);\n\t\n\t/**Reformat the time bucket with dayStep.**/\n\ttimeinfo.tm_year = year-1900;\n\ttimeinfo.tm_mon = month-1;\n\ttimeinfo.tm_mday = day;\n\ttimeinfo.tm_hour", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong year = (timeBucket / 10000) * 10000;\n\tlong month = (timeBucket / 100) * 100 - year;\n\tlong day = (timeBucket % 100 / dayStep) * dayStep;\n\tlong compressedTimeBucket = year + month + day;\n\treturn compressedTimeBucket;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n    long result = 0;\n    String temp = String.valueOf(timeBucket);\n    if(temp.length() != 8){\n        return 0;\n    }\n    String temp2 = temp.substring(0,6) + Integer.toString(Integer.parseInt(temp.substring(6,8)) / dayStep * dayStep);\n    try{\n        result = TIME_BUCKET_FORMATTER.parse(temp2).getTime();\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    return result;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tDate date = new Date(timeBucket);\n\tSimpleDateFormat dateFormatter = new SimpleDateFormat(TIME_BUCKET_FORMATTER);\n\ttry {\n\t\tdate = dateFormatter.parse(dateFormatter.format(date));\n\t} catch (ParseException e) {\n\t\tlog.error(\"Error occurs while parsing time bucket.\",e);\n\t}\n\tCalendar calendar = Calendar.getInstance();\n\tcalendar.setTime(date);\n\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\tint dayOfMonthMod = dayOfMonth % dayStep;\n\tif(dayOfMonthMod != 0){\n\t\tcalendar.set(Calendar.DAY_OF_MONTH, dayOfMonth - dayOfMonthMod);\n\t}\n\treturn calendar.getTimeInMillis();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Follow the dayStep to re-format the time bucket literal long value. Such as, in dayStep == 11, 20000105 re-formatted time bucket is 20000101, 20000115 re-formatted time bucket is 20000112, 20000123 re-formatted time bucket is 20000123\n */\n", "method_name": "compressTimeBucket", "codes": ["static long compressTimeBucket(long timeBucket,int dayStep){\n\n\n\tif(dayStep <= 0) return timeBucket;\n\tif(dayStep >= DAY_OF_MONTH) return timeBucket;\n\n\tlong day = timeBucket % 100;\n\tlong month = (timeBucket / 100) % 100;\n\tlong year = timeBucket / 10000;\n\n\tif(day <= dayStep) return timeBucket;\n\n\tday = (day / dayStep) * dayStep;\n\tif(day == 0) day = dayStep;\n\n\treturn year * 10000 + month * 100 + day;\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\t\tString strTimeBucket = String.valueOf(timeBucket);\n\t\tif (strTimeBucket.length() < 8)\n\t\t\treturn timeBucket;\n\t\tString strCompressTimeBucket = strTimeBucket.substring(0, 6) + (String.valueOf(timeBucket / 100 % 100 / dayStep * dayStep)).substring(1);\n\t\treturn Long.parseLong(strCompressTimeBucket);\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tif (dayStep <= 0 || dayStep >= 32) {\n\t\treturn timeBucket;\n\t}\n\t\n\tCalendar c = Calendar.getInstance();\n\tc.setTimeInMillis(timeBucket);\n\t\n\tint dayOfMonth = c.get(Calendar.DAY_OF_MONTH);\n\tdayOfMonth = dayOfMonth - dayOfMonth % dayStep;\n\tc.set(Calendar.DAY_OF_MONTH, dayOfMonth);\n\t\n\tc.set(Calendar.HOUR_OF_DAY, 0);\n\tc.set(Calendar.MINUTE, 0);\n\tc.set(Calendar.SECOND, 0);\n\tc.set(Calendar.MILLISECOND, 0);\n\t\n\treturn c.getTimeInMillis();\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tString timeBucketStr = String.valueOf(timeBucket);\n\tif(timeBucketStr.length()!= 8){\n\t\tthrow new IllegalArgumentException(\"Time bucket should be 8-bit digit.\");\n\t}\n\tString yearStr = timeBucketStr.substring(0,4);\n\tString monthStr = timeBucketStr.substring(4,6);\n\tString dayStr = timeBucketStr.substring(6,8);\n\tint day = Integer.valueOf(dayStr);\n\tint dayStepBase = dayStep;\n\tint dayStepRemainder = dayStep;\n\twhile(dayStepRemainder > dayStepBase){\n\t\tdayStepRemainder = dayStepRemainder - dayStepBase;\n\t}\n\tday = (day - dayStepRemainder) / dayStepBase * dayStepBase + dayStepRemainder;\n\tif(day<10){\n\t\tdayStr = \"0\" + String.valueOf(day);\n\t}else{\n\t\tdayStr = String.valueOf(day);\n\t}\n\t", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tif(dayStep>=0){\n\t\treturn timeBucket;\n\t}\n\t\n\tString timeBucketStr = String.valueOf(timeBucket);\n\tString year = timeBucketStr.substring(0, 4);\n\tString month = timeBucketStr.substring(4, 6);\n\tString day = timeBucketStr.substring(6, 8);\n\tint dayOfMonth = Integer.valueOf(day);\t\n\tint mod = dayOfMonth%Math.abs(dayStep);\n\tif(mod!=0){\n\t\tdayOfMonth = dayOfMonth - mod;\n\t}\n\t\n\treturn Long.valueOf(year+month+StringUtil.leftPad(String.valueOf(dayOfMonth),2,'0'));\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong result = 0l;\n\tif(dayStep <= 0 || dayStep >= 100){\n\t\treturn result;\n\t}\n\ttry {\n\t\tresult = TIME_BUCKET_FORMATTER.parse(TIME_BUCKET_FORMATTER.format(timeBucket)).getTime();\n\t} catch (ParseException e) {\n\t\te.printStackTrace();\n\t}\n\treturn result;\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong ret = 0;\n\tint year = 0;\n\tint month = 0;\n\tint day = 0;\n\tint hour = 0;\n\tint min = 0;\n\tint sec = 0;\n\tchar timeBucketStr[20] = {0};\n\tchar timeBucketStrCompressed[20] = {0};\n\tstruct tm timeinfo;\n\t\n\t/**Convert timeBucket from long to string.**/\n\tsprintf(timeBucketStr,\"%ld\",timeBucket);\n\t\n\t/**Get year, month, day, hour, min, sec from timeBucketStr.**/\n\tsscanf(timeBucketStr,\"%4d%2d%2d%2d%2d%2d\",&year,&month,&day,&hour,&min,&sec);\n\t\n\t/**Reformat the time bucket with dayStep.**/\n\ttimeinfo.tm_year = year-1900;\n\ttimeinfo.tm_mon = month-1;\n\ttimeinfo.tm_mday = day;\n\ttimeinfo.tm_hour", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tlong year = (timeBucket / 10000) * 10000;\n\tlong month = (timeBucket / 100) * 100 - year;\n\tlong day = (timeBucket % 100 / dayStep) * dayStep;\n\tlong compressedTimeBucket = year + month + day;\n\treturn compressedTimeBucket;\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n    long result = 0;\n    String temp = String.valueOf(timeBucket);\n    if(temp.length() != 8){\n        return 0;\n    }\n    String temp2 = temp.substring(0,6) + Integer.toString(Integer.parseInt(temp.substring(6,8)) / dayStep * dayStep);\n    try{\n        result = TIME_BUCKET_FORMATTER.parse(temp2).getTime();\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    return result;\n}", "static long compressTimeBucket(long timeBucket,int dayStep){\n\n\tDate date = new Date(timeBucket);\n\tSimpleDateFormat dateFormatter = new SimpleDateFormat(TIME_BUCKET_FORMATTER);\n\ttry {\n\t\tdate = dateFormatter.parse(dateFormatter.format(date));\n\t} catch (ParseException e) {\n\t\tlog.error(\"Error occurs while parsing time bucket.\",e);\n\t}\n\tCalendar calendar = Calendar.getInstance();\n\tcalendar.setTime(date);\n\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\tint dayOfMonthMod = dayOfMonth % dayStep;\n\tif(dayOfMonthMod != 0){\n\t\tcalendar.set(Calendar.DAY_OF_MONTH, dayOfMonth - dayOfMonthMod);\n\t}\n\treturn calendar.getTimeInMillis();\n}"], "code_level": "project_runnable", "_id": "636767dc1a6d9265ec0186be", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(Fields.Field field:fields){\n\t\tif(!containsField(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tif(fields==null)return true;\n\tfor(int i=0;i<fields.size();i++){\n\t\tif(!containsField(fields.get(i)))return false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tif(fields==null)\n\t\treturn false;\n\t\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(Field field:fields){\n\t\tif(!containsField(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n    return true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\t\tfor (Field field : fields){\n\t\t\tif (!properties.containsKey(field.name)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(Field field:fields.getFields()){\n\t\tif(!this.properties.containsKey(field.getName()))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private boolean containsAllFields(Fields fields){\n\n\tfor(String f:fields.getFields()){\n\t\tif(!properties.containsKey(f)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Returns ture when the input fields have already been stored in the properties.\n */\n", "method_name": "containsAllFields", "codes": ["private boolean containsAllFields(Fields fields){\n\n\tfor(Fields.Field field:fields){\n\t\tif(!containsField(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tif(fields==null)return true;\n\tfor(int i=0;i<fields.size();i++){\n\t\tif(!containsField(fields.get(i)))return false;\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tif(fields==null)\n\t\treturn false;\n\t\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tfor(Field field:fields){\n\t\tif(!containsField(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tfor(String field:fields.getFields()){\n\t\tif(!properties.containsKey(field)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n    return true;\n}", "private boolean containsAllFields(Fields fields){\n\n\t\tfor (Field field : fields){\n\t\t\tif (!properties.containsKey(field.name)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "private boolean containsAllFields(Fields fields){\n\n\tfor(Field field:fields.getFields()){\n\t\tif(!this.properties.containsKey(field.getName()))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "private boolean containsAllFields(Fields fields){\n\n\tfor(String f:fields.getFields()){\n\t\tif(!properties.containsKey(f)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186c6", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(!channels.isEmpty()){\n\t\tChannels newChannels=new Channels(channels.size());\n\t\tfor (Channel channel : channels) {\n\t\t\tif(!consumeTargets.contains(channel)){\n\t\t\t\tnewChannels.add(channel);\n\t\t\t}\n\t\t}\n\t\tif(!newChannels.isEmpty()){\n\t\t\tconsumeTargets.addAll(newChannels);\n\t\t\t//\u91cd\u65b0\u5206\u914d\u6d88\u8d39\u8005\n\t\t\tassignConsumer(consumeTargets, consumer,false);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(channels!=null&&consumer!=null){\n\t\t\tif(!consumeTargets.containsKey(channels)){\n\t\t\t\tconsumeTargets.put(channels, new ArrayList<IConsumer>());\n\t\t\t}\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n    if(consumeTargets.containsKey(channels)){\n        throw new RuntimeException(\"Target already exists for channels: \"+channels);\n    }\n    consumeTargets.put(channels,consumer);\n    if(consumer instanceof IConsumerClosed){\n        addCloseListener((IConsumerClosed)consumer);\n    }\n    if(consumer instanceof IConsumerConnected){\n        addConnectListener((IConsumerConnected)consumer);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tsynchronized(lock){\n\t\tif(consumer==null) return;\n\t\tif(consumeTargets.contains(channels)){\n\t\t\tList<IConsumer> list=consumeTargets.get(channels);\n\t\t\tif(!list.contains(consumer)){\n\t\t\t\tlist.add(consumer);\n\t\t\t\tconsumeTargets.put(channels, list);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tconsumeTargets.put(channels,new ArrayList<IConsumer>(Arrays.asList(consumer)));\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(consumer.getTarget() == channels){\n\t\treturn;\n\t}\n\tconsumer.setTarget(channels);\n\tconsumer.setConsumer(null);\n\tconsumer.setConsumer(this);\n\tconsumer.setConsumeTarget(true);\n\tif(!consumeTargets.contains(consumer)){\n\t\tconsumeTargets.add(consumer);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(consumeTargets==null){\n\t\tconsumeTargets=new HashMap();\n\t}\n\tconsumeTargets.put(channels,consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tconsumeTargets.put(channels, consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tsynchronized (consumeTargets) {\n\t\tif(consumeTargets.containsKey(channels)) {\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t\t}else {\n\t\t\tconsumeTargets.put(channels, new ArrayList<>());\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tconsumeTargets.put(channels,consumer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tfor(Channel channel : channels){\n\t\tif(!consumeTargets.contains(channel)){\n\t\t\tconsumeTargets.add(channel);\n\t\t\tchannel.addConsumer(consumer);\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Add a new target channels.\n */\n", "method_name": "addNewTarget", "codes": ["public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(!channels.isEmpty()){\n\t\tChannels newChannels=new Channels(channels.size());\n\t\tfor (Channel channel : channels) {\n\t\t\tif(!consumeTargets.contains(channel)){\n\t\t\t\tnewChannels.add(channel);\n\t\t\t}\n\t\t}\n\t\tif(!newChannels.isEmpty()){\n\t\t\tconsumeTargets.addAll(newChannels);\n\t\t\t//\u91cd\u65b0\u5206\u914d\u6d88\u8d39\u8005\n\t\t\tassignConsumer(consumeTargets, consumer,false);\n\t\t}\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(channels!=null&&consumer!=null){\n\t\t\tif(!consumeTargets.containsKey(channels)){\n\t\t\t\tconsumeTargets.put(channels, new ArrayList<IConsumer>());\n\t\t\t}\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n    if(consumeTargets.containsKey(channels)){\n        throw new RuntimeException(\"Target already exists for channels: \"+channels);\n    }\n    consumeTargets.put(channels,consumer);\n    if(consumer instanceof IConsumerClosed){\n        addCloseListener((IConsumerClosed)consumer);\n    }\n    if(consumer instanceof IConsumerConnected){\n        addConnectListener((IConsumerConnected)consumer);\n    }\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tsynchronized(lock){\n\t\tif(consumer==null) return;\n\t\tif(consumeTargets.contains(channels)){\n\t\t\tList<IConsumer> list=consumeTargets.get(channels);\n\t\t\tif(!list.contains(consumer)){\n\t\t\t\tlist.add(consumer);\n\t\t\t\tconsumeTargets.put(channels, list);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tconsumeTargets.put(channels,new ArrayList<IConsumer>(Arrays.asList(consumer)));\n\t\t}\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(consumer.getTarget() == channels){\n\t\treturn;\n\t}\n\tconsumer.setTarget(channels);\n\tconsumer.setConsumer(null);\n\tconsumer.setConsumer(this);\n\tconsumer.setConsumeTarget(true);\n\tif(!consumeTargets.contains(consumer)){\n\t\tconsumeTargets.add(consumer);\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tif(consumeTargets==null){\n\t\tconsumeTargets=new HashMap();\n\t}\n\tconsumeTargets.put(channels,consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tconsumeTargets.put(channels, consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tsynchronized (consumeTargets) {\n\t\tif(consumeTargets.containsKey(channels)) {\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t\t}else {\n\t\t\tconsumeTargets.put(channels, new ArrayList<>());\n\t\t\tconsumeTargets.get(channels).add(consumer);\n\t\t}\n\t}\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tconsumeTargets.put(channels,consumer);\n}", "public void addNewTarget(Channels channels,IConsumer consumer){\n\n\tfor(Channel channel : channels){\n\t\tif(!consumeTargets.contains(channel)){\n\t\t\tconsumeTargets.add(channel);\n\t\t\tchannel.addConsumer(consumer);\n\t\t}\n\t}\n}"], "code_level": "plib_runnable", "_id": "636767dd1a6d9265ec0186e5", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public void init(){\n\n\tdirectory = new ArrayList<>();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\tSystem.out.println(\"\\nEnter name of the directory: \");\n\tString name = sc.nextLine();\n\tSystem.out.println(\"Enter path of the directory: \");\n\tString path = sc.nextLine();\n\tSystem.out.println(\"Enter size of the directory: \");\n\tint size = sc.nextInt();\n\tSystem.out.println(\"Enter the number of files in the directory: \");\n\tint n = sc.nextInt();\n\t\n\tDirectory dir = new Directory(name, path, size);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tSystem.out.println(\"Enter name of file: \");\n\t\tString fname = sc.next();\n\t\tSystem.out.println(\"Enter path of file: \");\n\t\tString fpath = sc.next();\n\t\tSystem.out.println(\"Enter size of file: \");\n\t\tint fsize = sc.nextInt();\n\t\tFile f = new File(fname, fpath, fsize);\n\t\tdir.addFile(f);\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\tdirectory = new File(\"data/\");\n\tif(!directory.exists()){\n\t\tdirectory.mkdir();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\tSystem.out.println(\"Starting the directory setup...\");\n\tif(!Main.getMain().getDataFolder().exists()){\n\t\tif(!Main.getMain().getDataFolder().mkdir()){\n\t\t\tSystem.out.println(\"Failed to create data folder for plugin.\");\n\t\t\treturn;\n\t\t}\n\t}\n\tFile file = new File(Main.getMain().getDataFolder() + File.separator + \"config.yml\");\n\tif(!file.exists()){\n\t\ttry{\n\t\t\tif(!file.createNewFile()){\n\t\t\t\tSystem.out.println(\"Failed to create config file.\");\n\t\t\t}\n\t\t\tMain.getMain().saveDefaultConfig();\n\t\t\tSystem.out.println(\"Config file created.\");\n\t\t}catch(IOException e){\n\t\t\tSystem.out.println(\"Failed to create config file.\");\n\t\t}\n\t}\n\tfile = new File(Main.getMain().getDataFolder() + File.separator + \"data\");\n", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\t//creates a new file in the directory\n\tfor(int i=0;i<fs.maxFiles;i++){\n\t\t//creates the file\n\t\tfs.create(this.dir[i], this.dir[i].name);\n\t\t//sets the file's parent directory\n\t\tthis.dir[i].parent = this;\n\t\t//if the file is a directory\n\t\tif(this.dir[i].type == 0){\n\t\t\t//gets the file's directory\n\t\t\tDirectory d = (Directory)this.dir[i];\n\t\t\t//initializes the directory\n\t\t\td.init();\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\n  if(!this.root.isFile()){\n    try {\n      this.root.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n\t//set the name of the directory\n\tname = \"C:\\\\Users\\\\Arth\\\\workspace\\\\\" + \"Puzzle\";\n\t\n\t//create the directory\n\tdirectory = new File(name);\n\tdirectory.mkdir();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n    String[] files = new String[0];\n    String[] dirs = new String[0];\n    String[] links = new String[0];\n    String[] contents = new String[0];\n\n    String[] folders = new String[0];\n    String[] files2 = new String[0];\n    String[] links2 = new String[0];\n\n    String[] folders2 = new String[0];\n    String[] files3 = new String[0];\n    String[] links3 = new String[0];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public void init(){\n\n\t\t\n\t\t/**\n\t\t*If the directory is not empty, it will be deleted and a new one will be created.\n\t\t*If the directory is empty, it will be created.\n\t\t**/\n\t\t\n\t\tif(!(new File(PATH)).isDirectory()){\n\t\t\tnew File(PATH).mkdir();\n\t\t}\n\t\telse{\n\t\t\tif(new File(PATH).list().length>0){\n\t\t\t\tfor(File f: new File(PATH).listFiles()){\n\t\t\t\t\tf.delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public void init(){\n\n  File dir = new File(getPath());\n  if(!dir.exists()) {\n    if(!dir.mkdirs())\n      throw new IllegalStateException(\"Could not create directory \" + dir);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * initialize config, such as check dist path\n */\n", "method_name": "init", "codes": ["public void init(){\n\n\tdirectory = new ArrayList<>();\n}", "public void init(){\n\n\tSystem.out.println(\"\\nEnter name of the directory: \");\n\tString name = sc.nextLine();\n\tSystem.out.println(\"Enter path of the directory: \");\n\tString path = sc.nextLine();\n\tSystem.out.println(\"Enter size of the directory: \");\n\tint size = sc.nextInt();\n\tSystem.out.println(\"Enter the number of files in the directory: \");\n\tint n = sc.nextInt();\n\t\n\tDirectory dir = new Directory(name, path, size);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tSystem.out.println(\"Enter name of file: \");\n\t\tString fname = sc.next();\n\t\tSystem.out.println(\"Enter path of file: \");\n\t\tString fpath = sc.next();\n\t\tSystem.out.println(\"Enter size of file: \");\n\t\tint fsize = sc.nextInt();\n\t\tFile f = new File(fname, fpath, fsize);\n\t\tdir.addFile(f);\n\t}", "public void init(){\n\n\tdirectory = new File(\"data/\");\n\tif(!directory.exists()){\n\t\tdirectory.mkdir();\n\t}\n}", "public void init(){\n\n\tSystem.out.println(\"Starting the directory setup...\");\n\tif(!Main.getMain().getDataFolder().exists()){\n\t\tif(!Main.getMain().getDataFolder().mkdir()){\n\t\t\tSystem.out.println(\"Failed to create data folder for plugin.\");\n\t\t\treturn;\n\t\t}\n\t}\n\tFile file = new File(Main.getMain().getDataFolder() + File.separator + \"config.yml\");\n\tif(!file.exists()){\n\t\ttry{\n\t\t\tif(!file.createNewFile()){\n\t\t\t\tSystem.out.println(\"Failed to create config file.\");\n\t\t\t}\n\t\t\tMain.getMain().saveDefaultConfig();\n\t\t\tSystem.out.println(\"Config file created.\");\n\t\t}catch(IOException e){\n\t\t\tSystem.out.println(\"Failed to create config file.\");\n\t\t}\n\t}\n\tfile = new File(Main.getMain().getDataFolder() + File.separator + \"data\");\n", "public void init(){\n\n\t//creates a new file in the directory\n\tfor(int i=0;i<fs.maxFiles;i++){\n\t\t//creates the file\n\t\tfs.create(this.dir[i], this.dir[i].name);\n\t\t//sets the file's parent directory\n\t\tthis.dir[i].parent = this;\n\t\t//if the file is a directory\n\t\tif(this.dir[i].type == 0){\n\t\t\t//gets the file's directory\n\t\t\tDirectory d = (Directory)this.dir[i];\n\t\t\t//initializes the directory\n\t\t\td.init();\n\t\t}\n\t}\n}", "public void init(){\n\n\n  if(!this.root.isFile()){\n    try {\n      this.root.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "public void init(){\n\n\t//set the name of the directory\n\tname = \"C:\\\\Users\\\\Arth\\\\workspace\\\\\" + \"Puzzle\";\n\t\n\t//create the directory\n\tdirectory = new File(name);\n\tdirectory.mkdir();\n}", "public void init(){\n\n    String[] files = new String[0];\n    String[] dirs = new String[0];\n    String[] links = new String[0];\n    String[] contents = new String[0];\n\n    String[] folders = new String[0];\n    String[] files2 = new String[0];\n    String[] links2 = new String[0];\n\n    String[] folders2 = new String[0];\n    String[] files3 = new String[0];\n    String[] links3 = new String[0];\n}", "public void init(){\n\n\t\t\n\t\t/**\n\t\t*If the directory is not empty, it will be deleted and a new one will be created.\n\t\t*If the directory is empty, it will be created.\n\t\t**/\n\t\t\n\t\tif(!(new File(PATH)).isDirectory()){\n\t\t\tnew File(PATH).mkdir();\n\t\t}\n\t\telse{\n\t\t\tif(new File(PATH).list().length>0){\n\t\t\t\tfor(File f: new File(PATH).listFiles()){\n\t\t\t\t\tf.delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}", "public void init(){\n\n  File dir = new File(getPath());\n  if(!dir.exists()) {\n    if(!dir.mkdirs())\n      throw new IllegalStateException(\"Could not create directory \" + dir);\n  }\n}"], "code_level": "slib_runnable", "_id": "636767dc1a6d9265ec0186cb", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n    int minSequence=this.getMinSequence();\n    int maxSequence=this.getMaxSequence();\n    if(minSequence==maxSequence){\n        SequenceRange sequenceRange= new SequenceRange(minSequence,minSequence);\n        List<SequenceRange> sequenceRanges=new ArrayList<>();\n        sequenceRanges.add(sequenceRange);\n        return sequenceRanges;\n    }\n    List<SequenceRange> sequenceRanges=new ArrayList<>();\n    int maxLowerBound=maxSequence-SEQUENCE_RANGE_BATCH_SIZE;\n    for(int lowerBound=minSequence;lowerBound<=maxLowerBound;lowerBound+=SEQUENCE_RANGE_BATCH_SIZE){\n        SequenceRange sequenceRange=new SequenceRange(lowerBound,lowerBound+SEQUENCE_RANGE_BATCH_SIZE-1);\n        sequenceRanges.add(sequenceRange);\n    }\n    if(maxSequence>maxLowerBound){\n        SequenceRange sequenceRange=new SequenceRange(maxLowerBound+1,maxSequence);\n        sequenceR", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tint maxSequence = getMaxSequence();\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\tint minSequence = getMinSequence();\n\twhile(minSequence<=maxSequence){\n\t\tint upperBound = minSequence + SEQUENCE_RANGE_BATCH_SIZE;\n\t\tif(upperBound>maxSequence){\n\t\t\tupperBound = maxSequence;\n\t\t}\n\t\tSequenceRange sequenceRange = new SequenceRange(minSequence,upperBound);\n\t\tsequenceRanges.add(sequenceRange);\n\t\tminSequence = upperBound + 1;\n\t}\n\treturn sequenceRanges;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRangeList=new ArrayList<SequenceRange>();\n\tSequenceRange sr=null;\n\tfor(int i=minSequence;i<=maxSequence;i=i+SEQUENCE_RANGE_BATCH_SIZE){\n\t\tsr=new SequenceRange(i,i+SEQUENCE_RANGE_BATCH_SIZE);\n\t\tsequenceRangeList.add(sr);\n\t}\n\treturn sequenceRangeList;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n    int minSequence=0;\n    int maxSequence=sequenceDao.getMaxSequence();\n    List<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n    SequenceRange tempSequenceRange=null;\n    while(maxSequence>=minSequence){\n        tempSequenceRange=new SequenceRange();\n        tempSequenceRange.setMinSequence(minSequence);\n        tempSequenceRange.setMaxSequence(minSequence+SEQUENCE_RANGE_BATCH_SIZE-1);\n        minSequence+=SEQUENCE_RANGE_BATCH_SIZE;\n        sequenceRanges.add(tempSequenceRange);\n    }\n    return sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tSequenceRange sequenceRange=null;\n\tlong upperBound=minSequence;\n\twhile(upperBound<maxSequence){\n\t\tsequenceRange=new SequenceRange();\n\t\tsequenceRange.setLowerBound(upperBound);\n\t\tupperBound=upperBound+SEQUENCE_RANGE_BATCH_SIZE;\n\t\tsequenceRange.setUpperBound(upperBound);\n\t\tsequenceRanges.add(sequenceRange);\n\t}\n\treturn sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges = Lists.newArrayList();\n\tfor(int min = minSequence;min <= maxSequence;min = min + SEQUENCE_RANGE_BATCH_SIZE){\n\t\tint max = min + SEQUENCE_RANGE_BATCH_SIZE - 1;\n\t\tmax = max > maxSequence ? maxSequence : max;\n\t\tsequenceRanges.add(new SequenceRange(min,max));\n\t}\n\treturn sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n  List<SequenceRange> seqRanges=new ArrayList<SequenceRange>();\n  long maxSeq=this.getMaxSequence();\n  long minSeq=this.getMinSequence();\n  long upperBound=minSeq+SEQUENCE_RANGE_BATCH_SIZE;\n  while(upperBound<maxSeq){\n    seqRanges.add(new SequenceRange(minSeq,upperBound));\n    minSeq=upperBound;\n    upperBound+=SEQUENCE_RANGE_BATCH_SIZE;\n  }\n  seqRanges.add(new SequenceRange(minSeq,maxSeq));\n  return seqRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tif(this.maxSequence<=this.minSequence){\n\t\tsequenceRanges.add(new SequenceRange(this.minSequence,this.maxSequence));\n\t\treturn sequenceRanges;\n\t}\n\tfor(long i=this.minSequence;i<this.maxSequence;i+=SEQUENCE_RANGE_BATCH_SIZE){\n\t\tsequenceRanges.add(new SequenceRange(i,i+SEQUENCE_RANGE_BATCH_SIZE-1>=this.maxSequence?this.maxSequence:i+SEQUENCE_RANGE_BATCH_SIZE-1));\n\t}\n\treturn sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tfor (int i = 0; i < sequenceRangeNum; i++) {\n\t\tsequenceRanges.add(new SequenceRange(SEQUENCE_RANGE_BATCH_SIZE*i+minSequence, SEQUENCE_RANGE_BATCH_SIZE*(i+1)+minSequence-1));\n\t}\n\tsequenceRanges.get(sequenceRangeNum-1).setUpper(maxSequence);\n\treturn sequenceRanges;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tint maxSequence=this.getMaxSequence();\n\tint minSequence=this.getMinSequence();\n\tint range=maxSequence-minSequence;\n\tint batch=range/SEQUENCE_RANGE_BATCH_SIZE;\n\tint remainder=range%SEQUENCE_RANGE_BATCH_SIZE;\n\tint lowerBound=minSequence;\n\tint upperBound=minSequence+SEQUENCE_RANGE_BATCH_SIZE;\n\tfor(int i=0;i<batch;i++){\n\t\tsequenceRanges.add(new SequenceRange(lowerBound,upperBound));\n\t\tlowerBound=upperBound;\n\t\tupperBound+=SEQUENCE_RANGE_BATCH_SIZE;\n\t}\n\tif(remainder>0){\n\t\tsequenceRanges.add(new SequenceRange(upperBound-SEQUENCE_RANGE_BATCH_SIZE,upperBound));\n\t}\n\treturn sequenceRanges;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * build current profiles segment snapshot search sequence ranges\n */\n", "method_name": "buildSequenceRanges", "codes": ["public List<SequenceRange> buildSequenceRanges(){\n\n    int minSequence=this.getMinSequence();\n    int maxSequence=this.getMaxSequence();\n    if(minSequence==maxSequence){\n        SequenceRange sequenceRange= new SequenceRange(minSequence,minSequence);\n        List<SequenceRange> sequenceRanges=new ArrayList<>();\n        sequenceRanges.add(sequenceRange);\n        return sequenceRanges;\n    }\n    List<SequenceRange> sequenceRanges=new ArrayList<>();\n    int maxLowerBound=maxSequence-SEQUENCE_RANGE_BATCH_SIZE;\n    for(int lowerBound=minSequence;lowerBound<=maxLowerBound;lowerBound+=SEQUENCE_RANGE_BATCH_SIZE){\n        SequenceRange sequenceRange=new SequenceRange(lowerBound,lowerBound+SEQUENCE_RANGE_BATCH_SIZE-1);\n        sequenceRanges.add(sequenceRange);\n    }\n    if(maxSequence>maxLowerBound){\n        SequenceRange sequenceRange=new SequenceRange(maxLowerBound+1,maxSequence);\n        sequenceR", "public List<SequenceRange> buildSequenceRanges(){\n\n\tint maxSequence = getMaxSequence();\n\tList<SequenceRange> sequenceRanges = new ArrayList<SequenceRange>();\n\tint minSequence = getMinSequence();\n\twhile(minSequence<=maxSequence){\n\t\tint upperBound = minSequence + SEQUENCE_RANGE_BATCH_SIZE;\n\t\tif(upperBound>maxSequence){\n\t\t\tupperBound = maxSequence;\n\t\t}\n\t\tSequenceRange sequenceRange = new SequenceRange(minSequence,upperBound);\n\t\tsequenceRanges.add(sequenceRange);\n\t\tminSequence = upperBound + 1;\n\t}\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRangeList=new ArrayList<SequenceRange>();\n\tSequenceRange sr=null;\n\tfor(int i=minSequence;i<=maxSequence;i=i+SEQUENCE_RANGE_BATCH_SIZE){\n\t\tsr=new SequenceRange(i,i+SEQUENCE_RANGE_BATCH_SIZE);\n\t\tsequenceRangeList.add(sr);\n\t}\n\treturn sequenceRangeList;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n    int minSequence=0;\n    int maxSequence=sequenceDao.getMaxSequence();\n    List<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n    SequenceRange tempSequenceRange=null;\n    while(maxSequence>=minSequence){\n        tempSequenceRange=new SequenceRange();\n        tempSequenceRange.setMinSequence(minSequence);\n        tempSequenceRange.setMaxSequence(minSequence+SEQUENCE_RANGE_BATCH_SIZE-1);\n        minSequence+=SEQUENCE_RANGE_BATCH_SIZE;\n        sequenceRanges.add(tempSequenceRange);\n    }\n    return sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tSequenceRange sequenceRange=null;\n\tlong upperBound=minSequence;\n\twhile(upperBound<maxSequence){\n\t\tsequenceRange=new SequenceRange();\n\t\tsequenceRange.setLowerBound(upperBound);\n\t\tupperBound=upperBound+SEQUENCE_RANGE_BATCH_SIZE;\n\t\tsequenceRange.setUpperBound(upperBound);\n\t\tsequenceRanges.add(sequenceRange);\n\t}\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges = Lists.newArrayList();\n\tfor(int min = minSequence;min <= maxSequence;min = min + SEQUENCE_RANGE_BATCH_SIZE){\n\t\tint max = min + SEQUENCE_RANGE_BATCH_SIZE - 1;\n\t\tmax = max > maxSequence ? maxSequence : max;\n\t\tsequenceRanges.add(new SequenceRange(min,max));\n\t}\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n  List<SequenceRange> seqRanges=new ArrayList<SequenceRange>();\n  long maxSeq=this.getMaxSequence();\n  long minSeq=this.getMinSequence();\n  long upperBound=minSeq+SEQUENCE_RANGE_BATCH_SIZE;\n  while(upperBound<maxSeq){\n    seqRanges.add(new SequenceRange(minSeq,upperBound));\n    minSeq=upperBound;\n    upperBound+=SEQUENCE_RANGE_BATCH_SIZE;\n  }\n  seqRanges.add(new SequenceRange(minSeq,maxSeq));\n  return seqRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tif(this.maxSequence<=this.minSequence){\n\t\tsequenceRanges.add(new SequenceRange(this.minSequence,this.maxSequence));\n\t\treturn sequenceRanges;\n\t}\n\tfor(long i=this.minSequence;i<this.maxSequence;i+=SEQUENCE_RANGE_BATCH_SIZE){\n\t\tsequenceRanges.add(new SequenceRange(i,i+SEQUENCE_RANGE_BATCH_SIZE-1>=this.maxSequence?this.maxSequence:i+SEQUENCE_RANGE_BATCH_SIZE-1));\n\t}\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tfor (int i = 0; i < sequenceRangeNum; i++) {\n\t\tsequenceRanges.add(new SequenceRange(SEQUENCE_RANGE_BATCH_SIZE*i+minSequence, SEQUENCE_RANGE_BATCH_SIZE*(i+1)+minSequence-1));\n\t}\n\tsequenceRanges.get(sequenceRangeNum-1).setUpper(maxSequence);\n\treturn sequenceRanges;\n}", "public List<SequenceRange> buildSequenceRanges(){\n\n\tList<SequenceRange> sequenceRanges=new ArrayList<SequenceRange>();\n\tint maxSequence=this.getMaxSequence();\n\tint minSequence=this.getMinSequence();\n\tint range=maxSequence-minSequence;\n\tint batch=range/SEQUENCE_RANGE_BATCH_SIZE;\n\tint remainder=range%SEQUENCE_RANGE_BATCH_SIZE;\n\tint lowerBound=minSequence;\n\tint upperBound=minSequence+SEQUENCE_RANGE_BATCH_SIZE;\n\tfor(int i=0;i<batch;i++){\n\t\tsequenceRanges.add(new SequenceRange(lowerBound,upperBound));\n\t\tlowerBound=upperBound;\n\t\tupperBound+=SEQUENCE_RANGE_BATCH_SIZE;\n\t}\n\tif(remainder>0){\n\t\tsequenceRanges.add(new SequenceRange(upperBound-SEQUENCE_RANGE_BATCH_SIZE,upperBound));\n\t}\n\treturn sequenceRanges;\n}"], "code_level": "class_runnable", "_id": "636767de1a6d9265ec018726", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tList<ThreadSnapshot> threadSnapshots = parseFromFile(file);\n\tList<ThreadSnapshot> filteredThreadSnapshots = new ArrayList<ThreadSnapshot>();\n\tfor(ProfileAnalyzeTimeRange timeRange : timeRanges){\n\t\tfor(ThreadSnapshot threadSnapshot : threadSnapshots){\n\t\t\tif(timeRange.containTime(threadSnapshot.getTime())){\n\t\t\t\tfilteredThreadSnapshots.add(threadSnapshot);\n\t\t\t}\n\t\t}\n\t}\n\treturn filteredThreadSnapshots;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\treturn parseFromFileWithTimeRange(file.getCanonicalPath(),timeRanges);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tList<ThreadSnapshot> snapshots=parseFromFile(file);\n\tList<ThreadSnapshot> ret=new ArrayList<ThreadSnapshot>();\n\tif(snapshots==null)\n\t\treturn ret;\n\tfor(ThreadSnapshot snapshot:snapshots) {\n\t\tfor(ProfileAnalyzeTimeRange timeRange:timeRanges) {\n\t\t\tif(snapshot.getTimestamp()>=timeRange.getStartTime()&&snapshot.getTimestamp()<=timeRange.getEndTime())\n\t\t\t\tret.add(snapshot);\n\t\t}\n\t}\n\treturn ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    String line = null;\n    List<ThreadSnapshot> snapshots = new ArrayList<ThreadSnapshot>();\n    ThreadSnapshot snapshot = null;\n    List<ProfileAnalyzeTimeRange> copyOfTimeRanges = new ArrayList<ProfileAnalyzeTimeRange>(timeRanges);\n    long time = 0;\n    while((line = reader.readLine()) != null) {\n        if(line.startsWith(ThreadSnapshot.START_TAG)) {\n            snapshot = new ThreadSnapshot();\n            snapshots.add(snapshot);\n            snapshot.parseFromLine(line);\n        } else if(line.startsWith(ThreadSnapshot.END_TAG)) {\n            snapshot.parseFromLine(line);\n            time = snapshot.getEndTime().getTime() - snapshot.getStartTime().getTime();\n            for(ProfileAnalyzeTimeRange timeRange : copyOfTimeRanges) {\n                if(time >= timeRange.getMin() && time <= timeRange.getMax()) {\n                    timeRange.increase", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\t\tList<ThreadSnapshot> threadSnapshots=new ArrayList<ThreadSnapshot>();\n\t\tBufferedReader reader=new BufferedReader(new FileReader(file));\n\t\tString line;\n\t\twhile((line=reader.readLine())!=null){\n\t\t\tString[] parts=line.split(\";\");\n\t\t\tString threadName=parts[0];\n\t\t\tlong timestamp=Long.parseLong(parts[1]);\n\t\t\tProfileAnalyzeTimeRange.checkInTimeRange(timeRanges,timestamp);\n\t\t\tString methodName=parts[2];\n\t\t\tif(!methodName.equals(ProfileAnalyzer.THREAD_END_FLAG)){\n\t\t\t\tint lineNum=Integer.parseInt(parts[3]);\n\t\t\t\tthreadSnapshots.add(new ThreadSnapshot(threadName, timestamp, methodName, lineNum));\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\treturn threadSnapshots;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\treturn parseFromFileWithTimeRange(file,timeRanges,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tSystem.out.println(\"Loading the thread snapshot from file \"+file.getName());\n\tfinal List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader br = new BufferedReader(new FileReader(file));\n\tString line;\n\tString threadName = null;\n\tint lineNumber = 0;\n\tboolean isMatched = false;\n\twhile((line = br.readLine()) != null) {\n\t\tlineNumber++;\n\t\tif(line.startsWith(\"Full thread dump\")) {\n\t\t\tthreadSnapshots.add(new ThreadSnapshot());\n\t\t}\n\t\tif(line.startsWith(\"\\\"\")) {\n\t\t\tthreadName = line.split(\"\\\"\")[1];\n\t\t\tthreadSnapshots.get(threadSnapshots.size()-1).setThreadName(threadName);\n\t\t}\n\t\tif(line.startsWith(\"java.lang.Thread.State\")) {\n\t\t\tthreadSnapshots.get(threadSnapshots.size()-1).setThreadState(line.split(\" \"", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    List<ThreadSnapshot> threadSnapshots=new ArrayList<>();\n    if(!file.exists()){\n        throw new IOException(\"The file \"+file.getAbsolutePath()+\" does not exist.\");\n    }\n    FileInputStream fileInputStream=new FileInputStream(file);\n    BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(fileInputStream));\n    String line=null;\n    try {\n        line=bufferedReader.readLine();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    while(line != null){\n        if(line.startsWith(THREAD_SNAPSHOT_PREFIX)){\n            ThreadSnapshot threadSnapshot=parseFromLine(line);\n            threadSnapshots.add(threadSnapshot);\n            try {\n                line=bufferedReader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        else if(line.startsWith(THREAD_SNAPSHOT", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    List<ThreadSnapshot> ret=new ArrayList<ThreadSnapshot>();\n    if(file.exists()){\n        BufferedReader reader=null;\n        try{\n            reader=new BufferedReader(new FileReader(file));\n            String line=null;\n            while((line=reader.readLine())!=null){\n                ThreadSnapshot threadSnapshot=ThreadSnapshot.parseFromLine(line);\n                if(threadSnapshot!=null&&timeRanges.contains(threadSnapshot.getProfileAnalyzeTimeRange())){\n                    ret.add(threadSnapshot);\n                }\n            }\n        }finally{\n            if(reader!=null){\n                reader.close();\n            }\n        }\n    }\n    return ret;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tif(!file.exists()){\n\t\tthrow new IOException(\"The file \"+file.getAbsolutePath()+\" doesn't exist!\");\n\t}\n\tList<ThreadSnapshot> threadSnapshots=new ArrayList<ThreadSnapshot>();\n\tStringBuffer fileBuffer=new StringBuffer();\n\tBufferedReader br=null;\n\ttry{\n\t\tbr=new BufferedReader(new FileReader(file));\n\t\tString line=null;\n\t\twhile((line=br.readLine())!=null) {\n\t\t\tfileBuffer.append(line+\"\\n\");\n\t\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t\treturn null;\n\t}finally{\n\t\tif(br!=null){\n\t\t\tbr.close();\n\t\t}\n\t}\n\tString fileStr=fileBuffer.toString();\n\tint cursor=0;\n\twhile(cursor!=-1){\n\t\tint nextTsStartIndex=fileStr.indexOf(ThreadSnapshot.TS_START_FLAG,c", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * load thread snapshots in appointing time range\n */\n", "method_name": "parseFromFileWithTimeRange", "codes": ["public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tList<ThreadSnapshot> threadSnapshots = parseFromFile(file);\n\tList<ThreadSnapshot> filteredThreadSnapshots = new ArrayList<ThreadSnapshot>();\n\tfor(ProfileAnalyzeTimeRange timeRange : timeRanges){\n\t\tfor(ThreadSnapshot threadSnapshot : threadSnapshots){\n\t\t\tif(timeRange.containTime(threadSnapshot.getTime())){\n\t\t\t\tfilteredThreadSnapshots.add(threadSnapshot);\n\t\t\t}\n\t\t}\n\t}\n\treturn filteredThreadSnapshots;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\treturn parseFromFileWithTimeRange(file.getCanonicalPath(),timeRanges);\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tList<ThreadSnapshot> snapshots=parseFromFile(file);\n\tList<ThreadSnapshot> ret=new ArrayList<ThreadSnapshot>();\n\tif(snapshots==null)\n\t\treturn ret;\n\tfor(ThreadSnapshot snapshot:snapshots) {\n\t\tfor(ProfileAnalyzeTimeRange timeRange:timeRanges) {\n\t\t\tif(snapshot.getTimestamp()>=timeRange.getStartTime()&&snapshot.getTimestamp()<=timeRange.getEndTime())\n\t\t\t\tret.add(snapshot);\n\t\t}\n\t}\n\treturn ret;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    String line = null;\n    List<ThreadSnapshot> snapshots = new ArrayList<ThreadSnapshot>();\n    ThreadSnapshot snapshot = null;\n    List<ProfileAnalyzeTimeRange> copyOfTimeRanges = new ArrayList<ProfileAnalyzeTimeRange>(timeRanges);\n    long time = 0;\n    while((line = reader.readLine()) != null) {\n        if(line.startsWith(ThreadSnapshot.START_TAG)) {\n            snapshot = new ThreadSnapshot();\n            snapshots.add(snapshot);\n            snapshot.parseFromLine(line);\n        } else if(line.startsWith(ThreadSnapshot.END_TAG)) {\n            snapshot.parseFromLine(line);\n            time = snapshot.getEndTime().getTime() - snapshot.getStartTime().getTime();\n            for(ProfileAnalyzeTimeRange timeRange : copyOfTimeRanges) {\n                if(time >= timeRange.getMin() && time <= timeRange.getMax()) {\n                    timeRange.increase", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\t\tList<ThreadSnapshot> threadSnapshots=new ArrayList<ThreadSnapshot>();\n\t\tBufferedReader reader=new BufferedReader(new FileReader(file));\n\t\tString line;\n\t\twhile((line=reader.readLine())!=null){\n\t\t\tString[] parts=line.split(\";\");\n\t\t\tString threadName=parts[0];\n\t\t\tlong timestamp=Long.parseLong(parts[1]);\n\t\t\tProfileAnalyzeTimeRange.checkInTimeRange(timeRanges,timestamp);\n\t\t\tString methodName=parts[2];\n\t\t\tif(!methodName.equals(ProfileAnalyzer.THREAD_END_FLAG)){\n\t\t\t\tint lineNum=Integer.parseInt(parts[3]);\n\t\t\t\tthreadSnapshots.add(new ThreadSnapshot(threadName, timestamp, methodName, lineNum));\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\treturn threadSnapshots;\n\t}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\treturn parseFromFileWithTimeRange(file,timeRanges,false);\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tSystem.out.println(\"Loading the thread snapshot from file \"+file.getName());\n\tfinal List<ThreadSnapshot> threadSnapshots = new ArrayList<ThreadSnapshot>();\n\tBufferedReader br = new BufferedReader(new FileReader(file));\n\tString line;\n\tString threadName = null;\n\tint lineNumber = 0;\n\tboolean isMatched = false;\n\twhile((line = br.readLine()) != null) {\n\t\tlineNumber++;\n\t\tif(line.startsWith(\"Full thread dump\")) {\n\t\t\tthreadSnapshots.add(new ThreadSnapshot());\n\t\t}\n\t\tif(line.startsWith(\"\\\"\")) {\n\t\t\tthreadName = line.split(\"\\\"\")[1];\n\t\t\tthreadSnapshots.get(threadSnapshots.size()-1).setThreadName(threadName);\n\t\t}\n\t\tif(line.startsWith(\"java.lang.Thread.State\")) {\n\t\t\tthreadSnapshots.get(threadSnapshots.size()-1).setThreadState(line.split(\" \"", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    List<ThreadSnapshot> threadSnapshots=new ArrayList<>();\n    if(!file.exists()){\n        throw new IOException(\"The file \"+file.getAbsolutePath()+\" does not exist.\");\n    }\n    FileInputStream fileInputStream=new FileInputStream(file);\n    BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(fileInputStream));\n    String line=null;\n    try {\n        line=bufferedReader.readLine();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    while(line != null){\n        if(line.startsWith(THREAD_SNAPSHOT_PREFIX)){\n            ThreadSnapshot threadSnapshot=parseFromLine(line);\n            threadSnapshots.add(threadSnapshot);\n            try {\n                line=bufferedReader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        else if(line.startsWith(THREAD_SNAPSHOT", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n    List<ThreadSnapshot> ret=new ArrayList<ThreadSnapshot>();\n    if(file.exists()){\n        BufferedReader reader=null;\n        try{\n            reader=new BufferedReader(new FileReader(file));\n            String line=null;\n            while((line=reader.readLine())!=null){\n                ThreadSnapshot threadSnapshot=ThreadSnapshot.parseFromLine(line);\n                if(threadSnapshot!=null&&timeRanges.contains(threadSnapshot.getProfileAnalyzeTimeRange())){\n                    ret.add(threadSnapshot);\n                }\n            }\n        }finally{\n            if(reader!=null){\n                reader.close();\n            }\n        }\n    }\n    return ret;\n}", "public static List<ThreadSnapshot> parseFromFileWithTimeRange(File file,List<ProfileAnalyzeTimeRange> timeRanges) throws IOException {\n\n\tif(!file.exists()){\n\t\tthrow new IOException(\"The file \"+file.getAbsolutePath()+\" doesn't exist!\");\n\t}\n\tList<ThreadSnapshot> threadSnapshots=new ArrayList<ThreadSnapshot>();\n\tStringBuffer fileBuffer=new StringBuffer();\n\tBufferedReader br=null;\n\ttry{\n\t\tbr=new BufferedReader(new FileReader(file));\n\t\tString line=null;\n\t\twhile((line=br.readLine())!=null) {\n\t\t\tfileBuffer.append(line+\"\\n\");\n\t\t}\n\t}catch(Exception e){\n\t\te.printStackTrace();\n\t\treturn null;\n\t}finally{\n\t\tif(br!=null){\n\t\t\tbr.close();\n\t\t}\n\t}\n\tString fileStr=fileBuffer.toString();\n\tint cursor=0;\n\twhile(cursor!=-1){\n\t\tint nextTsStartIndex=fileStr.indexOf(ThreadSnapshot.TS_START_FLAG,c"], "code_level": "project_runnable", "_id": "636767e11a6d9265ec018790", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n    JsonObject jsonProperties = new JsonObject();\n    properties.forEach(p -> {\n        if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-1\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-1\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-2\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-2\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-3\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-3\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX +", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject propertiesJson = new JsonObject();\n\tfor (KeyStringValuePair pair : properties) {\n\t\tpropertiesJson.addProperty(pair.getKey(), pair.getValue());\n\t}\n\treturn propertiesJson;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject processPropertyJson = new JsonObject();\n\tif(properties!=null){\n\t\tfor(KeyStringValuePair property:properties){\n\t\t\tprocessPropertyJson.addProperty(property.getKey(), property.getValue());\n\t\t}\n\t}\n\treturn processPropertyJson;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonObject = new JsonObject();\n\tfor (KeyStringValuePair property : properties) {\n\t\tjsonObject.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject json = new JsonObject();\n\tfor(KeyStringValuePair pair : properties){\n\t\tjson.addProperty(pair.getKey(), pair.getValue());\n\t}\n\treturn json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject processProperties = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tprocessProperties.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn processProperties;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject json = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tjson.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn json;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\t\t\n\t\tJsonObject jsonObject = new JsonObject();\n\t\t\n\t\tfor (KeyStringValuePair property : properties) {\n\t\t\t\n\t\t\tif(property.getKey().equals(\"image\")){\n\t\t\t\tjsonObject.addProperty(\"image\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"tag\")){\n\t\t\t\tjsonObject.addProperty(\"tag\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"useDockerfile\")){\n\t\t\t\tjsonObject.addProperty(\"useDockerfile\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"dockerfile\")){\n\t\t\t\tjsonObject.addProperty(\"dockerfile\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"dockerfilePath\")){\n\t\t\t\tjsonObject.addProperty(\"dockerfilePath", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonProperties = new JsonObject();\n\tfor(KeyStringValuePair property:properties){\n\t\tjsonProperties.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonProperties;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonObject = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tjsonObject.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonObject;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Convert process properties to source data\n */\n", "method_name": "convertProperties", "codes": ["private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n    JsonObject jsonProperties = new JsonObject();\n    properties.forEach(p -> {\n        if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-1\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-1\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-2\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-2\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX + \"user-defined-property-3\")) {\n            jsonProperties.addProperty(PROCESS_KEY_PREFIX + \"user-defined-property-3\", (String) p.getValue());\n        } else if (p.getKey().equals(PROCESS_KEY_PREFIX +", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject propertiesJson = new JsonObject();\n\tfor (KeyStringValuePair pair : properties) {\n\t\tpropertiesJson.addProperty(pair.getKey(), pair.getValue());\n\t}\n\treturn propertiesJson;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject processPropertyJson = new JsonObject();\n\tif(properties!=null){\n\t\tfor(KeyStringValuePair property:properties){\n\t\t\tprocessPropertyJson.addProperty(property.getKey(), property.getValue());\n\t\t}\n\t}\n\treturn processPropertyJson;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonObject = new JsonObject();\n\tfor (KeyStringValuePair property : properties) {\n\t\tjsonObject.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonObject;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject json = new JsonObject();\n\tfor(KeyStringValuePair pair : properties){\n\t\tjson.addProperty(pair.getKey(), pair.getValue());\n\t}\n\treturn json;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject processProperties = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tprocessProperties.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn processProperties;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject json = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tjson.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn json;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\t\t\n\t\tJsonObject jsonObject = new JsonObject();\n\t\t\n\t\tfor (KeyStringValuePair property : properties) {\n\t\t\t\n\t\t\tif(property.getKey().equals(\"image\")){\n\t\t\t\tjsonObject.addProperty(\"image\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"tag\")){\n\t\t\t\tjsonObject.addProperty(\"tag\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"useDockerfile\")){\n\t\t\t\tjsonObject.addProperty(\"useDockerfile\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"dockerfile\")){\n\t\t\t\tjsonObject.addProperty(\"dockerfile\", property.getValue());\n\t\t\t}\n\t\t\t\n\t\t\tif(property.getKey().equals(\"dockerfilePath\")){\n\t\t\t\tjsonObject.addProperty(\"dockerfilePath", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonProperties = new JsonObject();\n\tfor(KeyStringValuePair property:properties){\n\t\tjsonProperties.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonProperties;\n}", "private JsonObject convertProperties(List<KeyStringValuePair> properties){\n\n\tJsonObject jsonObject = new JsonObject();\n\tfor(KeyStringValuePair property : properties){\n\t\tjsonObject.addProperty(property.getKey(), property.getValue());\n\t}\n\treturn jsonObject;\n}"], "code_level": "project_runnable", "_id": "636767e01a6d9265ec018764", "project_name": "skywalking-master"}
{"generate_results": [{"generate_code": "private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\tint type=outputFrame.pop();\n\tif(type==-1)\n\t\treturn -1;\n\tif(type>=0)\n\t\treturn type;\n\treturn -(type+1);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\treturn output_stack[--stack_ptr];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n    if(stack.isEmpty()) throw new IllegalStateException(\"Stack is empty!\");\n    return stack.pop();\n\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\treturn frame_stack[--current_stack_pointer];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n    int x = frameStack.pop();\n    return x;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\tint v=output[--output_pos];\n\tif(v>=0) return v;\n\tif(v==-1){\n\t\t//System.out.println(\"pop int\");\n\t\treturn output_int[--output_int_pos];\n\t}\n\t//System.out.println(\"pop long\");\n\treturn (int)output_long[--output_long_pos];\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private int pop(){\n\n\tint top=out_stack[out_top];\n\tout_top--;\n\treturn top;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops an abstract type from the output frame stack and returns its value.\n * @return the abstract type that has been popped from the output frame stack.\n */\n", "method_name": "pop", "codes": ["private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "private int pop(){\n\n\tint type=outputFrame.pop();\n\tif(type==-1)\n\t\treturn -1;\n\tif(type>=0)\n\t\treturn type;\n\treturn -(type+1);\n}", "private int pop(){\n\n\treturn output_stack[--stack_ptr];\n}", "private int pop(){\n\n    if(stack.isEmpty()) throw new IllegalStateException(\"Stack is empty!\");\n    return stack.pop();\n\n}", "private int pop(){\n\n\treturn frame_stack[--current_stack_pointer];\n}", "private int pop(){\n\n\treturn outputFrameStack.pop();\n}", "private int pop(){\n\n    int x = frameStack.pop();\n    return x;\n}", "private int pop(){\n\n\tint v=output[--output_pos];\n\tif(v>=0) return v;\n\tif(v==-1){\n\t\t//System.out.println(\"pop int\");\n\t\treturn output_int[--output_int_pos];\n\t}\n\t//System.out.println(\"pop long\");\n\treturn (int)output_long[--output_long_pos];\n}", "private int pop(){\n\n\tint top=out_stack[out_top];\n\tout_top--;\n\treturn top;\n}"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c2", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tfinal int frameSize = (numLocal + numStack);\n\tif(frameSize > currentFrame.length){\n\t\tcurrentFrame = new int[frameSize];\n\t}\n\tcurrentFrameOffset = offset;\n\tcurrentFrameLocalCount = numLocal;\n\tcurrentFrameStackCount = numStack;\n\t\n\treturn 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tfinal int currAddr = getCurrAddr();\n\tfinal int nextAddr = currAddr + offset;\n\tsetCurrAddr(nextAddr);\n\tfinal int numLocalStack = numLocal + numStack;\n\tfinal int[] currFrame = new int[numLocalStack];\n\tpushFrame(currFrame);\n\treturn 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tcurrentFrame=new Frame(offset,numLocal,numStack);\n\treturn 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n    final Frame currentFrame=new Frame(offset,numLocal,numStack);\n    if(offset<currentFrame.getOffset()){/**offset\u5c0f\u4e8ecurrentFrame.getOffset()\u65f6**/\n        currentFrame.setOffset(offset);\n    }\n    currentFrame.setLocalCount(currentFrame.getLocalCount()+numLocal);\n    currentFrame.setStackCount(numStack);\n    /**\u5c06currentFrame\u52a0\u5165\u5230frameList\u4e2d\u53bb**/\n    frameList.add(currentFrame);\n    return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n  final int currentFrame=frameCount++;\n  if(currentFrame>=frameOffsets.length){\n    int[] newOffsets=new int[frameOffsets.length*2];\n    System.arraycopy(frameOffsets,0,newOffsets,0,frameOffsets.length);\n    frameOffsets=newOffsets;\n  }\n  frameOffsets[currentFrame]=offset;\n  stackMap.putFrame(currentFrame,offset,numLocal,numStack);\n  return currentFrame;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\treturn 3;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n    if(numLocal>0)\n        printf(\"\\t.locals init (%d)\\n\",numLocal);\n    printf(\"\\t.maxstack %d\\n\",numStack);\n    return 3;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tif(curFrame == NULL){\n\t\tcurFrame = (Frame*)malloc(sizeof(Frame));\n\t\tcurFrame->offset = offset;\n\t\tcurFrame->numLocal = numLocal;\n\t\tcurFrame->numStack = numStack;\n\t\tcurFrame->next = NULL;\n\t\tcurFrame->prev = NULL;\n\t\treturn 3;\n\t}\n\telse{\n\t\tFrame* newFrame = (Frame*)malloc(sizeof(Frame));\n\t\tnewFrame->offset = offset;\n\t\tnewFrame->numLocal = numLocal;\n\t\tnewFrame->numStack = numStack;\n\t\tnewFrame->next = NULL;\n\t\tnewFrame->prev = curFrame;\n\t\tcurFrame->next = newFrame;\n\t\tcurFrame = curFrame->next;\n\t\treturn 3;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tint size = numLocal + numStack;\n\t/*\n\tif(size > 0){\n\t\treturn 3;\n\t}else{\n\t\treturn 0;\n\t}\n\t*/\n\treturn 3;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n   if(offset<0) return 1;\n   if(numLocal<0) return 2;\n   if(numStack<0) return 3;\n   currentFrame=new Frame(offset,numLocal,numStack);\n   return 0;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Starts the visit of a new stack map frame, stored in  {@link #currentFrame}.\n * @param offset   the bytecode offset of the instruction to which the frame corresponds.\n * @param numLocal the number of local variables in the frame.\n * @param numStack the number of stack elements in the frame.\n * @return the index of the next element to be written in this frame.\n */\n", "method_name": "visitFrameStart", "codes": ["int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tfinal int frameSize = (numLocal + numStack);\n\tif(frameSize > currentFrame.length){\n\t\tcurrentFrame = new int[frameSize];\n\t}\n\tcurrentFrameOffset = offset;\n\tcurrentFrameLocalCount = numLocal;\n\tcurrentFrameStackCount = numStack;\n\t\n\treturn 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tfinal int currAddr = getCurrAddr();\n\tfinal int nextAddr = currAddr + offset;\n\tsetCurrAddr(nextAddr);\n\tfinal int numLocalStack = numLocal + numStack;\n\tfinal int[] currFrame = new int[numLocalStack];\n\tpushFrame(currFrame);\n\treturn 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tcurrentFrame=new Frame(offset,numLocal,numStack);\n\treturn 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n    final Frame currentFrame=new Frame(offset,numLocal,numStack);\n    if(offset<currentFrame.getOffset()){/**offset\u5c0f\u4e8ecurrentFrame.getOffset()\u65f6**/\n        currentFrame.setOffset(offset);\n    }\n    currentFrame.setLocalCount(currentFrame.getLocalCount()+numLocal);\n    currentFrame.setStackCount(numStack);\n    /**\u5c06currentFrame\u52a0\u5165\u5230frameList\u4e2d\u53bb**/\n    frameList.add(currentFrame);\n    return 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n  final int currentFrame=frameCount++;\n  if(currentFrame>=frameOffsets.length){\n    int[] newOffsets=new int[frameOffsets.length*2];\n    System.arraycopy(frameOffsets,0,newOffsets,0,frameOffsets.length);\n    frameOffsets=newOffsets;\n  }\n  frameOffsets[currentFrame]=offset;\n  stackMap.putFrame(currentFrame,offset,numLocal,numStack);\n  return currentFrame;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\treturn 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n    if(numLocal>0)\n        printf(\"\\t.locals init (%d)\\n\",numLocal);\n    printf(\"\\t.maxstack %d\\n\",numStack);\n    return 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tif(curFrame == NULL){\n\t\tcurFrame = (Frame*)malloc(sizeof(Frame));\n\t\tcurFrame->offset = offset;\n\t\tcurFrame->numLocal = numLocal;\n\t\tcurFrame->numStack = numStack;\n\t\tcurFrame->next = NULL;\n\t\tcurFrame->prev = NULL;\n\t\treturn 3;\n\t}\n\telse{\n\t\tFrame* newFrame = (Frame*)malloc(sizeof(Frame));\n\t\tnewFrame->offset = offset;\n\t\tnewFrame->numLocal = numLocal;\n\t\tnewFrame->numStack = numStack;\n\t\tnewFrame->next = NULL;\n\t\tnewFrame->prev = curFrame;\n\t\tcurFrame->next = newFrame;\n\t\tcurFrame = curFrame->next;\n\t\treturn 3;\n\t}\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n\tint size = numLocal + numStack;\n\t/*\n\tif(size > 0){\n\t\treturn 3;\n\t}else{\n\t\treturn 0;\n\t}\n\t*/\n\treturn 3;\n}", "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n\n   if(offset<0) return 1;\n   if(numLocal<0) return 2;\n   if(numStack<0) return 3;\n   currentFrame=new Frame(offset,numLocal,numStack);\n   return 0;\n}"], "code_level": "self_contained", "_id": "636766aa1a6d9265ec0175ce", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "private void enlarge(final int size){\n\n\tfinal int[] newdata=new int[size];\n\tSystem.arraycopy(data, 0, newdata, 0, data.length);\n\tdata=newdata;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tint[] newArray=new int[size];\n\tfor(int i=0;i<data.length;i++)\n\t\tnewArray[i]=data[i];\n\tdata=newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size>=data.length){\n\t\tfinal int newSize=size<(2*data.length)?(2*data.length):(size+size/2);\n\t\tassert(newSize>size) : size+\", \"+newSize;\n\t\tfinal int[] temp=new int[newSize];\n\t\tfor(int i=0; i<size; i++){temp[i]=data[i];}\n\t\tdata=temp;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n    double[] newData=new double[size];\n    for(int i=0;i<data.length;i++)\n        newData[i]=data[i];\n    data=newData;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\t//System.out.println(\"Enlarging from \"+data.length+\" to \"+size);\n\tbyte[] temp=new byte[size];\n\tSystem.arraycopy(data, 0, temp, 0, data.length);\n\tdata=temp;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size<=data.length) return;\n\tbyte[] old=data;\n\tdata=new byte[size];\n\tfor(int i=0; i<old.length; i++){data[i]=old[i];}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tint[] newArray = new int[size];\n\tfor (int i = 0; i < data.length; i++) {\n\t\tnewArray[i] = data[i];\n\t}\n\tdata = newArray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\t//Check if the original data array is null\n\tif(data==null){\n\t\t//Create a new data array\n\t\tdata=new double[size];\n\t\treturn;\n\t\t}\n\t//Create a new data array\n\tdouble[] newData=new double[size];\n\t//Copy the data\n\tSystem.arraycopy(data,0,newData,0,data.length);\n\t//Set the new data array\n\tdata=newData;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tfinal int[] newarray=new int[size];\n\tSystem.arraycopy(array, 0, newarray, 0, array.length);\n\tarray=newarray;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void enlarge(final int size){\n\n\tif(size>=data.length){\n\t\tint[] newdata=new int[size*2];\n\t\tfor(int i=0;i<data.length;i++){newdata[i]=data[i];}\n\t\tdata=newdata;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Enlarges this byte vector so that it can receive 'size' more bytes.\n * @param size number of additional bytes that this byte vector should be able to receive.\n */\n", "method_name": "enlarge", "codes": ["private void enlarge(final int size){\n\n\tfinal int[] newdata=new int[size];\n\tSystem.arraycopy(data, 0, newdata, 0, data.length);\n\tdata=newdata;\n}", "private void enlarge(final int size){\n\n\tint[] newArray=new int[size];\n\tfor(int i=0;i<data.length;i++)\n\t\tnewArray[i]=data[i];\n\tdata=newArray;\n}", "private void enlarge(final int size){\n\n\tif(size>=data.length){\n\t\tfinal int newSize=size<(2*data.length)?(2*data.length):(size+size/2);\n\t\tassert(newSize>size) : size+\", \"+newSize;\n\t\tfinal int[] temp=new int[newSize];\n\t\tfor(int i=0; i<size; i++){temp[i]=data[i];}\n\t\tdata=temp;\n\t}\n}", "private void enlarge(final int size){\n\n    double[] newData=new double[size];\n    for(int i=0;i<data.length;i++)\n        newData[i]=data[i];\n    data=newData;\n}", "private void enlarge(final int size){\n\n\t//System.out.println(\"Enlarging from \"+data.length+\" to \"+size);\n\tbyte[] temp=new byte[size];\n\tSystem.arraycopy(data, 0, temp, 0, data.length);\n\tdata=temp;\n}", "private void enlarge(final int size){\n\n\tif(size<=data.length) return;\n\tbyte[] old=data;\n\tdata=new byte[size];\n\tfor(int i=0; i<old.length; i++){data[i]=old[i];}\n}", "private void enlarge(final int size){\n\n\tint[] newArray = new int[size];\n\tfor (int i = 0; i < data.length; i++) {\n\t\tnewArray[i] = data[i];\n\t}\n\tdata = newArray;\n}", "private void enlarge(final int size){\n\n\t//Check if the original data array is null\n\tif(data==null){\n\t\t//Create a new data array\n\t\tdata=new double[size];\n\t\treturn;\n\t\t}\n\t//Create a new data array\n\tdouble[] newData=new double[size];\n\t//Copy the data\n\tSystem.arraycopy(data,0,newData,0,data.length);\n\t//Set the new data array\n\tdata=newData;\n\t}", "private void enlarge(final int size){\n\n\tfinal int[] newarray=new int[size];\n\tSystem.arraycopy(array, 0, newarray, 0, array.length);\n\tarray=newarray;\n}", "private void enlarge(final int size){\n\n\tif(size>=data.length){\n\t\tint[] newdata=new int[size*2];\n\t\tfor(int i=0;i<data.length;i++){newdata[i]=data[i];}\n\t\tdata=newdata;\n\t}\n}"], "code_level": "self_contained", "_id": "636766a91a6d9265ec0175c1", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nsuper.putByteArray(byteArrayValue,byteOffset,byteLength);\nreturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint byteNewLength=this.length+byteLength;\n\tif(byteNewLength>this.data.length){\n\t\tthis.enlarge(byteNewLength);\n\t}\n\tif(byteLength!=0){\n\t\tSystem.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\n\t\tthis.length=byteNewLength;\n\t}\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nint byteLengthToCopy=byteLength;\nif((this.length+byteLengthToCopy)>this.data.length)\n{this.enlarge(byteLengthToCopy);}\nif(byteLengthToCopy<=8)\n{int byteOffsetInData=this.length;\nthis.length+=byteLengthToCopy;\nswitch(byteLengthToCopy)\n{case 8:this.data[byteOffsetInData+7]=(byte)byteArrayValue[byteOffset+7];\ncase 7:this.data[byteOffsetInData+6]=(byte)byteArrayValue[byteOffset+6];\ncase 6:this.data[byteOffsetInData+5]=(byte)byteArrayValue[byteOffset+5];\ncase 5:this.data[byteOffsetInData+4]=(byte)byteArrayValue[byteOffset+4];\ncase 4:this.data[byteOffsetInData+3]=(byte)byteArrayValue[byteOffset+3];\ncase 3:this.data[byteOffsetInData+2]=(byte)byteArrayValue[byteOffset+2];\ncase 2:this.data[byteOffset", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n//#ifdef DEBUG\nif(byteArrayValue==null){throw new NullPointerException(\"byteArrayValue\");}\n//#endif\nif(byteOffset<0){throw new ArrayIndexOutOfBoundsException(byteOffset);}\nif(byteLength<0){throw new ArrayIndexOutOfBoundsException(byteLength);}\nif(byteLength>byteArrayValue.length-byteOffset){throw new ArrayIndexOutOfBoundsException(byteLength);}\nif(byteLength>0){\n//#ifdef DEBUG\nif(this.byteArray==null){throw new IllegalStateException();}\n//#endif\n//#ifdef DEBUG\nif(this.byteArray.length<this.byteLength+byteLength){throw new IllegalArgumentException();}\n//#endif\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.byteLength,byteLength);\nthis.byteLength+=byteLength;\n}\nreturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int newByteLength=this.byteLength+byteLength;\n\tif(newByteLength>this.byteVector.length)\n\t\tthis.resizeByteVector(newByteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,this.byteVector,this.byteLength,byteLength);\n\tthis.byteLength=newByteLength;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nfor(int byteIndex=0;byteIndex<byteLength;byteIndex++){\nputByte(byteArrayValue[byteOffset+byteIndex]);\n}\nreturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nif(byteLength>=0){\nfinal int byteCapacity=this.byteCapacity;\nfinal int byteCount=this.byteCount;\nfinal int newByteCount=byteCount+byteLength;\nif(newByteCount>byteCapacity){\nthis.ensureByteCapacity(newByteCount);\n}\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,byteCount,byteLength);\nthis.byteCount=newByteCount;\nreturn this;\n}\nthrow new IllegalArgumentException();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int newLength=this.length+byteLength;\n\tif(newLength>this.data.length){\n\t\t/*EnsureCapacity(newLength);*/\n\t\tfinal int newCapacity=Math.max(this.length+this.length,newLength);\n\t\tfinal byte[] newData=new byte[newCapacity];\n\t\t/*System.arraycopy(this.data,0,newData,0,this.length);*/\n\t\tUnsafe.arraycopy(this.data,0,newData,0,this.length);\n\t\tthis.data=newData;\n\t}\n\t/*System.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);*/\n\tUnsafe.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\n\tthis.length=newLength;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nthis.ensureCapacity(this.length+byteLength);\nSystem.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\nthis.length+=byteLength;\nreturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nreturn this.putByteArray(byteArrayValue,byteOffset,byteLength,0);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n", "method_name": "putByteArray", "codes": ["public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nsuper.putByteArray(byteArrayValue,byteOffset,byteLength);\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tint byteNewLength=this.length+byteLength;\n\tif(byteNewLength>this.data.length){\n\t\tthis.enlarge(byteNewLength);\n\t}\n\tif(byteLength!=0){\n\t\tSystem.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\n\t\tthis.length=byteNewLength;\n\t}\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nint byteLengthToCopy=byteLength;\nif((this.length+byteLengthToCopy)>this.data.length)\n{this.enlarge(byteLengthToCopy);}\nif(byteLengthToCopy<=8)\n{int byteOffsetInData=this.length;\nthis.length+=byteLengthToCopy;\nswitch(byteLengthToCopy)\n{case 8:this.data[byteOffsetInData+7]=(byte)byteArrayValue[byteOffset+7];\ncase 7:this.data[byteOffsetInData+6]=(byte)byteArrayValue[byteOffset+6];\ncase 6:this.data[byteOffsetInData+5]=(byte)byteArrayValue[byteOffset+5];\ncase 5:this.data[byteOffsetInData+4]=(byte)byteArrayValue[byteOffset+4];\ncase 4:this.data[byteOffsetInData+3]=(byte)byteArrayValue[byteOffset+3];\ncase 3:this.data[byteOffsetInData+2]=(byte)byteArrayValue[byteOffset+2];\ncase 2:this.data[byteOffset", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n//#ifdef DEBUG\nif(byteArrayValue==null){throw new NullPointerException(\"byteArrayValue\");}\n//#endif\nif(byteOffset<0){throw new ArrayIndexOutOfBoundsException(byteOffset);}\nif(byteLength<0){throw new ArrayIndexOutOfBoundsException(byteLength);}\nif(byteLength>byteArrayValue.length-byteOffset){throw new ArrayIndexOutOfBoundsException(byteLength);}\nif(byteLength>0){\n//#ifdef DEBUG\nif(this.byteArray==null){throw new IllegalStateException();}\n//#endif\n//#ifdef DEBUG\nif(this.byteArray.length<this.byteLength+byteLength){throw new IllegalArgumentException();}\n//#endif\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,this.byteLength,byteLength);\nthis.byteLength+=byteLength;\n}\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int newByteLength=this.byteLength+byteLength;\n\tif(newByteLength>this.byteVector.length)\n\t\tthis.resizeByteVector(newByteLength);\n\tSystem.arraycopy(byteArrayValue,byteOffset,this.byteVector,this.byteLength,byteLength);\n\tthis.byteLength=newByteLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nfor(int byteIndex=0;byteIndex<byteLength;byteIndex++){\nputByte(byteArrayValue[byteOffset+byteIndex]);\n}\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nif(byteLength>=0){\nfinal int byteCapacity=this.byteCapacity;\nfinal int byteCount=this.byteCount;\nfinal int newByteCount=byteCount+byteLength;\nif(newByteCount>byteCapacity){\nthis.ensureByteCapacity(newByteCount);\n}\nSystem.arraycopy(byteArrayValue,byteOffset,this.byteArray,byteCount,byteLength);\nthis.byteCount=newByteCount;\nreturn this;\n}\nthrow new IllegalArgumentException();\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\n\tfinal int newLength=this.length+byteLength;\n\tif(newLength>this.data.length){\n\t\t/*EnsureCapacity(newLength);*/\n\t\tfinal int newCapacity=Math.max(this.length+this.length,newLength);\n\t\tfinal byte[] newData=new byte[newCapacity];\n\t\t/*System.arraycopy(this.data,0,newData,0,this.length);*/\n\t\tUnsafe.arraycopy(this.data,0,newData,0,this.length);\n\t\tthis.data=newData;\n\t}\n\t/*System.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);*/\n\tUnsafe.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\n\tthis.length=newLength;\n\treturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nthis.ensureCapacity(this.length+byteLength);\nSystem.arraycopy(byteArrayValue,byteOffset,this.data,this.length,byteLength);\nthis.length+=byteLength;\nreturn this;\n}", "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n\nreturn this.putByteArray(byteArrayValue,byteOffset,byteLength,0);\n}"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175ae", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "private void pop(final int elements){\n\n\tfor(int i = 0; i < elements; i++){\n\t\tif(stack.size() > 0){\n\t\t\tstack.remove(stack.size() - 1);\n\t\t}else{\n\t\t\tthrow new IllegalArgumentException(\"Stack is empty!\");\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\tfor(int i=0;i<elements;i++){\n\t\tstack.pop();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\tif(elements>stack.size())throw new IllegalArgumentException(\"too many elements to pop\");\n\tint i=0;\n\twhile(i<elements){\n\t\tstack.pop();\n\t\ti++;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\nfor(int i=elements;i>0;i--)stack.pop();}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\twhile(elements>0){\n\t\tstack.pop();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\tfinal int pop = elements*4;\n\tif(pop > sp){\n\t\tthrow new IllegalStateException(\"Stack underflow\");\n\t}\n\tsp -= pop;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\tif (stackPointer > elements){\n\t\tstackPointer -= elements;\n\t}\n\telse{\n\t\tstackPointer = 0;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\tfinal int newIndex=this.stackSize-elements;\n\tif(newIndex<0) throw new IndexOutOfBoundsException(\n\t\t\"Trying to remove more elements than there are on the stack.\");\n\tthis.stackSize=newIndex;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n\t//System.out.println(\"POP \" + elements);\n\tfor(int i = 0; i < elements; i++){\n\t\tstack.pop();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final int elements){\n\n    for(int i=0;i<elements;i++)\n        stack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops the given number of abstract types from the output frame stack.\n * @param elements the number of abstract types that must be popped.\n */\n", "method_name": "pop", "codes": ["private void pop(final int elements){\n\n\tfor(int i = 0; i < elements; i++){\n\t\tif(stack.size() > 0){\n\t\t\tstack.remove(stack.size() - 1);\n\t\t}else{\n\t\t\tthrow new IllegalArgumentException(\"Stack is empty!\");\n\t\t}\n\t}\n}", "private void pop(final int elements){\n\n\tfor(int i=0;i<elements;i++){\n\t\tstack.pop();\n\t}\n}", "private void pop(final int elements){\n\n\tif(elements>stack.size())throw new IllegalArgumentException(\"too many elements to pop\");\n\tint i=0;\n\twhile(i<elements){\n\t\tstack.pop();\n\t\ti++;\n\t}\n}", "private void pop(final int elements){\nfor(int i=elements;i>0;i--)stack.pop();}", "private void pop(final int elements){\n\n\twhile(elements>0){\n\t\tstack.pop();\n\t}\n}", "private void pop(final int elements){\n\n\tfinal int pop = elements*4;\n\tif(pop > sp){\n\t\tthrow new IllegalStateException(\"Stack underflow\");\n\t}\n\tsp -= pop;\n}", "private void pop(final int elements){\n\n\tif (stackPointer > elements){\n\t\tstackPointer -= elements;\n\t}\n\telse{\n\t\tstackPointer = 0;\n\t}\n}", "private void pop(final int elements){\n\n\tfinal int newIndex=this.stackSize-elements;\n\tif(newIndex<0) throw new IndexOutOfBoundsException(\n\t\t\"Trying to remove more elements than there are on the stack.\");\n\tthis.stackSize=newIndex;\n}", "private void pop(final int elements){\n\n\t//System.out.println(\"POP \" + elements);\n\tfor(int i = 0; i < elements; i++){\n\t\tstack.pop();\n\t}\n}", "private void pop(final int elements){\n\n    for(int i=0;i<elements;i++)\n        stack.pop();\n}"], "code_level": "self_contained", "_id": "636766a81a6d9265ec017586", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public ByteVector putInt(final int intValue){\n\n    final int byteCapacity=data.length;\n    if(index+4>byteCapacity)data=Arrays.copyOf(data,Math.max(2*byteCapacity,index+4));\n    int temp=intValue;\n    for(int i=0;i<4;i++){\n        data[index++]=(byte)temp;\n        temp>>>=8;\n    }\n    return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\tif(this.data.length<this.length+4){\n\t\tenlarge(4);\n\t}\n\tbyte[] data=this.data;\n\tint length=this.length;\n\tdata[length++]=(byte)(intValue>>>24);\n\tdata[length++]=(byte)(intValue>>>16);\n\tdata[length++]=(byte)(intValue>>>8);\n\tdata[length++]=(byte)intValue;\n\tthis.length=length;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\n    int size=data.length;\n    if(count+3>=size){\n        enlarge(3);\n    }\n    byte[] buf=data;\n    int i=count;\n    buf[i++]=(byte)(intValue>>>24);\n    buf[i++]=(byte)(intValue>>>16);\n    buf[i++]=(byte)(intValue>>>8);\n    buf[i++]=(byte)intValue;\n    count=i;\n    return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\tbyte[] buf = new byte[4];\n\tint i = 0;\n\tbuf[i++] = (byte)((intValue & 0xff000000) >> 24);\n\tbuf[i++] = (byte)((intValue & 0x00ff0000) >> 16);\n\tbuf[i++] = (byte)((intValue & 0x0000ff00) >> 8);\n\tbuf[i++] = (byte)(intValue & 0x000000ff);\n\tthis.putByteArray(buf, 0, 4);\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n    int size=this.length;\n    if(size+4>this.data.length){\n        enlarge(4);//\u6269\u5927byte\u6570\u7ec4\n    }\n    byte[] data=this.data;//byte\u6570\u7ec4\n    data[size++]=(byte)(intValue>>>24);//\u9ad8\u4f4dbyte\n    data[size++]=(byte)(intValue>>>16);//\u6b21\u9ad8\u4f4dbyte\n    data[size++]=(byte)(intValue>>>8);//\u6b21\u4f4e\u4f4dbyte\n    data[size++]=(byte)intValue;//\u4f4e\u4f4dbyte\n    this.length=size;\n    return this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\tint currentLength=data.length;\n\tif(currentLength+4>data.length){\n\t\tint newLength=currentLength*2;\n\t\tbyte[] newData=new byte[newLength];\n\t\tSystem.arraycopy(data,0,newData,0,currentLength);\n\t\tdata=newData;\n\t}\n\tint value=intValue;\n\tdata[currentLength++]=(byte)(value>>>24);\n\tdata[currentLength++]=(byte)(value>>>16);\n\tdata[currentLength++]=(byte)(value>>>8);\n\tdata[currentLength++]=(byte)value;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n    int size=this.size;\n    if(size+4>this.data.length)\n        enlarge(4);\n    byte[] data=this.data;\n    data[size++]=(byte)(intValue>>>24);\n    data[size++]=(byte)(intValue>>>16);\n    data[size++]=(byte)(intValue>>>8);\n    data[size++]=(byte)intValue;\n    this.size=size;\n    return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\tint length = data.size();\n\tif(length + 4 > data.capacity()){\n\t\tdata.ensureCapacity(length + 4);\n\t}\n\tdata.add(intValue >>> 24);\n\tdata.add(intValue >>> 16);\n\tdata.add(intValue >>> 8);\n\tdata.add(intValue);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n\tif(data==null){\n\t\tdata=new byte[4];\n\t}\n\tif(data.length<4){\n\t\tbyte[] newData=new byte[4];\n\t\tSystem.arraycopy(data,0,newData,4-data.length,data.length);\n\t\tdata=newData;\n\t}\n\tdata[0]=(byte)(intValue>>>24);\n\tdata[1]=(byte)(intValue>>>16);\n\tdata[2]=(byte)(intValue>>>8);\n\tdata[3]=(byte)(intValue);\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public ByteVector putInt(final int intValue){\n\n    int size=this.size;\n    if(size+4>data.length){\n        enlarge(4);\n    }\n    byte[] data=this.data;\n    data[size++]=(byte)(intValue>>>24);\n    data[size++]=(byte)(intValue>>>16);\n    data[size++]=(byte)(intValue>>>8);\n    data[size++]=(byte)intValue;\n    this.size=size;\n    return this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n", "method_name": "putInt", "codes": ["public ByteVector putInt(final int intValue){\n\n    final int byteCapacity=data.length;\n    if(index+4>byteCapacity)data=Arrays.copyOf(data,Math.max(2*byteCapacity,index+4));\n    int temp=intValue;\n    for(int i=0;i<4;i++){\n        data[index++]=(byte)temp;\n        temp>>>=8;\n    }\n    return this;\n}", "public ByteVector putInt(final int intValue){\n\n\tif(this.data.length<this.length+4){\n\t\tenlarge(4);\n\t}\n\tbyte[] data=this.data;\n\tint length=this.length;\n\tdata[length++]=(byte)(intValue>>>24);\n\tdata[length++]=(byte)(intValue>>>16);\n\tdata[length++]=(byte)(intValue>>>8);\n\tdata[length++]=(byte)intValue;\n\tthis.length=length;\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\n\n    int size=data.length;\n    if(count+3>=size){\n        enlarge(3);\n    }\n    byte[] buf=data;\n    int i=count;\n    buf[i++]=(byte)(intValue>>>24);\n    buf[i++]=(byte)(intValue>>>16);\n    buf[i++]=(byte)(intValue>>>8);\n    buf[i++]=(byte)intValue;\n    count=i;\n    return this;\n}", "public ByteVector putInt(final int intValue){\n\n\tbyte[] buf = new byte[4];\n\tint i = 0;\n\tbuf[i++] = (byte)((intValue & 0xff000000) >> 24);\n\tbuf[i++] = (byte)((intValue & 0x00ff0000) >> 16);\n\tbuf[i++] = (byte)((intValue & 0x0000ff00) >> 8);\n\tbuf[i++] = (byte)(intValue & 0x000000ff);\n\tthis.putByteArray(buf, 0, 4);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\n    int size=this.length;\n    if(size+4>this.data.length){\n        enlarge(4);//\u6269\u5927byte\u6570\u7ec4\n    }\n    byte[] data=this.data;//byte\u6570\u7ec4\n    data[size++]=(byte)(intValue>>>24);//\u9ad8\u4f4dbyte\n    data[size++]=(byte)(intValue>>>16);//\u6b21\u9ad8\u4f4dbyte\n    data[size++]=(byte)(intValue>>>8);//\u6b21\u4f4e\u4f4dbyte\n    data[size++]=(byte)intValue;//\u4f4e\u4f4dbyte\n    this.length=size;\n    return this;\n}", "public ByteVector putInt(final int intValue){\n\n\tint currentLength=data.length;\n\tif(currentLength+4>data.length){\n\t\tint newLength=currentLength*2;\n\t\tbyte[] newData=new byte[newLength];\n\t\tSystem.arraycopy(data,0,newData,0,currentLength);\n\t\tdata=newData;\n\t}\n\tint value=intValue;\n\tdata[currentLength++]=(byte)(value>>>24);\n\tdata[currentLength++]=(byte)(value>>>16);\n\tdata[currentLength++]=(byte)(value>>>8);\n\tdata[currentLength++]=(byte)value;\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\n    int size=this.size;\n    if(size+4>this.data.length)\n        enlarge(4);\n    byte[] data=this.data;\n    data[size++]=(byte)(intValue>>>24);\n    data[size++]=(byte)(intValue>>>16);\n    data[size++]=(byte)(intValue>>>8);\n    data[size++]=(byte)intValue;\n    this.size=size;\n    return this;\n}", "public ByteVector putInt(final int intValue){\n\n\tint length = data.size();\n\tif(length + 4 > data.capacity()){\n\t\tdata.ensureCapacity(length + 4);\n\t}\n\tdata.add(intValue >>> 24);\n\tdata.add(intValue >>> 16);\n\tdata.add(intValue >>> 8);\n\tdata.add(intValue);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\n\tif(data==null){\n\t\tdata=new byte[4];\n\t}\n\tif(data.length<4){\n\t\tbyte[] newData=new byte[4];\n\t\tSystem.arraycopy(data,0,newData,4-data.length,data.length);\n\t\tdata=newData;\n\t}\n\tdata[0]=(byte)(intValue>>>24);\n\tdata[1]=(byte)(intValue>>>16);\n\tdata[2]=(byte)(intValue>>>8);\n\tdata[3]=(byte)(intValue);\n\treturn this;\n}", "public ByteVector putInt(final int intValue){\n\n    int size=this.size;\n    if(size+4>data.length){\n        enlarge(4);\n    }\n    byte[] data=this.data;\n    data[size++]=(byte)(intValue>>>24);\n    data[size++]=(byte)(intValue>>>16);\n    data[size++]=(byte)(intValue>>>8);\n    data[size++]=(byte)intValue;\n    this.size=size;\n    return this;\n}"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017596", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "private void pop(final String descriptor){\n\n    if(descriptor.length()==1){\n        switch(descriptor.charAt(0)){\n            case 'I':case 'Z':case 'S':case 'B':case 'C':case 'F':\n                pop(Type.INT_TYPE);\n                return;\n            case 'J':\n                pop(Type.LONG_TYPE);\n                return;\n            case 'D':\n                pop(Type.DOUBLE_TYPE);\n                return;\n            case 'V':\n                return;\n        }\n    }\n    pop(Type.getType(descriptor));\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tif(descriptor.length()==1){\n\t\tswitch(descriptor.charAt(0)){\n\t\t\tcase 'I':\n\t\t\tcase 'Z':\n\t\t\tcase 'S':\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\t\tmv.visitInsn(Opcodes.POP);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'J':\n\t\t\t\tmv.visitInsn(Opcodes.POP2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}else{\n\t\tmv.visitInsn(Opcodes.POP);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'L':\n\tcase '[':\n\t\tthis.codeWriter.write(Opcodes.POP);\n\t\tbreak;\n\tcase 'D':\n\t\tthis.codeWriter.write(Opcodes.POP2);\n\t\tbreak;\n\tdefault:\n\t\tthis.codeWriter.write(Opcodes.POP);\n\t\tbreak;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\t\tcase 'B':\n\t\tcase 'C':\n\t\tcase 'I':\n\t\tcase 'S':\n\t\tcase 'Z':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\tthis.pop2();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\t\tcase 'D':case 'J':\n\t\t\tpop2();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpop();\n\t\t\tbreak;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'D': case 'J':\n\t\tstack.pop();\n\tcase 'F': case 'I': case 'S': case 'B': case 'C': case 'Z':\n\t\tstack.pop();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n    char firstChar=descriptor.charAt(0);\n    switch (firstChar){\n    case 'D':\n    case 'J':\n        pop2();\n        break;\n    default:\n        pop();\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tchar fieldDescriptor = descriptor.charAt(0);\n\tif(fieldDescriptor == 'D' || fieldDescriptor == 'J'){\n\t\tmv.visitInsn(POP2);\n\t}else{\n\t\tmv.visitInsn(POP);\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n    switch(descriptor.charAt(0)){\n        case 'Z':\n        case 'B':\n        case 'C':\n        case 'S':\n        case 'I':\n            pop();\n            return;\n        case 'F':\n            popf();\n            return;\n        case 'J':\n            pop2();\n            return;\n        case 'D':\n            pop2();\n            return;\n        case 'L':\n            pop();\n            return;\n        default:\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='D' || descriptor.charAt(0)=='J'){\n\t\tstack.pop();\n\t}\n\tstack.pop();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Pops as many abstract types from the output frame stack as described by the given descriptor.\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\n */\n", "method_name": "pop", "codes": ["private void pop(final String descriptor){\n\n    if(descriptor.length()==1){\n        switch(descriptor.charAt(0)){\n            case 'I':case 'Z':case 'S':case 'B':case 'C':case 'F':\n                pop(Type.INT_TYPE);\n                return;\n            case 'J':\n                pop(Type.LONG_TYPE);\n                return;\n            case 'D':\n                pop(Type.DOUBLE_TYPE);\n                return;\n            case 'V':\n                return;\n        }\n    }\n    pop(Type.getType(descriptor));\n}", "private void pop(final String descriptor){\n\n\tif(descriptor.length()==1){\n\t\tswitch(descriptor.charAt(0)){\n\t\t\tcase 'I':\n\t\t\tcase 'Z':\n\t\t\tcase 'S':\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\t\tmv.visitInsn(Opcodes.POP);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'J':\n\t\t\t\tmv.visitInsn(Opcodes.POP2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}else{\n\t\tmv.visitInsn(Opcodes.POP);\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'L':\n\tcase '[':\n\t\tthis.codeWriter.write(Opcodes.POP);\n\t\tbreak;\n\tcase 'D':\n\t\tthis.codeWriter.write(Opcodes.POP2);\n\t\tbreak;\n\tdefault:\n\t\tthis.codeWriter.write(Opcodes.POP);\n\t\tbreak;\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\t\tcase 'B':\n\t\tcase 'C':\n\t\tcase 'I':\n\t\tcase 'S':\n\t\tcase 'Z':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\tthis.pop2();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tthis.pop();\n\t\t\tbreak;\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\t\tcase 'D':case 'J':\n\t\t\tpop2();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpop();\n\t\t\tbreak;\n\t}\n}", "private void pop(final String descriptor){\n\n\tswitch(descriptor.charAt(0)){\n\tcase 'D': case 'J':\n\t\tstack.pop();\n\tcase 'F': case 'I': case 'S': case 'B': case 'C': case 'Z':\n\t\tstack.pop();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t}", "private void pop(final String descriptor){\n\n    char firstChar=descriptor.charAt(0);\n    switch (firstChar){\n    case 'D':\n    case 'J':\n        pop2();\n        break;\n    default:\n        pop();\n    }\n}", "private void pop(final String descriptor){\n\n\tchar fieldDescriptor = descriptor.charAt(0);\n\tif(fieldDescriptor == 'D' || fieldDescriptor == 'J'){\n\t\tmv.visitInsn(POP2);\n\t}else{\n\t\tmv.visitInsn(POP);\n\t}\n}", "private void pop(final String descriptor){\n\n    switch(descriptor.charAt(0)){\n        case 'Z':\n        case 'B':\n        case 'C':\n        case 'S':\n        case 'I':\n            pop();\n            return;\n        case 'F':\n            popf();\n            return;\n        case 'J':\n            pop2();\n            return;\n        case 'D':\n            pop2();\n            return;\n        case 'L':\n            pop();\n            return;\n        default:\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptor);\n    }\n}", "private void pop(final String descriptor){\n\n\tif(descriptor.charAt(0)=='D' || descriptor.charAt(0)=='J'){\n\t\tstack.pop();\n\t}\n\tstack.pop();\n}"], "code_level": "class_runnable", "_id": "636766a91a6d9265ec0175c4", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[index++]=byteValue1;\n\tthis.data[index++]=byteValue2;\n\tthis.length=index;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tput(byteValue1);\n\tput(byteValue2);\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=length;\n\tif(index+2>data.length){\n\t\tenlarge(2);\n\t}\n\tdata[index++]=(byte)byteValue1;\n\tdata[index++]=(byte)byteValue2;\n\tlength=index;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[index++]=(byte)byteValue1;\n\tthis.data[index++]=(byte)byteValue2;\n\tthis.length=index;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=length;\n\tif(index+2>data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tlength=index+2;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint length;\n\tif(byteValue1>255){\n\t\tthrow new IllegalArgumentException(\"byteValue1 \"+byteValue1);\n\t}\n\tif(byteValue2>255){\n\t\tthrow new IllegalArgumentException(\"byteValue2 \"+byteValue2);\n\t}\n\tlength=this.length;\n\tif(length+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[length++]=(byte)byteValue1;\n\tthis.data[length++]=(byte)byteValue2;\n\tthis.length=length;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint len=length;\n\tif(len+2>data.length){\n\t\tenlarge(2);\n\t}\n\tdata[len++]=byteValue1;\n\tdata[len++]=byteValue2;\n\tlength=len;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint newLen=this.length;\n\tif(newLen+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tint[] data=this.data;\n\tdata[newLen++]=byteValue1;\n\tdata[newLen++]=byteValue2;\n\tthis.length=newLen;\n\treturn this;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tthis.length=index+2;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tthis.length=index+2;\n\treturn this;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n", "method_name": "put11", "codes": ["final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[index++]=byteValue1;\n\tthis.data[index++]=byteValue2;\n\tthis.length=index;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tput(byteValue1);\n\tput(byteValue2);\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=length;\n\tif(index+2>data.length){\n\t\tenlarge(2);\n\t}\n\tdata[index++]=(byte)byteValue1;\n\tdata[index++]=(byte)byteValue2;\n\tlength=index;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[index++]=(byte)byteValue1;\n\tthis.data[index++]=(byte)byteValue2;\n\tthis.length=index;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=length;\n\tif(index+2>data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tlength=index+2;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint length;\n\tif(byteValue1>255){\n\t\tthrow new IllegalArgumentException(\"byteValue1 \"+byteValue1);\n\t}\n\tif(byteValue2>255){\n\t\tthrow new IllegalArgumentException(\"byteValue2 \"+byteValue2);\n\t}\n\tlength=this.length;\n\tif(length+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tthis.data[length++]=(byte)byteValue1;\n\tthis.data[length++]=(byte)byteValue2;\n\tthis.length=length;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint len=length;\n\tif(len+2>data.length){\n\t\tenlarge(2);\n\t}\n\tdata[len++]=byteValue1;\n\tdata[len++]=byteValue2;\n\tlength=len;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tint newLen=this.length;\n\tif(newLen+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tint[] data=this.data;\n\tdata[newLen++]=byteValue1;\n\tdata[newLen++]=byteValue2;\n\tthis.length=newLen;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tthis.length=index+2;\n\treturn this;\n}", "final ByteVector put11(final int byteValue1,final int byteValue2){\n\n\tfinal int index=this.length;\n\tif(index+2>this.data.length){\n\t\tenlarge(2);\n\t}\n\tfinal byte[] data=this.data;\n\tdata[index]=(byte)byteValue1;\n\tdata[index+1]=(byte)byteValue2;\n\tthis.length=index+2;\n\treturn this;\n}"], "code_level": "class_runnable", "_id": "636766a81a6d9265ec017595", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\treturn toString(features, JSONWriter.DEFAULT_MAX_LENGTH);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n    if(features==null)features=new JSONWriter.Feature[0];\n    JSONWriter writer=new JSONWriter(features);\n    writer.array();\n    for(JSONObject jsonObject:this){\n        writer.value(jsonObject);\n    }\n    writer.endArray();\n    return writer.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tint f=0;\n\tfor(Feature feature:features){\n\t\tf=f|feature.mask;\n\t}\n\treturn toString(f);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tStringWriter stringWriter=new StringWriter();\n\tJSONWriter writer=new JSONWriter(stringWriter,features);\n\twriter.object();\n\tfor(Map.Entry<String,String> entry : this.entrySet())\n\t\twriter.key(entry.getKey()).valueRaw(entry.getValue());\n\twriter.endObject();\n\treturn stringWriter.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n  try{\n    return write(features).toString();\n  }\n  catch(IOException e){\n    throw new RuntimeException(e);\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter sw=new StringWriter();\n\t\tJSONWriter jw=new JSONWriter(sw,features);\n\t\tjw.write(this);\n\t\treturn sw.toString();\n\t}catch(IOException e){\n\t\tthrow new AssertionError();\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter sw=new StringWriter();\n\t\tJSONWriter jw=new JSONWriter(sw,features);\n\t\tjw.write(this);\n\t\treturn sw.toString();\n\t}catch(Exception e){throw new RuntimeException(e);}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n    if(this.mode=='d'){\n        return this.getString();\n    }\n    return this.toString(0,0,features);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter writer=new StringWriter();\n\t\twriteTo(writer,features);\n\t\treturn writer.toString();}\n\tcatch(IOException e){throw new RuntimeException(e);}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tStringWriter sb=new StringWriter();\n\ttry{\n\t\twrite(sb,features);\n\t}catch(IOException ex){\n\t\tthrow new JSONException(\"IOException while writing to StringWriter\");\n\t}\n\treturn sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n", "method_name": "toString", "codes": ["@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\treturn toString(features, JSONWriter.DEFAULT_MAX_LENGTH);\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n    if(features==null)features=new JSONWriter.Feature[0];\n    JSONWriter writer=new JSONWriter(features);\n    writer.array();\n    for(JSONObject jsonObject:this){\n        writer.value(jsonObject);\n    }\n    writer.endArray();\n    return writer.toString();\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tint f=0;\n\tfor(Feature feature:features){\n\t\tf=f|feature.mask;\n\t}\n\treturn toString(f);\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tStringWriter stringWriter=new StringWriter();\n\tJSONWriter writer=new JSONWriter(stringWriter,features);\n\twriter.object();\n\tfor(Map.Entry<String,String> entry : this.entrySet())\n\t\twriter.key(entry.getKey()).valueRaw(entry.getValue());\n\twriter.endObject();\n\treturn stringWriter.toString();\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n  try{\n    return write(features).toString();\n  }\n  catch(IOException e){\n    throw new RuntimeException(e);\n  }\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter sw=new StringWriter();\n\t\tJSONWriter jw=new JSONWriter(sw,features);\n\t\tjw.write(this);\n\t\treturn sw.toString();\n\t}catch(IOException e){\n\t\tthrow new AssertionError();\n\t}\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter sw=new StringWriter();\n\t\tJSONWriter jw=new JSONWriter(sw,features);\n\t\tjw.write(this);\n\t\treturn sw.toString();\n\t}catch(Exception e){throw new RuntimeException(e);}\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n    if(this.mode=='d'){\n        return this.getString();\n    }\n    return this.toString(0,0,features);\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\ttry{\n\t\tStringWriter writer=new StringWriter();\n\t\twriteTo(writer,features);\n\t\treturn writer.toString();}\n\tcatch(IOException e){throw new RuntimeException(e);}\n}", "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n\n\tStringWriter sb=new StringWriter();\n\ttry{\n\t\twrite(sb,features);\n\t}catch(IOException ex){\n\t\tthrow new JSONException(\"IOException while writing to StringWriter\");\n\t}\n\treturn sb.toString();\n}"], "code_level": "self_contained", "_id": "636766a81a6d9265ec01757b", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint i = Arrays.binarySearch(primeCapacities, desiredCapacity);\n\t//If desiredCapacity is prime, return it.\n\tif(i >= 0) return primeCapacities[i];\n\t//If desiredCapacity is not prime, return the next prime number.\n\ti = -(i + 1) - 1;\n\tif(i < 0) i = 0;\n\treturn primeCapacities[i];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\t// Copy of the Java implementation of HashMap.\n\tint i = Arrays.binarySearch(primeCapacities, desiredCapacity);\n\tif(i < 0) i = -(i + 1);\n\treturn primeCapacities[i];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tif(desiredCapacity>MAX_CAPACITY)\n\t\treturn MAX_CAPACITY;\n\tfor(int capacity:primeCapacities)\n\t\tif(desiredCapacity<=capacity)\n\t\t\treturn capacity;\n\treturn desiredCapacity;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint i=Arrays.binarySearch(primeCapacities,desiredCapacity);\n\tif(i<0)\n\t\ti=-(i+1);\n\treturn primeCapacities[i];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint i = Arrays.binarySearch(primeCapacities,desiredCapacity);\n\tif(i < 0)\n\t\ti = -1 - i;//desiredCapacity not found, but i = insertion point\n\treturn primeCapacities[i];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint primeCandidate=desiredCapacity;\n\tif(primeCandidate%2==0)\n\t\tprimeCandidate++;\n\twhile(!isPrime(primeCandidate))\n\t\tprimeCandidate+=2;\n\treturn primeCandidate;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint[] primeCapacities=new int[]{\n\t\t\t3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,2147483647\n\t\t};\n\tfor(int i=0;i<primeCapacities.length;++i){\n\t\tif(primeCapacities[i]>=desiredCapacity){\n\t\t\treturn primeCapacities[i];\n\t\t}\n\t}\n\treturn primeCapacities[primeCapacities.length-1];\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n    int capacity = desiredCapacity;\n    if (capacity < primeCapacities[primeCapacities.length - 1]){\n        for(int i = 0; i < primeCapacities.length; i++){\n            if(primeCapacities[i] >= capacity){\n                capacity = primeCapacities[i];\n                break;\n            }\n        }\n    }\n    else{\n        capacity = nextPrime(capacity * 2);\n    }\n    return capacity;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n\tint primeCapacities[] = {\n\t\t\t3,\n\t\t\t7,\n\t\t\t11,\n\t\t\t17,\n\t\t\t23,\n\t\t\t29,\n\t\t\t37,\n\t\t\t47,\n\t\t\t59,\n\t\t\t71,\n\t\t\t89,\n\t\t\t107,\n\t\t\t131,\n\t\t\t163,\n\t\t\t197,\n\t\t\t239,\n\t\t\t293,\n\t\t\t353,\n\t\t\t431,\n\t\t\t521,\n\t\t\t631,\n\t\t\t761,\n\t\t\t919,\n\t\t\t1103,\n\t\t\t1327,\n\t\t\t1597,\n\t\t\t1931,\n\t\t\t2333,\n\t\t\t2801,\n\t\t\t3371,\n\t\t\t4049,\n\t\t\t4861,\n\t\t\t5839,\n\t\t\t7013,\n\t\t\t8419,\n\t\t\t10103,\n\t\t\t12143,\n\t\t\t14591", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static int nextPrime(int desiredCapacity){\n\n int i;\n for(i=0;i<primeCapacities.length;i++){\n  if(desiredCapacity<=primeCapacities[i]){\n   return primeCapacities[i];\n  }\n }\n return primeCapacities[i-1];\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).\n * @param desiredCapacity the capacity desired by the user.\n * @return the capacity which should be used for a hashtable.\n */\n", "method_name": "nextPrime", "codes": ["public static int nextPrime(int desiredCapacity){\n\n\tint i = Arrays.binarySearch(primeCapacities, desiredCapacity);\n\t//If desiredCapacity is prime, return it.\n\tif(i >= 0) return primeCapacities[i];\n\t//If desiredCapacity is not prime, return the next prime number.\n\ti = -(i + 1) - 1;\n\tif(i < 0) i = 0;\n\treturn primeCapacities[i];\n}", "public static int nextPrime(int desiredCapacity){\n\n\t// Copy of the Java implementation of HashMap.\n\tint i = Arrays.binarySearch(primeCapacities, desiredCapacity);\n\tif(i < 0) i = -(i + 1);\n\treturn primeCapacities[i];\n}", "public static int nextPrime(int desiredCapacity){\n\n\tif(desiredCapacity>MAX_CAPACITY)\n\t\treturn MAX_CAPACITY;\n\tfor(int capacity:primeCapacities)\n\t\tif(desiredCapacity<=capacity)\n\t\t\treturn capacity;\n\treturn desiredCapacity;\n}", "public static int nextPrime(int desiredCapacity){\n\n\tint i=Arrays.binarySearch(primeCapacities,desiredCapacity);\n\tif(i<0)\n\t\ti=-(i+1);\n\treturn primeCapacities[i];\n}", "public static int nextPrime(int desiredCapacity){\n\n\tint i = Arrays.binarySearch(primeCapacities,desiredCapacity);\n\tif(i < 0)\n\t\ti = -1 - i;//desiredCapacity not found, but i = insertion point\n\treturn primeCapacities[i];\n}", "public static int nextPrime(int desiredCapacity){\n\n\tint primeCandidate=desiredCapacity;\n\tif(primeCandidate%2==0)\n\t\tprimeCandidate++;\n\twhile(!isPrime(primeCandidate))\n\t\tprimeCandidate+=2;\n\treturn primeCandidate;\n}", "public static int nextPrime(int desiredCapacity){\n\n\tint[] primeCapacities=new int[]{\n\t\t\t3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,2147483647\n\t\t};\n\tfor(int i=0;i<primeCapacities.length;++i){\n\t\tif(primeCapacities[i]>=desiredCapacity){\n\t\t\treturn primeCapacities[i];\n\t\t}\n\t}\n\treturn primeCapacities[primeCapacities.length-1];\n}", "public static int nextPrime(int desiredCapacity){\n\n    int capacity = desiredCapacity;\n    if (capacity < primeCapacities[primeCapacities.length - 1]){\n        for(int i = 0; i < primeCapacities.length; i++){\n            if(primeCapacities[i] >= capacity){\n                capacity = primeCapacities[i];\n                break;\n            }\n        }\n    }\n    else{\n        capacity = nextPrime(capacity * 2);\n    }\n    return capacity;\n}", "public static int nextPrime(int desiredCapacity){\n\n\tint primeCapacities[] = {\n\t\t\t3,\n\t\t\t7,\n\t\t\t11,\n\t\t\t17,\n\t\t\t23,\n\t\t\t29,\n\t\t\t37,\n\t\t\t47,\n\t\t\t59,\n\t\t\t71,\n\t\t\t89,\n\t\t\t107,\n\t\t\t131,\n\t\t\t163,\n\t\t\t197,\n\t\t\t239,\n\t\t\t293,\n\t\t\t353,\n\t\t\t431,\n\t\t\t521,\n\t\t\t631,\n\t\t\t761,\n\t\t\t919,\n\t\t\t1103,\n\t\t\t1327,\n\t\t\t1597,\n\t\t\t1931,\n\t\t\t2333,\n\t\t\t2801,\n\t\t\t3371,\n\t\t\t4049,\n\t\t\t4861,\n\t\t\t5839,\n\t\t\t7013,\n\t\t\t8419,\n\t\t\t10103,\n\t\t\t12143,\n\t\t\t14591", "public static int nextPrime(int desiredCapacity){\n\n int i;\n for(i=0;i<primeCapacities.length;i++){\n  if(desiredCapacity<=primeCapacities[i]){\n   return primeCapacities[i];\n  }\n }\n return primeCapacities[i-1];\n}"], "code_level": "slib_runnable", "_id": "636766a81a6d9265ec01758e", "project_name": "fastjson2-main"}
{"generate_results": [{"generate_code": "private static int digitValue(final char c){\n\n\t\n\tif(c>='0' && c<='9'){\n\t\treturn c-'0';\n\t}\n\tif(c>='a' && c<='z'){\n\t\treturn c-'a'+10;\n\t}\n\tif(c>='A' && c<='Z'){\n\t\treturn c-'A'+10;\n\t}\n\treturn -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'A': return 10;\n\t\tcase 'B': return 11;\n\t\tcase 'C': return 12;\n\t\tcase 'D': return 13;\n\t\tcase 'E': return 14;\n\t\tcase 'F': return 15;\n\t\tcase 'G': return 16;\n\t\tcase 'H': return 17;\n\t\tcase 'I': return 18;\n\t\tcase 'J': return 19;\n\t\tcase 'K': return 20;\n\t\tcase 'L': return 21;\n\t\tcase 'M': return 22;\n\t\tcase 'N': return 23;\n\t\tcase 'O': return 24;", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'a': return 10;\n\t\tcase 'b': return 11;\n\t\tcase 'c': return 12;\n\t\tcase 'd': return 13;\n\t\tcase 'e': return 14;\n\t\tcase 'f': return 15;\n\t\tcase 'A': return 10;\n\t\tcase 'B': return 11;\n\t\tcase 'C': return 12;\n\t\tcase 'D': return 13;\n\t\tcase 'E': return 14;\n\t\tcase 'F': return 15;\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"\"+c);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tdefault: throw new IllegalArgumentException(\"char: \" + c);\n\t}\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\t\tswitch (c) {\n\t\t\tcase '0': return 0;\n\t\t\tcase '1': return 1;\n\t\t\tcase '2': return 2;\n\t\t\tcase '3': return 3;\n\t\t\tcase '4': return 4;\n\t\t\tcase '5': return 5;\n\t\t\tcase '6': return 6;\n\t\t\tcase '7': return 7;\n\t\t\tcase '8': return 8;\n\t\t\tcase '9': return 9;\n\t\t\tcase 'a': return 10;\n\t\t\tcase 'b': return 11;\n\t\t\tcase 'c': return 12;\n\t\t\tcase 'd': return 13;\n\t\t\tcase 'e': return 14;\n\t\t\tcase 'f': return 15;\n\t\t\tdefault: throw new IllegalArgumentException(\"Invalid hexadecimal number.\");\n\t\t}\n\t}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tif(c>='0' && c<='9') return c-'0';\n\tif(c>='A' && c<='Z') return c-'A'+10;\n\tif(c>='a' && c<='z') return c-'a'+10;\n\treturn -1;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'a': return 10;\n\t\tcase 'b': return 11;\n\t\tcase 'c': return 12;\n\t\tcase 'd': return 13;\n\t\tcase 'e': return 14;\n\t\tcase 'f': return 15;\n\t\tcase 'g': return 16;\n\t\tcase 'h': return 17;\n\t\tcase 'i': return 18;\n\t\tcase 'j': return 19;\n\t\tcase 'k': return 20;\n\t\tcase 'l': return 21;\n\t\tcase 'm': return 22;\n\t\tcase 'n': return 23;\n\t\tcase 'o': return 24;", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n    switch(c){\n        case '0': return 0;\n        case '1': return 1;\n        case '2': return 2;\n        case '3': return 3;\n        case '4': return 4;\n        case '5': return 5;\n        case '6': return 6;\n        case '7': return 7;\n        case '8': return 8;\n        case '9': return 9;\n        case 'A': return 10;\n        case 'B': return 11;\n        case 'C': return 12;\n        case 'D': return 13;\n        case 'E': return 14;\n        case 'F': return 15;\n        case 'G': return 16;\n        case 'H': return 17;\n        case 'I': return 18;\n        case 'J': return 19;\n        case 'K': return 20;\n        case 'L': return 21;\n        case 'M': return 22;\n        case 'N': return 23;\n        case 'O': return 24;\n        case 'P': return 25;\n        case 'Q': return 26;\n        case 'R': return", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\n\tif(c>='a'&&c<='z'){\n\t\treturn c-'a'+10;\n\t}\n\tif(c>='A'&&c<='Z'){\n\t\treturn c-'A'+10;\n\t}\n\tif(c>='0'&&c<='9'){\n\t\treturn c-'0';\n\t}\n\tthrow new IllegalArgumentException(\"Not a digit: \"+c);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "private static int digitValue(final char c){\n\nreturn Character.digit(c,10);\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Interpret a character as a digit (in any base up to 36) and return the numeric value. This is like {@code Character.digit()} but we don't accept non-ASCII digits.\n */\n", "method_name": "digitValue", "codes": ["private static int digitValue(final char c){\n\n\t\n\tif(c>='0' && c<='9'){\n\t\treturn c-'0';\n\t}\n\tif(c>='a' && c<='z'){\n\t\treturn c-'a'+10;\n\t}\n\tif(c>='A' && c<='Z'){\n\t\treturn c-'A'+10;\n\t}\n\treturn -1;\n}", "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'A': return 10;\n\t\tcase 'B': return 11;\n\t\tcase 'C': return 12;\n\t\tcase 'D': return 13;\n\t\tcase 'E': return 14;\n\t\tcase 'F': return 15;\n\t\tcase 'G': return 16;\n\t\tcase 'H': return 17;\n\t\tcase 'I': return 18;\n\t\tcase 'J': return 19;\n\t\tcase 'K': return 20;\n\t\tcase 'L': return 21;\n\t\tcase 'M': return 22;\n\t\tcase 'N': return 23;\n\t\tcase 'O': return 24;", "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'a': return 10;\n\t\tcase 'b': return 11;\n\t\tcase 'c': return 12;\n\t\tcase 'd': return 13;\n\t\tcase 'e': return 14;\n\t\tcase 'f': return 15;\n\t\tcase 'A': return 10;\n\t\tcase 'B': return 11;\n\t\tcase 'C': return 12;\n\t\tcase 'D': return 13;\n\t\tcase 'E': return 14;\n\t\tcase 'F': return 15;\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"\"+c);\n\t}\n}", "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tdefault: throw new IllegalArgumentException(\"char: \" + c);\n\t}\n}", "private static int digitValue(final char c){\n\n\t\tswitch (c) {\n\t\t\tcase '0': return 0;\n\t\t\tcase '1': return 1;\n\t\t\tcase '2': return 2;\n\t\t\tcase '3': return 3;\n\t\t\tcase '4': return 4;\n\t\t\tcase '5': return 5;\n\t\t\tcase '6': return 6;\n\t\t\tcase '7': return 7;\n\t\t\tcase '8': return 8;\n\t\t\tcase '9': return 9;\n\t\t\tcase 'a': return 10;\n\t\t\tcase 'b': return 11;\n\t\t\tcase 'c': return 12;\n\t\t\tcase 'd': return 13;\n\t\t\tcase 'e': return 14;\n\t\t\tcase 'f': return 15;\n\t\t\tdefault: throw new IllegalArgumentException(\"Invalid hexadecimal number.\");\n\t\t}\n\t}", "private static int digitValue(final char c){\n\n\tif(c>='0' && c<='9') return c-'0';\n\tif(c>='A' && c<='Z') return c-'A'+10;\n\tif(c>='a' && c<='z') return c-'a'+10;\n\treturn -1;\n}", "private static int digitValue(final char c){\n\n\tswitch(c){\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tcase 'a': return 10;\n\t\tcase 'b': return 11;\n\t\tcase 'c': return 12;\n\t\tcase 'd': return 13;\n\t\tcase 'e': return 14;\n\t\tcase 'f': return 15;\n\t\tcase 'g': return 16;\n\t\tcase 'h': return 17;\n\t\tcase 'i': return 18;\n\t\tcase 'j': return 19;\n\t\tcase 'k': return 20;\n\t\tcase 'l': return 21;\n\t\tcase 'm': return 22;\n\t\tcase 'n': return 23;\n\t\tcase 'o': return 24;", "private static int digitValue(final char c){\n\n    switch(c){\n        case '0': return 0;\n        case '1': return 1;\n        case '2': return 2;\n        case '3': return 3;\n        case '4': return 4;\n        case '5': return 5;\n        case '6': return 6;\n        case '7': return 7;\n        case '8': return 8;\n        case '9': return 9;\n        case 'A': return 10;\n        case 'B': return 11;\n        case 'C': return 12;\n        case 'D': return 13;\n        case 'E': return 14;\n        case 'F': return 15;\n        case 'G': return 16;\n        case 'H': return 17;\n        case 'I': return 18;\n        case 'J': return 19;\n        case 'K': return 20;\n        case 'L': return 21;\n        case 'M': return 22;\n        case 'N': return 23;\n        case 'O': return 24;\n        case 'P': return 25;\n        case 'Q': return 26;\n        case 'R': return", "private static int digitValue(final char c){\n\n\tif(c>='a'&&c<='z'){\n\t\treturn c-'a'+10;\n\t}\n\tif(c>='A'&&c<='Z'){\n\t\treturn c-'A'+10;\n\t}\n\tif(c>='0'&&c<='9'){\n\t\treturn c-'0';\n\t}\n\tthrow new IllegalArgumentException(\"Not a digit: \"+c);\n}", "private static int digitValue(final char c){\n\nreturn Character.digit(c,10);\n}"], "code_level": "self_contained", "_id": "636767a61a6d9265ec0185b7", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "private static boolean isHex(final char c){\n\n    return(('0'<=c&&c<='9')||('a'<=c&&c<='f')||('A'<=c&&c<='F'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn (c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\nreturn isDigit(c)||isHexLetter(c);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn (c>=48&&c<=57)||(c>=97&&c<=102)||(c>=65&&c<=70);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\nreturn(c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\nreturn(c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn (('0'<=c&&c<='9')||('a'<=c&&c<='f')||('A'<=c&&c<='F'));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static boolean isHex(final char c){\n\n\treturn\n\t\t('0' <= c && c <= '9') ||\n\t\t('a' <= c && c <= 'f') ||\n\t\t('A' <= c && c <= 'F');\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Is this a hex digit?\n */\n", "method_name": "isHex", "codes": ["private static boolean isHex(final char c){\n\n    return(('0'<=c&&c<='9')||('a'<=c&&c<='f')||('A'<=c&&c<='F'));\n}", "private static boolean isHex(final char c){\n\n\treturn ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F'));\n}", "private static boolean isHex(final char c){\n\n\treturn (c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');\n}", "private static boolean isHex(final char c){\n\nreturn isDigit(c)||isHexLetter(c);\n}", "private static boolean isHex(final char c){\n\n\treturn (c>=48&&c<=57)||(c>=97&&c<=102)||(c>=65&&c<=70);\n}", "private static boolean isHex(final char c){\n\nreturn(c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');\n}", "private static boolean isHex(final char c){\n\n\treturn ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F'));\n}", "private static boolean isHex(final char c){\nreturn(c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F');}", "private static boolean isHex(final char c){\n\n\treturn (('0'<=c&&c<='9')||('a'<=c&&c<='f')||('A'<=c&&c<='F'));\n}", "private static boolean isHex(final char c){\n\n\treturn\n\t\t('0' <= c && c <= '9') ||\n\t\t('a' <= c && c <= 'f') ||\n\t\t('A' <= c && c <= 'F');\n}"], "code_level": "self_contained", "_id": "636767ab1a6d9265ec018676", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\treturn writeDelimitedTo(out,message,schema,buffer,false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\treturn ProtobufOutput.writeDelimitedTo(out,message,schema,buffer);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n    int size = writeTo(buffer,message,schema);\n    if (size != 0) {\n        out.write(size);\n        out.write(buffer.buffer,0,size);\n    }\n    return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size=writeRawVarint32(out,rawVarint32Size(schema.getEncodedSize(message)));\n\tsize+=schema.writeTo(out,message,buffer);\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n    int size=writeRawVarint32Bytes(out,buffer,schema.size(message));\n    size+=schema.writeTo(out,message,buffer);\n    return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size = writeTo(buffer,message,schema);\n\tbuffer.writeTo(out);\n\treturn size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size = writeTo(buffer,message,schema);\n  ProtobufOutput output = new ProtobufOutput(out,buffer);\n  output.writeRawVarint32(size);\n  output.writeRawBytes(buffer.buffer,0,size);\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size = writeRawVarInt32(out,schema.getSerializedSize(message,buffer));\n  size += schema.writeTo(out,message,buffer);\n  return size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size=getSerializedSize(message,schema,buffer);\n\tint header=CodedOutput.computeRawVarint32Size(size);\n\tif(header+size>buffer.start(header)) {\n\t\tbuffer=LinkedBuffer.allocate(header+size);\n\t\tsize=getSerializedSize(message,schema,buffer);\n\t\theader=CodedOutput.computeRawVarint32Size(size);\n\t}\n\tbuffer.data=new byte[header+size];\n\tCodedOutput.newInstance(buffer.data,0,header+size).writeRawVarint32(size);\n\twriteTo(CodedOutput.newInstance(buffer.data,header,size),message,schema,buffer);\n\tout.write(buffer.data,0,header+size);\n\treturn header+size;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size=writeRawVarint32Bytes(out,buffer.startPosition+buffer.offset);\n  writeTo(out,message,schema,buffer);\n  return size+buffer.offset;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n", "method_name": "writeDelimitedTo", "codes": ["public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\treturn writeDelimitedTo(out,message,schema,buffer,false);\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\treturn ProtobufOutput.writeDelimitedTo(out,message,schema,buffer);\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n    int size = writeTo(buffer,message,schema);\n    if (size != 0) {\n        out.write(size);\n        out.write(buffer.buffer,0,size);\n    }\n    return size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size=writeRawVarint32(out,rawVarint32Size(schema.getEncodedSize(message)));\n\tsize+=schema.writeTo(out,message,buffer);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n    int size=writeRawVarint32Bytes(out,buffer,schema.size(message));\n    size+=schema.writeTo(out,message,buffer);\n    return size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size = writeTo(buffer,message,schema);\n\tbuffer.writeTo(out);\n\treturn size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size = writeTo(buffer,message,schema);\n  ProtobufOutput output = new ProtobufOutput(out,buffer);\n  output.writeRawVarint32(size);\n  output.writeRawBytes(buffer.buffer,0,size);\n  return size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size = writeRawVarInt32(out,schema.getSerializedSize(message,buffer));\n  size += schema.writeTo(out,message,buffer);\n  return size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n\tint size=getSerializedSize(message,schema,buffer);\n\tint header=CodedOutput.computeRawVarint32Size(size);\n\tif(header+size>buffer.start(header)) {\n\t\tbuffer=LinkedBuffer.allocate(header+size);\n\t\tsize=getSerializedSize(message,schema,buffer);\n\t\theader=CodedOutput.computeRawVarint32Size(size);\n\t}\n\tbuffer.data=new byte[header+size];\n\tCodedOutput.newInstance(buffer.data,0,header+size).writeRawVarint32(size);\n\twriteTo(CodedOutput.newInstance(buffer.data,header,size),message,schema,buffer);\n\tout.write(buffer.data,0,header+size);\n\treturn header+size;\n}", "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n\n  int size=writeRawVarint32Bytes(out,buffer.startPosition+buffer.offset);\n  writeTo(out,message,schema,buffer);\n  return size+buffer.offset;\n}"], "code_level": "project_runnable", "_id": "636767a41a6d9265ec018582", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(data==null)return false;\n\tif(len!=length)return false;\n\tfor(int i=0;i<len;i++)if(data[offset+i]!=bytes[i])return false;\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len != this.size)return false;\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i] != data[offset+i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\nif(offset<0||offset>data.length-len)throw new ArrayIndexOutOfBoundsException(\"offset<0||offset>data.length-len\");\nif(len>length)return false;\nfor(int i=0;i<len;i++){\nif(data[i+offset]!=bytes[i])return false;\n}\nreturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\treturn (len==_size)&&(len==0||Arrays.equals(_bytes,offset,offset+len,data,offset,offset+len));\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len!=this.length)return false;\n\tfor(int i=0; i<len; i++){\n\t\tif(data[i+offset]!=bytes[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\treturn equals(data,offset,len,0,bytes.length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(data==null||len!=length)return false;\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i]!=data[i+offset])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i]!=data[i+offset]){return false;}\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\nif(len!=length)return false;\nfor(int i=0;i<length;i++)if(data[offset+i]!=bytes[i])return false;\nreturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len!=n)return false;\n\tfor(int i=0;i<n;i++){\n\t\tif(data[offset+i]!=bytes[i])return false;\n\t}\n\treturn true;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n", "method_name": "equals", "codes": ["public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(data==null)return false;\n\tif(len!=length)return false;\n\tfor(int i=0;i<len;i++)if(data[offset+i]!=bytes[i])return false;\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len != this.size)return false;\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i] != data[offset+i])return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\nif(offset<0||offset>data.length-len)throw new ArrayIndexOutOfBoundsException(\"offset<0||offset>data.length-len\");\nif(len>length)return false;\nfor(int i=0;i<len;i++){\nif(data[i+offset]!=bytes[i])return false;\n}\nreturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\treturn (len==_size)&&(len==0||Arrays.equals(_bytes,offset,offset+len,data,offset,offset+len));\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len!=this.length)return false;\n\tfor(int i=0; i<len; i++){\n\t\tif(data[i+offset]!=bytes[i])return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\treturn equals(data,offset,len,0,bytes.length);\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(data==null||len!=length)return false;\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i]!=data[i+offset])return false;\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\tfor(int i=0;i<len;i++){\n\t\tif(bytes[i]!=data[i+offset]){return false;}\n\t}\n\treturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\nif(len!=length)return false;\nfor(int i=0;i<length;i++)if(data[offset+i]!=bytes[i])return false;\nreturn true;\n}", "public boolean equals(final byte[] data,int offset,final int len){\n\n\tif(len!=n)return false;\n\tfor(int i=0;i<n;i++){\n\t\tif(data[offset+i]!=bytes[i])return false;\n\t}\n\treturn true;\n}"], "code_level": "class_runnable", "_id": "636767a51a6d9265ec01859d", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nif(len==1){\nfinal char c=str.charAt(index);\nif(c<0x80)\nreturn 1;\nelse if(c<0x800)\nreturn 2;\nelse\nreturn 3;\n}\nint size=0;\nfor(int end=index+len;index<end;index++){\nfinal char c=str.charAt(index);\nif(c<0x80)\nsize++;\nelse if(c<0x800)\nsize+=2;\nelse\nsize+=3;\n}\nreturn size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint utf8size=0;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<=0x7F){\n\t\t\tutf8size++;\n\t\t}else if(c<=0x7FF){\n\t\t\tutf8size+=2;\n\t\t}else if(Character.isHighSurrogate(c)){\n\t\t\tutf8size+=4;\n\t\t\t++i;\n\t\t}else{\n\t\t\tutf8size+=3;\n\t\t}\n\t}\n\treturn utf8size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n  int size=0;\n  for(int i=0;i<len;i++){\n    final char ch=str.charAt(index+i);\n    if(ch<=0x007F)size++;\n    else if(ch<=0x07FF)size+=2;\n    else size+=3;\n  }\n  return size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nint utf8size=0;\nfor(int i=index;i<index+len;i++){\nfinal int char32=str.charAt(i);\nif(char32<0x80){utf8size+=1;}\nelse if(char32<0x800){utf8size+=2;}\nelse if(char32<0x10000){utf8size+=3;}\nelse if(char32<0x200000){utf8size+=4;}\nelse{utf8size+=2;}\n}\nreturn utf8size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint result=0;\n\tfor(int i=0;i<len;++i){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<0x80){\n\t\t\tresult+=1;\n\t\t}else if(c<0x800){\n\t\t\tresult+=2;\n\t\t}else if(c<0x10000){\n\t\t\tresult+=3;\n\t\t}else{\n\t\t\tresult+=4;\n\t\t}\n\t}\n\treturn result;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tif(len==0) return 0;\n\tint i=index,last=(index+len);\n\tint size=0;\n\tfor(;i<last;++i){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<0x80) size+=1;\n\t\telse if(c<0x800) size+=2;\n\t\telse if(Character.isSurrogate(c)){\n\t\t\tif(Character.isHighSurrogate(c)){\n\t\t\t\tif((i+1)<last){\n\t\t\t\t\tfinal char c2=str.charAt(i+1);\n\t\t\t\t\tif(Character.isLowSurrogate(c2)){\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\tsize+=4;\n\t\t\t\t\t}else size+=3;\n\t\t\t\t}else size+=3;\n\t\t\t}else size+=3;\n\t\t}else size+=3;\n\t}\n\treturn size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint size=0;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<0x80){\n\t\t\tsize++;\n\t\t}else if(c<0x800){\n\t\t\tsize+=2;\n\t\t}else if(c<0x10000){\n\t\t\tsize+=3;\n\t\t}else{\n\t\t\tsize+=4;\n\t\t}\n\t}\n\treturn size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint utf8size=0;\n\tint i=index;\n\tfinal int end=index+len;\n\tfor(;i < end;++i){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c < 0x80){\n\t\t\tutf8size += 1;\n\t\t}else if(c < 0x800){\n\t\t\tutf8size += 2;\n\t\t}else if(isSurrogatePair(c,str,i,end)){\n\t\t\tutf8size += 4;\n\t\t\ti++;\n\t\t}else{\n\t\t\tutf8size += 3;\n\t\t}\n\t}\n\treturn utf8size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nint utf8Size=0;\nfor(int end=index+len;index<end;index++){\nfinal int char32=charAt(str,index);\nif(char32<0x80)utf8Size++;\nelse if(char32<0x800)utf8Size+=2;\nelse if(char32<0x10000)utf8Size+=3;\nelse if(char32<0x200000)utf8Size+=4;\nelse if(char32<0x4000000)utf8Size+=5;\nelse if(char32<=Character.MAX_CODE_POINT)utf8Size+=6;\nelse throw new IllegalArgumentException(\"Illegal character point \"+Integer.toHexString(char32)+\" at index \"+index);\n}\nreturn utf8Size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint size=0;\n\tfinal int end=index+len;\n\tfor(int i=index;i<end;i++){\n\t\tfinal char ch=str.charAt(i);\n\t\tif(ch<=0x007F)size++;\n\t\telse if(ch<=0x07FF)size+=2;\n\t\telse size+=3;\n\t}\n\treturn size;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}], "docstring": "/** \n * Computes the size of the utf8 string beginning at the specified  {@code index} with the specified {@code length}.\n */\n", "method_name": "computeUTF8Size", "codes": ["public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nif(len==1){\nfinal char c=str.charAt(index);\nif(c<0x80)\nreturn 1;\nelse if(c<0x800)\nreturn 2;\nelse\nreturn 3;\n}\nint size=0;\nfor(int end=index+len;index<end;index++){\nfinal char c=str.charAt(index);\nif(c<0x80)\nsize++;\nelse if(c<0x800)\nsize+=2;\nelse\nsize+=3;\n}\nreturn size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint utf8size=0;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<=0x7F){\n\t\t\tutf8size++;\n\t\t}else if(c<=0x7FF){\n\t\t\tutf8size+=2;\n\t\t}else if(Character.isHighSurrogate(c)){\n\t\t\tutf8size+=4;\n\t\t\t++i;\n\t\t}else{\n\t\t\tutf8size+=3;\n\t\t}\n\t}\n\treturn utf8size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n  int size=0;\n  for(int i=0;i<len;i++){\n    final char ch=str.charAt(index+i);\n    if(ch<=0x007F)size++;\n    else if(ch<=0x07FF)size+=2;\n    else size+=3;\n  }\n  return size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nint utf8size=0;\nfor(int i=index;i<index+len;i++){\nfinal int char32=str.charAt(i);\nif(char32<0x80){utf8size+=1;}\nelse if(char32<0x800){utf8size+=2;}\nelse if(char32<0x10000){utf8size+=3;}\nelse if(char32<0x200000){utf8size+=4;}\nelse{utf8size+=2;}\n}\nreturn utf8size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint result=0;\n\tfor(int i=0;i<len;++i){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<0x80){\n\t\t\tresult+=1;\n\t\t}else if(c<0x800){\n\t\t\tresult+=2;\n\t\t}else if(c<0x10000){\n\t\t\tresult+=3;\n\t\t}else{\n\t\t\tresult+=4;\n\t\t}\n\t}\n\treturn result;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tif(len==0) return 0;\n\tint i=index,last=(index+len);\n\tint size=0;\n\tfor(;i<last;++i){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<0x80) size+=1;\n\t\telse if(c<0x800) size+=2;\n\t\telse if(Character.isSurrogate(c)){\n\t\t\tif(Character.isHighSurrogate(c)){\n\t\t\t\tif((i+1)<last){\n\t\t\t\t\tfinal char c2=str.charAt(i+1);\n\t\t\t\t\tif(Character.isLowSurrogate(c2)){\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\tsize+=4;\n\t\t\t\t\t}else size+=3;\n\t\t\t\t}else size+=3;\n\t\t\t}else size+=3;\n\t\t}else size+=3;\n\t}\n\treturn size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint size=0;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(index+i);\n\t\tif(c<0x80){\n\t\t\tsize++;\n\t\t}else if(c<0x800){\n\t\t\tsize+=2;\n\t\t}else if(c<0x10000){\n\t\t\tsize+=3;\n\t\t}else{\n\t\t\tsize+=4;\n\t\t}\n\t}\n\treturn size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint utf8size=0;\n\tint i=index;\n\tfinal int end=index+len;\n\tfor(;i < end;++i){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c < 0x80){\n\t\t\tutf8size += 1;\n\t\t}else if(c < 0x800){\n\t\t\tutf8size += 2;\n\t\t}else if(isSurrogatePair(c,str,i,end)){\n\t\t\tutf8size += 4;\n\t\t\ti++;\n\t\t}else{\n\t\t\tutf8size += 3;\n\t\t}\n\t}\n\treturn utf8size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\nint utf8Size=0;\nfor(int end=index+len;index<end;index++){\nfinal int char32=charAt(str,index);\nif(char32<0x80)utf8Size++;\nelse if(char32<0x800)utf8Size+=2;\nelse if(char32<0x10000)utf8Size+=3;\nelse if(char32<0x200000)utf8Size+=4;\nelse if(char32<0x4000000)utf8Size+=5;\nelse if(char32<=Character.MAX_CODE_POINT)utf8Size+=6;\nelse throw new IllegalArgumentException(\"Illegal character point \"+Integer.toHexString(char32)+\" at index \"+index);\n}\nreturn utf8Size;\n}", "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n\n\tint size=0;\n\tfinal int end=index+len;\n\tfor(int i=index;i<end;i++){\n\t\tfinal char ch=str.charAt(i);\n\t\tif(ch<=0x007F)size++;\n\t\telse if(ch<=0x07FF)size+=2;\n\t\telse size+=3;\n\t}\n\treturn size;\n}"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01856c", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tif(session.isSession){\n\t\treturn writeUTF8(str,session.writer,lb);\n\t}\n\treturn writeUTF8(str,session.writer.asWriter,lb);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal byte[] buf=session.buffer();\n\tif(buf==null){\n\t\t//no buffer, write directly to the LinkedBuffer\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint c=str.charAt(i);\n\t\t\tif(c<0x80){ // 7 bits\n\t\t\t\tlb.writeByte(c);\n\t\t\t}else if(c<0x800){ // 11 bits\n\t\t\t\tlb.writeByte(0xc0 | c >> 6);\n\t\t\t\tlb.writeByte(0x80 | c & 0x3f);\n\t\t\t}else if(c<0xD800 || c>0xDFFF){ // 16 bits\n\t\t\t\tlb.writeByte(0xe0 | c >> 12);\n\t\t\t\tlb.writeByte(0x80 | c >> 6 & 0x3f);\n\t\t\t\tlb.writeByte(0x80 | c & 0x3f);\n\t\t\t}else if(c<=", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\nif(str==null){\nreturn writeNull(session,lb);\n}\nfinal int len=str.length();\nif(len==0){\nreturn _writeByte(0,session,lb);\n}\nif(len<=16){\n_writeByte(len|0x80,session,lb);\nfor(int i=0;i<len;i++){\n_writeChar(str.charAt(i),session,lb);\n}\nreturn lb;\n}\nfinal byte[] bytes=session.getBytes();\nfinal int blen=Utf8.encode(str,bytes);\nif(blen<=255){\n_writeByte(blen|0xC0,session,lb);\nif(blen==255){\n_writeByte(255,session,lb);\n}\n_writeBytes(bytes,0,blen,session,lb);\n}else{\n_writeByte(255,session,lb);\n_writeInt(blen,session,lb);\n_writeBytes(bytes,0,blen,session,lb);\n}\nreturn lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len = str.length();\n\tfinal int size = session.writeUTF8Size(str);\n\tLinkedBuffer next = lb.grow(size);\n\tByteBuffer bb = next.buf;\n\tint start = next.start;\n\tfor(int i = 0; i < len; i++){\n\t\tchar c = str.charAt(i);\n\t\tif(c < 0x80){\n\t\t\tif(start == bb.capacity()){\n\t\t\t\tbb = next.buf = bb.slice();\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t\tbb.put(start++, (byte)c);\n\t\t}else if(c < 0x800){\n\t\t\tif(bb.capacity() - start < 2){\n\t\t\t\tbb = next.buf = bb.slice();\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t\tbb.put(start++, (byte)(0xc0|c>>6));\n\t\t\tbb.put(start++, (byte)(0x80|", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\nif(str.length()==0){\nif(lb.offset+1<=lb.buffer.length){\nlb.buffer[lb.offset++]=(byte)0;\n}else{\nlb.offset=1+writeBytes(lb.buffer,0,lb.offset,session,lb);\nlb.buffer[0]=(byte)0;\n}\nreturn lb;\n}\nint len=calculateUTF8Length(str);\nif(lb.offset+len>lb.buffer.length){\nlb.offset=len+writeBytes(lb.buffer,0,lb.offset,session,lb);\n}\nwriteUTF8(str,len,lb.buffer,lb.offset);\nlb.offset+=len;\nreturn lb;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal int max=session.head+len;\n\tint i=0;\n\tbyte b;\n\twhile(session.head<max){\n\t\tb=(byte)str.charAt(i++);\n\t\tif(b<0){\n\t\t\tsession.buffer[session.head++]=b;\n\t\t\tif(b<-64){\n\t\t\t\tif(b<-32){\n\t\t\t\t\tif(b<-16){\n\t\t\t\t\t\tsession.buffer[session.head++]=(byte)(0xE0 | ((b>>12)&0x0F));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsession.buffer[session.head++]=(byte)(0xC0 | ((b>>6)&0x1F));\n\t\t\t\t\t}\n\t\t\t\t\tsession.buffer[session.head++]=(byte)(0x80 | ((b>>0)&0x3F));\n\t\t\t\t}else{\n\t\t\t\t\tsession.buffer[", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal int blen=lb.b.length;\n\tint offset=lb.offset,end=blen;\n\tfinal char[] chars=session.chars;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<'\\u0080'){\n\t\t\tif(offset==end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)c;\n\t\t}else if(c<'\\u0800'){\n\t\t\tif(offset+1>=end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)(0xc0|c>>6);\n\t\t\tlb.b[offset++]=(byte)(0x80|c&0x3f);\n\t\t}else{\n\t\t\tif(offset+2>=end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)(0xe0|c>>12", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\treturn writeUTF8(str,session,lb,false);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tif(len==0){\n\t\treturn lb;\n\t}\n\tfinal int bufLen=lb.writeBuffer.length;\n\tfinal byte[] buf=lb.writeBuffer;\n\tint at=lb.writePos;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<0x80){//7bit\n\t\t\tif(at<bufLen){\n\t\t\t\tbuf[at++]=(byte)c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//else\n\t\t\tfinal byte[] temp=new byte[bufLen<<1];\n\t\t\tSystem.arraycopy(buf,0,temp,0,bufLen);\n\t\t\ttemp[at++]=(byte)c;\n\t\t\tlb.writeBuffer=buf=temp;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c<0x800){//11bit\n\t\t\tif(at<bufLen-1){\n\t\t\t", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tint pos=lb.offset;\n\tint strLen=str.length();\n\tint len=0;\n\tfor(int i=0;i<strLen;++i){\n\t\tchar c=str.charAt(i);\n\t\tif(c<0x80){\n\t\t\tlen++;\n\t\t}else if(c<0x800){\n\t\t\tlen+=2;\n\t\t}else{\n\t\t\tlen+=3;\n\t\t}\n\t}\n\tif(len>=0x80){\n\t\tsession.putVarInt32(len,lb);\n\t}else{\n\t\tlb.ensureCapacity(lb.offset+len+1);\n\t\tlb.buffer[lb.offset++]=(byte)len;\n\t}\n\tlb.ensureCapacity(pos+len);\n\tfor(int i=0;i<strLen;++i){\n\t\tchar c=str.charAt(i);\n\t\tif(c<0x80){\n\t\t\tlb.buffer[pos++]=(byte)c;\n\t\t", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the utf8-encoded bytes from the string into the  {@link LinkedBuffer}.\n */\n", "method_name": "writeUTF8", "codes": ["public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tif(session.isSession){\n\t\treturn writeUTF8(str,session.writer,lb);\n\t}\n\treturn writeUTF8(str,session.writer.asWriter,lb);\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal byte[] buf=session.buffer();\n\tif(buf==null){\n\t\t//no buffer, write directly to the LinkedBuffer\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint c=str.charAt(i);\n\t\t\tif(c<0x80){ // 7 bits\n\t\t\t\tlb.writeByte(c);\n\t\t\t}else if(c<0x800){ // 11 bits\n\t\t\t\tlb.writeByte(0xc0 | c >> 6);\n\t\t\t\tlb.writeByte(0x80 | c & 0x3f);\n\t\t\t}else if(c<0xD800 || c>0xDFFF){ // 16 bits\n\t\t\t\tlb.writeByte(0xe0 | c >> 12);\n\t\t\t\tlb.writeByte(0x80 | c >> 6 & 0x3f);\n\t\t\t\tlb.writeByte(0x80 | c & 0x3f);\n\t\t\t}else if(c<=", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\nif(str==null){\nreturn writeNull(session,lb);\n}\nfinal int len=str.length();\nif(len==0){\nreturn _writeByte(0,session,lb);\n}\nif(len<=16){\n_writeByte(len|0x80,session,lb);\nfor(int i=0;i<len;i++){\n_writeChar(str.charAt(i),session,lb);\n}\nreturn lb;\n}\nfinal byte[] bytes=session.getBytes();\nfinal int blen=Utf8.encode(str,bytes);\nif(blen<=255){\n_writeByte(blen|0xC0,session,lb);\nif(blen==255){\n_writeByte(255,session,lb);\n}\n_writeBytes(bytes,0,blen,session,lb);\n}else{\n_writeByte(255,session,lb);\n_writeInt(blen,session,lb);\n_writeBytes(bytes,0,blen,session,lb);\n}\nreturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len = str.length();\n\tfinal int size = session.writeUTF8Size(str);\n\tLinkedBuffer next = lb.grow(size);\n\tByteBuffer bb = next.buf;\n\tint start = next.start;\n\tfor(int i = 0; i < len; i++){\n\t\tchar c = str.charAt(i);\n\t\tif(c < 0x80){\n\t\t\tif(start == bb.capacity()){\n\t\t\t\tbb = next.buf = bb.slice();\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t\tbb.put(start++, (byte)c);\n\t\t}else if(c < 0x800){\n\t\t\tif(bb.capacity() - start < 2){\n\t\t\t\tbb = next.buf = bb.slice();\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t\tbb.put(start++, (byte)(0xc0|c>>6));\n\t\t\tbb.put(start++, (byte)(0x80|", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\nif(str.length()==0){\nif(lb.offset+1<=lb.buffer.length){\nlb.buffer[lb.offset++]=(byte)0;\n}else{\nlb.offset=1+writeBytes(lb.buffer,0,lb.offset,session,lb);\nlb.buffer[0]=(byte)0;\n}\nreturn lb;\n}\nint len=calculateUTF8Length(str);\nif(lb.offset+len>lb.buffer.length){\nlb.offset=len+writeBytes(lb.buffer,0,lb.offset,session,lb);\n}\nwriteUTF8(str,len,lb.buffer,lb.offset);\nlb.offset+=len;\nreturn lb;\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal int max=session.head+len;\n\tint i=0;\n\tbyte b;\n\twhile(session.head<max){\n\t\tb=(byte)str.charAt(i++);\n\t\tif(b<0){\n\t\t\tsession.buffer[session.head++]=b;\n\t\t\tif(b<-64){\n\t\t\t\tif(b<-32){\n\t\t\t\t\tif(b<-16){\n\t\t\t\t\t\tsession.buffer[session.head++]=(byte)(0xE0 | ((b>>12)&0x0F));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsession.buffer[session.head++]=(byte)(0xC0 | ((b>>6)&0x1F));\n\t\t\t\t\t}\n\t\t\t\t\tsession.buffer[session.head++]=(byte)(0x80 | ((b>>0)&0x3F));\n\t\t\t\t}else{\n\t\t\t\t\tsession.buffer[", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tfinal int blen=lb.b.length;\n\tint offset=lb.offset,end=blen;\n\tfinal char[] chars=session.chars;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<'\\u0080'){\n\t\t\tif(offset==end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)c;\n\t\t}else if(c<'\\u0800'){\n\t\t\tif(offset+1>=end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)(0xc0|c>>6);\n\t\t\tlb.b[offset++]=(byte)(0x80|c&0x3f);\n\t\t}else{\n\t\t\tif(offset+2>=end)lb.realloc(session);\n\t\t\tlb.b[offset++]=(byte)(0xe0|c>>12", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\treturn writeUTF8(str,session,lb,false);\n}", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tfinal int len=str.length();\n\tif(len==0){\n\t\treturn lb;\n\t}\n\tfinal int bufLen=lb.writeBuffer.length;\n\tfinal byte[] buf=lb.writeBuffer;\n\tint at=lb.writePos;\n\tfor(int i=0;i<len;i++){\n\t\tfinal char c=str.charAt(i);\n\t\tif(c<0x80){//7bit\n\t\t\tif(at<bufLen){\n\t\t\t\tbuf[at++]=(byte)c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//else\n\t\t\tfinal byte[] temp=new byte[bufLen<<1];\n\t\t\tSystem.arraycopy(buf,0,temp,0,bufLen);\n\t\t\ttemp[at++]=(byte)c;\n\t\t\tlb.writeBuffer=buf=temp;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c<0x800){//11bit\n\t\t\tif(at<bufLen-1){\n\t\t\t", "public static LinkedBuffer writeUTF8(final CharSequence str,final WriteSession session,final LinkedBuffer lb){\n\n\tint pos=lb.offset;\n\tint strLen=str.length();\n\tint len=0;\n\tfor(int i=0;i<strLen;++i){\n\t\tchar c=str.charAt(i);\n\t\tif(c<0x80){\n\t\t\tlen++;\n\t\t}else if(c<0x800){\n\t\t\tlen+=2;\n\t\t}else{\n\t\t\tlen+=3;\n\t\t}\n\t}\n\tif(len>=0x80){\n\t\tsession.putVarInt32(len,lb);\n\t}else{\n\t\tlb.ensureCapacity(lb.offset+len+1);\n\t\tlb.buffer[lb.offset++]=(byte)len;\n\t}\n\tlb.ensureCapacity(pos+len);\n\tfor(int i=0;i<strLen;++i){\n\t\tchar c=str.charAt(i);\n\t\tif(c<0x80){\n\t\t\tlb.buffer[pos++]=(byte)c;\n\t\t"], "code_level": "project_runnable", "_id": "636767ab1a6d9265ec01867b", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public long readRawVarint64() throws IOException {\n\n  int shift = 0;\n  long result = 0;\n  while (shift < 64) {\n    final byte b = readRawByte();\n    result |= (long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n      final byte b = readRawByte();\n      result |= (long)(b & 0x7F) << shift;\n      if ((b & 0x80) == 0) {\n        return result;\n      }\n      shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n        int shift = 0;\n        long result = 0;\n        while (shift < 64) {\n          final byte b = readRawByte();\n          result |= (long)(b & 0x7F) << shift;\n          if ((b & 0x80) == 0) {\n            return result;\n          }\n          shift += 7;\n        }\n        throw InvalidProtocolBufferException.malformedVarint();\n      }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n  int shift = 0;\n  long result = 0;\n  while (shift < 64) {\n    final byte b = readRawByte();\n    result |= (long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw new InvalidProtocolBufferException(\"Malformed varint\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n      final byte b = readRawByte();\n      result |= (long)(b & 0x7F) << shift;\n      if ((b & 0x80) == 0) {\n        return result;\n      }\n      shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long) (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift &lt; 64) {\n        final byte b = readRawByte();\n        result |= (long)(b &amp; 0x7F) &lt;&lt; shift;\n        if ((b &amp; 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a raw Varint from the stream.\n */\n", "method_name": "readRawVarint64", "codes": ["public long readRawVarint64() throws IOException {\n\n  int shift = 0;\n  long result = 0;\n  while (shift < 64) {\n    final byte b = readRawByte();\n    result |= (long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n      final byte b = readRawByte();\n      result |= (long)(b & 0x7F) << shift;\n      if ((b & 0x80) == 0) {\n        return result;\n      }\n      shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n  }", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "public long readRawVarint64() throws IOException {\n\n        int shift = 0;\n        long result = 0;\n        while (shift < 64) {\n          final byte b = readRawByte();\n          result |= (long)(b & 0x7F) << shift;\n          if ((b & 0x80) == 0) {\n            return result;\n          }\n          shift += 7;\n        }\n        throw InvalidProtocolBufferException.malformedVarint();\n      }", "public long readRawVarint64() throws IOException {\n\n  int shift = 0;\n  long result = 0;\n  while (shift < 64) {\n    final byte b = readRawByte();\n    result |= (long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift += 7;\n  }\n  throw InvalidProtocolBufferException.malformedVarint();\n}", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw new InvalidProtocolBufferException(\"Malformed varint\");\n}", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n      final byte b = readRawByte();\n      result |= (long)(b & 0x7F) << shift;\n      if ((b & 0x80) == 0) {\n        return result;\n      }\n      shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n  }", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long) (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift < 64) {\n        final byte b = readRawByte();\n        result |= (long)(b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}", "public long readRawVarint64() throws IOException {\n\n    int shift = 0;\n    long result = 0;\n    while (shift &lt; 64) {\n        final byte b = readRawByte();\n        result |= (long)(b &amp; 0x7F) &lt;&lt; shift;\n        if ((b &amp; 0x80) == 0) {\n            return result;\n        }\n        shift += 7;\n    }\n    throw InvalidProtocolBufferException.malformedVarint();\n}"], "code_level": "class_runnable", "_id": "636767a41a6d9265ec018572", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n        if(node==null)node=BUFFER;\n        final int size=node.size;\n        int i=0;\n        for(byte[] bb:node.buffers){\n                if(bb==null)break;\n                out.write(bb,0,size<bb.length?size:bb.length);\n                size-=bb.length;\n                i++;\n        }\n        return i;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint size=0;\n\twhile(node!=null) {\n\t\tout.write(node.data,0,node.used);\n\t\tsize+=node.used;\n\t\tnode=node.next;\n\t}\n\treturn size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n    int size=0;\n    if (node==null) {\n        out.writeInt(0);\n        return size;\n    }\n    int length=node.length;\n    out.writeInt(length);\n    size+=4;\n    DataOutputStream dout=new DataOutputStream(out);\n    for (int i=0;i<length;i++) {\n        dout.write(node.chars,node.offset+i,1);\n        size++;\n    }\n    return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint len=0,size=0;\n\twhile(node.hasNext()) {\n\t\tif(node.isFull()) {\n\t\t\tlen+=node.write(out);\n\t\t\tsize+=node.size();\n\t\t\tnode=node.next();\n\t\t}else break;\n\t}\n\tif(node.remain()>0) {\n\t\tlen+=node.write(out);\n\t\tsize+=node.size();\n\t}\n\treturn len;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n  if(node == null){\n    out.writeInt(0);\n    return 4;\n  }\n  int size = node.getSize();\n  out.writeInt(size);\n  out.write(node.getData(),0,size);\n  return size + 4;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n    int size = 0;\n    for (; node.next != null; node = node.next) {\n        size += node.write(out);\n    }\n    size += node.write(out);\n    return size;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tnode=node.next;\n\tif(node==null)\n\t{\n\t\tout.writeInt(0);\n\t\treturn 0;\n\t}\n\tint s=0;\n\tdo{\n\t\ts+=node.len;\n\t\tout.writeInt(node.len);\n\t\tout.write(node.buf,0,node.len);\n\t\tnode=node.next;\n\t}while(node!=null);\n\treturn s;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\t// write the total length\n\tint length = node.link.length;\n\tout.writeInt(length);\n\t// write the content\n\tout.write(node.link.array,0,length);\n\t// write the child\n\tif(node.child != null) {\n\t\tlength += writeTo(out,node.child);\n\t}\n\treturn length;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint c = 0;\n\twhile(node!=null){\n\t\tint r = node.writeTo(out);\n\t\tc += r;\n\t\tnode = node.next;\n\t}\n\treturn c;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\t\tif(node.length == 0)return 0;\n\t\tint length = 0;\n\t\twhile(node.next != null) {\n\t\t\tout.write(node.buffer, 0, node.length);\n\t\t\tlength += node.length;\n\t\t\tnode = node.next;\n\t\t}\n\t\tout.write(node.buffer, 0, node.length);\n\t\tlength += node.length;\n\t\treturn length;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Writes the contents of the  {@link LinkedBuffer} into the {@link DataOutput}.\n * @return the total content size of the buffer.\n */\n", "method_name": "writeTo", "codes": ["public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n        if(node==null)node=BUFFER;\n        final int size=node.size;\n        int i=0;\n        for(byte[] bb:node.buffers){\n                if(bb==null)break;\n                out.write(bb,0,size<bb.length?size:bb.length);\n                size-=bb.length;\n                i++;\n        }\n        return i;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint size=0;\n\twhile(node!=null) {\n\t\tout.write(node.data,0,node.used);\n\t\tsize+=node.used;\n\t\tnode=node.next;\n\t}\n\treturn size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n    int size=0;\n    if (node==null) {\n        out.writeInt(0);\n        return size;\n    }\n    int length=node.length;\n    out.writeInt(length);\n    size+=4;\n    DataOutputStream dout=new DataOutputStream(out);\n    for (int i=0;i<length;i++) {\n        dout.write(node.chars,node.offset+i,1);\n        size++;\n    }\n    return size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint len=0,size=0;\n\twhile(node.hasNext()) {\n\t\tif(node.isFull()) {\n\t\t\tlen+=node.write(out);\n\t\t\tsize+=node.size();\n\t\t\tnode=node.next();\n\t\t}else break;\n\t}\n\tif(node.remain()>0) {\n\t\tlen+=node.write(out);\n\t\tsize+=node.size();\n\t}\n\treturn len;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n  if(node == null){\n    out.writeInt(0);\n    return 4;\n  }\n  int size = node.getSize();\n  out.writeInt(size);\n  out.write(node.getData(),0,size);\n  return size + 4;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n    int size = 0;\n    for (; node.next != null; node = node.next) {\n        size += node.write(out);\n    }\n    size += node.write(out);\n    return size;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tnode=node.next;\n\tif(node==null)\n\t{\n\t\tout.writeInt(0);\n\t\treturn 0;\n\t}\n\tint s=0;\n\tdo{\n\t\ts+=node.len;\n\t\tout.writeInt(node.len);\n\t\tout.write(node.buf,0,node.len);\n\t\tnode=node.next;\n\t}while(node!=null);\n\treturn s;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\t// write the total length\n\tint length = node.link.length;\n\tout.writeInt(length);\n\t// write the content\n\tout.write(node.link.array,0,length);\n\t// write the child\n\tif(node.child != null) {\n\t\tlength += writeTo(out,node.child);\n\t}\n\treturn length;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\tint c = 0;\n\twhile(node!=null){\n\t\tint r = node.writeTo(out);\n\t\tc += r;\n\t\tnode = node.next;\n\t}\n\treturn c;\n}", "public static int writeTo(final DataOutput out,LinkedBuffer node) throws IOException {\n\n\t\tif(node.length == 0)return 0;\n\t\tint length = 0;\n\t\twhile(node.next != null) {\n\t\t\tout.write(node.buffer, 0, node.length);\n\t\t\tlength += node.length;\n\t\t\tnode = node.next;\n\t\t}\n\t\tout.write(node.buffer, 0, node.length);\n\t\tlength += node.length;\n\t\treturn length;\n\t}"], "code_level": "class_runnable", "_id": "636767aa1a6d9265ec01865a", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "@Override public String readString() throws IOException {\n\n\tint len=readInt();\n\tif(len==-1) return null;\n\tbyte[] buf=new byte[len];\n\treadFully(buf);\n\treturn new String(buf,utf8);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n  /*Read length*/\n  int length = readInt();\n  if (length == -1) {\n    return null;\n  }\n  /*Read bytes*/\n  byte[] bytes = new byte[length];\n  readFully(bytes);\n  /*Create string*/\n  return DataConverter.toString(bytes);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n\tif (stringBuf == null)\n\t\tstringBuf = new StringBuffer();\n\tstringBuf.setLength(0);\n\twhile (true) {\n\t\tchar c = readChar();\n\t\tif (c == 0)\n\t\t\tbreak;\n\t\tstringBuf.append(c);\n\t}\n\treturn stringBuf.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n\treturn readString(readUShort());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n  return readString(false);\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n\treturn readString(readInt());\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n    // 1. Read the length of the string\n    int length = readInt();\n    if (length == -1) {\n      return null;\n    }\n    byte[] bytes = new byte[length];\n    readFully(bytes, 0, length);\n    return new String(bytes, \"UTF-8\");\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n    StringBuilder sb = new StringBuilder();\n    int c;\n    while ((c = read()) > 0) {\n        sb.append((char) c);\n    }\n    if (c < 0) {\n        throw new EOFException();\n    }\n    return sb.toString();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n    return readS();\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "@Override public String readString() throws IOException {\n\n  final int len = readInt();\n  if (len == -1) return null;\n  final byte[] buf = new byte[len];\n  readFully(buf);\n  return new String(buf, \"UTF-8\");\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n", "method_name": "readString", "codes": ["@Override public String readString() throws IOException {\n\n\tint len=readInt();\n\tif(len==-1) return null;\n\tbyte[] buf=new byte[len];\n\treadFully(buf);\n\treturn new String(buf,utf8);\n}", "@Override public String readString() throws IOException {\n\n  /*Read length*/\n  int length = readInt();\n  if (length == -1) {\n    return null;\n  }\n  /*Read bytes*/\n  byte[] bytes = new byte[length];\n  readFully(bytes);\n  /*Create string*/\n  return DataConverter.toString(bytes);\n}", "@Override public String readString() throws IOException {\n\n\tif (stringBuf == null)\n\t\tstringBuf = new StringBuffer();\n\tstringBuf.setLength(0);\n\twhile (true) {\n\t\tchar c = readChar();\n\t\tif (c == 0)\n\t\t\tbreak;\n\t\tstringBuf.append(c);\n\t}\n\treturn stringBuf.toString();\n}", "@Override public String readString() throws IOException {\n\n\treturn readString(readUShort());\n}", "@Override public String readString() throws IOException {\n\n  return readString(false);\n}", "@Override public String readString() throws IOException {\n\n\treturn readString(readInt());\n}", "@Override public String readString() throws IOException {\n\n    // 1. Read the length of the string\n    int length = readInt();\n    if (length == -1) {\n      return null;\n    }\n    byte[] bytes = new byte[length];\n    readFully(bytes, 0, length);\n    return new String(bytes, \"UTF-8\");\n  }", "@Override public String readString() throws IOException {\n\n    StringBuilder sb = new StringBuilder();\n    int c;\n    while ((c = read()) > 0) {\n        sb.append((char) c);\n    }\n    if (c < 0) {\n        throw new EOFException();\n    }\n    return sb.toString();\n}", "@Override public String readString() throws IOException {\n\n    return readS();\n}", "@Override public String readString() throws IOException {\n\n  final int len = readInt();\n  if (len == -1) return null;\n  final byte[] buf = new byte[len];\n  readFully(buf);\n  return new String(buf, \"UTF-8\");\n}"], "code_level": "project_runnable", "_id": "636767a31a6d9265ec018552", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public final byte[] toByteArray(){\n\n\tif(writePos==0)return Const.EMPTY_BYTE_ARRAY;\n\tbyte[] bytes=new byte[writePos];\n\tread(bytes,0,writePos);\n\treturn bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\tif(this.isEmpty())\n\t\treturn null;\n\tint n=this.size();\n\tbyte[] b=new byte[n];\n\tbyte[] bb=null;\n\tint i=0;\n\twhile(true){\n\t\tbb=this.poll();\n\t\tif(bb==null)\n\t\t\tbreak;\n\t\tSystem.arraycopy(bb,0,b,i,bb.length);\n\t\ti+=bb.length;\n\t}\n\treturn b;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\t\tif(this.isEmpty())\n\t\t\treturn null;\n\t\tint size=this.size();\n\t\tbyte[] out=new byte[size];\n\t\tint index=0;\n\t\tfor(LinkedBuffer l:this){\n\t\t\tSystem.arraycopy(l.getBytes(), 0, out, index, l.getSize());\n\t\t\tindex+=l.getSize();\n\t\t}\n\t\treturn out;\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\treturn toByteArray(0,length);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\treturn toByteArray(false);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\tif(buffer==null) return null;\n\treturn buffer.toByteArray();\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\tif(length==0)return EmptyArrays.EMPTY_BYTES;\n\tbyte[] bytes=new byte[length];\n\tint i=0;\n\tfor(LinkedBuffer buffer=this;buffer!=null;buffer=buffer.next){\n\t\tint bufferLength=buffer.length;\n\t\tSystem.arraycopy(buffer.bytes,0,bytes,i,bufferLength);\n\t\ti+=bufferLength;\n\t}\n\treturn bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n    if(this.isEmpty()){\n        return EMPTY_BYTE_ARRAY;\n    }\n    byte[] b = new byte[this.size()];\n    this.read(b,0,b.length);\n    return b;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\tfinal byte[] array=new byte[size];\n\tint index=0;\n\tfor(LinkedBuffer l=this;l!=null;l=l.next){\n\t\tSystem.arraycopy(l.buffer,0,array,index,l.index);\n\t\tindex+=l.index;\n\t}\n\treturn array;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public final byte[] toByteArray(){\n\n\treturn this.copyOf(0,this.size);\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Returns a single byte array containg all the contents written to the buffer(s).\n */\n", "method_name": "toByteArray", "codes": ["public final byte[] toByteArray(){\n\n\tif(writePos==0)return Const.EMPTY_BYTE_ARRAY;\n\tbyte[] bytes=new byte[writePos];\n\tread(bytes,0,writePos);\n\treturn bytes;\n}", "public final byte[] toByteArray(){\n\n\tif(this.isEmpty())\n\t\treturn null;\n\tint n=this.size();\n\tbyte[] b=new byte[n];\n\tbyte[] bb=null;\n\tint i=0;\n\twhile(true){\n\t\tbb=this.poll();\n\t\tif(bb==null)\n\t\t\tbreak;\n\t\tSystem.arraycopy(bb,0,b,i,bb.length);\n\t\ti+=bb.length;\n\t}\n\treturn b;\n}", "public final byte[] toByteArray(){\n\n\t\tif(this.isEmpty())\n\t\t\treturn null;\n\t\tint size=this.size();\n\t\tbyte[] out=new byte[size];\n\t\tint index=0;\n\t\tfor(LinkedBuffer l:this){\n\t\t\tSystem.arraycopy(l.getBytes(), 0, out, index, l.getSize());\n\t\t\tindex+=l.getSize();\n\t\t}\n\t\treturn out;\n\t}", "public final byte[] toByteArray(){\n\n\treturn toByteArray(0,length);\n}", "public final byte[] toByteArray(){\n\n\treturn toByteArray(false);\n}", "public final byte[] toByteArray(){\n\n\tif(buffer==null) return null;\n\treturn buffer.toByteArray();\n}", "public final byte[] toByteArray(){\n\n\tif(length==0)return EmptyArrays.EMPTY_BYTES;\n\tbyte[] bytes=new byte[length];\n\tint i=0;\n\tfor(LinkedBuffer buffer=this;buffer!=null;buffer=buffer.next){\n\t\tint bufferLength=buffer.length;\n\t\tSystem.arraycopy(buffer.bytes,0,bytes,i,bufferLength);\n\t\ti+=bufferLength;\n\t}\n\treturn bytes;\n}", "public final byte[] toByteArray(){\n\n    if(this.isEmpty()){\n        return EMPTY_BYTE_ARRAY;\n    }\n    byte[] b = new byte[this.size()];\n    this.read(b,0,b.length);\n    return b;\n}", "public final byte[] toByteArray(){\n\n\tfinal byte[] array=new byte[size];\n\tint index=0;\n\tfor(LinkedBuffer l=this;l!=null;l=l.next){\n\t\tSystem.arraycopy(l.buffer,0,array,index,l.index);\n\t\tindex+=l.index;\n\t}\n\treturn array;\n}", "public final byte[] toByteArray(){\n\n\treturn this.copyOf(0,this.size);\n}"], "code_level": "project_runnable", "_id": "636767a21a6d9265ec018517", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n\tlong ua=a^SIGN;\n\tlong ub=b^SIGN;\n\treturn (ua<ub)?-1:(ua>ub)?1:0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "private static int compareSigned(long a,long b){\n\nif(a<b){\nreturn -1;\n}\nif(a>b){\nreturn 1;\n}\nreturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n\tif(a<b){\n\t\treturn -1;\n\t}\n\tif(a>b){\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n  return (a<b) ? -1 : ((a>b) ? 1 : 0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\n\treturn(a<b?-1:(a==b?0:1));\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\nreturn a<b?-1:(a>b?1:0);\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "private static int compareSigned(long a,long b){\n\nreturn (a>b)?1:(a<b)?-1:0;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Compares the two specified  {@code long} values. The sign of the value returned is the same as that of{@code ((Long) a).compareTo(b)}. <p> <b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the equivalent {@link Long#compare} method instead.\n * @param a the first  {@code long} to compare\n * @param b the second  {@code long} to compare\n * @return a negative value if {@code a} is less than {@code b}; a positive value if  {@code a} is greater than{@code b}; or zero if they are equal\n */\n", "method_name": "compareSigned", "codes": ["private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "private static int compareSigned(long a,long b){\n\n\tlong ua=a^SIGN;\n\tlong ub=b^SIGN;\n\treturn (ua<ub)?-1:(ua>ub)?1:0;\n}", "private static int compareSigned(long a,long b){\n\nif(a<b){\nreturn -1;\n}\nif(a>b){\nreturn 1;\n}\nreturn 0;\n}", "private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "private static int compareSigned(long a,long b){\n\n\tif(a<b){\n\t\treturn -1;\n\t}\n\tif(a>b){\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "private static int compareSigned(long a,long b){\n\n  return (a<b) ? -1 : ((a>b) ? 1 : 0);\n}", "private static int compareSigned(long a,long b){\n\n\tif(a<b)return -1;\n\tif(a>b)return 1;\n\treturn 0;\n}", "private static int compareSigned(long a,long b){\n\n\treturn(a<b?-1:(a==b?0:1));\n}", "private static int compareSigned(long a,long b){\n\nreturn a<b?-1:(a>b?1:0);\n}", "private static int compareSigned(long a,long b){\n\nreturn (a>b)?1:(a<b)?-1:0;\n}"], "code_level": "self_contained", "_id": "636767a41a6d9265ec01857e", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] buffer=new byte[length];\n\tSystem.arraycopy(data,0,buffer,0,length);\n\treturn buffer;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] bs=new byte[size];\n\tSystem.arraycopy(bytes, 0, bs, 0, size);\n\treturn bs;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\ttry{\n\t\tByteArrayOutputStream baos=new ByteArrayOutputStream();\n\t\twriteTo(baos);\n\t\treturn baos.toByteArray();\n\t}catch(Exception ex){\n\t\tthrow new RuntimeException(ex);\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] bytes = new byte[length];\n\tSystem.arraycopy(buf,start,bytes,0,length);\n\treturn bytes;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tint size=0;\n\tint len=array.length;\n\tfor(int i=0;i<len;i++){\n\t\tsize+=array[i].length;\n\t}\n\tbyte[] data=new byte[size];\n\tint index=0;\n\tfor(int i=0;i<len;i++){\n\t\tbyte[] b=array[i];\n\t\tint len2=b.length;\n\t\tfor(int j=0;j<len2;j++){\n\t\t\tdata[index++]=b[j];\n\t\t}\n\t}\n\treturn data;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] b=new byte[length];\n\tSystem.arraycopy(bytes,start,b,0,length);\n\treturn b;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] b = new byte[size()];\n\ttoByteArray(b);\n\treturn b;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] result=new byte[size];\n\tSystem.arraycopy(buffer,0,result,0,size);\n\treturn result;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\ttry{\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tcopyTo(baos);\n\t\treturn baos.toByteArray();\n\t}catch(Exception e){\n\t\treturn null;\n\t}\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}, {"generate_code": "public byte[] toByteArray(){\n\n\tbyte[] buf = new byte[length];\n\tSystem.arraycopy(buffer,0,buf,0,length);\n\treturn buf;\n}", "errormessage": "", "error_detail_message": "", "is_pass": false}], "docstring": "/** \n * Copies bytes to a  {@code byte[]}.\n */\n", "method_name": "toByteArray", "codes": ["public byte[] toByteArray(){\n\n\tbyte[] buffer=new byte[length];\n\tSystem.arraycopy(data,0,buffer,0,length);\n\treturn buffer;\n}", "public byte[] toByteArray(){\n\n\tbyte[] bs=new byte[size];\n\tSystem.arraycopy(bytes, 0, bs, 0, size);\n\treturn bs;\n}", "public byte[] toByteArray(){\n\n\ttry{\n\t\tByteArrayOutputStream baos=new ByteArrayOutputStream();\n\t\twriteTo(baos);\n\t\treturn baos.toByteArray();\n\t}catch(Exception ex){\n\t\tthrow new RuntimeException(ex);\n\t}\n}", "public byte[] toByteArray(){\n\n\tbyte[] bytes = new byte[length];\n\tSystem.arraycopy(buf,start,bytes,0,length);\n\treturn bytes;\n}", "public byte[] toByteArray(){\n\n\tint size=0;\n\tint len=array.length;\n\tfor(int i=0;i<len;i++){\n\t\tsize+=array[i].length;\n\t}\n\tbyte[] data=new byte[size];\n\tint index=0;\n\tfor(int i=0;i<len;i++){\n\t\tbyte[] b=array[i];\n\t\tint len2=b.length;\n\t\tfor(int j=0;j<len2;j++){\n\t\t\tdata[index++]=b[j];\n\t\t}\n\t}\n\treturn data;\n}", "public byte[] toByteArray(){\n\n\tbyte[] b=new byte[length];\n\tSystem.arraycopy(bytes,start,b,0,length);\n\treturn b;\n}", "public byte[] toByteArray(){\n\n\tbyte[] b = new byte[size()];\n\ttoByteArray(b);\n\treturn b;\n}", "public byte[] toByteArray(){\n\n\tbyte[] result=new byte[size];\n\tSystem.arraycopy(buffer,0,result,0,size);\n\treturn result;\n}", "public byte[] toByteArray(){\n\n\ttry{\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tcopyTo(baos);\n\t\treturn baos.toByteArray();\n\t}catch(Exception e){\n\t\treturn null;\n\t}\n}", "public byte[] toByteArray(){\n\n\tbyte[] buf = new byte[length];\n\tSystem.arraycopy(buffer,0,buf,0,length);\n\treturn buf;\n}"], "code_level": "self_contained", "_id": "636767aa1a6d9265ec01864a", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "private void checkIfPackedField() throws IOException {\n\n  if (packedFields.containsKey(curFieldName)) {\n    int packedFieldLength = packedFields.get(curFieldName);\n    int remainingBytes = packedFieldLength - (int) (totalBytesRead - fieldStart);\n    if (remainingBytes > 0) {\n      read(remainingBytes);\n      fieldStart = totalBytesRead;\n    } else if (remainingBytes == 0) {\n      fieldStart = totalBytesRead;\n    }\n  }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n\t//If there is no field,then return\n\tif(field==null)\n\t\treturn;\n\t//Check if the field should be packed,if so,read the field and update the internal state.\n\tif(field.isPacked()) {\n\t\t//Read the packed field\n\t\ttry {\n\t\t\treadPackedField();\n\t\t} catch (DecodeException e) {\n\t\t\t//If it is not a packed field,then clear the field,and return\n\t\t\tif(e.getReason()==DecodeException.Reason.NOT_PACKED_FIELD) {\n\t\t\t\tclearField();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//Otherwise throw the exception\n\t\t\telse {\n\t\t\t\tthrow new IOException(\"Unexpected exception when reading packed field!\",e);\n\t\t\t}\n\t\t}\n\t\t//Clear the field\n\t\tclearField();\n\t}\n\t//If it is not packed field,then return\n\telse {\n\t\treturn;\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n\tif (this.packedField) {\n\t\tthis.packedField = false;\n\t\tthis.packedFieldType = -1;\n\t\tthis.packedFieldSize = -1;\n\t\tif (this.packedFieldType == 0) {\n\t\t\twhile (this.packedFieldSize > 0) {\n\t\t\t\tthis.readField();\n\t\t\t}\n\t\t} else {\n\t\t\twhile (this.in.readByte() == 0) {\n\t\t\t\tthis.packedFieldSize--;\n\t\t\t}\n\t\t}\n\t}\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n    if (field.getLiteType() == WireFormat.FieldType.PACKED) {\n        int length = readRawVarint32();\n        if (length < 0) {\n            throw InvalidProtocolBufferException.negativeSize();\n        }\n        if (length > input.getBytesUntilLimit()) {\n            throw InvalidProtocolBufferException.truncatedMessage();\n        }\n        if (length > 0) {\n            state = STATE_PACKED_FIELD;\n            packedLimit = input.getTotalBytesRead() + length;\n        } else {\n            state = STATE_READ_DONE;\n        }\n    } else {\n        state = STATE_READ_DONE;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n    if (this.packedFieldCount > 0) {\n        if (this.packedFieldCount == 1) {\n            this.packedFieldCount = 0;\n            this.packedFields = 0;\n            this.packedFields = this.inputStream.read();\n            if (this.packedFields == -1) {\n                throw new IOException(\"Invalid stream header\");\n            }\n            this.packedFields--;\n        }\n        this.packedFieldCount--;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n    if (currentField.isPacked) {\n        int setSize = readInt();\n        if (setSize == -1) {\n            throw new IOException(\"Field is packed,but no setSize is found.\");\n        }\n        currentField.value = new ArrayList<Object>();\n        for (int i = 0; i < setSize; ++i) {\n            currentField.value.add(readObject());\n        }\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n        if ((this.flags & 0x10000000) != 0) {\n            this.fieldPacked = true;\n            this.fieldLength = this.readVarint();\n            this.fieldLengthBytes = this.fieldLengthBytes - this.fieldLength;\n            if (this.fieldLength == 0) {\n                this.fieldPacked = false;\n                this.fieldLength = this.readVarint();\n                this.fieldLengthBytes = this.fieldLengthBytes - this.fieldLength;\n            }\n        }\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n    if (currentFieldIsPacked) {\n        currentFieldLength = packedFieldLength;\n        currentFieldIsPacked = false;\n        currentFieldIsNull = false;\n        currentFieldIsSQLNull = false;\n        currentFieldIsDefault = false;\n        currentFieldIsArray = false;\n        currentFieldIsLong = false;\n        currentFieldIsLob = false;\n        currentFieldIsEncrypted = false;\n        currentFieldIsFromRow = false;\n        currentFieldIsFromBaseRow = false;\n        currentFieldEncryptionScheme = (byte) 0;\n        currentFieldUncompressedLength = 0;\n        currentFieldCompressedLength = 0;\n        currentFieldCompressedStream = null;\n        currentFieldIsNullCompressed = false;\n    }\n    //Read the field if it is packed.\n    if (fieldIsPacked[currentField]) {\n        int fieldNumber = currentField;\n        currentFieldIsPacked = true;\n        currentFieldLength = 0;\n        currentFieldIsNull = false;\n        currentFieldIsSQLNull = false;\n        currentFieldIsDefault = false", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n        if (packedField) {\n            this.packedField = false;\n            this.packedFields = this.packedFields * 10 + this.readNextByte();\n            this.checkIfPackedField();\n        }\n    }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "private void checkIfPackedField() throws IOException {\n\n    if (this.isPacked) {\n        switch (this.fieldType) {\n            case DOUBLE:\n                this.field = getPackedDouble();\n                break;\n            case FLOAT:\n                this.field = getPackedFloat();\n                break;\n            case INT:\n                this.field = getPackedInt();\n                break;\n            case LONG:\n                this.field = getPackedLong();\n                break;\n            default:\n                throw new IOException(\"not support yet\");\n        }\n        this.isPacked = false;\n    }\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}], "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n", "method_name": "checkIfPackedField", "codes": ["private void checkIfPackedField() throws IOException {\n\n  if (packedFields.containsKey(curFieldName)) {\n    int packedFieldLength = packedFields.get(curFieldName);\n    int remainingBytes = packedFieldLength - (int) (totalBytesRead - fieldStart);\n    if (remainingBytes > 0) {\n      read(remainingBytes);\n      fieldStart = totalBytesRead;\n    } else if (remainingBytes == 0) {\n      fieldStart = totalBytesRead;\n    }\n  }\n}", "private void checkIfPackedField() throws IOException {\n\n\t//If there is no field,then return\n\tif(field==null)\n\t\treturn;\n\t//Check if the field should be packed,if so,read the field and update the internal state.\n\tif(field.isPacked()) {\n\t\t//Read the packed field\n\t\ttry {\n\t\t\treadPackedField();\n\t\t} catch (DecodeException e) {\n\t\t\t//If it is not a packed field,then clear the field,and return\n\t\t\tif(e.getReason()==DecodeException.Reason.NOT_PACKED_FIELD) {\n\t\t\t\tclearField();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//Otherwise throw the exception\n\t\t\telse {\n\t\t\t\tthrow new IOException(\"Unexpected exception when reading packed field!\",e);\n\t\t\t}\n\t\t}\n\t\t//Clear the field\n\t\tclearField();\n\t}\n\t//If it is not packed field,then return\n\telse {\n\t\treturn;\n\t}\n}", "private void checkIfPackedField() throws IOException {\n\n\tif (this.packedField) {\n\t\tthis.packedField = false;\n\t\tthis.packedFieldType = -1;\n\t\tthis.packedFieldSize = -1;\n\t\tif (this.packedFieldType == 0) {\n\t\t\twhile (this.packedFieldSize > 0) {\n\t\t\t\tthis.readField();\n\t\t\t}\n\t\t} else {\n\t\t\twhile (this.in.readByte() == 0) {\n\t\t\t\tthis.packedFieldSize--;\n\t\t\t}\n\t\t}\n\t}\n}", "private void checkIfPackedField() throws IOException {\n\n    if (field.getLiteType() == WireFormat.FieldType.PACKED) {\n        int length = readRawVarint32();\n        if (length < 0) {\n            throw InvalidProtocolBufferException.negativeSize();\n        }\n        if (length > input.getBytesUntilLimit()) {\n            throw InvalidProtocolBufferException.truncatedMessage();\n        }\n        if (length > 0) {\n            state = STATE_PACKED_FIELD;\n            packedLimit = input.getTotalBytesRead() + length;\n        } else {\n            state = STATE_READ_DONE;\n        }\n    } else {\n        state = STATE_READ_DONE;\n    }\n}", "private void checkIfPackedField() throws IOException {\n\n    if (this.packedFieldCount > 0) {\n        if (this.packedFieldCount == 1) {\n            this.packedFieldCount = 0;\n            this.packedFields = 0;\n            this.packedFields = this.inputStream.read();\n            if (this.packedFields == -1) {\n                throw new IOException(\"Invalid stream header\");\n            }\n            this.packedFields--;\n        }\n        this.packedFieldCount--;\n    }\n}", "private void checkIfPackedField() throws IOException {\n\n    if (currentField.isPacked) {\n        int setSize = readInt();\n        if (setSize == -1) {\n            throw new IOException(\"Field is packed,but no setSize is found.\");\n        }\n        currentField.value = new ArrayList<Object>();\n        for (int i = 0; i < setSize; ++i) {\n            currentField.value.add(readObject());\n        }\n    }\n}", "private void checkIfPackedField() throws IOException {\n\n        if ((this.flags & 0x10000000) != 0) {\n            this.fieldPacked = true;\n            this.fieldLength = this.readVarint();\n            this.fieldLengthBytes = this.fieldLengthBytes - this.fieldLength;\n            if (this.fieldLength == 0) {\n                this.fieldPacked = false;\n                this.fieldLength = this.readVarint();\n                this.fieldLengthBytes = this.fieldLengthBytes - this.fieldLength;\n            }\n        }\n    }", "private void checkIfPackedField() throws IOException {\n\n    if (currentFieldIsPacked) {\n        currentFieldLength = packedFieldLength;\n        currentFieldIsPacked = false;\n        currentFieldIsNull = false;\n        currentFieldIsSQLNull = false;\n        currentFieldIsDefault = false;\n        currentFieldIsArray = false;\n        currentFieldIsLong = false;\n        currentFieldIsLob = false;\n        currentFieldIsEncrypted = false;\n        currentFieldIsFromRow = false;\n        currentFieldIsFromBaseRow = false;\n        currentFieldEncryptionScheme = (byte) 0;\n        currentFieldUncompressedLength = 0;\n        currentFieldCompressedLength = 0;\n        currentFieldCompressedStream = null;\n        currentFieldIsNullCompressed = false;\n    }\n    //Read the field if it is packed.\n    if (fieldIsPacked[currentField]) {\n        int fieldNumber = currentField;\n        currentFieldIsPacked = true;\n        currentFieldLength = 0;\n        currentFieldIsNull = false;\n        currentFieldIsSQLNull = false;\n        currentFieldIsDefault = false", "private void checkIfPackedField() throws IOException {\n\n        if (packedField) {\n            this.packedField = false;\n            this.packedFields = this.packedFields * 10 + this.readNextByte();\n            this.checkIfPackedField();\n        }\n    }", "private void checkIfPackedField() throws IOException {\n\n    if (this.isPacked) {\n        switch (this.fieldType) {\n            case DOUBLE:\n                this.field = getPackedDouble();\n                break;\n            case FLOAT:\n                this.field = getPackedFloat();\n                break;\n            case INT:\n                this.field = getPackedInt();\n                break;\n            case LONG:\n                this.field = getPackedLong();\n                break;\n            default:\n                throw new IOException(\"not support yet\");\n        }\n        this.isPacked = false;\n    }\n}"], "code_level": "class_runnable", "_id": "636767a31a6d9265ec01854f", "project_name": "protostuff-master"}
{"generate_results": [{"generate_code": "public int readTag() throws IOException {\n\n    // Try reading a tag without reading anything.\n    int tag = readRawVarint32();\n    if (tag != 0) {\n      return tag;\n    }\n    // If we actually read zero, that's not a valid tag.\n    throw InvalidProtocolBufferException.invalidTag();\n  }", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n\n\tif(m_nTagType == 0){\n\t\tm_nTagType = TAG_TYPE_BITS;\n\t\tm_nTag = readRawVarint32();\n\t\tif(m_nTag == 0){\n\t\t\tthrow new IOException(\"Protocol message contained an invalid tag(zero)\");\n\t\t}\n\t}\n\tint tag = (m_nTag & ((1 << m_nTagType) - 1));\n\twhile(m_nTagType < TAG_TYPE_BITS){\n\t\tm_nTagType += TAG_TYPE_BITS;\n\t\tm_nTag = readRawVarint32();\n\t\ttag |= (m_nTag & ((1 << m_nTagType) - 1)) << (TAG_TYPE_BITS - m_nTagType);\n\t}\n\tm_nTagType = 0;\n\tm_nTag = 0;\n\treturn tag;\n}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n\n\tint tag = readUInt32();\n\tif ((tag >>> TAG_TYPE_BITS) > 0) {\n\t\tthrow new IOException(\"Read tag error,tag = \" + tag);\n\t}\n\treturn tag;\n}", "errormessage": "exec error!", "error_detail_message": "exec error!", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n\n\tint tag = readRawVarint32();\n\tif (tag >>> TAG_TYPE_BITS == 0) {\n\t\treturn tag;\n\t}\n\tint fieldNumber = (tag & ~(0x07 << TAG_TYPE_BITS));\n\t\n\t//WireFormat.makeTag(fieldNumber, WireFormat.getTagWireType(tag))\n\treturn ((tag >>> TAG_TYPE_BITS) << TAG_TYPE_BITS) | fieldNumber;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n\n    int tag = readRawVarint32();\n    if (tag >>> TAG_TYPE_BITS == 0) {\n        throw ProtobufException.invalidTag();\n    }\n    return tag;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n\n\tint tag = readRawVarint32();\n\tif (tag >>> TAG_TYPE_BITS == 0) {\n\t\treturn tag;\n\t}\n\tint fieldNumber = (tag >>> TAG_TYPE_BITS);\n\tint wireType = (tag & 0x00000007);\n\treturn (fieldNumber << TAG_TYPE_BITS) | wireType;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n\n\t  int tag = readRawVarint32();\n\t  if (tag >>> TAG_TYPE_BITS == 0) {\n\t    return tag;\n\t  }\n\t  int fieldNumber = (tag >>> TAG_TYPE_BITS);\n\t  return (fieldNumber << TAG_TYPE_BITS) | (tag & TAG_TYPE_MASK);\n\t}", "errormessage": "", "error_detail_message": "", "is_pass": true}, {"generate_code": "public int readTag() throws IOException {\n\n\t//assert(tag == 0);\n\ttag = is.read();\n\tif (tag == -1) {\n\t\ttag = 0;\n\t\treturn 0;\n\t}\n\n\ttag = (tag & 0xFF) >>> TAG_TYPE_BITS;\n\tif (tag == 0) {\n\t\t//long tag\n\t\ttag = (long)is.read() & 0xFF;\n\t\ttag |= ((long)is.read() & 0xFF) << 8;\n\t\ttag |= ((long)is.read() & 0xFF) << 16;\n\t\ttag |= ((long)is.read() & 0xFF) << 24;\n\t\ttag |= ((long)is.read() & 0xFF) << 32;\n\t\ttag |= ((long)is.read() & 0xFF) << 40;\n\t\ttag |= ((long)is.read() & 0xFF) << 48;\n\t\ttag |= ((long)is.read() & 0xFF) << 56;\n\t\tif (tag <= 0) {\n\t\t\t", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n\n\t\tint tag = read();\n\t\tif (tag < 0) {\n\t\t\ttag = 0;\n\t\t}\n\t\tint type = tag & TAG_TYPE_MASK;\n\t\tif (type == TAG_TYPE_MASK) {\n\t\t\ttype = read();\n\t\t\tif (type < 0) {\n\t\t\t\tthrow new IOException();\n\t\t\t}\n\t\t}\n\t\ttag = (tag & TAG_MASK) | type;\n\t\treturn tag;\n\t}", "errormessage": "compile error", "error_detail_message": "null", "is_pass": false}, {"generate_code": "public int readTag() throws IOException {\n\n  int tag = readRawVarint32();\n  if (tag >>> TAG_TYPE_BITS == 0) {\n    throw new IOException(\"Protocol message contained an invalid tag (zero).\");\n  }\n  return tag;\n}", "errormessage": "", "error_detail_message": "", "is_pass": true}], "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n", "method_name": "readTag", "codes": ["public int readTag() throws IOException {\n\n    // Try reading a tag without reading anything.\n    int tag = readRawVarint32();\n    if (tag != 0) {\n      return tag;\n    }\n    // If we actually read zero, that's not a valid tag.\n    throw InvalidProtocolBufferException.invalidTag();\n  }", "public int readTag() throws IOException {\n\n\tif(m_nTagType == 0){\n\t\tm_nTagType = TAG_TYPE_BITS;\n\t\tm_nTag = readRawVarint32();\n\t\tif(m_nTag == 0){\n\t\t\tthrow new IOException(\"Protocol message contained an invalid tag(zero)\");\n\t\t}\n\t}\n\tint tag = (m_nTag & ((1 << m_nTagType) - 1));\n\twhile(m_nTagType < TAG_TYPE_BITS){\n\t\tm_nTagType += TAG_TYPE_BITS;\n\t\tm_nTag = readRawVarint32();\n\t\ttag |= (m_nTag & ((1 << m_nTagType) - 1)) << (TAG_TYPE_BITS - m_nTagType);\n\t}\n\tm_nTagType = 0;\n\tm_nTag = 0;\n\treturn tag;\n}", "public int readTag() throws IOException {\n\n\tint tag = readUInt32();\n\tif ((tag >>> TAG_TYPE_BITS) > 0) {\n\t\tthrow new IOException(\"Read tag error,tag = \" + tag);\n\t}\n\treturn tag;\n}", "public int readTag() throws IOException {\n\n\tint tag = readRawVarint32();\n\tif (tag >>> TAG_TYPE_BITS == 0) {\n\t\treturn tag;\n\t}\n\tint fieldNumber = (tag & ~(0x07 << TAG_TYPE_BITS));\n\t\n\t//WireFormat.makeTag(fieldNumber, WireFormat.getTagWireType(tag))\n\treturn ((tag >>> TAG_TYPE_BITS) << TAG_TYPE_BITS) | fieldNumber;\n}", "public int readTag() throws IOException {\n\n    int tag = readRawVarint32();\n    if (tag >>> TAG_TYPE_BITS == 0) {\n        throw ProtobufException.invalidTag();\n    }\n    return tag;\n}", "public int readTag() throws IOException {\n\n\tint tag = readRawVarint32();\n\tif (tag >>> TAG_TYPE_BITS == 0) {\n\t\treturn tag;\n\t}\n\tint fieldNumber = (tag >>> TAG_TYPE_BITS);\n\tint wireType = (tag & 0x00000007);\n\treturn (fieldNumber << TAG_TYPE_BITS) | wireType;\n}", "public int readTag() throws IOException {\n\n\t  int tag = readRawVarint32();\n\t  if (tag >>> TAG_TYPE_BITS == 0) {\n\t    return tag;\n\t  }\n\t  int fieldNumber = (tag >>> TAG_TYPE_BITS);\n\t  return (fieldNumber << TAG_TYPE_BITS) | (tag & TAG_TYPE_MASK);\n\t}", "public int readTag() throws IOException {\n\n\t//assert(tag == 0);\n\ttag = is.read();\n\tif (tag == -1) {\n\t\ttag = 0;\n\t\treturn 0;\n\t}\n\n\ttag = (tag & 0xFF) >>> TAG_TYPE_BITS;\n\tif (tag == 0) {\n\t\t//long tag\n\t\ttag = (long)is.read() & 0xFF;\n\t\ttag |= ((long)is.read() & 0xFF) << 8;\n\t\ttag |= ((long)is.read() & 0xFF) << 16;\n\t\ttag |= ((long)is.read() & 0xFF) << 24;\n\t\ttag |= ((long)is.read() & 0xFF) << 32;\n\t\ttag |= ((long)is.read() & 0xFF) << 40;\n\t\ttag |= ((long)is.read() & 0xFF) << 48;\n\t\ttag |= ((long)is.read() & 0xFF) << 56;\n\t\tif (tag <= 0) {\n\t\t\t", "public int readTag() throws IOException {\n\n\t\tint tag = read();\n\t\tif (tag < 0) {\n\t\t\ttag = 0;\n\t\t}\n\t\tint type = tag & TAG_TYPE_MASK;\n\t\tif (type == TAG_TYPE_MASK) {\n\t\t\ttype = read();\n\t\t\tif (type < 0) {\n\t\t\t\tthrow new IOException();\n\t\t\t}\n\t\t}\n\t\ttag = (tag & TAG_MASK) | type;\n\t\treturn tag;\n\t}", "public int readTag() throws IOException {\n\n  int tag = readRawVarint32();\n  if (tag >>> TAG_TYPE_BITS == 0) {\n    throw new IOException(\"Protocol message contained an invalid tag (zero).\");\n  }\n  return tag;\n}"], "code_level": "class_runnable", "_id": "636767a81a6d9265ec0185fc", "project_name": "protostuff-master"}
